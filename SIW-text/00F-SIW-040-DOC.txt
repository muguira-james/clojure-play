A CORBA Infrastructure plugged into the German pSISA ArchitectureReinhard Herzog, Thomas UsländerFraunhofer IITBFraunhoferstr. 1D-76131 Karlsruhe, Germany+49-721-6091 294, +49-721-6091 480hzg@iitb.fhg.de ,  HYPERLINK mailto:usl@iitb.fhg.de usl@iitb.fhg.deKay Pixius, Hans-Peter MenzlerWehrtechnische Dienststelle der Bundeswehr für Fernmeldewesen und Elektronik (WTD 81)KalvarienbergD- 91171 Greding, Germany+49-8463 652-546; +49-8463 652-599 HYPERLINK "mailto: KayPixius@bwb.org" KayPixius@bwb.org, HPMenzler@bwb.orgKeywords:Object Modeling, CORBA, HLA, pSISA, InteroperabilityABSTRACT The German Proposed Standard Interface for Simulation Applications (pSISA) provides an easy-to-use HLA-compliant and object-oriented programming environment with plug-in capabilities for heterogeneous run-time communication infrastructures, included in these are, of course, the RTI implementations. The current pSISA implementation of the German Federal Armed Forces is limited to the C++/RTI1.3 profile. However, the RTI API is shielded by a so-called Run-time Communication Interface (RCI). Using a multi-level architecture, the programmer of a pSISA simulation application just operates with objects relevant to his individual simulation domain. These objects are directly related to the SOM/FOM models. The paper presents the initial results of a running project that aims at validating the pSISA architecture by plugging a CORBA-based communication infrastructure underneath the RCI instead of the RTI. The requirement, for the CORBA service interfaces, is to be compliant with the OMG Distributed Simulation Facility standard. Thus, the CORBA Cap server approach embedded into the RTI1.3NG delivery is considered as a primary candidate when re-using both the existing HLA and OMG-compliant implementation. The paper presents the overall SISA over CORBA requirements, provides the resulting architecture  and gives an insight into the first practical implementation experiences found with this approach. As a result, a SISA over CORBA architecture is presented that may be able to improve the degree of "HLA Interoperability".IntroductionIn mid 1999 efforts were launched to develop a slim API to the RTI, denoted as pSISA, at the Federal Armed Forces Technical Center for Communication and Electronics (WTD 81). The acronym pSISA stands for proposed Standard Interface for Simulation Applications. The decision to develop pSISA arose from lessons learned during several national projects. The projects aimed at establishing a HLA-compliant distributed simulation environment among different vendors of simulation applications. It was recognized that each participant struggled with the RTI API. Indeed, many time- and money-consuming activities were dedicated to basic functionality like joining and resigning objects to and from the federation. Furthermore, much coordinating work had to be carried out to gain an agreement on names conventions etc. Consequently, pSISA was initiated to focus on this routine work and lift this load from the contributor of a simulation application. The basic concept depicted in Figure 1 consists of two layers, the so-called OMT-Shell and the so-called RCI-Socket interface. The latter fulfills the evolving IEEE 1516.1 standard, the OMT-shell mirrors the evolving IEEE 1516.2. The idea is to define an abstract class in the OMT-shell which is to be implemented by the OO-shell. The OO-Shell itself does not belong to pSISA and is an encapsulation of the simulation application participating in a federation provided by the vendor. As the OO-shell sets up an object model it must assure that this is done in accordance to IEEE 1516. To be more detailed: the OMT-shell is comprised of only a few classes: OMT_InteractionClass, OMT_Interaction, OMT_Object, OMT_Class, and OMT_Frame.The RCI socket, finally, manages the coupling to the underlying Run-Time Infrastructure.  EINBETTEN Word.Picture.8  Figure  SEQ Figure \* ARABISCH 1:  The pSISA ConceptWithin the project partially described in this paper, the main focus is on integrating a CORBA-compliant communication layer that allows – in principle – the user and the communication layer to become independent from DMSO’s RTI implementation, but to retain HLA-compliancy, at least to the highest degree possible.The Way to CORBAThe pSISA architecture claims to relieve the application programmer of mapping its application to the specific version of a RTI implementation or even to a completely different platform solution. In order to prove this claim it is planned to establish the RCI_Socket interface, defined by pSISA, by a mapping from pSISA to CORBA. For the CORBA interface it is planned to use the interface definition defined by the OMG as the “Distributed Simulation Facility” [4] proposed standard. This is the natural choice because this interface is greatly influenced by the RTI interface definition and is supported by DMSO.Furthermore, it is planned to realize a more “straight-forward” mapping to the CORBA common service definitions [5], in order to prove that pSISA can also be mapped to a non-RTI based implementation.RTI-NG Implementation ArchitectureFor the current study it was decided to use the RTI-NG Version 1.3v2 together with the CorbaCap package.With this implementation platform several connections from an application to the RTIexec are possible. The regular way for an application to connect to the RTIexec is to use the RTIlib with the C++ interface definitions. With the CorbaCap it is also possible to use the interface defined by the CORBA interface definition. Following the common way of CORBA programming, an idl compiler generates Stub and Skeleton code from this “idl-file” which then implements the CORBA interface to the CorbaCap server.  EINBETTEN Word.Picture.8  Figure  SEQ Figure \* ARABISCH 2:  RTI-NG and CorbaCap ArchitectureAs an intermediate solution the CorbaCap also provides a CorbaCapClient library that offers the same C++ interface as the RTIlib.The RTI-NG itself is also implemented by using CORBA from ACE-TAO [7]. Ironically, this leads to problems when interacting with other CORBA products, especially when using other name services. The rtiexec from the RTI-NG implements its own name services and it will not start, if it finds any other name server.The CorbaCap SolutionThere are some shortcomings in the selection of the development platforms to be used. The CorbaCap software [6] is currently the only available implementation of a CORBA-based RTI access. Unfortunately, the CorbaCap package is only available for Solaris, which is not the targeted implementation platform for this project, and more seriously, it does not support the original interface definition from the OMG to 100%.The main deviations are:In the CorbaCap version there is a factory object for the creation of the RTI ambassador object. This object does not exist in the OMG proposal.The OMG defines time as a value of the type double whereas the CorbaCap uses an unspecified byte sequence for coding the time.The CorbaCap version defines two methods tick and tickOnce. These two methods are related to the tick methods of the RTI C++ interface. In the OMG proposal there is no method for the tick concept of the RTI. If the tick method in the CorbaCap has the same importance as the tick method in the RTI, it constitutes a major conceptual difference to the OMG proposal.In the CorbaCap version, there are several exceptions which are not found in the OMG definition (like Exceptions Concurrent Access Attempted, Region In Use, Array Index out of Bounds).In the CorbaCap version, there are also additional methods for manipulating regions. The method handling as well is different. It uses handles for manipulating regions instead of the values itself.Anyway it was decided to use the CorbaCap as the first validation step in mapping pSISA to CORBA.Implementation ConsiderationsIn order to map the pSISA to a specific run-time infrastructure, it is necessary to implement the RCI Socket Interface. One implementation is already available, which is the RTI Socket. It also maps pSISA to the RTI1.3. With some minor modifications the same RTI Socket can also be used to map pSISA to the RTI-NG.Figure  SEQ Figure \* ARABISCH 3: Implementation OptionsThe next implementation of the RTI Socket interface will be called “OMG Socket” and it will map pSISA to the modified version of the Distributed Simulation Facility defined by the OMG. As mentioned before, this is not exactly compliant with the standard, but it is the only available implementation. It is up to the standard committee and the authors of the CorbaCap server to decide whether the standard or the implementation must be corrected.The CorbaCap is not an RTI implementation by itself. It simply forwards the CORBA services to the original RTI-NG services. It is this not the most performant solution, but is will serve as a “proof of concept” solution.If other implementations of the OMG interface will become available, they can be used by the OMG Socket implementation of pSISA.Further proof for the independence of HLA implementations would be the mapping of pSISA to a direct usage of the CORBA common services. However, this would result in a new implementation of the RTI.Currently, the RTI leaves the coding of the attribute values and also the coding of the time to the application programmer. CORBA could relieve the programmer of such low-level coding burdens, because it provides a marshalling mechanism to transfer values between machines and operating systems with different coding conventions. However, this might sound like a good solution but it would require the application to define the types of the attributes in its SOM definitions. As this is currently not the case, there is no HLA-compliant way to solve these coding problems.HLA InteroperabilityA further important topic for the pSISA architecture is the question of HLA interoperability. A good definition of RTI Interoperability is provided by the RTI Interoperability Study Group. In their final report [8] they describe architectural variations that are based on the combination of homogeneous and heterogeneous federations and RTIs.Apart from this architectural implications there are more levels or areas where interoperability is relevant. In order to have a sound basis for discussions it is important to know which kind of interoperability is possible and desirable.  The following criteria are considered for evaluating the concept of pSISA and the usage of CORBA with respect to interoperability:Portability: the ability to change from one RTI implementation to another, without modifying the application;Interoperability at application level: the ability to migrate simulation objects from one federate to another;Interoperability at model level: the ability to provide several views of one simulation object;Interoperability at RTI service level: the ability to share RTI services of different RTI implementations (e.g the time services of two different RTI implementations can work together);Interoperability at middleware level: integrate RTI implementations, which work on different middleware technologies (e.g DCOM, MQSeries, DIS, ALSP);Interoperability at communication level: independence of the communication profile (OSI 1-4);Interoperability at platform level: the ability to use different HW/SW Platforms together (e.g. Unix, Windows);Interoperability at language level: the ability to use different implementation languages at the same time;Usage of component concepts: the ability to use standard software components (e.g. Enterprise Java Beans, MS-Windows Applications);Persistence: the ability to make simulation objects persistent. EINBETTEN Word.Picture.8  Figure  SEQ Figure \* ARABISCH 4: Interoperability LevelsIt will be interesting to see the implications between design decisions on the different architectural levels. For example CORBA could solve some interoperability problems like the platform and language independent coding of attributes and time, but this would require explicit type information in the federation level. As this is currently not the case, this typical middleware problem will remain, even if the middleware could solve it.ConclusionIn the future, there will probably be more than one HLA implementation available on the market. Therefore, the freedom of pSISA applications to choose between different implementations without changing the application will be a very important point.If pSISA can be successfully mapped to different implementations of the HLA concept, this will be a significant improvement to the independence of the application developer from the availability of a specific HLA implementation. The mapping of pSISA to CORBA instead of the RTI implementation serves as a first validation of this approach.The possibility of using several mappings at the same time, will provide ideal implementation conditions for Proxy implementations, which can be used to connect two federations working on different RTI implementations.ReferencesFollowing books and articles are referenced in this paper: [1]	IEEE P1516.2 Draft: "Standard for Modeling and Simulation (M&S) High level Architecture (HLA) - HLA Object Model Template (OMT)", Version 1.3, 20 April 1998[2]	K. Pixius, H.-P.Menzler, U. Krosta: “A common access to the HLA utilizing Design Patterns“; in: R. Van Landeghem (Ed.): Simulation and Modeling: Enablers for a better quality of life; Proceedings of the 14th European Simulation Multiconference ESM2000, 23.-26. Mai 2000, Ghent, Belgium.[3]	H.-P. Menzler, U. Krosta, K. Pixius: “HLA in an Nutshell: (-SA Proposed Standard Interface for Simulation Applications“; in: Proc. Simulation Interoperability Workshop SIW Spring 2000, 26.- 31. March 2000, Orlando, FL, U.S.A.[4]	Object Management Group, Inc. (OMG): “Facility for Distributed Simulation Systems, Proposed Request for Comments”; mfg/98-06-06,   HYPERLINK http://www.omg.org; http://www.omg.org;.[5]	Object Management Group, Inc. (OMG): “CORBAservices: Common Object Services Specification”;  Updated Edition December 1998, formal/98-12-11,  HYPERLINK http://www.omg.org http://www.omg.org;.[6]	CorbaCap; HLA Software Distribution Center supported by DMSO; available at  HYPERLINK http://hla.dmso.mil/sdc/hla_soft.htm http://hla.dmso.mil/sdc/hla_soft.htm[7]	ACE/TAO: ACE Version OCI-5.0a and TAO Version OCI1.0a; OCI’s Distribution of TAO; released Mon Aug 30 1999.[8]	RTI Interoperability Study Group: Final Report; 99F-SIW-001: April 1999.AUTHOR BIOGRAPHIESREINHARD HERZOG studied computer science at the University of Karlsruhe and received his masters degree in 1989. After then he joined the Fraunhofer Institute IITB where he is currently working on simulation and training systems.THOMAS USLÄNDER graduated from University of Karlsruhe with a masters degree in computer science in 1987. As a scientist and system engineer  at Fraunhofer IITB and Conware Computer Consulting, Karlsruhe, he developed kernel components of distributed systems, e.g. for ISO/OSI and Internet network management. Since 1995, he is group and project manager at Fraunhofer IITB working on tailored CORBA-based integration platforms and client/server information systems.KAY PIXIUS joined the Simulation Infrastructure Department of WTD 81 in late 1998, after his trainee program with the Federal Office for Defense Technology and Procurement BWB. He graduated from University of Cologne with a masters degree in semiconductor physics and earned his PhD in Material Sciences from RWTH Aachen. He has worked as a research scientist at the Institute of Materials Research of the German Aerospace Research Establishment DLR; where he finally was Assistant to the Board of Directors prior to joining the BWB.HANS-PETER MENZLER studied physics at the University of Osnabrueck, Germany, and earned his PhD in applied mathematical physics in 1989. He worked for three years as a scientist at the Max-Planck Institute for Plasmaphysics and then became a system engineer at Competence Center Informatik GmbH (CCI). In April 1999 he became head of the Simulation Infrastructure Department at WTD 81, Greding. Note that although this layer is denoted as a socket it does not directly address TCP/IP.			