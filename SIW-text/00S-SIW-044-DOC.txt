Object Model Mapping and Inspection:  The Key to Adaptable FederatesJane T. BachmanPaul GustavsonSYNETICS Inc.16539 Commerce Drive, Suite 10King George, Virginia 22485540.663.2137jbachman@dv.synetics.com, pgustav@dv.synetics.comKeywords:Adaptable Federate, Analysis, FEDEP, FOM, Integration, Inspection, Mapping, SOM, Tools.ABSTRACT: Object Model (OM) inspection supports an important aspect of the verification, validation and federation implementation activities as described in the Federation Engineering Process (FEDEP).  As Federation Object Model (FOM) and Simulation Object Model (SOM) generations evolve, engineers will find a growing need for methods to map SOMs to FOMs and vice-a-versa, through the process of object model inspection.  Synetics, under the sponsorship of the U.S. Army Simulation Training Instrumentation Command (STRICOM), has developed a suite of High Level Architecture (HLA) tools called OMSuite™ featuring OMSpector™.  OMSpector™ is a tool enabling the engineer to inspect object models and rapidly map FOMs to SOMs allowing federates to adapt to numerous and diverse FOMs.  This paper examines the concept of Adaptable Federates, and the benefits of Object Model (OM) Mapping and Inspection.   An illustration of a SOM-to-FOM Map is provided.IntroductionThe Department of Defense (DoD) Modeling and Simulation (M&S) Master Plan calls for the establishment of a common high-level simulation architecture to facilitate the interoperability of all types of models and simulations including C4I systems, and to facilitate the reuse of simulation components. The High Level Architecture (HLA), developed in response to the Master Plan, provides a systematic and consistent basis for addressing simulation system design and implementation issues, facilitates interoperability and reuse through a set of common rules, and furnishes a framework for making policy decisions.  Within HLA, interoperable systems, simulators, and real-time applications such as viewers and loggers are known as federates.  A federation consists of multiple federates that have the capability of interoperating among one another; exchanging and reflecting data during a federation execution.  Thus far, the most difficult task is adapting a system, simulator or application to be able to participate as a federate within a single federation.  In the future, federates will need to be able to participate in a number of unique federations, not just one.  Since the Federation Object Model (FOM) identifies the characteristics of a federation, and each federation is represented by a FOM, federates will need to be able to rapidly transition from one FOM to another FOM with minimal impact and in minimal time. This paper addresses the “Adaptable Federate” concept which supports this anticipated transition requirement, and explores an innovative approach for fulfilling the concept of the “Adaptable Federate” through Object Model (OM) Mapping and Inspection.Adaptable FederatesThe objective is to provide the capability for a federate to participate in many federations without the continual effort of modifying, re-compiling, and re-linking code for every federation a federate is to join.  The “Adaptable Federate” concept provides a way for the federate to quickly conform to the characteristics of a federation.  The method described in this paper will result in the reduction of time, cost, and resources normally required for these simulation modifications.By examining steps 4 and 5 of the Federation Development and Execution Process (FEDEP) as shown in Figure 2.1, the effort associated in making a federate conform to a federation can be better understood.Figure 2.1 Six Step FEDEP Model.Step 4: Develop Federation.  “The Federation Object Model (FOM) is developed, federate agreements on consistent databases/algorithms are established, and modifications to federates are implemented (as required).”Step 5: Integrate and Test Federation.  “All necessary federation implementation activities are performed, and testing is conducted to ensure that interoperability requirements are being met.”These two steps illustrate the process required for a federate to prepare for a federation execution. The FOM represents the interface of the federation. Once the FOM is produced in FEDEP Step 4, federation members (federate engineers) determine “how federation objects will interact with each other during the execution.” Code changes typically ensue to allow a federate to be compatible to a federation’s FOM. If the federate was capable of interoperating with a previous federation (defined by a different FOM), it may no longer be capable of interoperating with the next federation because of the FOM change. As defined by the HLA Rules [5], the federate will require software changes so that it can represent the objects and interactions of the FOM.  Rule 2.  “In a federation, all representations of objects in the FOM shall be in the federates, not in the Runtime Infrastructure (RTI).”If a federate is expected to participate in a wide variety of federation executions and the objects defined in each FOM are quite different, then the federate will undergo substantial change. As illustrated in Figure 2.2, a federate represented by the Simulation Object Model (SOM) may be required to participate with federation X.  The federate’s simulation code will be written so that it can publish and subscribe the FOM X objects and interactions for which the federate is responsible.  Suppose in the following month, it’s required that the federate participate with federation Y.  In order to participate, changes to simulation code are implemented which allow the federate to publish and subscribe the FOM Y objects and interactions for which the federate is now responsible. The second integration effort requires significant code changes, re-compiling and re-linking.  Once changes are made, the federate may no longer be able to plug-and-play with federation X again unless either the modification process is repeated or the previous federate was separately maintained and managed. In the latter case, multiple instances of the same federate may be considered a curse worse than death for managers, developers, and testers and therefore are not encouraged.  Figure 2.2 Typical Federate IntegrationThe “Adaptable Federate” concept provides a way to maintain the internal object structure of a federate that has already been coded and provides a way to fulfill the expectations of the FEDEP and HLA Rules. This mechanism is provided through an Adaptable Federate Link Module (AFLM) as illustrated in Figure 2.3.  In this case, if a federate that is participating with federation X is expected to also participate in a federation Y, the effort required to transition from FOM X to FOM Y requires less time.  As shown in this illustration, the effort could realistically be accomplished in a day rather than a month.  Figure 2.3 Adaptable Federate IntegrationThe key in maintaining the integrity of the federate and providing this rapid transition is for the federate to be fully represented by its SOM. Then, within the AFLM, the necessary code implementations can be identified that allow a SOM-based federate to participate in a FOM-based federation. It is through object model mapping and inspection, that federates can adapt to new and existing federations in the M&S community. This is accomplished by examining the role of a federate’s SOM and identifying the SOM-to-FOM mappings.SOM – The Interface to the FederateA prerequisite in the adaptation process is a federate's SOM. The SOM, in essence, is the resume of capabilities a federate is capable of providing and is described in an object-based model -- the Object Model Template (OMT). The SOM is important for several reasons: SOMs can be used as a guide for the development of the FOM; SOMs provide the basis for the interface definition between a FOM and the federates within a specific federate execution; and Once implemented, SOMs provide a way to tap into the federate without having to know (or the need to change) internal federate code.  This last important item is the heart of the “Adaptable Federate” concept. When the SOM is treated as an interface to the federate, the SOM can then be used to identify mappings to a variety of FOMs. The mappings are possible because both the SOM and FOM are described in the same manner (OMT format) and, as such, provide an object-oriented hierarchy that is cross-linkable. Once a SOM is defined for a federate, it should then be implemented within the federate code to provide the basis for an interface to an Adaptable Federate Link Module such as a Windows Dynamic Link Library (DLL). The AFLM provides the SOM-to-FOM-to-RTI mapping connection for the federate. With the right tools and know-how, the creation of an AFLM can be made quickly and easily, and will allow federates to  “plug-and-play” with a myriad of federations and various RTI implementations.  In order to understand the process of how an Adaptable Federate Link Module is created, let us examine the process of object model mapping and inspection. OM Mapping and InspectionThe OMT is formatted in a manner that provides a convenient method to map elements of one object model to another object model. As in the analogy of using a navigational map, the goal of reaching the destination begins by plotting point A to point B and mapping out the course of travel. In this case, Point A represents our origin or Core, and Point B represents the destination or Target. Core and Target are important terms that will be used throughout this paper. Object model mapping is similar to the navigational concept. Object Model “A”, the Core, is linked to Object Model “B”, the Target, and the course is mapped by the remaining links involved. The purpose of object model mapping is to identify the similarities and determine the syntactical differences between two object models, and to determine the roles and responsibilities a federate will have with the Target federation. This information helps us identify the AFLM interface and transition code necessary for a federate to participate in a federation.  The process of mapping two object models is described below using the OMSpector™ tool. OMSpector™ provides the automation of Object Model Mapping. Example operation procedures of OMSpector™ are used to help illustrate the mapping process. 4.1  Object / Interaction LinkingThe first key to creating an Object Model Map is by linking objects and interactions between two different object models. Within OMSpector™ this involves displaying two object models in a manner that provides a side-by-side visual comparison of classes and interactions and associated attributes and parameters. This mechanism provides a rapid process for examining and linking object classes and attributes. After an object class link is made, the associated attributes are displayed in below the hierarchy of object classes, as illustrated in Figure 4.1.1.Figure 4.1.1 Object Class/Attribute Linkage4.2  Attribute / Parameter LinkingAfter completing the object/interaction linkage, the engineer can proceed to link the Core object attribute (or an interaction parameter) to the Target object attribute (or interaction parameter) as shown in Figure 4.1.1. When an attribute/parameter link is accomplished, the elements of both the Core and Target attributes (or interactions) are displayed side-by-side as illustrated in Figure 4.2.1. The engineer can then inspect the attribute/parameter element differences. Figure 4.2.1 Attribute Parameter Display4.3  Attribute/Parameter Element InspectionIn addition to the side-by-side display, OMSpector™ provides an automatic comparison capability of attribute/parameter element information. Upon linking the appropriate object class and attribute, an engineer can inspect the linked attributes’ elements as shown in Figure 4.2.1. Inspection includes identifying object class attribute discrepancies and examining the complex data types. A magnifying glass icon placed to the right of the element name marks any discrepancies found between the respective elements. This provides the user with a visual flag identifying differences between the federate interface (i.e. SOM) and the federation interface (i.e. FOM). These discrepancies are important pieces of data that will be used in creating the Adaptable Federate Link Module.5.  Adaptable Federate Link Module Object model comparison is the key to achieving a successful adaptation of the federate because it provides a way to examine the impact of the object model linkage. It answers the question, “how can my federate participate in this federation?” The information gained from the mapping and inspection allows us to (1) identify the roles and responsibilities of the federate, and (2) identify the transition code necessary for the SOM-based federate to communicate with the FOM-based federation. These two important components are needed for creating an Adaptable Federate Link Module.5.1  Internals of the AFLMAs illustrated in Figure 5.1, the AFLM contains the implementation of calls issued by the Federate (e.g. data to Publish) and provides callbacks to the Federate for data that it is expecting to receive (e.g. Subscription data). Also contained within the AFLM is the translation code necessary to allow the federate to communicate with the federation (the FOM). FOM-based functions within the AFLM provide communication with the designated RTI. The AFLM also utilizes the Runtime-Initialization Data (RID) file and Federation Execution Data (FED) file at execution time. Figure 5.1 – Internals of the AFLM5.2  Identifying Federate ResponsibilitiesAssuming object models were originally created based on well defined objectives and requirements (such as conceptual models contained within Use Cases  [6]), then the mapping ensures the success for Activity 4.2 of the FEDEP; “…federation members must use the federation conceptual model to gain an understanding and agreement on the behavior of all federation objects and how federation objects will interact with each other during the execution.” [1]The behavior and interaction agreements are determined by examining the Publish and Subscribe (P/S) capabilities of the linked SOM-to-FOM object and interaction classes. Simply stated, the object model map helps identify the P/S support needed by the federate to participate in the federation. This information helps determine the necessary AFLM and RTI call(s).Once mappings are completed and federate responsibilities are identified, the interface for the Adaptable Federate Link Module (AFLM) can be defined. The SOM, again, provides the basis for the AFLM interface, but it is the (P/S) capabilities that identify the exchange mechanism between the federate and AFLM (i.e., what calls are made and what callbacks are expected).    5.3  Transition CodeAlso contained within the AFLM is the translation code necessary to allow the federate to communicate with the federation (the FOM). FOM-based methods within the AFLM provide communication with the designated RTI (or other network unit). Transition code generated for the AFLM provides effective federation integration. The end result is that a federate is able to “plug-and-play” with various federations and RTI implementations. The AFLM is not limited to just HLA in the RTI. Other network interfaces may also be used such as a DIS PDU interface or Microsoft’s Direct Play API. This concept is useful for federates that need to play HLA one day and drop back to play DIS another day. Once an AFLM is created, it can be retrieved again at a later time and reused by the federate (without having to remap). This approach allows the maintenance of only one instance of a federate.Based upon the discrepancies found during the mapping and inspection process, along with publish and subscribe (P/S) capabilities, OMSpector™ provides the capability to generate the transition code stub for the AFLM in C++. The source (cpp) and header (hpp) files are displayed in a code view section for engineer inspection. A C++ class is generated for each Target object class (FOM) linked by the Core (SOM) and the appropriate translations methods are declared within the respective class (see code listing in Appendix A). The user is left only with the requirement to insert the necessary translation algorithms within the source (cpp) file for the AFLM. This necessitates the capability to reuse algorithms.  The issue of algorithms must be common across the federation as defined by the FEDEP. This is necessary to insure valid interactions among all federation participants. This can be accomplished via code library selections in which an engineer selects the code library that satisfies the algorithm agreements and inserts the appropriate algorithms within the AFLM for the transition methods.5.4  ALFM FlexibilityThe approach described thus far is feasible for a number of operating systems including Unix, and Windows 9x/NT/2000. Currently, OMSpector™ is designed to support the creation of an AFLM that is a Windows-based DLL. The header file that identifies the interface for the AFLM provides the API calls that the federate will utilize to pass on SOM information to the federation. The AFLM modifies that information (if necessary) and passes it on as FOM information through the RTI calls to the Federation. Incoming information is also translated by the AFLM and passed on to the federate by way of AFLM defined Window callback messages. This approach within Windows allows federates developed under a number of languages (whether they are object-oriented or not) to communicate with the AFLM (which is object-oriented). Example federate languages might include C/C++, Delphi, Visual Basic, Lisp, Java, and others.5.5  ExampleAppendix A provides a listing of the code generated due to Publish and/or Subscribe capabilities of the object class link illustrated earlier. In this case, the SOM object class, “SeaVesselMil”, is linked to the FOM object class, “MiltarySeaSurfacePlatform”. The SOM object class attribute, “AngularVelVector” with capability as Subscribe (S), is linked to the FOM object class attribute, “VelocityVector” with capability as Publish/Subscribe (P/S). As additional object class attributes and interaction class parameters are linked and automatically compared, a code block can be created to allow inclusion of the appropriate function that handles the discrepancies found within the attribute/parameter linkage. This is the insertion point for a SOM-to-FOM transition algorithm. 6.  OM Synchronization (OMS) FileIt is important to note that OMSpector™ creates and utilizes an open Object Model Synchronization (OMS) Data Interchange Format (DIF) file that contains the map information that the engineer has generated. Currently, the OMS DIF file format is in Backus-Naur Format (BNF); however, requirements are in place for migrating the format to the eXtensible Markup Language (XML). The next few paragraphs identify and explain the type of data captured in the OMS DIF file.The majority of the data captured in the OMS file identifies the links made between object classes and the links between the attributes of those object classes. Figure 6.1 provides a snapshot of the data stored in the OMS file based on the links illustrated in Figure 4.1.1. To facilitate FEDEP automation, OMSpector™ automatically publishes the OMS DIF file through the CAFDE Engine [4]. Once the mapping process is underway, a full inspection of the object model linkage can be attained. Figure 6.1 OMS DIF Additional BenefitsIn addition to providing support for Adaptable Federates, the Object Model Inspection approach can also be used to support a number of other significant capabilities. These capabilities are identified and described in the following sections.7.1 FOM-to-FOM mappingConsider the possibility of two different, pre-established federations that desire to interoperate with one another. Rather than merging the two FOMs that represent each federation into a single FOM, and insisting that each federate comply with the new FOM, a Dual Federation Gateway could instead be established which provides the necessary interoperability between each federation. This is accomplished by first performing a FOM-to-FOM mapping and generating the links and translation code necessary to create a Dual Federation Gateway.  As a result, existing Federations remain intact without comprise and yet they are still able to cooperate with other federations. The concept of Multiple Federation Executions may certainly be required in the future, and a FOM-to-FOM Mapping provides a method of satisfying this requirement.7.2 SOM-to-SOM mappingAs a federate grows and expands its SOM may require modification and change. In order to facilitate the integration and evolution of the federate to a new or updated SOM, a mechanism is needed. The concept of SOM-to-SOM mapping provides a way to support SOM changes within the federate. Considering that this mapping identifies the areas of modification, specifically the differences that require translation, and the new features that require new updates, a SOM-to-SOM mapping helps in the maturation process of a federate by providing update support.7.3 BOM-to-OM MappingIf SOMs and FOMs are built with reusable components such Base Object Models (BOMs), a library of “reusable” code could be available which would support faster federate integration [7]. This would revolutionize federate/federation integration, however to accomplish this, a mechanism is required to identify objects within a FOM or SOM. Again, the concept of mapping BOMs to either FOMs or SOMs will prove to be vital in identifying important meta-data such as requirement information and translation code.  BOMs are common units, if one federates SOM links with a BOM contained within a federation FOM, quite possibly other federate SOMs link as well.  Rather than each federate engineer designing, developing, and implementing similar translation algorithms, it can be done once and shared among federate engineers.  7.4  Federation ExecutionThe OM Mapping identifies the federate’s responsibilities and capabilities. This information allows testers and analysts to assess the effectiveness/performance of the federate within the federation during the execution. This helps achieve the goals identified in FEDEP Step 6.FEDEP Step 6 – “The federation is executed, outputs generated and analyzed, and feedback provided to the federation sponsor.”Measuring actual federate participation against the federate expectations identified in the map allows analysts to properly determine federation performance and feedback verifiable data to the federation sponsor. Conclusions The “Adaptable Federate” concept described within this paper provides an approach that effectively reduces the hurdles a federate encounters when attempting to comply with a federation. This is achieved through Object Model Mapping and Inspection between a federate (SOM) and federation (FOM).  Based on the discrepancies identified from the mapping, SOM to FOM transition code can be generated allowing a SOM-based federate to adapt to various FOM-based federations.  In addition, the RTI Interface calls needed to support the federate that occur between the FOM and RTI can also be easily identified by way of the P/S responsibilities for a federate.  Object Model Inspection with automated tools such as OMSpector™ assist in the Adaptable Federate concept.  Benefits include minimal code impact, minimal time consumption for the federate, little to no impact to the simulator, and promotion of reusable algorithms for the transition code. Through Object Model Mapping, federates are able to “plug-and-play” in multiple federations via the Adaptable Federate Link Module (AFLM).References[1] Defense Modeling and Simulation Office, “HLA Federation Development and Execution Process (FEDEP) Model,” Version 1.4, June 1999.[2] OMSuite Home Page, http://www.synetics.com/omsuite.[3] CAFDE Home Page, http://www.cafde.org.[4] Bachman, J. & Goss, S., “CAFDE TDK: Facilitating Tool Interoperability and FEDEP Automation,” 1999 Spring Simulation Interoperability Workshop Papers, Volume I (99S-SIW-031), March 1999.[5] Defense Modeling and Simulation Office, “HLA Rules,” Version 1.3, Feb 5 1998.[6] Gustavson, P. Root, L. & McAuliffe M., “Use Cases – A Blueprint Approach for Federation Development, Testing, and Analysis,” 1999 Fall Simulation Interoperability Workshop Papers, Volume II (99F-SIW-112), September 1999.[7] Gustavson, P. & Hancock, J., “Base Object Models (BOMs): Reusable Component Objects for Federation Development,” 1998 Fall Simulation Interoperability Workshop Papers, Volume II (99F-SIW-034), September 1998.Author BiographiesJANE T. BACHMAN is a Software Engineer for the Synetics Systems Engineering Division located in Dahlgren, Virginia. She is supporting STRICOM in the development of the CAFDE architecture, CAFDE TBX, and OMSuite™, a CAFDE Enabled tool suite. She is a member of the CAFDE and OMSuiteTM development teams, serving as lead engineer in the development of OMManager™ and OMSpector™. Currently, she chairs the CAFDE Integrated Product Team (IPT) and is serving on the EMF panel. She has been active in modeling and simulation technologies since 1988.PAUL L. GUSTAVSON has over ten years of engineering experience. He is presently a Systems Engineer for the Synetics Advanced Technology Division supporting the Naval Surface Warfare Center Dahlgren Division (NSWCDD) in Dahlgren, VA. Mr. Gustavson has been an active member of the DIS and HLA community since 1993 and has authored and presented several SIW publications. Mr. Gustavson served as a principal member of the RFOM Study Group, championing the BOM concept. He is currently developing OMSuiteTM, an HLA implementation tool suite that utilizes Use Cases, BOMs and is based on the HLA FEDEP and CAFDE architecture. Appendix A - AFLM Source Code ListingThe AFLM Source Code consists of three key files in addition to RTI header files:  CORE Header File, TARGET Header File, and ADAPTABLE CPP File. OMSpector™ generates each of these files.  The Adaptable CPP file provides STUB routines that allow the developer to insert the necessary translation code.  Once complete, the DLL simply needs to be compiled and linked.  The TARGET system requires no future modification after it has undergone an initial build to load an AFLM DLL.  In Windows, this can be done through either a LoadLibrary() call at runtime, or “lib” linked at build time.CORE Header File// This file defines CORE Object Model Structures (it is used by the CORE System)// and the API routines for the core System (such as a federate) to communicate with the// an AFLM DLL#ifndef COREH#define COREH//---------------------------------------------------------------------------// CORE OM Structures// ----------------------------------------------------------------------------------COREhwnd// ----------------------------------------------------------------------------------struct SOMSeaVesselMil {  AccelerationStruct    AccelVector;  AngVelocityStruct     AngularVelVector;  DRAlgorithmEnum		DeadReckonAlgo;  EntityTypeStruct      EntityType;  FederateIdStruct      FederateID;  bool					IsActive;  OrientationStruct     Orientation;  PositionStruct		Position;  VelocityStruct		VelVector;  DamageStateEnum		DamageState;  bool					EngineSmokeOn;  bool					FlamesPresent;  bool					HasFuelSupplyCap;  bool					HasRecoveryCap;  bool					HasRepairCap;  HatchStateEnum		CannopyState;  bool					Immobilized;  LifeformStateEnum     LifeformState;  LightStateEnum		LightsState;  MarkingStruct			Marking;  bool					SmokePlumePresent;  TrailStateEnum		TrailState;  EntityTypeStruct		AlternateEntityType;  bool					CamouflageType;  bool					FirePowerDisabled;  ForceIdEnum			ForceID;  bool					IsConcealed;  bool					AfterburnerVisible;  bool					HasAmmunitionSupplyCap;  bool					LauncherRaised;};// ----------------------------------------------------------------------------------struct SOMSubVessel{  AccelerationStruct    AccelVector;  AngVelocityStruct     AngularVelVector;  DRAlgorithmEnum		DeadReckonAlgo;  EntityTypeStruct      EntityType;  FederateIdStruct      FederateID;  bool					IsActive;  OrientationStruct     Orientation;  PositionStruct		Position;  VelocityStruct		VelVector;  DamageStateEnum		DamageState;  bool					EngineSmokeOn;  bool					FlamesPresent;  bool					HasFuelSupplyCap;  bool					HasRecoveryCap;  bool					HasRepairCap;  HatchStateEnum		CannopyState;  bool					Immobilized;  LifeformStateEnum     LifeformState;  LightStateEnum		LightsState;  MarkingStruct			Marking;  bool					SmokePlumePresent;  TrailStateEnum		TrailState;  EntityTypeStruct		AlternateEntityType;  bool					CamouflageType;  bool					FirePowerDisabled;  ForceIdEnum			ForceID;  bool					IsConcealed;  bool					AfterburnerVisible;  bool					HasAmmunitionSupplyCap;  bool					LauncherRaised;};// ----------------------------------------------------------------------------------// Declaration for Function Call Prototypes // (based on "Publish" ability of CORE structures)// ----------------------------------------------------------------------------------int PublishSOMSeaVesselMil(SOMSeaVesselMile *);int PublishSOMSubVesselMil(SOMSubVesselMile *);// ----------------------------------------------------------------------------------// Declaration for Callback// (based on "Subscribe" ability of CORE structures)// ----------------------------------------------------------------------------------#define SubscribeSOMSeaVesselMil	(WM_USER + 2001)  #endif // COREHTARGET Header File// This file defines Target Object Model Classes (it is not used by the CORE System)#ifndef TARGETH#define TARGETH// ----------------------------------------------------------------------------------class FOMRootObjectClass{public:  // Method to publish to RTI  // virtual so that these maybe overridden  virtual void Publish_to_RTI();   // RTI Event Handling Methods  virtual void Subscribe_from_RTI(); // SOMSeaVesselMil is linked to FOMMilitarySeaSurfacePlatform.	}  // ----------------------------------------------------------------------------------class FOMMilitarySeaSurfacePlatform  : public FOMObjects{public:  AccelerationStruct    AccelerationVector;  AngVelocityStruct     AngularVelocityVector;  DRAlgorithmEnum		DRAlgorithm;  EntityTypeStruct		EntityType;  FederateIdStruct		FederateID;  bool					IsFrozen;  OrientationStruct     Orientation;  PositionStruct		Position;  VelocityStruct		VelocityVector;  ArticulatedParameterStruct     ArticulatedParametersArray;  unsigned short		ArticulatedParametersCount;  DamageStateEnum		DamageState;  bool					EngineSmokeOn;  bool					FlamesPresent;  bool					HasFuelSupplyCap;  bool					HasRecoveryCap;  bool					HasRepairCap;  HatchStateEnum		HatchState;  bool					Immobilized;  LifeformStateEnum     LifeformState;  LightStateEnum		LightsState;  MarkingStruct			Marking;  bool					PowerPlantOn;  bool					RampDeployed;  bool					SmokePlumePresent;  bool					TentDeployed;  TrailStateEnum		TrailState;  EntityTypeStruct		AlternateEntityType;  bool					CamouflageType;  bool					FirePowerDisabled;  ForceIdEnum			ForceID;  bool					IsConcealed;  bool					AfterburnerOn;  bool					HasAmmunitionSupplyCap;  bool					LauncherRaised;  // translation code - Methods to handle attribute descrepancies  void VelocityVector_from_AngularVelVector(AngVelocityStruct value);  // publish from CORE  AngVelocityStruct VelocityVector_to_AngularVelVector();   // subscrbe from CORE  // RTI Event Handling Methods  void Subscribe_from_RTI(); // SOMSeaVesselMil is linked to FOMMilitarySeaSurfacePlatform.};#endif  // TARGETHAFLM CPP File/* This file defines source file for the AFLM DLL program based on input from the two header files listed above and the mappings contained within the OMS file described earlier.*/#include "core.h"    // identifies interface and Core objects#include "target.h"  // indentfies Target objects (what is being mapped to)HWND COREhwnd;  // needed for callbacks to the CORE system/******************************************************************************//*	DLLMain																	  *//******************************************************************************/bool WINAPI DllMain(HMODULE hModule, DWORD dwReason, LPVOID lpReserved){	switch(dwReason)	{	case DLL_PROCESS_ATTACH:		COREhwnd = hModule;		break;	case DLL_THREAD_ATTACH:		break;	case DLL_THREAD_DETACH:		break;	case DLL_PROCESS_DETACH:		break;	}	return true;}// ----------------------------------------------------------------------------------void FOMObjects::Publish_to_RTI(){// RTI Transmission Call//     Insert <<RTI Publish>> processing here...}// ----------------------------------------------------------------------------------void FOMObjects::Subscribe_to_RTI(){// RTI Reception Call//     Insert <<RTI Reception>> even handling processing here...}  // ----------------------------------------------------------------------------------void FOMMilitarySeaSurfacePlatform::VelocityVector_from_AngularVelVector(AngVelocityStruct value)  // publish from CORE{// Data Type//     Insert <<VelocityStruct - AngVelocityStruct>> conversion processing here... // Update Condition//     Insert <<VelocityChange - AngVelocityChange>> conversion processing here...}// ----------------------------------------------------------------------------------AngVelocityStruct FOMMilitarySeaSurfacePlatform::VelocityVector_to_AngularVelVector() // subscrbe from CORE{// Data Type//     Insert <<VelocityStruct - AngVelocityStruct>> conversion processing here...// Update Condition//     Insert <<VelocityChange - AngVelocityChange>> conversion processing here...}// ----------------------------------------------------------------------------------void FOMMilitarySeaSurfacePlatform::Subscribe_from_RTI(){	// instantiate CORE Object	SOMSeaVesselMil * coreobject = new SOMSeaVesselMil;		// perform necessary conversion so that the CORE system understands the object	coreobject->AngularVelVector = VelocityVector_to_AngularVelVector();	unsigned int lparam = 0;	// Tell Core System about message;	SendMessage(COREhwnd,			SubscribeSOMSeaVesselMil,  // standard windows message			(WPARAM) coreobject,	// tell other apps that control program quit			(LPARAM) lparam);	// let CORE system handle deletion of object}// ----------------------------------------------------------------------------------// DLL Function Calls (calls made by the CORE System (e.g the Federate)// (based on "Publish" ability of CORE structures)// ----------------------------------------------------------------------------------// ----------------------------------------------------------------------------------int PublishSOMSeaVesselMil(SOMSeaVesselMile *){// NOTE: link established with Target... FOMMilitarySeaSurfacePlatform	// instantiate Target Object	FOMMilitarySeaSurfacePlatform  * targetobject = new FOMMilitarySeaSurfacePlatform;	// translation routines    targetobject->VelocityVector_from_AngularVelVector(SOMSeaVesselMile->AngularVelVector);  // publish from CORE	// RTI routines	targetobject->Publish_to_RTI();	delete targetobject;}// ----------------------------------------------------------------------------------int PublishSOMSubVesselMil(SOMSeaVesselMile *){	// no map link	return -1;}/*** End DLL Source Code ***/