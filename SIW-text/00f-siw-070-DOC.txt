Networking in the Reconfigurable Flight SimulatorC.A. IppolitoMITRE Corp.McLean VAA.R. PritchettGeorgia Institute of TechnologyAtlanta GA ABSTRACT: The Reconfigurable Flight Simulator (RFS) has been developed as a simulation tool intended to meet the needs of the aerospace research and design community.  This paper discusses the implementation of networking in the RFS.  As background, the need for a simulation architecture used for research and design is briefly discussed and used to illustrate the need for a flexible, extendable architecture which meets the needs of both general users and the developers who will add to the simulator.  The RFS architecture is discussed at a high-level, and a specific discussion networking in a flexible, extendable and modular simulator is provided.  Finally, a description is provided of the  current networking component, which uses the High-Level Architecture (HLA).IntroductionSimulation is an integral part of aerospace research and design.  Its ability to predict complex system behavior makes it valuable to the analysis and testing of many entities, including vehicles, on-board components such as avionics systems, pilot-interactive systems such as cockpit displays, flight control systems, and procedures for operation of vehicles [].  At the completion of vehicle design, high-fidelity simulations can serve as a complement to (or replacement for) flight tests [], and can serve to train the pilots who will first fly the aircraftHowever, there is currently no widely available simulation architectures intended specifically for a comprehensive range of aerospace research and design needs.  Solutions are often oriented towards a single objective and are difficult to apply or modify to fit additional requirements; for example, pilot-in-the-loop simulators can be difficult to convert to simulations capable of running fast-time analyses of flight control systems, and vice versa.  Solutions that do provide a wide-ranging and robust framework are proprietary, expensive, platform-specific or difficult to obtain [].A vital function in a simulation architecture for research and design is the ability to distribute its functions and computational load across a network.  Often in simulation, processing intensive components such as full screen textured 3D renderings, complex display components, and complex aircraft models are too intensive to operate on a single machine while meeting the objectives of a project or experiment.  High fidelity simulations typically require multiple processors to run at interactive rates, where components operate on different machines communicating over a local area network.  Further, a simulation that requires multiple human operators, such as real-time simulations of air traffic control, will require multiple machines to provide input and output services for each operator.This paper outlines the inclusion of networking capability in the Reconfigurable Flight Simulator (RFS).  First, background about RFS is provided.  Then the general networking requirements in a simulator suitable for research and design is discusseded, followed by a detailed description of the current networking components using the High-Level Architecture (HLA).Background on the Reconfigurable Flight SimulatorRequirements Of Simulation For Research And DesignSimulation may be applied in many different ways in aerospace research and design projects (henceforth referred to as ‘design projects’ for brevity’s sake).  Conceptual vehicle design may use lower fidelity simulations of single-aircraft flight dynamics as a tool to analyze vehicle sizing and configuration; human factors experiments may use mid-fidelity pilot-in-the-loop simulations; avionics prototyping and design may use simulation as a hardware-in-the-loop testing mechanism; design of operational procedures or mission scenarios may use batch simulations of multiple vehicles; flight control design may use fast-time simulations with high fidelity vehicle dynamic models; and flight tests require a flight simulator with fidelity high in every measure.This range of needs highlights the need for a design project to have a simulation tool available that is flexible; i.e. the simulation should not be fundamentally constrained by its basic architecture to one mode of operation or to one level of fidelity.A simulation for design projects must also accommodate user types that are fundamentally different than the users of current flight simulators.  The first is that of the general user, who wants to use the simulation as part of his or her day-to-day design activities.  The general user can be defined as a designer who does not want to interact with source code or recompile software.  While all simulations must support general users, design projects are novel in that their general user is quite knowledgeable, and desires considerable power over the simulation so that he or she can reconfigure it and use it in a number of ways.  With normal flight simulations, the general user is shielded from the underlying functionality through graphical user interfaces or simple configuration scripts []; in simulations for design projects, the general user benefits from greater power over the simulation.Unlike most simulation software packages, simulations for design projects must provide support for an additional user class – that of the developer.  In traditional software projects, developers are normally dedicated programmers and software engineers, whose primary purpose is to program the simulation.  Conversely, in design projects the developer is often a member of the design team with some programming knowledge; the developer’s purpose is to make the simulation into a research and design tool.  In this case, the developer is motivated to get the simulation running quickly without any supervision of software quality.  He or she may not be in a situation to understand the complete workings of all the simulation components, and therefore may not understand the impact of his or her modifications.  Additionally, the developers in design projects may be distributed throughout an organization.As such, simulation software for design projects must be designed to be inherently robust and programmable: robust in that modifications to one part of the software should not have widespread, unanticipated effects on other parts of the software;  programmable in that the developer should find the overall framework of the simulation easy to understand, and he or she should quickly be able to find where and how modifications should be made to evoke the desired behavior.To support design projects, simulations must be inherently extendable; i.e. it should be easy to add new functionality to the simulator through the addition of new components, rather than through fundamental changes to the entire architecture.  Likewise, the components should be maintained in a form such that new components can be added to the simulation without destroying currently existing functionality.Finally, the desire for the simulator to be widely-distributed imposes several practical constraints.  For example, many design projects do not need simulations of such high-fidelity that they can not be run on Pentium-based personal computers, while other simulations may be so computationally expensive as to warrant investment in high-speed computers.  As such, simulations that are restricted to one platform inherently limit their distribution.  Likewise, simulations have more general utility when they do not require specific external hardware or peripherals.  DESIGN OF THE RECONFIGURABLE FLIGHT SIMULATORThe Reconfigurable Flight Simulator (RFS) was designed to meet the requirements of a simulator useful for aerospace research and design activities.  The architecture was designed in an object-oriented manner with attention to OOAD principles.  It is programmed in C++, with graphics capability provided by OpenGL, to facilitate portability across platforms.  This section provides a brief description of the RFS architecture; a more thorough discussion of networking in RFS is given in section 3.Overview of the Simulator ArchitectureThe RFS is highly modular.  The main RFS application does not contain any simulation models.  Instead, as shown schematically in Figure 1, the main application provides the run-time support for individual simulation components.  This run-time support includes initializing and registering the individual components, and providing communication between them.  The main application also contains the interface standards that the components must inherit from.Figure 1. Simulation Access of ComponentsThe components, or plug-in modules, are each stored in a precompiled library that can be loaded by the simulator during run-time.  The user can select from a library of available components to configure the simulation as desired for any particular run.  Developers can extend the capabilities of the simulator by creating new modules.The major components of the RFS are shown in Figure 2.  Arrows in this diagram represent the access each component has to other objects in the simulation.  Cyclic dependencies were avoided by creating a hierarchy within the components; in the dependencies shown, for example, the scenario object can call the four types of objects that are ‘underneath’ it, the simulation controller objects can call three types of objects, and so on, with the Environmental Controller and Database (ECAD) object at the bottom of the chain.  All of the objects are based on a simulation foundation class (SFC).  To provide a dynamic framework, the RFS architecture supports swapping, removing, and loading components during run-time.  To prevent problems with violation errors (where objects attempt to access components that have been removed) and to ensure that a newly-loaded component is used properly by other objects, a notification system notifies all components of discrete changes.Components Within RFSThe component-based design of the RFS allows developers to create plug-in modules providing new vehicle models, displays or simulation controllers.  Because these components are stored in linked-lists in the simulation, the number of each which can be included in a simulator configuration at one time is limited only by the computer hardware on which the simulator is being run.  The functionality of the main RFS application can also be extended.  This component-based architecture has several advantages.  Developers in different locations and on different projects can create new components and upload them to a central repository; as such, a distributed development environment is possible.  Since each module is encapsulated, the developer can work on individual modules without needing knowledge about other components.  This facilitates code re-use and reduces the amount of time to tailor the simulation to particular applications.  In addition, simulation developers do not require a broad range of expertise.  For example, a flight controls designer need only modify an aircraft’s dynamic model and flight control design, using established display modules without needing knowledge of computer graphics.General users also benefit from this architecture, as they can create new simulations from this growing library of modules.  Also, a simulation user can store only those components that are needed for their applications, reducing storage requirements.  This paper has focused on how these components are fit into the RFS framework.  The specific details of their underlying models are already well covered in the existing literature, ranging from aircraft dynamic models [] to computer graphics [,].  Also, graphical programming tools, and code generators are increasingly prevalent for these types of components [,].Object Data/Method ExtensionsThe base objects within the main RFS application define the minimum communication standards for components within the simulation.  However, if these standards were the only communication mechanism, then components would be constrained unnecessarily.  For example, a particularly intricate display may require information from an aircraft that is not available through the base vehicle interface.To extend these base vehicle definitions, the Object Data/ Method Extensions (OD/ME) interface was created.  It establishes a generic, simulation-wide mechanism for message and data passing between objects.  All objects in the RFS have OD/ME capabilities built into their base classes, giving them the ability to declare methods and variables to the entire Figure 2. Main RFS Components(Arrows Represent Access to Other Objects In the Simulation)simulation.  The variables can be write-able or write-protected.  Other components can then access these methods and variables through the OD/ME interface.OD/ME adds to the simulation the power to use components with arbitrary communication requirements; this corresponds to an ability to include components of arbitrarily high fidelity and detail.  However, because it passes through an interpreter, OD/ME access can be an order of magnitude slower than direct access through the base class interfaces. User Control Over Simulation RunsThe OD/ME interface also provides the user with the ability to access all aspects of the simulation during run-time.  The most basic method of access is through Graphical User Interfaces (GUIs), such as data viewer windows and graphing windows; such GUIs can be implemented as components meeting the base IO object interface standards.  In addition, the interpreter object can map strings of characters to specific method invocations or data requests.  As such, the user can control the simulator directly through text commands in a command-line window.  Commands are entered through the command window and parsed by the interpreter.  The parsed commands are stored as character strings in the computer memory, which OD/ME can map into method invocations or data retrieval.  In this way, the user can manipulate any object in the simulation during run-time through method invocations and data access.  This interpreted access is a powerful feature of RFS. Interpreter commands were built into RFS that allow the user to control the simulation through the command line window, including the ability to add new components to the simulation, and to list all methods and variables that are available within any active component.  The interpreter language is similar in form to C++, so that developers and general users will not need to learn a new syntax.  Developers can test new components from the command line by executing their methods one-by-one.  Interactions between components can be configured during run-time to meet the needs of the task; for example, a button from a joystick can be mapped to any method of any component active in the simulator, so that pressing the joystick button can execute that method.  Command line inputs can also be stored in plain text script files that the interpreter object can access and process.  As such, general users can configure the simulator before run-time through plain text files, without requiring any access to the source code or recompilation.  These script files can also contain references to other script files, so that standard configurations can be defined and referred to, reducing the complexity of any individual script file.NetworkingRequirements for Networking in Simulators for Research and DesignNetworking is an integral part of many contemporary simulation architectures.  For example, the LaSRS++ simulator requires that all components access shared memory, which can be passed between machines running the simulation.  However, as is common in current simulation architectures, the networking is at a ‘lower-level’ than the other components in the simulation, making them dependent on the networking object.  As a result, changes in networking methods or configuration may require modifications to all components that use networking [].However, the plug-in component design of RFS and the requirement that developers have the ability to further extend the capabilities of the simulator poses difficult design considerations for networking.  RFS provides only the framework for simulation, while particular components such as displays, instruments, and vehicles are added to the simulator through plug-in modules.  RFS encourages developers to create components that do not require the presence of other components.  This facilitates the development of components that can be reused in many different simulations, but provides no single simulator configuration or interface standard for networking to support, and requires the networking object to handle all aspects of inter-machine communication.Since different simulation needs will require different configurations for components, the networking requirements for RFS are somewhat unique in that networking must be provided without knowledge of the configuration of the simulation, including the number of vehicles being simulated and how they uniquely interact.  The challenge is to create an architecture where the networking complements rather than constrains the flexibility of the RFS, allowing for many different configuration possibilities.  Networking components that function for only a few components or configurations will not provide the reusability needed for all RFS users.  This challenge is not to be taken lightly, as different configurations will exhibit different fundamental behavior: in large-scale simulations such as air traffic control simulations, components such as aircraft generators will insert and remove aircraft into an airspace stochastically and controllers will alter trajectories; the simulation can operate in real-time, fast-time, or even run an asynchronous simulation; and human controlled aircraft will be largely unpredictable.The networking component also does not have predetermined knowledge as to what types of vehicles are being simulated.  RFS does define a standard interface that all vehicles must implement, allowing the networking component to retrieve basic vehicle information such as position, orientation, and velocity.  However, the additional interfaces defined by components are usually critical to their operation and the goals of the simulation.  For instance, a conceptual vehicle subsystem may be simulated with custom avionics for pilot interaction.  A networking architecture for the RFS that does not recognize and allow for the communication requirements of such custom components will be of little value.A further complication is that, for developers of other simulation components, the networking must be transparent.  An architecture where networking is transparent allows for modularity in the networking functionality; several networking components can be developed using different protocols without affecting any of the other simulation components.  Developers of other components benefit in that they do not need to learn how to develop for a specific networking protocol, reducing not only the workload and requirements on the developer, but also reducing the size and complexity of the components.  This in turn decreases development time, reduces the propensity for errors, and benefits almost every other aspect of product quality.  Further, since any component can be used in a distributed simulation, this promotes reusability of components.  The downside of a transparent networking functionality is that the workload of the developer of the networking components increases substantially, as complex networking modules are needed.  In general, the networking will know the basic interfaces for simulation components, but will not know the methods or attributes that are defined to extend the interfaces.  The networking components also will not know about the configuration and other components in the simulation.  Since networking is a plug-in capability, the simulation modules will not be able to facilitate communication for distributed simulation. Finally, a desirable trait in networking is ease of use by the general user.  Some networking mechanisms require machine reconfiguration and the initiation of multiple programs in order to perform a simulation run. This adds to the general user’s workload and training requirements, but also increases the potential for errors if a precise start-up sequence is required, especially when the machines driving the simulation are not co-located.  As such, a networking capability is desirable which does not require extra start-up tasks and which does not impose specific start-up sequences across machines.The RFS and the Networking ComponentThe RFS basically provides an empty slot where networking components can be added to the simulation.  As part of its contract with these networking components, the networking object is provided access to almost every other component in the simulation.  The reverse is not true.  We refer here to the networking component as being at a “higher level” than and “above” the other simulation components [].  Such a system achieves transparency for the networking object, meeting many of the requirements outlined in the previous section.Networking components are delivered to the RFS in the same way as other components: through precompiled dynamic-link library (DLL) modules.  All implementation details are relegated to the DLL, distancing the RFS from any networking protocols, links, and libraries.  Different protocols can be used as necessary by developing and using different network components. The networking components are responsible for allowing multiple instances of RFS to operate in a common virtual environment.  Although the actual implementation is up to the developer, it is intended that networking components be responsible for ensuring each RFS instance contains an image of the simulated vehicles in the virtual environment.  These vehicles are either locally loaded vehicle modules, or are vehicle images that approximate the behavior of remote vehicles (remote vehicle approximations, or RVA).  It is the responsibility of the networking component to maintain these images and provide updates on the objects through techniques such as dead-reckoning, although again, the actual implementation is up to the networking component developer.The HLA Networking Component for RFSThe networking object currently used by, and distributed with, RFS has been developed at Georgia Tech using HLA Version 1.3 and the existing run-time infrastructure (RTI) provided by the Defense Modeling and Simulation Office (DMSO).  HLA was chosen for several reasons: the availability of the RTI to handle the low-level network-communications; HLA’s role as a general standard; and the ability of HLA standards to fit into the requirements imposed on the networking object, especially transparency to the developer.An HLA federation is created by the use of the networking component on all participating machines ( federates).  Each federate can communicate information as defined in an attribute table for RFS, creating a shared virtual environment.  All federates are at an equal level, so that real-time simulation data is shared equally between all machines.  Other HLA simulations can connect by supporting the RFS attribute table.The networking module for RFS is flexible, allowing for many different configurations.  For example, a pilot-in-the-loop simulation may distribute graphics and dynamic-model calculations across multiple machines; a controller station can be added to remotely control the simulator; and other federates can join in to provide a multiple vehicle simulation.  Changes in configuration do not require modification of the networking object or any other components’ software.  Instead, the configurations are determined by the components that are run on each individual machine at start-up; the configurations can be changed during run-time.The majority of the data passing concerns information about the vehicles.  Vehicle information is passed between networking objects to create remote vehicle approximations (RVAs) on all the machines.  Displays and other components on an individual machine can interact with an RVA as if it were a vehicle component resident on that machine.In order to reduce network bandwidth, the RVAs use dead-reckoning to update their picture of vehicles states.  The initial state of a vehicle is sent across the network when the simulation starts (or when a new vehicle is added), thus initializing an RVA on each machine for this vehicle.  Within the machine actually simulating the vehicle, the networking object compares the vehicle state predicted by the RVA with the actual vehicle state; when the difference reaches a specified tolerance, updates of the out-of-tolerance parameters are sent to all the federates to update their RVA. In addition to a standard set of vehicle states, the networking component in each federate is also responsible for communicating the extensions of any vehicle component beyond the standard vehicle interface.  These are made available as OD/ME variables registered to a vehicle, and are included in the RVA for each vehicle on each federate.  This allows any component in the simulation to access the entire set of parameters made public by a vehicle component, without requiring the developer of a vehicle to change the networking object.The ability to pass OD/ME variables and methods also creates the ability for run-time manipulation of any simulation component from any machine.  OD/ME commands can be directed to any component through the command window on any machine.  For example, an experimenter can remotely change the properties of an aircraft or a display for the subject-pilot to react to.  Components within the simulation can also send commands to other components.  For use in some situations, this functionality can be disabled on some machines; for instance, the machine that a subject-pilot is operating can have this capability denied.The shared virtual environment created by this use of HLA provides a powerful mechanism for running simulations across multiple machines.  It requires no additions to any simulation components; the same components can be run in any of a number of configurations (networked or not) without requiring any changes to their source code.  As such, the objective of complete transparency to the developer has been realized.  Likewise, the general user needs only to run the HLA networking tools in the background and start the networking object on each machine to create a networked simulation, meeting the need for a networking mechanism easy for the general user to utilize.However, this particular application of HLA and networking components does have some limitations.  First, changing in the networking protocol require a developer to create a new networking component.  This networking component receives little ‘help’ from the other components in the simulation; instead, it must actively communicate and monitor them.  Second, the use of RVA’s may not provide sufficient bandwidth and reduced latency in simulations with fast dynamics.  Finally, in very large simulations, it may be cumbersome and computationally inefficient for each federate to monitor each vehicle when any particular machine may only need knowledge of a sub-set of the total vehicles.CONCLUSIONThis paper examined simulation as a general research and design tool.  While simulation can bring powerful analysis capabilities to research and design, its use has traditionally been limited by the time and resources required to create a simulation providing the desired features, and by the use of different simulation architectures in different domains.The RFS provides a framework that is extremely flexible and extendable to fulfill these needs. Simulation users are provided with near-complete control over the simulation and its components, and can build on existing components to rapidly create new prototypes and solutions.  The RFS has proven to be a stable and scalable platform for development.  Designers benefit from a library of components that facilitate development, such as real-time monitoring and graphing components, as well as features such as the programmable real-time environment to provide extreme control over all objects in the simulation during run-time. The RFS has been used for a variety of simulations, from fast-time large-scale simulations of air traffic control [], to single-aircraft pilot-in-the-loop studies of cockpit systems [,].Through its flexible architecture, the RFS provides a single software simulation solution for the entire design process.  As a design matures, it requires a simulation that can adapt to new requirements and higher fidelity. The RFS provides a flexible and scalable framework for early design work which can adapt as more detailed and accurate simulations are required. For conceptual design and exploratory prototyping, component reuse and modification of existing capabilities can provide a fast solution. As the design progresses and requirements grow, the RFS adapts by allowing the development and integration of higher fidelity components, hardware interfaces, and other tools to expand the simulation as requirements grow. The RFS architecture opted to place the networking a higher level then the components, with the result that networking capabilities are transparent to component developers and components do not need to build in special features to access the networking interface.  Instead, the burden is placed on the developer of a networking interface to determine the information that is to be passed.  Further, the overall architecture is not reliant on a single networking protocol.  Currently, a networking component has been developed that uses the High Level Architecture (HLA) standards.  A shared virtual environment is created between all instances of RFS across the network, in which all instances have knowledge of all vehicle objects.  To reduce bandwidth requirements, each instance uses dead-reckoning to update their information about the vehicles; accurate updates of vehicle information are sent out only when needed.  The application of OD/ME within the networking object has allowed for transparent implementation of objects that have interface requirements extending beyond the base vehicle standards used throughout RFS.  Additionally, commands can be sent between machines using the OD/ME interface, so that simulation components on separate machines can be controlled remotely, without requiring any special development or configuration.ACKNOWLEDGEMENTSThis work was supported by a contract with the Lockheed Martin Corporation, David Hansen acting as technical monitor, and by NASA grant NAG 1-2175 from the Langley Research Center, Paul Schutte acting as technical monitor.  Thanks is also due to the other programmers who have contributed to the development of RFS modules.REFERENCES___________________________________________PAGE  1[] S.T. Tuohy: “An Integrated Vehicle Simulation For the Development and Validation of a Commercial Reusable Launch Vehicle” AIAA Modeling and Simulation Technologies Conference and Exhibit, Boston, MA, 1998.[] J.J. Totah and D.J. Kinney: “Simulating Conceptual and Developmental Aircraft” AIAA Modeling and Simulation Technologies Conference and Exhibit, Boston, MA, 1998.[] R.A. Leslie et al: “LaRS++ An Object-Oriented Framework for Real-Time Simulation of Aircraft” AIAA Modeling and Simulation Technologies Conference and Exhibit, Boston, MA, 1998.[] S. Khoshafian, and R. Abnous: Object Orientation: Concepts, Analysis & Design, Languages, Databases, Graphical User Interfaces, Standards, Wiley, New York, 1995.[] B. Stevens and F. Lewis: Aircraft Control and Simulation,  John Wiley, New York, 1992.[] J. Foley et al.: Computer Graphics: Principles and Practice, Addison-Wesley, Reading, MA, 1992.[] M. Woo et al.: OpenGL 1.2 Programmers Guide, Addison-Wesley, Reading, MA, 1997.[] C.A. Ippolito and A.R. Pritchett: "SABO: A Self-Assembling Architecture for Complex System Simulation", The 38th AIAA Aerospace Sciences Meeting and Exhibit, Reno, NV, 2000.[] A. Robins et al: “Commercial Visual Programming Environments: One Step Closer to Real Simulation Reuse” AIAA Modeling and Simulation Technologies Conference and Exhibit, Boston, MA, 1998.[] M.M. Madden, P.C. Glaab, K. Cunningham, P.S. Kenney, R.A. Leslie, and D.W. Geyer “Constructing a Multiple-Vehicle, Multiple-CPU Simulation Using Object-Oriented C++”, AIAA Modeling and Simulation Technologies Conference and Exhibit, Boston MA, 1998.[] J. Lakos: Large Scale C++ Software Development, Addison-Wesley, Reading, MA, 1996.[] A.R. Pritchett, S.M. Lee, D. Huang, and D. Goldsman: “Hybrid-System Simulation for National Airspace System Safety Analysis”, AIAA Modeling and Simulation Technologies Conference and Exhibit, Denver, CO, 2000.[] A.R. Pritchett and L.J. Yankosky: “Pilot Performance at New ATM Operations: Maintaining In-Trail Separation and Arrival Sequencing”, AIAA Guidance, Navigation and Control Conference, Denver, CO, 2000.[] T.L. Chen:  “Intelligent Displays for Flight Re-Planning Following System Failures”, Unpublished masters thesis, School of Aerospace Engineering, Georgia Institute of Technology, Atlanta, GA, 2000.COREY IPPOLITO  is a senior software engineer at the MITRE Corp’s Center for Advanced Aviation System Design (CAASD).  He has received a B.S. and M.S. from the School of Aerospace Engineering at the Georgia Institute of Technology, specializing in software engineering concerns in flight simulation and large-scale simulation architectures.AMY PRITCHETT is an assistant professor in the Schools of Industrial and Systems Engineering and Aerospace Engineering at the Georgia Institute of Technology.  She has received an S.B., S.M. and Sci.D. from the Department of Aeronautics and Astronautics at the Massachusetts Institute of Technology.  Her research specialties include cockpit design, air traffic control, flight simulation, and large-scale agent-based simulation of hybrid systems.