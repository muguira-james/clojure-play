RTI NG and pRTI Performance for Simulated Aircraft, Real Time UpdatesRune Sj√∂str√∂mUlf JohanssonAndreas NybergCelsiusTech Systems ABNettov√§gen 6SE 17588 J√§rf√§lla, Sweden+46 8 580 840 00rusj@celsiustech.se, uljo@celsiustech.se, anny@celsiustech.se Keywords:RTI NG, pRTI, real time, performance, simulated aircraft.ABSTRACT: In distributed real time simulations for air defence C2 systems, a large part of the computer and network load consists of aircraft state updates. This paper presents the results of performance measurements with RTI NG and pRTI in a federation comprising performance test federates running on PC/Windows NT nodes attached to an Ethernet LAN. CPU load, update delays and LAN utilisation are measured. The performance test federate, developed by CelsiusTech Systems, creates a variable number of aircraft objects and generates and receives aircraft attribute updates (e.g. position, velocity and orientation) with a variable update flow. The performances of the studied RTI:s (both best effort and reliable delivery modes) are compared and analysed. The study is sponsored by the Swedish Defence Materiel Administration.1. IntroductionIn distributed simulations for air defence C2 systems, a large part of computer and network load consists of aircraft state updates. In this paper, we will present a performance study of two HLA RTI:s, RTI NG (DMSO, USA) and pRTI (Pitch AB, Sweden), with respect to simulated aircraft state updates. The paper will focus on CPU load, transmission delays and network utilisation, in the ranges where the RTI:s work satisfactory. Interactions and Data Distribution Management are not used. The study is sponsored by the Swedish Defence Materiel Administration. 1.1 BackgroundCelsiusTech Systems AB develops and maintains military command and control systems and combat management systems for air and naval defence. In conjunction with the C2 systems, simulators are used for operational evaluation of new systems and for training of system operators.1.2 PurposeThe purpose of this study is to investigate the performance of the RTI:s in a well defined environment, in order to get a reference. The reference will enable us to predict the performance of future configurations. For this, we have chosen a PC based Local Area Network configuration.1.3 OutlineChapter two describes the measurement method and the configurations. In chapter three the results are listed and analysed, followed by a summary and conclusions in chapter four.2. Measurement MethodThe basic idea of the measurements is to measure CPU load, attribute update delays and network utilisation in a federation with identical federates.Each federate registers a configurable number of aircraft objects, updates them, and subscribes to and receives the updates from the other federates.The number of test aircraft objects are the same for all federates in the same measurement, but are varied from one measurement to another.2.1 HardwareThree identical nodes (equivalent to a standard desktop PC) are used, each comprising:300 MHz Intel Pentium II single CPU PC128 MB RAMEthernet/Fast Ethernet network cardWindows NT4 SP5The network is a 10 Mbps Ethernet with the nodes connected using a hub. 2.2 SoftwareThe software products used in the tests are:RTI NG 1.3-V1 for PC/NT (C++) from DMSO running with the default RID file values.pRTI 1.3.12 (C++ binding) from Pitch Kunskapsutveckling AB running with Java JVM from JDK 1.2.2 from Sun Microsystems.The test federate FPLL v1.4 (C++) from CelsiusTech Systems AB, compiled with Microsoft Visual C++ 6.0 SP3.The federate, FPLL, is a real time simulation application designed to test performance for aircraft state updates. It is a C++ program that is compiled and linked with either RTI NG or pRTI using the C++ interface provided by the RTI. Functionally, FPLL is similar to a combination of the RTI throughput and latency benchmark programs from DMSO [1].Each FPLL instance is a federate generating a configurable number of aircraft and updating those with a configurable frequency. Normally all the updates are sent in a single batch at the beginning of each period. After the transmission of a batch the program waits for the period to end, using tick() for RTI NG and sleep() for pRTI (the pRTI implementation of tick() is a sleep()). Other update strategies are also applied for the sake of comparison. When so, this is explicitly stated in the text.Several FPLL federates comprise a federation where each federate receives the updates that are generated by the other(s). Each update is assigned a timestamp just before calling the RTI ambassador for attribute set creation, data packing and subsequent update request. The clock available from the operating system is used for this timestamp (see also 2.4 for more details). The timestamp is transmitted as data with the update. At reception of the timestamp attribute, it is compared to the time in the receiving FPLL federate. This is done just after the data is extracted in the federate ambassador reflectAttributeValues() callback. Mean value and standard deviation are calculated from the time difference and reported after the measurement period has ended.Figure 2.1 FPLL SOMThe FPLL SOM, Figure 2.1, is derived from the BaseEntity object of the RPR FOM [2] and is also used as the FOM. A TestAircraft subclass has been added, containing an attribute with a timestamp and a reference for collecting the statistics data (currently referring to the federate). All attributes except the DrParameter are used in the measurement updates. Note that the entity used in these measurements may represent any object with similar attributes. We have chosen an aircraft, since such an object interests us the most.Two versions of the FED file are used with either reliable or best effort delivery mode selected for the attributes. Both FED files use receive order for all attributes.2.3 ConfigurationsFour different measurement configurations are used, each one for a specific purpose:In the first configuration, the bypass configuration, the federate is sending updates to itself by a data copy operation in a single computer. The RTI is not used. By running this configuration the contribution to CPU load and update delays from FPLL itself can be measured. As it turned out the CPU load and delays are very small (less than one percent) compared to the configurations below. Thus the contributions from FPLL are ignored.In the second configuration, the single node configuration, a federation with two or three federates is created and executed together with the RTI within the same computer. The purpose of this configuration is to measure CPU load and update delays without the contributions from the network.In the third configuration, the dual nodes configuration, one federate will run in each of two computers attached to the network, Figure 2.2. The two federates communicate using either of the RTI:s. This is the main measurement configuration and the basis of most of the diagrams. In this configuration each federate sends and receives updates, e.g. for a federation with 300 objects, each federate sends updates for 150 objects and receives updates for 150 objects.Figure 2.2 Dual Nodes ConfigurationIn the last configuration, the triple nodes configuration, one federate will run in each of three computers attached to the network. The federates communicate using either of the RTI:s. This configuration is used to measure the influence on the results of the addition of a new simulation node to the federation. In this configuration each federate sends and receives updates, e.g. for a federation with 300 objects, each federate sends updates for 100 objects and receives updates for 200 objects (100 from each of the other federates).2.4 ToolsCPU load is measured using the NT Performance Monitor.Delays are measured using the system clock of each computer. Since the actual delays are of the same magnitude as the accuracy of the network clock synchronisation (Windows NT Timeserv/NTP), direct subtraction of send time from receive time is not useful. Instead the average of the delays in both directions between any two federates are used. As the time differences in the two directions cancel each other, this is assumed to be correct within the drift of the clocks.LAN utilisation is measured using the Microsoft Network Monitor attached to a separate monitoring computer in the network. For all measurements the average from a measurement period of 100s is used.3. Measurement ResultsThe measurement results for CPU load, update delays and LAN utilisation are presented and analysed in the following paragraphs. The values of the x-axis of the diagrams are state updates/second. This is the sum of all TestAircraft state updates, from all federates in the federation. As all federates subscribe to all updates, this value will also be the sum of the sent and the received updates for a single federate. A state update is the update of the position, velocity, orientation and time attributes of a TestAircraft object. All attributes have an update frequency of 1Hz.In the diagrams "rel" means reliable delivery mode and "be" means best effort delivery mode.3.1 CPU LoadThe CPU load discussed here is the load of a single FPLL process including the Local RTI Component in a node. The RTIexec:s of the two RTI:s generates very little CPU load during the object update transmissions. It is basically during initialisations and registrations that the RTIexec:s generate any significant load.Figure 3.1 shows the CPU load for dual nodes. From the measurements it can be derived that within the measurement range, such a load is proportional to the number of objects in the federation. The best effort delivery mode requires slightly more CPU power than the reliable delivery mode for both pRTI and RTI NG.When using Sun¬¥s Java Virtual Machine (JVM) from JDK 1.2.2, pRTI requires approximately three times as much CPU power as RTI NG.Figure 3.1 Dual Nodes CPU LoadThe CPU load varies for pRTI between dual and triple node federations with the same number of objects in a federation. The load is 15-20% higher for triple nodes than for dual nodes. For RTI NG, the difference is less than 5%.Comparing a single node configuration to a dual nodes ditto, i.e. comparing the sum of the CPU load of two federates on a single node with the CPU load of one federate on node1 and another federate on node2, yields no obvious difference in CPU load. The same comparison between a single node configuration with three federates to a corresponding triple nodes configuration, yields no obvious difference in CPU load either.In an attempt to find an explanation for the differences in CPU load between pRTI and RTI NG a separate set of tests was performed with a different JVM (Sun¬¥s Java Hotspot2 release candidate 1 [TM] JVM). The tests show that the CPU load of pRTI was reduced by 45% in reliable delivery mode and by 21% in best effort delivery mode.Figure 3.2 pRTI CPU Load ImprovementFigure 3.2 shows the CPU load reduction for pRTI when using Sun¬¥s new JVM. The figures for Hotspot2rc1 [TM] JVM are published with kind permission from Sun Microsystems, Inc.The measurements presented in Figure 3.2 were conducted with pRTI 1.3.16 in a federation with two FPLL federates in a single node.3.2 Update DelaysThe average delay is measured between the two federates in a federation with two network nodes and one federate in each node. The diagrams, Figure 3.3 and Figure 3.4, shows how the delay varies with the update rate for a constant update frequency (1 Hz). The standard deviation of the delays is not shown in the diagrams, but is still measured. It varies a lot but is roughly of the same size for both RTI:s as the delays themselves.Figure 3.3 Dual Nodes Transmission Delays (1)For small federation update rates, below 300 updates/s (Figure 3.3) it can be noted that pRTI has a delay that is approximately proportional to the update rate while RTI NG has a more or less constant delay. One possible explanation for this is that, with the used RTI configurations, RTI NG use bundling of data before transmission while pRTI does not.Figure 3.4 Dual Nodes Transmission Delays (2)For federation update rates above 300 updates/s, the delay increases as the update rate increases. A significant improvement can be achieved by using modified update strategies to avoid the blocking of data reception that occurs during the consecutive update calls. For both RTI:s the updates can be broken into several smaller batches spread out over the refresh period. However, even without improvements the delays are well below the update period of 1000 ms.For RTI NG, an additional improvement possibility has been tried by using tick(). Figure 3.5 shows the result of inserting a tick() after every 31 update. This gives a significant improvement of delay times, but does not affect CPU load or LAN utilisation. Inserting tick() more often gives no significant additional improvement of delay times, but increases the CPU load.Figure 3.5 RTI NG Transmission Delays ImprovementThe curves in Figure 3.4 are for a network with two nodes with one federate in each node. Addition of another node and another federate give similar delays.Measurements with both federates in the same node shows no obvious differences in delay times, given the same load as in the two node case.3.3 LAN UtilisationRTI NG and pRTI use TCP/IP unicast for reliable delivery between federates. For best effort delivery, RTI NG uses UDP/IP multicast while pRTI uses UDP/IP unicast. Bundling is enabled as default for RTI NG, while pRTI have bundling disabled as default.Figure 3.6 shows the LAN utilisation for dual nodes. There is a linear increase of LAN utilisation in all four cases. pRTI¬¥s LAN utilisation is higher than RTI NG¬¥s. pRTI reliable delivery generates 15-20% more traffic than pRTI best effort delivery, while the graphs of RTI NG (best effort and reliable) are very similar.The use of bundling in RTI NG is probably the main reason for its lower LAN utilisation. The larger size of the TCP header compared to the UDP header and the transmission of TCP acknowledge packets, explains the difference in LAN utilisation between best effort and reliable delivery modes. These facts have a much larger impact on pRTI¬¥s performance since pRTI (without bundling enabled as default) adds TCP or UDP/IP and Ethernet headers to each update while RTI NG (with bundling as default) spreads the header overhead between many updates.Figure 3.6 Dual Nodes LAN UtilisationIn the triple nodes configuration, Figure 3.7, we see the benefit of using UDP/IP multicast instead of unicast for best effort delivery. The LAN utilisation of RTI NG best effort delivery is only half of that of the other three cases.Figure 3.7 Triple Nodes LAN UtilisationWhen we compare the LAN utilisation for dual nodes and triple nodes test cases having the same number of state updates/s, RTI NG best effort delivery is the only test case, with a similar LAN utilisation both in dual and triple node simulations. In the other three cases the utilisation is doubled, due to the fact that unicast sends one transmission to each subscriber.In the single node simulations, only RTI NG best effort delivery generates traffic on the LAN. RTI NG best effort delivery distributes all updates on the LAN, even if RTIexec, Fedex and all federates are running on the same node.Both RTI:s managed to send and receive all attribute updates in all reliable delivery test cases. In the best effort cases test cases, the RTI:s began losing updates at approximately 250 state updates/s. At the maximum update levels for dual nodes (1024 state updates/s), the federates managed to receive more than 89% of all updates sent. This is valid for both RTI:s. pRTI began losing updates earlier than RTI NG and received marginally less updates.4. Summary and ConclusionsBoth of the studied RTI:s are able to handle federation update rates in the range from 1 to 1000 aircraft state updates per second in the studied network configuration. It has to be emphasised that the measurements are made using the default RID file values for RTI NG. Other values for the configuration parameters may give different results. pRTI¬¥s C++ binding is not configurable, although the bundling option can be set from pRTI¬¥s Java API.There are other previous performance papers of the RTI:s examined in this study. RTI Lite, a Java based RTI which pRTI has evolved from, was presented at the 1998 Spring SIW [3]. A RTI NG performance study was presented at HLA AMG meeting 32 in august 1999 [4].The main conclusions drawn from the CPU load measurement results are:The CPU load is proportional to the amount of state updates per second.pRTI generates more CPU load than RTI NG. One of the reasons may be the performance of the JVM used by pRTI.Best effort delivery generates slightly more CPU load than reliable delivery for both RTI:s.The main conclusions drawn from the delay measurement results are:The delays are small compared to the update period.By using special update strategies, the delays for large update rates can be reduced.For small update rates pRTI has smaller delays than RTI NG, possibly due to the fact that, with the used RTI configurations, RTI NG have bundling enabled while pRTI have not.The main conclusions drawn from the LAN utilisation measurement results are:The LAN utilisation is proportional to the amount of state updates per second.pRTI, especially reliable delivery, has a higher LAN utilisation than RTI NG. The lack of bundling may be the main reason for this.RTI NG¬¥s use of UDP/IP multicast for best effort delivery is very useful when the federates are located at three or more nodes, but may be a drawback on single node simulations.5. References[1]	Defense Modeling & Simulation Office, ‚ÄùRTI Performance Benchmarks‚Äù, 1999[2]	Simulation Interoperability Standards Organization, ‚ÄùReal-time Platform Reference FOM‚Äù, version 0.5, July 1998[3]	Mikael Karlsson, Staffan L√∂f, Bj√∂rn L√∂fstrand: ‚ÄùExperiences From Implementing an RTI in Java‚Äù, 1998 Spring Simulation Interoperability Workshop, 98S-SIW-062, March 1998.[4]	Defense Modeling & Simulation Office, ‚ÄùRTI Next Generation Update‚Äù, presentation at the HLA Architecture Management Group Meeting 32, August 1999.Author BiographiesRUNE SJ√ñSTR√ñM is an Advisory Scientist at CelsiusTech Systems, J√§rf√§lla, Sweden. He works with system analysis and design and has recently been involved in the development of a training and evaluation simulator for Air Defence Command and Control, including performance measurements. He received a Master of Science from Chalmers University of Technology, G√∂teborg, Sweden.ULF JOHANSSON is a Systems Engineer at CelsiusTech Systems, J√§rf√§lla, Sweden. He works as a software developer and has experience from HLA and DIS applications and simulation of communication systems and networks.ANDREAS NYBERG is a Systems Engineer at CelsiusTech Systems, J√§rf√§lla, Sweden. He works as a software developer and has experience from HLA applications. EMBED Word.Document.8 \s 