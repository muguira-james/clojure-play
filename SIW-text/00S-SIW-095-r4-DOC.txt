Utilising HLA Object Models within a C++ Repository to generate tools to support the Federation Development and Execution ProcessChris RougetPaul HenryFlight Management & Control DepartmentAir Systems SectorUK Defence Evaluation and Research Agency (DERA)Bedford, EnglandTel +44 (0) 1234 22 5281Fax +44 (0) 1234 22 5409cjrouget@dera.gov.ukpshenry@dera.gov.ukKeywords:Code Generation; FEDEP; FOM; Framework; HLA; OMDT; Repository; SOM; ToolsABSTRACT:  As part of the process for developing High Level Architecture (HLA) federations there is scope to generate tools which can be used to examine any HLA compliant Object Model (Federation Object Model or Simulation Object Model), as well as automatically generating HLA Federate source code.HLA Object Model Template (OMT) consistency checks can be performed between a Federation Object Model (FOM) and either one or more Simulation Object Models (SOMs) or another FOM. Specifically between object class structures, interaction class structures, attribute tables, parameter tables, enumerated and complex datatypes.The outputs from this process include reports that can assist Federation developers to monitor and record FOM/SOM changes and to check the allocation of functionality to the selected Federateâ€™s (SOMs), identified during the Federation Development and Execution Process (FEDEP).This paper describes lessons learned from work already completed and work currently in progress concerned with the utilisation of HLA Object Models within a C++ Repository to generate tools to support the FEDEP. The HLA Federate source code that is generated provides a framework, which separates the interface between the HLA Run-Time Infrastructure (RTI) implementation and the Federate developers application.IntroductionThis paper describes work currently in progress in the UK, aimed at studying the scope for generating tools to support the FEDEP, based on the utilisation of HLA Object Models within a C++ Repository.This work is funded as part of the UK DERA Corporate Research Programme (CRP), Technology Group 5 and originates from earlier CRP studies conducted between 1996 and 1999. These studies provided an initial focus for integrating â€˜legacyâ€™ human-in-the-loop flight simulators into a distributed simulation environment based on standards for Distributed Interactive Simulation (DIS).One of the prime lessons learned was that the availability of Commercial-off-the-Shelf (COTS) Tools to support DIS based applications reduces the cost and implementation time-scales. As an example, the use of COTS products such as the MaK VR-link toolkit allows application-coding frameworks to be developed that minimise the developersâ€™ need for expertise with the low level DIS protocols and allow the developersâ€™ to concentrate their effort on their particular simulation application.DIS provides standards based protocols and supporting enumerated types, ideally suited to such C++ class coding frameworks. The scope of the data interchange is both well defined and tightly controlled, originally through the DIS workshops, with final encapsulation in the IEEE 1278 standards. In contrast HLA in its broadest sense has no fixed protocols, data-types or enumeration values. Reference FOMs may appear and become accepted standards but currently the only one attracting particular interest is the Realtime Platform Reference FOM (RPR-FOM) which is, some may consider, to be DIS by another means.The HLA community wants to take full advantage of the freedom to tailor HLA Object Models (FOMs and SOMs) for optimum functionality, rather than be confined by restrictions imposed by DIS.This research study examines the scope for producing tools that allow automation of coding frameworks independent of the FOM/SOM content. The research activities to date have looked at generating such a prototype framework emphasising the extent to which the RTI internals could be hidden from the developer, thus allowing them to concentrate on their application.Repository OverviewOne of the first requirements was to take the HLA FOM and SOM definitions and get them into a form suitable to processing. This form is termed the Repository which enables the stored FOM/SOM information to be browsed.Figure 1 shows a Rumbaugh Class Diagram representation of the Repository FOM/SOM Class-object and interaction hierarchy with its relationships to other FOM/SOM base data items (complex data types and enumerations).Figure  SEQ Figure \* ARABIC 1: Repository FOM/SOM hierarchyFigure 2 shows how the complex data types and enumerated values within the FOM/SOM are stored. The base types are the common C/C++ in-built types (char, int, float, etc.).Figure  SEQ Figure \* ARABIC 2: FOM/SOM base data itemsAlthough the HLA is not strictly object-oriented, it is object based and as such supports the concept of class hierarchy. These class hierarchies contain no â€˜methodsâ€™ and naturally fit into a C++ class hierarchy. To turn this into a Class-Repository access methods need to be added, which allow the hierarchy to be navigated and searched.Such a hierarchy was implemented on a Silicon Graphics computing platform running under IRIX 6.2 operating environment, using the MIPS C++ compiler.A parser was written to process the Data Interchange Format (DIF) output files generated by the Object Model Development Tool (OMDT), which stores all the FOM/SOM information and generate a hierarchy within the Repository.Having stored the FOM/SOM details in the Repository, a basic set of automation tools which simply translated the data within the FOM/SOM into an equivalent C++ format were produced. These were essentially header files covering the following information:Enumerated data types and their value pairs;Complex data types;Class-object hierarchy including individual class attributes;Interaction hierarchy including individual interaction properties.By automating the production of â€˜commonâ€™ representations, the risk of C++ coded implementations differing from the FOM/SOM definition is removed. All class hierarchical relationships are also defined.The next phase of the research studies involved generating the development framework itself. This was in the form of C++ header and source files. An alternative solution would have been to produce a binary C++ class library, but the source approach was adopted since it gives greater flexibility. Although the framework output is produced on a Silicon Graphics platform it can be used on any platform on which the RTI 1.3v6 Application Programmers Interface (API) has been implemented. To correctly function, the Repository required is that of the Federate SOM not the overall FOM.The first phase of the framework development was to carry out the â€˜initialisationâ€™ stage of an HLA application. The framework automatically creates and joins the appropriate federation, then by default it disables time-management and sets up to run as a real time federate. It then obtains the â€˜dynamically allocatedâ€™ HLA constants; These are the various handles used to identify data components:Class handles;Class attribute handles;Interaction handles;Interaction property handles.Unlike the DIS Protocol Data Unit (PDU) enumerations, these handles are not known at compile time and therefore have to be gathered at execution time.These handles are stored in static class members. Currently all SOM handles are obtained regardless of whether the local Federate actively uses them. The framework then carries out all the publication and subscription requests for classes (but not yet for interactions). The next phase of the work, scheduled to be completed by the end of March 2000, is to implement automated support for the actual handling of information exchange between Federates. The design is in place to:Automate storage for access of information about remote and local Class-object instances; lists of object instances will be maintained which allow the user to browse at will;Automate attribute updates for both remote and local Class-objects instances; any data updates about remote entities will be automatically interpreted and the appropriate objectâ€™s relevant attributes will be updated. For local objectâ€™s the user is only required to change an objectâ€™s attributes through a â€˜setâ€™ method to cause the information to be tagged for sending.Having produced the Repository it became apparent that with the information in this format could be adapted to produce tool applications for use within the FEDEP and Federation planning domains.Basic C++ methods were added to the Repository classes to allow the Repository to be utilised by user applications. As an example, a method allows the user to browse the contents in a hierarchical format. The example function prototypes shown below are typical of methods added to the class object hierarchy. The Repository header holds a link-list of top level Class-Objects (i.e. those with no parents). The Class-Objects themselves contain pointers to their immediate parent class and a further link-list of pointers to any child classes. Various convenience functions are present which allow the user to locate classes based on their specified match criteria.Example Repository methodsExample Class-object class methodsThe use of C++ for the Repository was chosen because it gives the required level of abstraction for the interface whilst maintaining a degree of flexibility and portability. The Object Oriented nature of the language also means that users can extend the Repository functionality without access to the Repository source code by using their own sub-classes.Repository ToolsThe Repository tools fall into two categories; those that process a single OMDT DIF file using a single Repository instance and those that process multiple OMDT DIF files using multiple Repository instances.The Repository has been used to produce a number of applications to support the FEDEP process. All current applications are simple command line processes, which accept the names of the expected input DIF files and produce output as ASCII text.To date the only platform which supports the Repository is a Silicon Graphics computing platform running under IRIX 5.3 or 6.2 operating environment.The tool suite can be divided into two categories of tools. The first type is the single Repository application that reads in a single DIF file, analyses it and reports on the contents. The frame work generating tools (tK_gen.sh) fall into this category. Based on a single SOM DIF file they generate the complex data types header file (tK_cd.h), enumerated data types header file (tK_en.h) and the main frame work body and header files (tKu.cc and tKu.h). Other single Repository tools add no extra content to that information contained in the DIF but simply display aspects of the content in a more readable or suitable form.The other form of tool takes two or more DIF input files and creates Repository instances for each. These can then be compared or combined with each other in whatever way is required.Single Repository applicationsIn addition to the framework generating tools, two other single Repository tools have been produced. The first (â€˜docgenâ€™) documents FOM/SOM contents to show the FOM/SOM internal details in an ordered format more suitable as a paper representation for project management purposes.The second application (â€˜checkâ€™) carries out consistency checks of relevance to application developers. In particular it looks for potential problems which may cause problems or ambiguity when the SOM/FOM needs to be implemented as a real application. These include:Unknown enumerated types, complex data types or base data types used within the defined Class-Objects, Interactions or complex data types;Empty or undefined mandatory fields;Duplicated attribute names;Duplicated property names.Multiple Repository applicationsA number of multi-Repository based applications have now been produced whose aim is to provide documentation during the FEDEP process to show how the various Federates interact and to map the overall development path of the Federation.The â€˜compareâ€™ application documents differences between FOMs or SOMs, it accepts two OMDT DIF files as input. It provides the basis for documenting FOM changes in a developing FOM. Amongst other things it highlights:Class, interaction, complex data type or enumerated type missing or added;Class, interaction, complex data type or enumerated type contents differ;Class or interaction hierarchy (parent-child relationships) differ.It can also be used to check for consistency between two Federatesâ€™ SOMs or between a FOM and a SOM.The â€˜mergeâ€™ application takes two or more Federateâ€™s SOMs and combines these to create a FOM. It warns of any inconstancies that exist (i.e. different definitions of the same class). This application is of particular use to systems not using a reference FOM but attempting to create a FOM from scratch.The â€˜runtime_fomâ€™ application accepts as arguments a reference FOM specification and two or more SOM specifications. It documents the actual Reference FOM usage within the Federation. This is the effective â€˜Runtime FOMâ€™, that portion of the reference FOM actively being used.The â€˜overlapâ€™ application accepts two or more SOM specifications as input arguments. Its primary purpose is to document Federate data exchanges. It parses the SOMs associated with each Federate and shows the combinations of publish and subscribe exchanges supported between SOMs. It indicates how many Federates are actually interoperating through exchange of the possible FOM Class-Objects or Interactions.Lessons LearnedOne of the prime lessons learned was that the availability of Commercial-off-the-Shelf (COTS) Tools reduces the costs and implementation time-scales.Initial studies have shown that there is scope for additional tools to be employed as part of the HLA FEDEP process. As an example, it is possible to generate a coding framework which attempts to minimise the developersâ€™ need for in-depth knowledge of the RTI API and allow the developersâ€™ to concentrate their effort on their particular simulation application.The use of this Repository and its associated application tools benefits the developer by automating the production of source code and enabling Object Models (FOMs and SOMs) to be compared. The source code can be incorporated into a Federate to minimise the risk of C++ coded implementations differing from its SOM definition.Future WorkWhen fully implemented this Repository and its associated application tools will enhance the set of FEDEP support tools currently available.The enhancements are to produce reports in HMTL (Hypertext Markup Language) and XML (Extensible Markup Language) formats in addition to ASCII text and to generate SQL (Structured Query Language) output that enable database queries to be performed.Within the UK, it is expected that more FOMs and SOMs will evolve as part of the future experiments based on Synthetic Environment technology. This will provide a broader range of Object Models which can be used to test the framework and toolset.Author BiographiesCHRIS ROUGET is a Consultant Engineer presently working for Flight Management and Control Department (Air Systems Sector) at DERA Bedford. A graduate of Imperial College, London, he has 19 years experience in mathematical and relational database modeling, working on simulation based applications associated with military weapons, military aircraft, civilian aircraft, and the communications industries. More recently practical experience has been gained in the use of methods and tools with respect to DIS and HLA application development.PAUL HENRY is a Software Consultant presently working for Flight Management and Control Department (Air Systems Sector) at DERA Bedford. A graduate of Imperial College, London, he has 12 years experience in simulation, covering military and civilian aircraft applications, air traffic control and the chemical production industries. More recently practical experience has been gained in the use of DIS and HLA with respect to networking high performance real-time human-in-the-loop flight simulators with other simulation systems.ïƒ“ British Crown copyright 2000. Published with the permission of the Defence Evaluation and Research Agency on behalf of the Controller of HMSO.// number of top-level class-objectsint numTopClassObj(void);// return pointer to nth top-level objectClassObj *top(int n);// find 1st class object that matches criteriaClassObj *findClass(int (*matchCriteriaFunc) (ClassObj &c, void *usr_data), void *usr);// return pointer to parent classClassObj *getParent(void);// number of top-level class-objectsint numChildren(void);// return pointer to nth direct descendent classClassObj *getChild(int n); EMBED Visio.Drawing.4   EMBED Visio.Drawing.4  