Self-Contained Federations: A New HLA ParadigmJohn F. Fay, Ph.D.Sverdrup Technology/TEAS GroupP.O. Box 1935Eglin AFB, FL  32542-5000850-729-6330fayjf@eglin.af.milKeywords:HLA, Latency, Federation, RTI, ArchitectureABSTRACT: Acceptance of the Defense Modeling and Simulation Office (DMSO) High-Level Architecture (HLA) in the Research, Development, and Engineering (RDE) community has been hampered by the slow performance of the present Run-Time Infrastructure (RTI) and by the unavailability of source code.  This paper proposes a new style of HLA federation that is all contained in a single executing program.  Federates are defined as individual objects in the program; the RTI is contained elsewhere in the program.  All of the HLA rules and specifications are followed in this new implementation.  The architecture of the self-contained federation causes the latency to be lowered by orders of magnitude but limits the size of the federation.  Because it is self-contained, creating an RTI does not need to account for communications protocols and other complexities.  A “homespun” RTI with open source code is within reach using this new paradigm.1. Introduction1.1 The ProblemA primary barrier to the widespread acceptance of the High-Level Architecture (HLA) in the research and development community is performance.  Six months ago, the RDE forum in its outbrief[1] noted that “each successive RTI release consumes more bandwidth” and lamented that “[t]here are no indications that [the next RTI release] will depart from the ‘fat and slow’ paradigm.”  Unfortunately the generality of HLA comes at a price, and that price is the size of the RTI.  In addition, communications among computers take time, and there is a physical limit to how fast a DMSO-style RTI can be.One application of modeling and simulation in the RDE field is digital circuit simulation.  In one Department of Defense (DoD) application, an HLA user wrote a simulation of a Serial EEPROM chip and placed it in a simple HLA federation using the DMSO RTI 1.3.  The update rate was one time step every few milliseconds.  In order to be practical, the simulation requires an update on the order of every microsecond, a difference of three orders of magnitude.  While it may be argued that circuit simulation is not what HLA was designed for, the fact remains that HLA has been mandated for all DoD simulations for the past year and a half.Some experimental RTI’s have been developed using different paradigms in an effort to improve performance.  Ferenci and Fujimoto[2] investigated RTI configurations that operated on a shared-memory computer, a high-speed switched network, and traditional TCP/IP networking.  They showed an improvement in speed of over an order of magnitude in latency.  While considerable, this still falls short of the three-order-of-magnitude increase needed.  Christensen, van Hook, and Wolfson [3] developed a full shared-memory RTI which operated using SCRAMNet and showed a two- to four-fold improvement in metrics such as throughput, latency, and time-advance size.  Again, while this is an improvement it is still insufficient.  Additionally, it was decided by their sponsors not to release the shared-memory RTI.A second barrier to acceptance of HLA has been the well-documented reluctance on the part of DMSO to release the source code of the RTI.  While DMSO has some good reasons for this policy, it still results in a federation being a black box that cannot be tuned to optimize performance.Writing a separate RTI has not been an option for most users.  One of the developers of the DMSO RTI commented at a SIW a few years ago that “Writing an RTI is not for the faint of heart.”  Apart from the sheer size of the application interface, the would-be writer must deal with issues of cross-platform capability and communications protocols.  Most users do not have the time or resources to tackle the problem.1.2 The SolutionA radically different architecture of an HLA RTI is proposed, which would improve performance and simplify the architecture.  In this architecture, the entire HLA federation is a single executing program on a single computer.  Its main program calls each of the federates as subroutines, and then calls an RTI subroutine to pass information updates around.  This architecture largely meets the HLA specification as developed by SISO or as implemented by DMSO.  (The present paper restricts itself to the SISO specification.)  Because of its stand-alone nature, it will be called the Self-Contained Federation.This new architecture is not a panacea.  Because the federation is contained entirely within a single executing program, any application which uses distributed processing is automatically excluded from using this sort of RTI.  In addition, the federation must be small enough that it can fit on a single computer.  However, the self-contained federation can provide a niche capability for users with small applications who need extremely high performance.2. Self-Contained Federation Architecture2.1 Main ProgramThe main program of the self-contained federation is relatively simple and is seen in figure 1.  The heavy lines and clear boxes in figure 1 show processing that takes place in the main program or calls made by the main program; the lighter lines and shaded boxes show some of the HLA-specific processing that is handled in functions.The program begins by creating an object for each federate.  The federate’s constructor function handles all the HLA initialization work.  In particular, the first federate to be constructed creates the federation, and as each new federate is constructed it joins the federation.  Because the HLA specifications do not allow the RTI to call the federates’ update functions, the main program needs to save pointers to these functions in a list separate from the federation’s list of federates.The main program then enters an event loop.  Within the event loop, it calls an update function for each federate.  This update function performs all of the federate’s time-dependent processing, including a call to a RTI time advancement function.  After all of the federates have been updated, the main program calls a function to update the RTI.  The update RTI function discovers new objects to the federates, reflects attribute values, receives interactions, and so on.The main program remains in the event loop for as long as a federation is in existence.  Each federate handles its own “resign federation” and “destroy federation” calls.  The last federate to resign will succeed in destroying the federation and the main program will then drop out of its loop.  It should be noted that the actual destruction of the federation needs to be done after the last call to a federate update function has been completed; trying to destroy a federation from within the “destroy federation” call will cause a run-time error in some C++ compilers.There is no reason why a self-contained federation program cannot contain more than one federation.  In the present application it is not particularly necessary, but it is still easily done and is shown in the flowchart in figure 1.  When the main program creates its federates, the individual federates can create more than one federation.  Then during the main loop, the program steps through the list of federations.  For each federation, it steps through the list of federates to call the update functions.  A federate that belongs to more than one federation would need to track which federation it is being updated by and adjust its behavior accordingly.2.2 Federate ArchitectureA federate in this paradigm is an individual object in the self-contained federation program.  The federate may, and probably will, contain sub-objects within itself to simulate the objects being modeled.  It may contain many of these sub-objects, either directly or via pointers, but it presents itself to the rest of the program as a single object.  It needs the following pieces for its interface to the remainder of the federation:a Constructor function, which is called implicitly when the main program creates the federate object.  This function creates and joins the federation.a Destructor function, which is called implicitly when the object is destroyed.  This function would free any memory allocated during program execution and not freed earlier.an Initialization function, which the main program calls after the federate object has been added to the linked list of objects in the federation.  This function publishes and subscribes to the object and interaction classes.an Update function, which the main program calls each time through the update loop.  This function does everything else:  registering objects; updating the federate objects; calling the “update attributes,” “send interaction,” and “time advance request” functions; and finally resigning from and destroying the federation.an RTI Ambassador object, which contains the HLA functions that the federate calls in order to communicate with the rest of the federation.  The format of this object is dictated by the HLA Interface Specification and its executable code is part of the RTI.a Federate Ambassador object, which contains the HLA functions that the RTI calls and which the federate must answer.  The format of this object is also dictated by the HLA Interface Specification but its executable code must be written by the federate designer.Proper design of a federate in a self-contained federation requires careful consideration of what data are contained in the federate’s sub-objects and what data are contained in the federate itself.  The federate time and the ambassadors clearly belong in the federate object itself, while object attribute data clearly belong in the sub-objects.  HLA object class handles belong in the federate object, but the HLA handles of individually-registered objects belong in the sub-objects.  The practice of storing federate data in static functions and variables in the object class, which the traditional HLA federation can use, will not work in the self-contained federation because more than one federate may use the same federate object class.The single greatest difference between a federate in a self-contained federation and one in the traditional HLA paradigm is the control of the federate’s event loop.  With traditional HLA, the federate enters an event loop in which it calls a RTI time advancement function in order to ensure that the RTI can work.  The RTI does not return control to the federate until it is ready to grant a time advance.  In the self-contained federation, the event loop has been moved from the federate to the main program.  The federate gives control to the RTI at the end of each call to its update function.  The next time the main program calls the federate’s update function, the federate may do any processing it likes.  If it has been granted a time advance, it may request another one; otherwise it does not.  This is more flexible than the traditional HLA architecture.2.3 RTI ArchitectureThe HLA specifications leave the implementation of the RTI as an exercise for the student.  For the example self-contained federation that formed the basis for the results given in this paper, the RTI was implemented as a set of linked lists of classes and structures.  The key list, from which all the others depend, is the list of federations.  Within each federation are structures that define the federation.  Each main type of structure is listed separately here.For the purposes of the present paper, a complete RTI was not constructed.  As a result, the structures that are listed below should not be taken as all-inclusive.  They are simply what was found to be necessary to write the demonstration RTI which showed that the concept of the self-contained federation is workable.  The demonstration RTI was written from the IEEE draft HLA specifications; writing one to the DMSO specifications should not pose any great problem.In the design of the self-contained federation, it was found necessary to have two types of linked list.  The first is a linked list of some sort of things such as federates, HLA objects, or attributes.  The second is a linked list of pointers to the aforementioned things.  The architecture is shown in figure 2.  This allows a thing to be part of two linked lists at once.Most of the RTI is contained in private files, away from the user’s attention.  Some of the RTI, like the interface specification, needs to be open to the federation builder.  The parts of the RTI listed below are all private unless specified otherwise.2.3.1 The Federation StructureEach federation structure contains the following information:the federation name, given as the federation is createda list of object classes, read from the FDD file (see section 2.3.2 below)a list of interaction classes, read from the FDD file (see section 2.3.4 below)a list of joined federates, updated as each federate joins and resigns from the federation (see section 2.3.6 below)a list of reserved names of objects which have been reserved but have not yet been registereda list of registered objects, created as each federate registers its objects (see section 2.3.8 below)lists of pointers to newly-joined federates, pointers to newly-registered objects, and pointers to objects with newly-updated attributes; created as the federation evolvesa list of current interactions, created as the federation evolves (this was not implemented in the self-contained federation)a pointer to the next federation in the linked listflags telling whether the federation should be saved (set when a federate calls the “initiate save” function), restored (set when a federate calls the “initiate restore” function), or destroyed (set when a federate successfully calls the “destroy federation” function)A true RTI federation structure would also contain other information, such as DDM data and the data type table, which was not placed in the demonstration program.2.3.2 The Object Class List StructureEach object class list structure contains the following information, which is all read from the FDD file:the object namea list of object subclasses, each of which is its own object class list structurea list of attributes of the object class (see section 2.3.3 below)a pointer to the next object class in the linked list2.3.3 The Attribute List StructureEach attribute list structure contains the following information:the attribute name, read from the FDD filethe attribute type, read from the FDD filethe attribute size, read from the FDD filethe update, transferability, publish/subscribe, and transport information of the attribute, read from the FDD filea list of federates which publish the given attribute, created as each federate calls its publish and unpublish attribute functionsa list of federates which subscribe to the given attribute, created as each federate calls its subscribe and unsubscribe attribute functionsa pointer to the next attribute in the linked list2.3.4 The Interaction Class List StructureThe demonstration program did not include the sending and receiving of interactions.  It is surmised, however, that each interaction class list structure would contain the following information:the interaction name, read from the FDD filea list of interaction subclasses, each of which is its own interaction class list structure, read from the FDD filea list of parameters of the interaction class, read from the FDD file (see section 2.3.5 below)the dimensions, transport, and order information for the interaction class, read from the FDD filea list of pointers to federates which send the given interaction, created as each federate calls its publish and unpublish interaction functionsa list of pointers to federates which receive the given interaction, created as federates call the subscribe and unsubscribe interaction functionsa pointer to the next interaction class in the linked list2.3.5 The Parameter List StructureAs with interactions, the demonstration program did not include parameters.  It is again surmised, however, that each parameter list structure contains the following information, all read from the FDD file:the parameter namethe parameter typethe parameter sizea pointer to the next parameter in the linked list2.3.6 The Federate List StructureEach federate list structure contains the following information:the federate name, received when the federate joins the federationa pointer to the federate object (see section 2.3.7 below), assigned by the main program in the self-contained federation.  This is a departure from the traditional RTI.a pointer to the Federate Ambassador, which is assigned when the federate object is createdpointers to the federate’s Time Factory and Time Interval Factory.  The existence of these factories is dictated by the C++ binding (Annex A) of the HLA Interface Specification.  Whether they belong to the federate list structure or the federate structure is a matter of some flexibility.flags telling whether the federate is time-constrained, is time-regulating, has interactions turned on, has attribute updates turned on, etc.lists of pointers to the object classes with attributes which the federate publishes or subscribes toa list of pointers to the interaction classes which the federate sends and receivesa flag (of type “string”) indicating the type of federate.  This should not be necessary in a well-built, general RTI but was put in the sample application as the easiest way to solve a programming problem.a pointer to the next federate in the list2.3.7 The Federate StructureThe federate structure serves as a base class for an individual federate’s “federate” class.  It is part of the public RTI that is exposed to the user; in the demonstration RTI it was placed in the “RTI.h” file.  It contains the following information:the federate’s name, received when it joins the federationa pointer to the federate object’s parent federate list object (see section 2.3.6 above), assigned when the federate object is created.  This is a departure from the traditional RTI.There is some ambiguity over what information should be in the federate list structure, which is part of the private RTI, and what information should be in the federate structure, which is part of the public RTI.  An effort was made to keep the RTI header file structure unchanged from the RTI header files given in the HLA Interface Specification, but it was not entirely successful.  More flexibility in the specification in this regard would allow for an easier time making a self-contained federation.2.3.8 The Registered Object StructureEach registered object structure contains the following information:a federation-unique name of the object instance, set during registration or when the federate reserves the object instance namea pointer to the object class list structure giving the class of the object instance (see section 2.3.2 above), assigned during registrationa list of the specific attributes of the object instance (see section 2.3.9 below)a pointer to the federate which has the privilege to delete the object instance (see section 2.3.6 above), assigned during registrationa list of pointers to federates which have discovered this object instance (see section 2.3.6 above), assigned as the federation evolvesa pointer to the next registered object instance in the linked list2.3.9 The Registered Attribute StructureEach registered attribute structure contains the following information:a pointer to the attribute list structure giving the type (object class) of the attribute (see section 2.3.3 above), assigned during registrationan update flag, set whenever the owning federate updates the attribute and reset when the RTI reflects the updatea pointer to the value of the attribute.  The memory pointed to by this pointer is assigned when the attribute’s object instance is registered and can be of any size.  The pointer is necessary because different data types (especially complex data types) have different sizes.the size of the attribute valuea pointer to the federate which owns this specific attribute.  If the federate that registers the object instance publishes the present attribute type, then it owns the present attribute instance by default; otherwise the attribute instance is unowned and the pointer is set to null.a pointer to the next attribute instance in the linked list2.3.10 The Update RTI FunctionAn essential part of the self-contained federation’s RTI is the Update RTI function.  It needs to perform the following actions for each federation:if any federates have reserved names, send messages indicating the success or failure of the name reservationsif any federates have just joined the federation, discover any objects that they may subscribe toif any federates have just registered objects, discover them to any subscribing federates (except newly-joined federates, which discovered them in the previous step)if any federates have just updated any object attributes, reflect the updates to any subscribing federatesif any federates have just sent any interactions, pass them on to the receiving federatesif any federate has just requested time constraint or regulation to be enabled or disabled, make it soif a federate has just requested a time advance, grant it if possibleif the federation needs to be destroyed, call the destructor function3. Compliance With the HLA SpecificationThe self-contained federation presents a significant departure from the traditional HLA architecture.  Because of this, the HLA specifications as drafted by SISO [4, 5, 6] were carefully examined to ensure that the new implementation of HLA was conformant.  It was found that the self-contained federation follows the HLA rules exactly, that it cannot follow the HLA Interface Specification without some extensions to the latter, and that it follows the HLA OMT exactly.3.1 HLA RulesThe HLA Rules specification [4] contains a list of definitions and ten rules.  Most of the definitions clearly fit the self-contained federation, while some definitions require clarification.The definition of a “federate” in the HLA Rules is “A software application that may be or is currently coupled with other software applications under a common object model and runtime infrastructure (RTI).”  The self-contained federation can be said to contain federates only if an object in a larger program can be called a “software application.” The self-contained federate object is capable of joining a federation multiple times simply by calling the “Join Federation Execution” more than once from its constructor function. The definitions of the “federate application” and “joined federate” therefore remain unchanged.The definitions of “federation” and “federation execution” are unchanged and require no unusual understandings when applied to the self-contained federation.The HLA rules themselves apply directly to the self-contained federation without any difficulty.  The rules as quoted verbatim from [4] are:Federations shall have an HLA federation object model (FOM), documented in accordance with the HLA Object Model Template OMT.In a federation, all simulation-associated object instance representation shall be in the federates, not in the runtime infrastructure (RTI).During a federation execution, all exchange of FOM data among joined federates shall occur via the RTI.During a federation execution, joined federates shall interact with the RTI in accordance with the HLA interface specification.During a federation execution, an instance attribute shall be owned by at most one joined federate at any given timeFederates shall have an HLA Simulation Object Model (SOM), documented in accordance with the HLA OMT.Federates shall be able to update and/or reflect any instance attributes and send and/or receive interactions, as specified in their SOMs.Federates shall be able to transfer and/or accept ownership of instance attributes dynamically during a federation execution, as specified in their SOMs.Federates shall be able to vary the conditions (e.g., thresholds) under which they provide updates of instance attributes, as specified in their SOMs.Federates shall be able to manage local time in a way that will allow them to coordinate data exchange with other members of a federation.There is nothing in any of these rules which cannot be applied directly to the self-contained federation, without any modification or difficulty.  The HLA rules specify the division of labor between federates and RTI, the SOM and FOM, and the use of the interface specification, but they do not specify the architecture of the overarching federation.3.2 HLA Interface SpecificationOf all the HLA specifications, the one that gives the most difficulty is the Interface Specification.  The reason is that this document contains, as a normative annex, the header files to be used when a federate communicates with the RTI.  It specifies the functions which shall be called, the names which the RTI and Federate ambassadors shall use, and that they shall use container types from the Standard C++ Library.  Compliance to this level of detail is difficult, and perhaps impossible.It was found necessary to add two variables to the RTI and Federate ambassador objects.  The first one, which may be called “parent,” is a pointer to the federate of which the ambassador is a part.  The second one, which may be called “my_federation,” is a pointer to the federation of which the RTI or federate ambassador is part.  These variables are needed in a self-contained federation because it contains many federates in a single executable program, each with its own time advance grant flag and list of objects.  In a traditional HLA federation, the program contains only a single federate and so it is possible to use static or global variables to store the data.An interesting item that the Interface Specification does not specify is the behavior of the time advancement functions.  In the traditional HLA federation, calling a time advancement function passes control over to the RTI so that the RTI can pass messages on to the federate.  In the self-contained federation, the time advancement function merely stores its arguments and returns control to the calling federate.  The calling federate should then return control to the main program so that the main program can call the “update RTI” function to pass any waiting messages to the federate.  This difference in behavior does not violate the HLA Interface Specification. 3.3 HLA Object Model TemplateThe self-contained federation complies with the Object Model Template (OMT) with no changes.  Most of the OMT specification delineates the FOM and SOM tables, which are external and therefore irrelevant to the federation architecture.Two primary aspects of the OMT specification that the self-contained federation must account for are the data entry and the data storage.  The method for reading the data into the federation is through the FOM Document Data (FDD) file as specified in annex D of the OMT specification [6].  The FDD file is in Extensible Markup Language (XML) format, and to read a general FDD file requires either a general XML processor or at least a function to read a specific FDD-type XML file.  For the purposes of this paper, this was not done; instead, because the FOM for the sample federation is quite simple, the FOM data were applied to the RTI as hard-coded assignment statements.  There is no reason, however, that a self-contained federation with a real RTI could not include an XML processor.The storage of the OMT data in a self-contained federation is discussed in the earlier section on RTI architecture.  Again, for the present paper not all the data listed in [6] were stored; for example, the section on data distribution management was not implemented. Implementing the remainder of the OMT is not expected to affect the self-contained federation’s performance materially.3.4 Other Issues3.4.1 Management Object ModelFirst on the list, and in fact part of the HLA Interface Specification compliance, is the Management Object Model (MOM).  There is no reason the MOM cannot be made part of the self-contained federation.  On the other hand, there may not be any real reason to include it.  Since the federation is contained entirely within a single executing program, most of the purpose of the MOM goes away.  Insight into, and control over, the execution of the federation can be accomplished by using any good source-level debugger. Since the purpose of the self-contained federation is to achieve very rapid execution times in relatively small federations, there would be very little need for user intervention in a smoothly-running federation.3.4.2 RTI InteroperabilityThe RTI Interoperability Study Group [7] defined four levels of RTI interoperability:  federate, model, service, and communication interoperability.Federate interoperability requires that a federation give the same results whether two objects are modeled in a single federate or in multiple federates.  The self-contained federation’s federate update functions behave in the same way, as far as updating the objects is concerned, as the update functions from a traditional federation.  As such, the self-contained federation should have the same federate interoperability characteristics as a traditional federation.Model interoperability requires the ability “to effectively and unambiguously communicate simulated entity state information and behavior between two federates.”  At present this requires that the federates’ SOMs be compatible with each other and with the federation’s FOM.  Again, there is no difference between the self-contained and the traditional federation, and a solution that will work in one case will work in the other.Service-level interoperability requires many different RTI’s to cooperate to manage a single federation.  While on the face of it, the self-contained federation would appear to have no interest in cooperating with different RTI’s, such a thing may still be possible.  It would require some modifications to the “Update RTI” function in order to provide an interface to other RTI’s in other executables.  This runs somewhat contrary to the original purpose of the self-contained federation, but if the need is there the modification may be done.Communication interoperability requires the existence of a standard communications protocol, or “wire standard.”  Since the self-contained federation does not use distributed communications this is a non-player.It should be noted that there is nothing in the paradigm of the self-contained federation that prevents the use of a “bridge federate.”  Such a bridge federate would be a federate object in the self-contained federation and would, on its creation, call the traditional RTI to create and join an outside federation.  Such a federate would function without requiring any modification to the rest of the self-contained federation, or to the other federation either.  This arrangement would be practical if a federation designer wishes to use a high-performance self-contained federation to run a high-fidelity model of the inner workings of a system and present the system’s outputs to a lower-fidelity outside simulation.3.4.3 Reuse of Self-Contained Federates in Traditional HLA FederationsAn issue that must be addressed is the ability of a federate in a self-contained federation to use a standard RTI and vice versa.  A direct change from one RTI to another RTI without modifying the federate is clearly impossible.  The self-contained federation’s federate is an object in a larger program; the standard HLA federate is an executable program in itself.  Also, the standard HLA federate contains its own event loop control; in the self-contained federation, the event loop is controlled from the main program.That said, it is possible to design a federate that will use either RTI with minimal modification.  The federate is first designed to work in a self-contained federation.  It is then supplied with a main program that creates it, initializes it, and controls the event loop.  The federate object calls the standard RTI library and thus operates as a traditional HLA federate.3.4.4 Relaxing the Interface SpecificationSeveral parts of the HLA Interface Specification require the RTI to use mechanisms which, while eminently portable, are less than optimal for the self-contained federation.  An example of this is the loading of object attributes into an attribute-handle-value-pair structure rather than simply passing a pointer to the attribute’s address.  Since the passing of attributes is a large component of the execution time, this inefficiency has a fairly strong effect on the self-contained federation’s performance.The passing of pointers instead of values has been discussed before in connection with RTI performance.  If an attribute is defined in the FOM as the address of the variable containing the information rather than the information itself, then no change to the Interface Specification will be necessary.  If the attribute is defined as the value itself, then some allowance for parameter passing by reference will be necessary.It was noted earlier that the self-contained federation needs its federate and RTI ambassador objects to contain new variables pointing to the federate and federation they represent.  This will also require a change to Annex A of the HLA Interface Specification.The author does not recommend any changes to the body of the HLA Interface Specification.   It might be desirable to split Annex A into normative and informative parts, with the parts that the federate uses directly being made normative and the definitions of the variable types informative.4. Sample Federation ResultsIn order to demonstrate the feasibility of the self-contained federation and to assess its possible performance, a sample self-contained federation was written.  It was modeled on the DMSO “Hello World” sample federation that is distributed with the DMSO RTI but was based on the draft IEEE specification.  It contains the following parts of the self-contained federation:the main program, in fullthe following parts of the RTI:federation structurefederate structuresobject class and registered object structuresattribute and registered attribute structuresthe following parts of the Update RTI function:federation creation and destructionfederate joining and resignationobject name reservationobject registration and discoveryattribute updating and reflectionthe following parts of the Hello World federates:federation creation, joining, resignation, and destructioncreation and registration of the local country object and discovery of remote countriesobject name reservation and notificationvarious of the RTI support servicesFor the purposes of demonstrating the concept of the self-contained federation, the interactions were not coded.  Since the sample federation sends an interaction once every one hundred time steps, this was considered not to be a major player.  The advancement in time was also modeled very roughly by advancing each federate in time once every three iterations.The federation was developed and run with Microsoft Visual C++ 5.0 on a single-processor Pentium 266 personal computer running Windows 95.  Several compromises were necessary, most notably with the use of the C++ Standard Library in the Interface Specification.  Most of them were necessitated by the author’s inexperience with the C++ programming language.To test the program performance, a federation was created, joined, executed for 10,000 time steps (30,000 iterations), resigned from, and destroyed.  The number of federates in the federation was varied.  As a point of comparison, the DMSO Hello World federation was run on the same computer for 1,000 iterations (time steps) and timed.  In both federations the output statements during the update loop were commented out.  Table 1 lists the update times per time step in microseconds.Table 1 shows some very striking features.  The update time of the self-contained federation scales very well with the square of the number of federates.  This stands to reason if the primary driver is the updating of attributes:  the number of attributes and the number of federates which receive these attributes both increase linearly with the number of federates.  Later results show this to be the case.Table  SEQ Table \* ARABIC 1.  Update Times Per Time Step For HLA Federations, in microsecondsNumber of  FederatesSelf-Contained FederationDMSO RTI Federation1105100,0002420320,0003930330,00041,650wouldn’t run52,600wouldn’t run63,900wouldn’t run75,300wouldn’t runThe update time of the DMSO sample federation appears to be one value for a federation with a single federate, and then another value for a multiple-federate federation.  The latter observation is based on two data points, although it does reflect other people’s experience [8].  The shorter update interval for the single-federate execution may result from the fact that the federate’s attribute updates are not turned on until a second federate discovers the object being updated.  The fact that the DMSO federation does not run with more than three federates is a well-known limitation of Windows 95.Most striking about table 1 is the comparison of the two columns.  The self-contained federation executes between two and three orders of magnitude faster than the DMSO federation.  This is not surprising, given the differences in federation architecture.  It does show, however, that federations for which the DMSO RTI is simply too slow may benefit from a self-contained federation.In an effort to determine which part of the self-contained federation took the most execution time, the update and reflect attributes were turned off separately in the case of five federates.  When both attributes were updated, the federation execution time was 2,600 microseconds per time step.  Updating only a single attribute reduced the execution time to about 2,100 microseconds.  If neither attribute was updated but the code to reflect the updates was still executed, the execution time was reduced to about 1,100 microseconds per iteration.  Turning off the “reflect attributes” code but still updating both attributes reduced the execution time to 460 microseconds, while neither updating nor reflecting any attributes reduced the execution time to 140 microseconds per iteration.  Clearly, reflecting updated attribute values takes the lion’s share of the self-contained federation’s time in this case.5. Summary and ConclusionsThis paper has proposed a new architecture for HLA federations called the self-contained federation.  This architecture, which is demonstrated in a sample federation, shows increases in execution speed of two to three orders of magnitude with promises of more.  It is well suited to HLA federations that contain only a few federates but which need much greater execution speed than a distributed architecture can give.  The new architecture also follows the HLA Rules and OMT exactly, although it needs some minor changes to the Interface Specification.It is recommended that the HLA community consider relaxing the Interface Specification annexes to allow the new federation architecture.6. References[1]	Briggs, Keith, “RDE Users Forum Outbrief,” Fall 1999 Simulation Interoperability Workshop, Orlando, FL, September 17, 1999.[2]	Ferenci, Steve L., and Richard Fujimoto, “RTI Performance on Shared Memory and Message Passing Architectures,” Spring 1999 Simulation Interoperability Workshop Paper 99S-SIW-074, Orlando, FL, March 14-19, 1999.[3]	Christensen, Paul J., Daniel J. Van Hook, and Harry M. Wolfson, “HLA RTI Shared Memory Communication,” Spring 1999 Simulation Interoperability Workshop Paper 99S-SIW-090, Orlando, FL, March 14-19, 1999.[4]	Draft Standard for Modeling and Simulation (M&S) High-Level Architecture (HLA) – Framework and Rules, IEEE P1516/D4, Simulation Interoperability Standards Committee of the IEEE Computer Society, IEEE Standards Department, Piscataway, NJ, April, 1999.[5]	Draft Standard for Modeling and Simulation (M&S) High-Level Architecture (HLA) – Federate Interface Specification, IEEE P1516.1/D4, Simulation Interoperability Standards Committee of the IEEE Computer Society, IEEE Standards Department, Piscataway, NJ, April, 1999.[6]	Draft Standard for Modeling and Simulation (M&S) High-Level Architecture (HLA) – Object Model Template (OMT), IEEE P1516.2/D4, Simulation Interoperability Standards Committee of the IEEE Computer Society, IEEE Standards Department, Piscataway, NJ, April, 1999.[7]	Myjak, Michael D., Duncan Clark, and Tom Lake, “RTI Interoperability Study Group Final Report,” Fall 1999 Simulation Interoperability Workshop Paper 99F-SIW-001, Orlando, FL, September 12-17, 1999.[8]	Pounds, S. LaTreva, and Jeffrey A. Simmers, “RTI 1.3, Scalability Challenged?” Spring 1999 Simulation Interoperability Workshop Paper 99S-SIW-009, Orlando, FL, March 14-19, 1999.Author BiographyJOHN F. FAY is a Senior Engineer with Sverdrup Technology / TEAS Group.  His fields of expertise include modeling and simulation, aerodynamics, computational fluid dynamics, penetration modeling, and applied mathematics. EMBED Word.Picture.8   EMBED Word.Picture.8  