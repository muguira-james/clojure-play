Geometric and Algorithmic ResultsRegarding HLA Data Distribution Management MatchingMikel D. Petty, Ph.D.Old Dominion UniversityVirginia Modeling, Analysis & Simulation Center, 7000 College Drive, Suffolk VA 23435mpetty@vmasc.odu.edu  757-686-6210Keywords:High Level Architecture, Data Distribution Management, Lower bound.ABSTRACT:  The High Level Architecture (HLA) is an architecture for constructing distributed simulations.  The Data Distribution Management (DDM) services of HLA reduce the amount of data delivered to an HLA federate by allowing communications connections to be based on federates‚Äô expressions of data production and requirements. In a process called DDM matching, the HLA Run-Time Infrastructure determines the data connections in a federation.  The definition of HLA in general, and DDM in particular, has changed from the previous DoD 1.3 version to the new IEEE 1516 version of the HLA specifications.  Geometric and algorithmic methods are used to show two results.  First, DDM under the IEEE 1516 specification is proven to be at least as powerful as DDM under the DoD 1.3 specification.  Second, lower bounds for time for a DDM matching query and for the DDM matching process are proven to be in ((log n) and ((n log n) respectively.IntroductionThe High Level Architecture (HLA) is an architecture for constructing distributed simulations.  In HLA terms, a set of simulations capable of interoperating is a federation, and the individual simulations are federates.  HLA includes a category of services, called Data Distribution Management (DDM), which are intended to reduce the quantity of data delivered by the Run-Time Infrastructure (RTI) to the federates during a federation execution.  During DDM matching the RTI must determine if regions defining the federates‚Äô data publications and subscriptions overlap.Two specifications of HLA are currently available, the Department of Defense Version 1.3 and the draft Institute for Electrical and Electronic Engineers standard 1516.  DDM under the first specification (DDM 1.3) is different from DDM under the second specification (DDM 1516).Because DDM matching can be defined geometrically, it is amenable to geometric and algorithmic analysis.  Those methods are used to prove the following results:Theorem 1.  DDM 1516 is at least as powerful, in terms of relating data production and requirements by DDM matching, as DDM 1.3.  This is shown by exhibiting a transformation that transforms any DDM 1.3 configuration (a DDM 1.3 configuration is a set of dimensions, routing spaces, and regions within those routing spaces) into an equivalent DDM 1516 configuration (which is a set of dimensions and regions).Theorem 2.  Lower bounds on the time required for a single DDM matching query and the DDM matching process during a federation execution are in ((log n) and ((n log n) respectively, where n is the number of regions created or updated during a federation execution.  This lower bound is established using the familiar reduction method.General and result-specific background information on HLA and DDM is provided next.  Following that, proofs of the geometric and algorithmic results are given.BackgroundThis section provides general background on the High Level Architecture and Data Distribution Management.  Specific information about the run-time DDM processes and the differences between DDM as defined in the Version 1.3 specification and in the Draft IEEE 1516 specification is also given.High Level ArchitectureHLA is an architecture for constructing distributed simulations.  It facilitates interoperability among different simulations and simulation types and promotes reuse of simulation software modules [1].  HLA can support virtual, constructive, and live simulations from a variety of applications domains.  HLA is defined by three documents:1.  The HLA Rules [2], which define interoperability and what capabilities a simulation must have to achieve it within HLA.2.  The Object Model Template [3], which is a methodology for specifying simulation data in terms of a hierarchy of object classes, and their attributes, and interactions between objects of those classes, and their parameters.3.  The Interface Specification [4], which is a precise specification of the interoperability-related actions that a simulation may perform, or be asked to perform, during a simulation execution.The HLA RTI is an implementation of the Interface Specification, consisting of a set of services.  The RTI provides services to start and stop a simulation execution, to transfer data between interoperating simulations, to control the amount and routing of data that is passed, and to coordinate the passage of simulated time among the simulations.  Within the HLA, a set of collaborating simulations is called a federation, each of the collaborating simulations is a federate, and a simulation run is called a federation execution.  Federates that adhere to the Rules can exchange data defined using the Object Model Template by invoking the services defined in the Interface Specification; those services are provided at run-time by the RTI.Data Distribution ManagementOne category of services defined in the Interface Specification, Data Distribution Management, is intended to reduce the amount of simulation data delivered to a federate during a federation execution.  To accomplish the reduction, one or more multidimensional coordinate spaces, referred to as routing spaces, are defined with dimensions corresponding to simulation data (simulation object attributes or other data available in the simulation).  During a federation execution federates specify what simulation data they are going to produce (publish) or interested in receiving (subscribe).  They do so by creating regions, called update and subscription regions, within the routing spaces.  Each region is composed of one or more rectangular subspaces, called extents, within a routing space.  All the extents of a single region are in the same routing space and are defined on all of the dimensions of that routing space; the extents and the region are said to have those dimensions.  The extents of a region are ranges on all of the dimensions of the routing space in which the region is defined.  A range is a semi-open interval of the form [low value, high value) along a dimension.  Two extents overlap (i.e., intersect) if and only if all of their ranges overlap on their respective dimensions, i.e., all the dimensions of the routing space.When any pair of extents from an update region and a subscription region overlap in a routing space the regions are said to overlap.  In that case simulation data should be delivered by the RTI from the federate that created the update region to the federate that created the subscription region.  The data distribution services allow update and subscription regions to be created, modified, and deleted dynamically by federates throughout a federation execution.  Each time a region is created, modified, or deleted, the set of regions it overlaps may change, and if so, the data delivery connections used by the RTI must be changed to reflect the new region configuration.The use of DDM during a federation execution can be decomposed into four conceptual processes. These processes can occur repeatedly and asynchronously during a federation execution.1.  Declaring.  Federates express the data they intend to produce (publish) and/or desire to receive (subscribe) in terms of publication and subscription regions in a multi-dimensional routing space.2.  Matching.  The RTI finds all publication regions that overlap subscription regions in a routing space.  For each such overlap found, data associated with the publication region will be sent from the federate that created the publication region to the federate that created the subscription region.  We will refer to a single determination of the overlapping regions as a DDM matching query, and to all of the DDM matching queries that occur during a federation execution as the DDM matching process.3.  Connecting.  The RTI establishes data flow connectivity between the sending and receiving federates.  The method for doing so depends on the network infrastructure, but using multicast groups is a common approach.4.  Sending.  The RTI and the federation‚Äôs interconnecting network transport simulation data generated by the sending federates to the receiving federates using the established connections.Differences between DDM 1.3 and DDM 1516DDM 1.3 and DDM 1516 are different.  There are several specific differences, but the most important ones here, because of the consequences they have on the definition of overlapping regions, are the elimination of routing spaces in DDM 1516 and the replacement of DDM 1.3 regions and extents with the similar but not identical DDM 1516 region sets and regions.In DDM 1.3, a routing space is a named sequence of dimensions.  A set of routing spaces can be defined for use during a federation execution.  Regions are created within a particular routing space.  Regions can only overlap with regions in the same routing space, implying that only regions with the same dimensions can overlap.  In DDM 1516, there are no routing spaces; all dimensions are available in a single DDM coordinate space.As mentioned, in DDM 1.3 regions consist of one or more extents, each of which is a rectangular subspace of a routing space.  Because they are all in the routing space, all of the extents of a region have the same dimensions.  Two regions overlap if and only if any pair of their extents overlap.  In DDM 1516, regions are a single rectangular subspace within the coordinate space, analogous to extents.  Region sets are sets of one or more regions.  Regions may be defined on any subset of the available dimensions and regions in a region set may differ in the dimensions they have.  Regions overlap if and only if they have at least one common dimension and they have overlapping ranges on all common dimensions.  Note that it is possible for regions with different dimensions to overlap as long as they have some common dimensions and overlap on them.  Region sets overlap if and only if any pair of their regions overlap.DDM matching as a geometric problemDDM 1.3 regions are composed of one or more extents; each extent is a rectangular subset of a coordinate space.  The same is true of DDM 1516 region sets and regions.  The coordinate space is one of a set of routing spaces in DDM 1.3 and a single DDM space in DDM 1516.  Considered geometrically, a DDM coordinate space is d-dimensional, where d is the number of dimensions that define the space.  Extents (DDM 1.3) and regions (DDM 1516) are axis-parallel d-dimensional hyper-rectangles (d-rectangles, for short) within the coordinate spaces.  A d-rectangle is a rectangular subset of a coordinate space, with faces parallel to the planes defined by each pair of axes.  Two d-rectangles intersect if and only if they share at least one point.The DDM matching process can be restated as a geometric problem, called dynamic d-rectangle intersection, as follows:  process an arbitrary sequence of insertions, deletions, and queries of d-rectangles, where a query is to report all current (inserted and not deleted) d-rectangles that intersect the query d-rectangle.  To see that this problem is equivalent to DDM matching, consider the following.  Regions can be created, modified, and deleted dynamically throughout a federation execution.  Those events each correspond to one or more operations (insertions, deletions, and queries) in the dynamic d-rectangle intersection searching problem.  When an update region is created, the subscription regions it intersects must be determined (a query) so that appropriate data delivery connections can be established, and the new region must be recorded for future queries (an insertion).  Similarly, when a subscription region is created the update regions it intersects must be determined and the region recorded.  When a region is deleted a d-rectangle query is required to determine which data delivery connections should be broken and a d-rectangle deletion is needed to remove the region from the current region data structures.  Region modifications are logically equivalent to a deletion followed by a creation.ResultsThis section contains the theorems.  Background definitions and explanations of the proof techniques are given for each result.DDM 1516 is at least as powerful as DDM 1.3Because DDM 1.3 is expected to be replaced by DDM 1516, it is of interest to know if the latter is as powerful, in terms of expressive power for relating data production and requirements by DDM matching, as the former.  Here we resolve that question.  Informally, a DDM 1.3 configuration is defined to be a set of dimensions, a set of routing spaces defined on those dimensions, and a set of regions (and their component extents) created within those routing spaces; a DDM 1516 configuration is similar, but does not include routing spaces, and has region sets and regions instead of regions and extents.  The power of a DDM specification is defined as the size of the set of distinct configurations it may express.  Let (1.3 be the set of all distinct configurations possible under the DDM 1.3 specification and (1516 the set of those possible under the DDM 1516 specification.  The power of DDM 1.3 is just |(1.3| and for DDM 1516 it is |(1516|.  Of course, without a restriction on the number of dimensions, (1.3 and  (1516 are infinite sets, but as we shall see their sizes can still be compared.Two configurations are equivalent if there is a bijection (i.e., a one-to-one and onto mapping) from the regions of one configuration to the regions of the other configuration such that two regions overlap in one configuration if and only if their corresponding regions overlap in the other.  This definition applies whether the two configurations are under the same DDM specification or different specifications.We will show that DDM 1516 is at least as powerful as DDM 1.3 by exhibiting a mapping or transformation ( that transforms any DDM 1.3 configuration C ( (1.3 into an equivalent DDM 1516 configuration ((C) ( (1516.  This implies that the set of distinct configurations possible in DDM 1516 is at least as large as the set of distinct configurations in DDM 1.3, i.e., that |(1516| ( |(1.3|.Theorem 1.  For every DDM 1.3 configuration C ( (1.3 there exists an equivalent DDM 1516 configuration ((C) ( (1516 and therefore |(1516| ( |(1.3|.Proof.  Let C be a DDM 1.3 configuration, i.e., C ( (1.3.  Configuration C is a 3-tuple, C = (D, S, R).  D is a set of dimensions, D = {d1, d2, ..., dk}; each di 1 ( i ( k is a dimension; k = |D|.  S is a set of routing spaces, S = {s1, s2, ..., sl}; each si 1 ( i ( l is a routing space; l = |S|.  Each routing space si is a sequence of dimensions, si = (di,1, di,2, ..., di,m); each di,j 1 ( j ( m is a dimension in D; m = |si|.  R is a set of regions, R = {r1, r2, ..., rn}; each ri 1 ( i ( n is a region.  Each region ri ( R is a 2-tuple, ri = (si, {ei,1, ei,2, ..., ei,p}) where si is the routing space in which ri is defined, i.e., a sequence of dimensions, and {ei,1, ei,2, ..., ei,p} is a set of the extents of ri.  Each extent ei,j 1 ( j ( p is a sequence of ranges on the dimensions of si.A transformation ( from any DDM 1.3 configuration C( (1.3 to an equivalent configuration ((C) ( (1516 is defined as follows.  Let ((C) be a DDM 1516 configuration, i.e., ((C) ( (1516.  Configuration ((C) is a 2-tuple, ((C)  = (((D), ((R)).  The set of dimensions ((D) = {di,j | 1 ( i ( l, 1 (  j (  |si|} contains all of the dimensions of all of the routing spaces of S.  Within S some dimensions may occur more than once, in different routing spaces; in ((D) they likewise appear more than once but are uniquely renamed so they can all appear in the set.  The region sets ((R) are the regions of R, ((R) = {((r1), ((r2), ‚Ä¶, ((rn)), with the dimensions renamed to match ((D).  Each region set ((ri) 1 ( i ( n is a 2-tuple, ((ri) = (((si), {ei,1, ei,2, ..., ei,p}).  The region set is defined on the sequence of dimensions ((si) = (di,j | 1 (  j (  |si|), which is the same sequence of dimensions as routing space si, but renamed as before.  The regions of region set ((ri) are just the extents of region ri.We now show that given any two regions r1 and r2 ( C, r1 overlaps r2 in C if and only if region set ((r1) overlaps region set ((r2) in ((C).(Only if)  Assume that in C r1 overlaps r2.  By the definition of overlap in DDM 1.3, regions r1 and r2 are in the same routing space and must have extents that overlap in that routing space, call them e1 and e2.  Because they are in the same routing space, e1 and e2 have the same dimensions, and because they overlap, all their ranges on those dimensions overlap.  Because e1 and e2 have the same dimensions from D, by transformation ( regions ((e1) and ((e2) of region sets ((r1) and ((r2) have the same dimensions from ((D).  Because the ranges of e1 and e2 overlap on all of their dimensions and ( does not change the ranges, the ranges of ((e1) and ((e2) overlap on all of their dimensions.  Because ((e1) and ((e2) have all the same dimensions and their ranges on all those dimensions overlap, they overlap in ((C).  Therefore region sets ((r1) and ((r2) overlap in ((C).(If)  Assume that in ((C) ((r1) overlaps ((r2).  By the definition of overlap in DDM 1516, ((r1) and ((r2) have regions that overlap, call them ((e1) and ((e2).  Also definition, ((e1) and ((e2) have some common dimensions and the ranges of ((e1) and ((e2) overlap on all of those common dimensions.  Under transformation ( the dimensions of any two distinct routing spaces in S are distinct in ((D), even if they are the same in D.  Because of this and the fact that ((e1) and ((e2) have some common dimensions, e1 and e2 must be in the same routing space in C.  Thus e1 and e2 have the same dimensions.  Because the ranges of ((e1) and ((e2) overlap on all of their common dimensions, and e1 and e2 have all their dimensions in common, extents e1 and e2 overlap in C. Therefore regions r1 and r2 overlap in C.Therefore, for every DDM 1.3 configuration C ( (1.3 there exists an equivalent DDM 1516 configuration ((C) ( (1516.  Thus |(1516| ( |(1.3|.  ‚ñ†In other words, by Theorem 1 DDM 1516 is at least as powerful as DDM 1.3.An alert reader will have observed that transformation ( in Theorem 1 said nothing about transforming the actual values for the ranges.  DDM 1.3 defines dimensions to be continuous implicitly semi-open intervals within the semi-open interval [axis lower bound, axis upper bound), where axis lower bound and axis upper bound are implementation parameters, and ranges to be semi-open subsets of that interval.  DDM 1516 defines dimensions to be explicitly semi-open intervals within the semi-open interval [0, dimension upper bound), where dimension upper bound is an implementation parameter, and ranges to be semi-open subsets of that interval.  DDM 1516 adds the restriction that the difference 45between a range upper bound and a range lower bound can be no less than 1.  The question of whether DDM 1.3 intervals within [axis lower bound, axis upper bound) can be transformed into DDM 1516 intervals within [0, dimension upper bound), subject to the minimum difference restriction, without introducing loss of resolution, discontinuities, or other anomalies depends on the details of the implementation and computer arithmetic.  Those details are outside the scope of this paper.  Also, differences between those parameters can cause differences in the number of distinct configurations, but those differences are not interesting here; we are concerned with the more fundamental differences in power due to the structural aspects of the DDM specifications.  Therefore, for Theorem 1 it was implicitly assumed that transforming the range values without changing the number of distinct configurations is possible and that the range value bounds are not changed.Lower bounds for DDM matchingThe time and space (memory) required by algorithms for problems, including DDM matching, are often matters of interest.  Those requirements are given as a function of the size of the input, which is conventionally denoted n (or sometimes N, e.g., [9]).  Exactly what is counted by n depends on the problem; e.g., for a sort algorithm, n is the number of items to be sorted.  It the remainder of this section we focus on time requirements to simplify the exposition, but similar results can be proven for space requirements as well.The upper bound or ‚Äúworst case‚Äù requirement for an algorithm is the largest amount of time that the algorithm could require on any valid input.  A complete valid input to a problem is called an instance of the problem.  The upper bound is denoted as O(f(n)), which is the set of all functions g(n) bounded above by a positive constant multiple C of f(n), provided that n is greater than some threshold.  Usually the function f(n) counts, as a function of the input size, some primitive constant-time operation that forms the basis of the algorithm, with the unstated multiplicative constant C representing the time required for each of those operations.  For example, for an algorithm that, given a set of n line segments in the plane, finds all intersecting pairs of segments by testing every possible pair for intersection, the basic operation is a segment-segment intersection test.  The actual time required for each segment-segment intersection test depends on a number of things, including programming language and processor speed, but it is fixed for any specific execution of the algorithm and does not depend on the input size, so it is abstracted away by the unstated multiplicative constant C in the order notation.  Given n segments, the number of segment pairs to test is n(n-1)/2 ( O(n2), so the algorithm‚Äôs worst case time requirement is in O(n2).Note that an upper bound for an algorithm is also an upper bound for the computational complexity of the problem solved by that algorithm.  If a given algorithm X for problem A can solve A in, at worst, O(f(n)) time, then any efficient algorithm Y to solve A should require at worst O(f(n)) time; if not, it would be faster to use X and Y is not efficient.  (Clearly, if we do not require efficiency, there is no upper bound for any problem.)The lower bound or ‚Äúbest case‚Äù requirement for an algorithm is the smallest amount of time that the algorithm could require on any instance.  It is denoted as ((f(n)), which is the set of all functions g(n) bounded below by a positive multiple C of f(n), provided that n is greater than some threshold.  We observed that an upper bound for an algorithm is also an upper bound for the problem solved by the algorithm.  However, the same is not true for the lower bound.  A lower bound ((f(n)) for an algorithm X for problem A does not prove that A could not be solved faster by a different, more efficient algorithm.  In general, finding the lower bound for a problem is more difficult than finding an upper bound because a lower bound must be proven for all possible algorithms to solve the problem.  Nevertheless, it is desirable to find the lower bound for a problem so as to avoid a futile search for algorithms more efficient than the problem‚Äôs theoretical lower bound.There is a technique for proving lower bounds known as reduction [6] [7] or transformation of problems [9].  Suppose there are two problems A and B which are similar in structure so that every instance of problem B can be solved as follows:1.	Transform the instance of A into an instance of B.2.	Solve the instance of B.3.	Transform the solution for the instance of B into a solution to the original instance of A.Once the transformations of steps 1 and 3 have been defined then problem A is said to have been transformed or reduced to problem B.Figure 1.  Transfer of upper and lower bounds by reduction.The time required for the transformations, denoted ((n), is usually given as an upper bound, e.g., O(n).  The transformation of A into B is written A (((n) B.Now suppose problem A is known to have a lower bound of ((f(n)).  If the time required for the transformation ((n) is strictly less than f(n), then ((f(n)) is also a lower bound  for problem B.  This is because if an algorithm existed to solve an instance of B faster than ((f(n)), then instances of A could be solved by transforming them into instances of B and solving them using the faster algorithm for B, contradicting the known lower bound for A.If an upper bound, say O(f(n)), is known for B, and transformation time ((n) ( O(f(n)), the same transformation allows the transfer of B‚Äôs upper bound O(f(n)) to A.  This is because it would always be possible to solve an instance of A by transforming it into an instance of B and solving it using the algorithm for B, which is known to require time in O(f(n)).  Figure 1 summarizes the reduction technique; see [6] or [9] for more detail.In the DDM matching process the RTI repeatedly determines which federates will send data to which other federates by finding geometric intersections among the publication and subscription regions created and updated by the federates.  Geometrically, those regions are d-rectangles.  The DDM matching process is here restated formally as the DYNAMIC RECTANGLE INTERSECTION problem.DYNAMIC RECTANGLE INTERSECTION (DRI)Instance: Dimension d ( 1; set R = {r1, r2, ..., rn} of d-rectangles (d ( 1), where initially R = (; and sequence (a1, a2, ..., an) of actions, each a 2-tuple ai = (qi, oi), where qi is a d-rectangle and oi is an operation, oi ( {insert, delete, query}, for 1 ( i ( n.  Problem:  Process each action ai = (qi, oi) in sequence from a1 to an, as follows.  If oi = insert, set R = R ( {qi}.  If oi = delete, set R = R - {qi}.  If oi = query, determine and report all d-rectangles r in R that intersect the query d-rectangle qi, i.e., all r ( R ( r ( qi ( (.Recall that the DDM operations of creating and deleting regions each consist of two DRI actions, and that the query action is included for both.  Therefore DRI is at least a sequence of d-rectangle intersection queries, each of which is equivalent to a single DDM matching query.  A formal definition of this DRI subproblem is as follows:RECTANGLE INTERSECTION QUERY (RIQ)Instance:  Dimension d ( 1; set R = {r1, r2, ..., rn} of d-rectangles; and query d-rectangle q.  Problem:  Determine and report all d-rectangles r in R that intersect the query d-rectangle q, i.e., all r ( R ( r ( q ( (.With these problem definitions in hand the lower bound result can be given.Theorem 2.  Lower bounds on the time required for a single DDM matching query and the DDM matching process during a federation execution are in ((log n) and ((n log n) respectively.Proof.  The formal problems RIQ and DRI correspond to a single DDM matching query and the DDM matching process respectively.  We first prove a lower bound for RIQ by transformation from the problem BINARY SEARCH (BS), which is known to have a lower bound ((log n) [9].BINARY SEARCH (BS)Instance:  Sequence X = (x1, x2, ..., xn) of n real numbers, given ordered ( xi ( xi+1 for 1 ( i < n; query real number q.  Problem:  Determine the value of i ( 0 ( i ( n and xi ( q < xi+1, assuming x0 = -( and xn+1 = (.An instance of BS can be solved using an algorithm for RIQ in this manner.  The sequence X = (x1, x2, ..., xn) of n real numbers to be searched in BS are treated in RIQ as n 1-rectangles (line segments), where for 1 ( i < n, 1-rectangle ri = [xi,xi+1] and 1-rectangle rn = [xn,(].  The query real number q is treated as a degenerate 1-rectangle [q,q].  Note that X is not actually converted in its entirety to 1-rectangles, which would require O(n) time and invalidate the transformation.  Rather, each real number xi in X is treated as a 1-rectangle when it is accessed by the RIQ algorithm by retrieving it and its successor xi+1, thereby adding only constant time to each of the accesses.Figure 2.  Example sequence and three different queries for BS (O(log n) RIQ.This time is part of the RIQ execution, not the transformation, so the transformation from BS to RIQ is null, and thus time ((n) ( O(1), which is strictly less than ((log n).  The solution to RIQ, i.e., those 1-rectangles from the sequence that intersect the query 1-rectangle, will consist of zero, one, or two 1-rectangles.If the solution to RIQ is one 1-rectangle, say [xi,xi+1], than the solution to BS is i.  If it is two 1-rectangles, say [xi,xi+1] and [xi+1,xi+2], then the solution to BS is i+1.  If it is zero 1-rectangles, than the solution to BS is 0.  Figure 2 illustrates these possibilities with an example.  In the figure, the 1-rectangles corresponding to the sequence are shown spread out in two dimensions for clarity, but the 1-rectangles are, by definition, 1-dimensional.  Transforming the solution to RIQ to a solution to BS takes constant time, so ((n) remains ( O(1).Through this transformation an algorithm to solve RIQ can be used to solve BS.  Therefore, the lower bound ((log n) for BS transfers to RIQ, i.e., BS (O(1) RIQ and BS ( ((log n) ( RIQ ( ((log n).An instance of DRI consists of a sequence of n RIQ instances, each of which requires time in ((log n) to solve.  Therefore, the lower bound for DRI is in ((n log n).  These are the lower bounds for the DDM matching query and the DDM matching process, respectively.  ‚ñ†Conclusions and Future WorkWe have given two results regarding HLA DDM:1.	DDM 1516 is at least as powerful as DDM 1.3.2.	Lower bounds on the time required for a single DDM matching query and the DDM matching process during a federation execution are in ((log n) and ((n log n) respectively.These results may seem fairly obvious to a reader knowledgeable of HLA DDM.  The main contributions of this paper are the formal proofs of these basic properties of this important process.The question of whether DDM 1.3 and DDM 1516 are equivalent in power remains open.  Together with Theorem 1, showing that any DDM 1516 configuration can be transformed into an equivalent DDM 1.3 configuration would prove their equivalence.  Conversely, showing that such a transformation could not exist or exhibiting a DDM 1516 configuration that could not be transformed into an equivalent DDM 1.3 configuration would prove the opposite.Finally, in a companion paper we show that DDM matching is not NP-complete and that one approach to DDM connecting is NP-complete [8].References[1]	Dahmann, J. S., Kuhl, F., and Weatherly, R. (1998).  ‚ÄúStandards for Simulation:  As Simple as Possible But Not Simpler:  The High Level Architecture for Simulation,‚Äù Simulation, Vol. 71, No. 6, pp. 378-387, December 1998.[2]	Defense Modeling and Simulation Office (1998)  ‚ÄúDepartment of Defense High Level Architecture Rules, Version 1.3,‚Äù February 5 1998, Online document at http://hla.dmso.mil/hls/tech/rules/.[3]	Defense Modeling and Simulation Office (1998)  ‚ÄúDepartment of Defense High Level Architecture Object Model Template, Version 1.3,‚Äù February 5 1998, Online document at http://hla.dmso.mil/hls/tech/omtspec/.[4]	Defense Modeling and Simulation Office (1998)  ‚ÄúDepartment of Defense High Level Architecture Interface Specification, Version 1.3,‚Äù April 2 1998, Online document at http://hla.dmso.mil/hls/tech/ifspec/.[5]	Institute of Electrical and Electronic Engineers (2000).  ‚ÄúIEEE P1516.1/D5 Draft Standard for Modeling and Simulation (M&S) High Level Architecture (HLA) ‚Äì Federate Interface Specification‚Äù, IEEE Standards Draft, DRAFT 5, March 17 2000.[6]	Laszlo, M. J. (1996).  Computational Geometry and Computer Graphics in C++, Prentice Hall, Upper Saddle River NJ, 1996.[7]	O‚ÄôRourke, J. (1994).  Computational Geometry in C, Cambridge University Press, Cambridge UK, 1994.[8]	Petty, M. D. and Morse, K. L. (2000).  ‚ÄúComputational Complexity of HLA Data Distribution Management‚Äù, Proceedings of the Fall 2000 Simulation Interoperability Workshop, Orlando FL, September 17-22 2000.[9]	Preparata, F. P. and Shamos, M. I. (1985).  Computational Geometry, An Introduction, Springer-Verlag, New York NY, 1985.AcknowledgementsDr. Katherine L. Morse reviewed a draft of this paper and provided consultation on the differences between DDM 1.3 and DDM 1516; her expert assistance is gratefully acknowledged.Author BiographyMIKEL D. PETTY is Chief Scientist of the Virginia Modeling, Analysis & Simulation Center at Old Dominion University.  Prior to that he was an Assistant Director of the Institute for Simulation and Training of the University of Central Florida.  He received a Ph.D. in 1997, an M.S. in 1988, and a B.S. in 1980, all in computer science.  Dr. Petty‚Äôs research interests include distributed simulation, computer generated forces, and multi-resolution simulation; he has published over 75 papers in these areas.  He is currently a member of the National Research Council Committee on M&S for the 21st Century Manufacturing and Acquisition. In this subsection, DDM is described as per the DDM 1.3 specification in [4].  The differences between DDM 1.3 and DDM 1516 are presented later. In this subsection, DDM 1516 is described as per the most recent draft of the IEEE 1516 specification at the time this is written (July 2000) [5].  All statements regarding DDM 1516 throughout the document refer to that draft.  That draft is not yet approved as a standard and may change again. The term region is overloaded in the proof of Theorem 1, referring in some cases to DDM 1.3 regions (e.g., r1) which are sets of extents, and in others to DDM 1516 regions (e.g., ((e1)) which are elements of region sets.  The type of object referred to implies the definition of the term. Note that O(f(n)) is a set (of functions), not a quantity, so it is usually incorrect to say something like ‚Äú...the time required = O(n2)‚Äù instead of  ‚Äú...the time required is in O(n2).‚Äù  However, we will follow the convention of using shorthand phrases like ‚Äúan O(f(n)) algorithm‚Äù to mean ‚Äúan algorithm that requires time in O(f(n)).‚Äù As noted in [9], transformation is more descriptive of the method but reduction continues to be used for historical reasons. This does not, however, prove that an algorithm that executes that quickly necessarily exists for problem B; it simply proves that no algorithm to solve B can be faster than ((f(n)).