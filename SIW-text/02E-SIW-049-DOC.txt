Extensibility: Modular HLA RTI ServicesRajeev Sudra Simon J.E. TaylorCentre for Applied Simulation ModellingBrunel University, Uxbridge UB8 3PHUNITED KINGDOM{rajeev.sudra, simon.taylor}@brunel.ac.ukKeywords:Distributed Simulation, GRIDS, HLA, Simulation Modeling, RTI.ABSTRACT: This paper investigates an approach to extending the distributed simulation services available in the HLA RTI. The motivation is the observation that although this infrastructure supports a wide variety of distributed simulation requirements, there is still a possibility that more services might be required (e.g. extended time management, COTS package integration).   To investigate an extensible infrastructure, we present the Generic Runtime Infrastructure for Distributed Simulation (GRIDS) (00F-SIW-051, 01E-SIW-097) with two illustrative examples.The first example illustrates the use of thin agents (the GRIDS mechanism for extensibility) to provide HLA support within GRIDS. It takes an existing HLA federation compliant with the RTI and replaces it with GRIDS. The RTI calls required by the federation are implemented within thin agents and used to extend the functionality of GRIDS to mimic an HLA RTI. The second example illustrates the use of GRIDS to support a federation consisting of mixed federate types. The federation is composed of a HLA federate (as in example one) and a legacy federate (DIS). A new thin agent is introduced to bridge the legacy federate with the rest of the federation facilitating its interoperation. These examples highlight the use of components to augment the functionality of GRIDS and suggest an approach to extend the services of an RTI.1. IntroductionThe standardization of the HLA [1,2,3] has been an important step for the distributed simulation community. This has brought about a level of stability with regards to the API [2] as described by the interface specification and allowed developers to build federations with a degree of certainty regarding interoperability. Additionally, this has stimulated continued development in the RTI to support distributed simulation.Generally, current implementations of the RTI do not support a simple mechanism to modify the functionality of the RTI middleware. These modifications could be driven through changing requirements or the need for a feature not directly supported by the RTI. The only avenue to tackle this type of problem is through relatively complex, bespoke changes to the middleware or to the federates. The work presented in this paper investigates an approach to an RTI based on modularity. The implementation is known as the Generic Runtime Infrastructure for Distributed Simulation (GRIDS). The feature which distinguishes GRIDS from other RTIs is its support of modularity through its extensibility mechanism. This mechanism provides the facility to add additional services or modules within the middleware through thin agents.. To demonstrate the feature of extensibility within an RTI, GRIDS is used in two case studies to support two types of distributed simulations, an existing HLA federation and a mixed (HLA and DIS) federation.This paper is structured as follows. In section 2 we briefly discuss the functionality provided by current RTI specification and suggest benefits possible from a modular RTI. Our approach to a modular RTI is presented in section 3. The first example describes HLA support using thin agents which is discussed in section 4. Section 5 then continues with the second example which examines legacy support within a mixed federation, again using thin agent components to deliver services required by the application. The paper ends with some conclusions along with a discussion of ongoing work in section 6.2. Current RTI FunctionalityThe services described within the HLA address a range of simulation requirements. Examples of these include the integration of simulations based on different time schemes by the time management service group and relevance filtering as provided in part by the data distribution management group. The RTI implementations such as the pRTI 1516 [4] from Pitch AB or the DMSO RTI represent fully compliant middleware implementations of the RTI specification. However, their implementations do not provide the facility to add additional functionality by federation developers due to the rigid design of the software.As a standard it is accepted that HLA compliant RTIs need only implement required services. The HLA API has been carefully designed to provide simulation specific functionality for distributed simulation. Furthermore, the HLA is seen as a generalized architecture to facilitate reuse and interoperability for a variety of simulations. Generally, the “variety” is seen to come from the defense community but the hope has been to encourage HLA technology into non-defense applications. A greater acceptance of the HLA by all communities creates experiences in best practice and an increase in exposure and familiarity to the HLA approach to distributed simulation.The greatest barrier to using an architecture such as the HLA and the RTI is its complexity [5]. There has been increased interest in non-defense related uses of HLA alongside the required uptake from the defense communities. However, the lack of flexibility within the RTI to support additional or alternative services is seen as further barrier to particular types of applications. A modular, component-based RTI could provide the following benefits:Vendors could develop RTI components to deliver the services provided by the six service groups. A federation developer could mix and match service components from various vendors providing a compliant yet optimized RTI. The developers could implement an RTI by choosing from a range of appropriate components.RTI developers could incrementally upgrade their software through releases of components while maintaining a stable core RTI.Fundamental changes to the HLA standard will impact heavily on the RTI. However, through a component enabled RTI, new service components will replace the older ones. Furthermore, the new compliant RTI can be assembled very quickly from the components.Leading on from this discussion, our approach to a modular, component-based RTI is now examined.3. Review of GRIDSThe Generic Runtime Infrastructure for Distributed Simulation (GRIDS) is an extensible middleware for research into distributed simulation tools and techniques. Instead of the fixed functionality advocated by the HLA RTI specification, GRIDS provides basic functionality for the interoperation of federates within a federation (interaction of models in a distributed simulation) and a mechanism to add extra functions where appropriate.This extensibility is provided by thin agents that encapsulate additional services as and when required (for example, dead reckoning [6], different time synchronization management algorithms [7,8,9], message filtering, security, translation, etc.). The basic functionality is a subset of the HLA RTI functionality. The extensibility is the principal difference between GRIDS and other approaches to distributed simulation middleware.GRIDS is best described as an execution environment capable of supporting a broad range of simulation types. Examples of types include applications such as real-time training simulations to discrete event analytical simulations. For distributed simulation, the primary role of the infrastructure is to coordinate the activities of distributed components using a message-based communication scheme. The environment’s functionality is further enhanced through an extension mechanism in response to specific requirements made by the distributed simulation. The advantage of this approach is to avoid making bespoke changes to either the middleware or the simulation application in response to changing or additional requirements.The likelihood that additional services might be required by distributed simulation applications is a real possibility and the extension mechanism provides a means to realize this. GRIDS is broadly separated into two categories, the basic architecture outlining fundamental services and the extensibility mechanism. GRIDS has already been presented in previous papers [6,7,8,9,10] and work is under way with defense and manufacturing applications. We now briefly review specific features of our middleware.3.1 Basic architectureGRIDS is based on message-oriented middleware. Following this structure, the basic unit of information exchange within the middleware is the message. The middleware is composed of the following major elements:Boot Server The boot server is a single process used to coordinate the initialization, execution and termination of a distributed simulation. The boot server is started and serves as a central location for all the participants of the simulation to connect to. The boot server is also loaded with any configuration information required to be passed to the connected simulations. It is equivalent to the Central Runtime Component (CRC).Client The GRIDS client is used by the federate to interact with the rest of the federation. The client initially is used to contact the GRIDS server and register its intention to participate in a simulation exercise. The client is loaded with configuration data where it is able to communicate directly with other clients during the execution of the federation. It is equivalent to the Local Runtime Component (LRC).Thin Agent A thin agent is the GRIDS term for a component service. Thin agents are coded to provide a service or range of services. Their specific function is entirely dependent on the requirements of the application and therefore can be application specific services or more general. Thin agents are loaded by the boot server and distributed to connecting clients prior to the execution of the simulation. The thin agents are then integrated into the client, so augmenting the services available to that clientMetadatabase The metadatabase is the general data structure in GRIDS used to store information. The data stored commonly includes both infrastructural and application data but is capable of storing any conceivable data structure as appropriate. REF _Ref1934757 \h Figure 1 provides an illustration of a typical GRIDS federation. Simulation objects/federates are connected to a GRIDS client via an interface. Thin agents are distributed to participating clients and instantiated to provide the required services. EMBED Visio.Drawing.4  Figure  SEQ Figure \* ARABIC 1. Typical GRIDS federationA GRIDS session has five distinct stages of execution: Initialization, Register, Broadcast, Runtime and Terminate. Based on the stages, GRIDS communicates in two modes, client-server (between the boot server and the client) and peer-to-peer (client to client). These stages of execution based on a typical GRIDS execution session are described.Stage 1: InitializationInitialization involves the starting of a GRIDS boot server. The server is loaded with thin agents that are to be used to support the simulation exercise.Stage 2: RegisterRegistering involves individual simulation nodes making their presence known to the GRIDS boot server and publishing the initial state variables of that node. Additionally, the boot server builds up the namespace of all the clients registering, and builds a central entity list of all entities in the simulation. Once all clients are registered the server closes all incoming connections for registration.Stage 3: BroadcastUpon a simulation “Start” event, the boot server broadcasts to all registered clients the entire entity list built up during registration. The entity list is stored in the internal database on each GRIDS client. In addition to broadcasting the entity list, the server broadcasts the namespace for all participating clients to be stored internally within each GRIDS client.Stage 4: RunOnce all entity lists and namespaces are broadcast to the individual clients, the server issues a “go” command to all the clients, signaling the start of the simulation. At this point, the server ceases its interactions with the clients. The clients now communicate directly as necessary in a peer to peer fashion to other nodes in the simulation. The GRIDS client is responsible for synchronizing entity attributes between the local and remote nodes.Stage 5: TerminateOnce the simulations have completed executing, the clients register back with the boot server signaling that they are exiting gracefully from the federation. EMBED Visio.Drawing.4  Figure  SEQ Figure \* ARABIC 2. Composition of a GRIDS and federate nodeNIM needs changing to GRIDS Message ManagerThe structure of a GRIDS node is summarized in  REF _Ref1936896 \h Figure 2. Network access is controlled by the network interface manager. This is composed of several services that manage the distribution for the rest of the client. The thin agent manager is used to delegate jobs to thin agents. These are based on requests originating both from the network and the federate. Service conducted by the thin agent is specific to its implementation. The metadatabase is a general storage facility used by both managers to store relevant information. Finally, the thin agent manager is connected to the federate via an interface (described in the next section). Data is transmitted and received by the federate through this interface using the GRIDS middleware.3.2 Extensibility mechanismThe key feature that distinguishes GRIDS from other RTI is that it supports extensibility. This property allows the functionality of the infrastructure to be augmented. Extensibility is provided within GRIDS at several levels:User-defined message types to transport data and for general communication.API extensions via subclassing of the GRIDS interface.Functionality extensions via thin agent components.Internal data storage extensions via the MDB interface.Modular internal structure based on runtime bindings.Of the items above, those of interest are the first three in the context of this paper. As a message-oriented middleware, GRIDS relies heavily on message types to communicate. Messages represent a low level interaction primitive and therefore provide scope to abstract more complex forms of communication upon this foundation. GRIDS contains a series of internal message types. However, developers are able to add user-defined message types for their own applications.The application interface within GRIDS is in the form of two basic object-oriented interfaces that must be implemented during an applications development. The SimInterface is equivalent to the federate ambassador. It defines a single method which is used to transfer data into the federate such as a callback. The GridsInterface is equivalent to the RTI ambassador. It defines a single method again used to transfer data into the middleware. A developer is expected to implement the SimInterface and provide all packing and unpacking of GRIDS messages. It must also provide an equivalent interface to match the calls made by the federate. This could be as simple as implementing just the single defined method or require a series of methods dealing with individual message types allowing a high degree of customization of the API presented by the middleware.Thin agents encapsulate specific behavior and control providing each federation with a set of precise services (as defined by the component developer) during execution. As dynamically distributed and instantiated entities, thin agents provide a versatile and standard way for developers to provide specific services, without having to rewrite any code within the GRIDS RTI.Developing a user-defined thin agent follows the process illustrated in  REF _Ref1938247 \h Figure 3. Creation of every thin agent begins with an abstract service. This service is defined by the thin agent superclass interface. The thin agent is written as a service program based on the abstract service. This involves the implementation of the thin agent interface and superclass by a service program as source code. The service program is then compiled into a machine independent executable format known as Java bytecode. The service bytecode is ready to be distributed from the central GRIDS boot server to clients during an execution of a federation. The GRIDS clients receive the bytecode and instantiate it into a live service. The instantiation process may involve providing the service component with its own thread of execution, where it will have its own program loop. At this stage, the installed thin agent can be queried via invoking calls through its interface from the thin agent manager or through message interceptions as is now described. EMBED Visio.Drawing.4  Figure  SEQ Figure \* ARABIC 3. Thin agent development lifecycleThin agents primarily perform their functions through the message interception approach. When a thin agent is installed into a GRIDS client, it first registers itself to receive particular message types. During execution the thin agent requires the GRIDS client to receive messages as illustrated in  REF _Ref1935995 \h Figure 4. The TAM is used to route messages between the federate, the thin agents and the network. The TAM uses two queues to manage inbound and outbound messages. The TAM’s thread of execution is used to check the inbound and outbound queues to direct messages through the GRIDS client. The TAM’s circle in the figure represents the routing decision point. If the message type compares with a registered handling thin agent, the intercepted message is passed directly to the thin agent where it is processed. Otherwise the message continues either inbound or outbound according to its original path. EMBED Visio.Drawing.4  Figure  SEQ Figure \* ARABIC 4. Thin agent message interception4. Example One: HLA SupportThe first example describes an approach to using the extensibility properties of GRIDS to provide support for an HLA application. The example concentrates on an existing federation that executes using an HLA compliant RTI. The approach describes the substitution of the RTI with GRIDS extended with thin agents to provide HLA services. The substitution should not result in any lost functionality during federation execution. The federation and the HLA services it utilizes is now discussed.4.1 The ‘Tanks’ federationPitch AB has developed a simple federation to facilitate understanding for development with the HLA RTI. The federation is known as ‘Tanks’. It includes a number of user-controllable tanks, each existing within its own federate. Additional federates increment the number of tanks within the federation. The tanks are controlled via the keyboard and move within a two-dimensional environment. Movements include forwards, backwards and on-the-spot rotation. The user receives feedback of the current tank's position through a map window managed by the federate.  REF _Ref1820427 \h Figure 5 illustrates a federate GUI. The solid box is the local modeled tank owned by the federate while the wire frame boxes represent remotely modeled tanks within other federates.The federation is designed to work with the pRTI (again from Pitch AB [4]), which is a Java based implementation. The federation implementation makes use of object attribute update and reflection rather than through interactions. As such the federate only makes use of a limited number of HLA service calls. These are summarized in  REF _Ref1821728 \h Table 1. EMBED PBrush  Figure  SEQ Figure \* ARABIC 5. A Tanks FederateService GroupRTI AmbassadorFederate AmbassadorFederation ManagementCreate Federation Execution(),Join Federation Execution()Declaration ManagementPublish Object Class(),Subscribe Object ClassAttributes()Object ManagementRegister Object Instance(),Update Attribute Values(),Request Object Attribute Value Update()Discover Object Instance(),Reflect Attribute Values(),Provide Attribute Value Update()RTI Support ServicesGet Object Class Handle(),Get Attribute Handle()Table  SEQ Table \* ARABIC 1. RTI calls used by the federation4.2 HLA-introduced challenges to GRIDSThe RTI and GRIDS provide dissimilar approaches to the problem of distributed simulation interoperability. Much of this is based on the implementation style of the two approaches.  REF _Ref1850755 \h Table 2 specifies these differences. Through careful use of the extensibility mechanism the variations must be leveled giving GRIDS an HLA feel.CategoryRTIGRIDSCommunicationRPC-basedMessage basedInterface density160 methods2 methodsFunctionalitySimulation specificDistribution support onlyStartupDynamicFixedFederate delayed entry supportCRC active during FEDEXCRC passive during FEDEXTable  SEQ Table \* ARABIC 2. Differences in approachesWhile the RTI is based on RPC, GRIDS is based on message-oriented middleware. It is the responsibility of the GRIDS interface to capture messages passed within the middleware and translate them into method calls. The number of method calls provided by the RTI are relative large in comparison to GRIDS. The two methods provided by the GRIDS interface must be extended to match the RTI equivalent with each one providing a primitive to send messages into and out of the federate. The tanks federation makes uses of only 12 methods from the complete set available. Implementation of this subset would be enough to demonstrate HLA support for the federation. Furthermore, the RTI provides specific functionality for simulations which is underpinned by distribution support. The latter is only present within GRIDS. However, additional functionality such as simulation specific services can be appended through the extensibility mechanism. This feature is used to deliver the functionality provided by the 12 methods used in the tanks federation. An additional complication exists surrounding the execution sequences of the RTI and GRIDS. The RTI uses a dynamic approach to the creation, joining and execution of a federation. A federate takes the responsibility of creating a federation execution and joining it. The RTI’s CRC, the RTIexec is used to allow delayed joins within a federation execution. The GRIDS approach to executing a federation requires all participants to register with the boot server first, then broadcast installed thin agents and configuration data and then proceed to execution. This model of execution does not currently support delayed entries into a federation execution.4.2 Integration support through the HLA librariesTo facilitate the interoperability of the federation using GRIDS required RTI functionality within the GRIDS middleware. This functionality was provided using the thin agent extension mechanism. GRIDS also required an interface that conformed to the RTI calls used by the federates to allow a more straightforward substitution of the RTI with GRIDS. This extended interface would translate calls into different GRIDS message types used to send requests between federates through the middleware and to the thin agents.The approach used was to develop an add-on package to the GRIDS libraries. This is referred to as the HLA libraries. The libraries contained the following components:An implementation of the Federate Ambassador extending the SimInterface. This would translate messages receive by GRIDS into federate callbacks.An implementation of the RTI Ambassador extending the GridsInterface. This would translate method calls from the federate into messages and deliver them into the middleware.A series of HLA specific message types matching the extended interface used to transfer messages between GRIDS clients and by thin agents to invoke services.The HLA thin agent (HLA-TA) implemented to provide the functionality of the services in  REF _Ref1821728 \h Table 1.Additional classes to define data types used by the library such as the attribute set used to transport data. REF _Ref1933057 \h Figure 6 illustrates the required extensions to the GRIDS client which are shaded. The GRIDS-RTI interface extension contains the modified implementations of the RTI and federate ambassadors. The HLA-TA contains the functionality of the RTI services used by the tanks federation. EMBED Visio.Drawing.4  Figure  SEQ Figure \* ARABIC 6. Required GRIDS Extensions to support the Tanks HLA FederationThe additional user-defined message types used within the HLA libraries are presented in  REF _Ref1903386 \h Table 3. The federate and RTI ambassadors are used to either generate and transmit or receive and invoke appropriate methods within the federate and the middleware.Message Type Message Description MSG HLA SYSTEM HLA Generic/NullMSG HLA JFEDRQ Join Federation RequestMSG HLA JFEDRP Join Federation ReplyMSG HLA GOCHRQ Get Object Class Handle RequestMSG HLA GOCHRP Get Object Class Handle ReplyMSG HLA GAHRQ Get Attribute Handle RequestMSG HLA GAHRP Get Attribute Handle ReplyMSG HLA UPDAV Update Attribute ValueMSG HLA ROIRQ Register Object Instance RequestMSG HLA ROIRP Register Object Instance ReplyMSG HLA REATV Reflect Attribute ValuesMSG HLA ROAVU Request Object Attribute Value UpdateMSG HLA PATVU Provide Attribute Value UpdateMSG HLA DOBJI Discover Object InstanceTable  SEQ Table \* ARABIC 3. Extended HLA library message typesThe message types are also used to invoke services within the HLA-TA using the thin agent message interception mechanism. When a message is created by the RTI ambassador to initiate a service, it is sent into the middleware. The HLA-TA registers itself to handle the messages listed in  REF _Ref1903386 \h Table 3 during the initialization of the GRIDS client prior to execution. The HLA-TA handles messages based on the following cases during the interception:If the message is from the local RTI ambassador:The request is handled by the local HLA-TA which generates a message back to the local RTI ambassador as a callback.The request is handled by a remote HLA-TA and forwarded to the remote node.If the message is from a remote RTI ambassador:The request is forwarded to the local RTI ambassador as a callback.The request is terminated as it encapsulates a redundant call. EMBED PBrush  Figure  SEQ Figure \* ARABIC 7. Tanks federation using GRIDS REF _Ref1980827 \h Figure 7 illustrates a running version of the tanks federation using the GRIDS middleware. The functionality of the federates are identical (barring any differences in latency between the RTI and GRIDS) between the original version of the federation and the GRIDS supported version. The federation was tested on a single machines as characterized by the figure as well as through the network with four federates using both the RTI and GRIDS implementations. There was no observed differences between the functionality provided by the implementations.5. Example Two: Legacy SupportThe second example describes an approach to supporting a legacy style simulation (DIS) within a HLA federation. The example attempts to interoperate a HLA federate (from example one) with a DIS federate as presented in a previous paper [6].5.1 Introducing the DIS federateThe federate originally known as “tanksim”, is again based around a series of tanks autonomously moving within a two-dimensional environment. The environment is a fixed size with a square boundary. The tanks (each within its own federate) move within this environment via simple rules. A tank's movement pattern is broken into phases. A movement phase begins with the tank selecting a target waypoint. The tank moves towards the waypoint at a specified speed until the waypoint is achieved. Achievement of a waypoint is denoted by moving within a threshold distance from the waypoint (e.g. within 25 meters). The tank then selects a new random waypoint and begins another iteration of the movement phase.As a DIS style simulation, each tanksim node is required to broadcast continuous updates to the rest of the distributed simulation. The scalability of DIS applications has always been a limiting factor due to bandwidth demands. Our previous papers use the GRIDS middleware to connect the tanksim federates together while providing relevance filtering through a dead reckoning thin agent (DR-TA).The bridging thin agentThis example discusses the key challenges faced in facilitating the interoperability of a DIS federate as described and an HLA federate from the first example. The approach to achieving the successful execution of the mixed federation using GRIDS is based on reusing as much of the federates and thin agents as possible. The use of a bridging thin agent to link the services provided by the existing DR-TA and the HLA-TA is used to achieve this. For clarity, the DIS federate DISFed while the federate from example one is referred to as HLAFed.The approach to interoperating the mixed mode federation is to bridge the communication between the HLA federate (HLAFed) and the DIS federate (DISFed) as in  REF _Ref1932687 \h Figure 8. It illustrates the position of the DIS-HLA Bridge Thin Agent (DHB-TA) when deployed within the GRIDS middleware. The new thin agent only resides within the node containing the DISFed and the DR-TA.The function of the DHB-TA is further illustrated by the expanded view of the DISFed's GRIDS client at the bottom of  REF _Ref1932687 \h Figure 8. It communicates HLA messages as specified in  REF _Ref1821728 \h Table 1 with the rest of the federation. The DHB-TA translates any calls required to be sent to the federate into messages that the DR-TA can understand (entity state PDU’s) and then passes them on. The DR-TA handles these messages as if they had been received from the network and operates accordingly. As the DISFed generates entity state updates destined for the federation, the DR-TA intercepts these according to normal execution. After processing, if the decision by the DR-TA is such that an update message is required to correct the low fidelity models of all the federation for the entity modeled locally, the update message is passed to the DHB-TA rather than the network. The DHB-TA translates this into the appropriate RTI call (such as an update attribute value call) for the rest of the federation (in this case, the HLAFed). EMBED Visio.Drawing.4  Figure  SEQ Figure \* ARABIC 8. DIS-HLA bridge thin agentThe DHB-TA does not need any associations to new message types. It is registered to intercept the existing DIS and HLA messages and implements the functionality to translate between the two federate types. Algorithmically, the DHB-TA is very similar to the HLA-TA. It must manage the handles for structures such as the class types of objects, the objects and the attributes. These data types are foreign to a DIS application. The following list details how the DHB-TA manages RTI calls that are not supported conceptually within a DIS application.Object Creation When the DHB-TA receives its first entity state update message from the DR-TA, it regards this as the object creation request. The object handle is generated and stored locally within the DHB-TA. The object discovery message is then propagated in the normal manner to the rest of the federation.Object Discovery If an object discovery message is received, the DHB-TA immediately requests an object attribute value update after storing the object handle.Attribute Value Update If an entity state update message is received by the DHB-TA from the DR-TA, the message is translated into an attribute value update and broadcast to the federation. A copy of the entities state is stored within the DHB-TA in case values are requests from other federates on demand.Reflect Attribute Value A received reflect attribute value message by the DHB-TA is translated into an entity state update message and passed to the DR-TA to deliver to the federate.Request Object Attribute Value Update If an object discovery message is received, a request object attribute value update message is sent to the owning federate of the object.Provide Attribute Value Update If the DHB-TA receives a provide attribute value update, the most current stored state values within the DHB-TA are used to generate an attribute value update. EMBED PBrush  Figure  SEQ Figure \* ARABIC 9. DIS and HLA mixed federation using GRIDS REF _Ref1930098 \h Figure 9 is a screenshot of the mixed mode federation executing. To recap, the HLA federate from example one generates a user interface. This interface is a basic window which displays the position of the local tank as a solid square and all other tanks (updated from remote sources) as wire frame squares. The DIS federate uses a text-based interface directly to the command prompt. The solid square in the top left of the federate GUI is the HLAFed’s tank. The wire frame square in the bottom right is the DISFed’s tank. The rounded rectangles and lines identify the consoles that provide the execution context for each tank.6. ConclusionsThis paper has demonstrated an alternative approach to the implementation of the RTI based on extensibility. The paper has identified that current implementations of the RTI do not easily provide support for the inclusion of additional functionality beyond that specified by the HLA standard. GRIDS, representing an early adopter of the component RTI philosophy, provides an extensibility mechanism to add additional service components in the form of thin agents. The paper has presented two examples demonstrating the application of extensibility. The first used thin agent components to provide HLA support within GRIDS to execute an existing HLA compliant federation. The second used thin agent components to provide support for a legacy DIS federate to interoperate with a HLA federate in a mixed federation.The two examples demonstrate functionality which exists without the need for a modular RTI and can be delivered using traditional RTI. However, the examples demonstrate the flexibility provided by the extensibility mechanism and offer a vehicle to realize services not included by the HLA. Current work using the GRIDS RTI is continuing based on the following investigations:A comparison of implementations of a federation using an HLA compliant RTI and GRIDS. This work is in conjunction with FOI (Swedish Defense Research Agency) and attempts to investigate the development time, best practice developing simulations using GRIDS and the performance of both RTI.Time management to support distributed supply chain simulation. This is based on an increased interest in using distributed simulation technology for non-defense purposes. Work in this area has already attempted to use various middleware including the HLA [11], CORBA [12] and our approach using GRIDS and a thin agent implementing a conservative synchronization protocol (known as a CPADS-TA [8,9]).Commercial-of-the-shelf (COTS) simulation package integration to facilitate distributed simulation development using traditional simulation packages [10]. The challenge here is to use thin agents to gain access and control of the package and to provide mechanisms to relay event messages between packages.Full HLA RTI support through thin agents. A single component is used to encapsulate each service group providing the opportunity to upgrade incrementally and to select alternative algorithmic approaches to particular services.Thin agents as simulation components. This work is founded on the area of component-based simulation. The property of mobility of thin agents is seen as a method for load-balancing a distributed simulation through the transfer of entities between federates. Related to this, thin agents can also be used for object ownership transferal to other federates as with the HLA.We hope to report on the progress of these research interests in future publications and welcome comments regarding these and alternative uses of components within RTI.As a concluding remark, it is suggested that a modular RTI such as GRIDS may provide a vehicle for greater transfer of distributed simulation technology into non-defense areas. This is based on the view that GRIDS, for a given application is a skeleton infrastructure which can be fleshed with required. With the possibility to provide HLA support within the middleware, this type of functionality may generate interest and the flexibility required by a wider community while satisfying traditional users.7. References[1]	IEEE Std 1516-2000 IEEE standard for Modeling and Simulation (M&S) High Level Architecture (HLA) – Framework and Rules[2]	IEEE Std 1516.1-2000 IEEE standard for Modeling and Simulation [M and S] High Level Architecture [HLA] – Federate Interface Specification[3]	IEEE Std 1516.2-2000 IEEE standard for Modeling and Simulation (M&S) High Level Architecture (HLA) – Object Model Template[4]	M.Karlsson, and L. Olsson: “pRTITM 1516 – Rationale and Design”. In Proceedings of the Fall 2001 Simulation Interoperability Workshop. Orlando, Florida. 01F-SIW-038. 2001.[5]	C. McLean, and F. Riddick: “The IMS Mission Architecture for Distributed Manufacturing Simulation.” In Proceedings of the 2000 Winter Simulation Conference. J. A. Joines, R. R. Barton, K. Kang, and P. A. Fishwick, eds, pp 1539-1548. Orlando, FL. 2000.[6]	S.J.E. Taylor, J. Saville., and R. Sudra: “Developing Interest Management Techniques in Distributed Interactive Simulation using JAVA”. In Proceedings of the 1999 Winter Simulation Conference. Phoenix, Arizona. 1999.[7]	R. Sudra, S.J.E. Taylor and T. Janahan: “Distributed Supply Chain Management in GRIDS”. In Proceedings of the 2000 Winter Simulation Conference. J. A. Joines, R. R. Barton, K. Kang, and P. A. Fishwick, eds, Orlando, Florida. 2000.[8]	R. Sudra., S.J.E. Taylor and T. Janahan: “GRIDS: A Novel Architecture for Distributed Supply Chain Management”. In Proceedings of the Fall 2000 Simulation Interoperability Workshop. Orlando, Florida. 00F-SIW-051. 2000.[9]	S.J.E. Taylor, R. Sudra., G. Tan, and J. Ladbrook: “Issues in Developing Distributed Supply Chain Simulation for the Automotive Industry” In Proceedings of the 2001 European Simulation Interoperability Workshop, pp 629-637 London, UK. 01E-SIW-097. 2001.[10]	S.J.E. Taylor, R. Sudra., T. Janahan, G. Tan, and J. Ladbrook: “Towards COTS Distributed Simulation using GRIDS”. In Proceedings of the 2001 Winter Simulation Conference. B.A. Peters, J.S. Smith, D.J. Medeiros, and M.W. Rohrer, eds, pp 1372-1379. Arlington, Virginia. 2001.[11]	S.J. Turner, W. Cai and B.P. Gan: “Adapting a Supply Chain Simulation for HLA.” In Proceedings of the 4th International Workshop on Distributed Simulation and Real Time Applications, pp 71-78. IEEE Computer Society Press. San Francisco, California, USA. 2000[12]	B.P. Ziegler, D. Kim, and S.J. Buckley: “Distributed Supply Chain Simulation in a DEVS/CORBA Execution Environment.” In Proceedings of the 1999 Winter Simulation Conference, P.A.. Farrington, H.B. Nembhard, D.T. Sturrock, and G.W. Evans, eds, pp 1333-1340. Phoenix, AZ. 1999.Author BiographiesRAJEEV SUDRA is a research in the Centre for Applied Simulation Modelling at Brunel University, UK. He received his Ph.D. and B.Sc. in Computer Science and Economics from the Department of Information Systems and Computing at Brunel University. He is a member of the UK Operational Research Society and the UK Simulation Society. He has gained much experience working in industry ranging from middleware software development to enterprise-wide telecoms network deployment and integration. His research focuses on component-based simulation and issues in distributed simulation interoperability.SIMON J.E. TAYLOR is the Chair of the Simulation Study Group of the UK Operational Research Society and the GROUPSIM Network. He is a Senior Lecturer in the Department of Information Systems and Computing and is a member of the Centre for Applied Simulation Modelling, both at Brunel University, UK. He was previously part of the Centre for Parallel Computing at the University of Westminster. He has an undergraduate degree in Industrial Studies (Sheffield Hallam), a M.Sc. in Computing Studies (Sheffield Hallam) and a Ph.D. in Parallel and Distributed Simulation (Leeds Metropolitan). His main research interests are end user applications of distributed systems. He is also a member of the Purple Theatre Company.