Persistence Memory Management forCheckpoint and Restart of SPEEDESDr. Ronald Van IwaardenGary BlankScott ShupeMetron Incorporated512 Via de la ValleSolana Beach, ca 91075(719)567-9873, (858)792-890, (858)792-8904 HYPERLINK mailto:vaniwaar@ca.metsci.com,blank@ca.metsci.com vaniwaar@ca.metsci.com,blank@ca.metsci.com, shupe@ca.metsci.comKeywords:Save/restore, persistence memory management, SPEEDES, ABSTRACT: Persistence memory management is a scheme for allowing objects in volatile memory to persist beyond the scope of a single program.  That is, once a program has ended, persistence memory management will allow for the reconstruction of objects that existed in that program for use within another instance of that program or some other third party software.  This is then applied to the problem of supporting checkpoint and restart within an optimistic discrete event simulation. By saving (“checkpointing”) all simulation objects and the events that act upon those objects, the entire simulation state is made persistent and can be used to restart the execution right where it left off.  This paper presents an implementation of persistence memory management and then describes the application of this implementation for the checkpoint and restart of a simulation with the SPEEDES framework.1. IntroductionThis paper describes an implementation of persistence memory management and the resulting implementation of checkpoint and restart within the SPEEDES framework. This paper will detail the techniques used to save and restore RAM objects while maintaining the correctness of pointers within these objects. It will then describe the changes that needed to be made to SPEEDES in order to support the checkpoint and restoration of a parallel simulation.  Care will be taken to point out possible platform-specific issues and assumptions about the behavior of compilers.  This work was funded by the TISA (Technical Insertion, Studies, and Analysis) and Wargame 2000 delivery orders at the Joint National Test FacilityOne of the primary obstacles to saving C++ objects and then restoring them is the issue of fixing the pointers.  If a C++ class A has a pointer to a class B instance, and this instance is not restored to exactly the same physical memory location, the pointer in the restored class A object will point to incorrect data.  This can produce potentially disastrous results when class A is used within a program.  In order to avoid this problem, all pointers within A must be stored and when both classes A and B are restored, the pointers within A must be corrected to point to the new locations.  This is the essence of persistence memory management.The importance of persistence memory management to SPEEDES is to enable the checkpoint and restart of a simulation.  It will allow complex simulation objects and messages containing pointers to be saved, recording the state of the simulation at an instant.  This state file can then be browsed in a post processing fashion to examine data and events at a given time, or it can be used to restart the simulation, allowing for what-if experiments.2. ImplementationsPersistence can be accomplished in a variety of different ways.  A common method is the one chosen by the Versant object-oriented database. In their implementation, C++ code is parsed directly, which leads to the ability to exactly reconstruct the objects, as they were stored.  While this is a very accurate solution, it requires the development or use of a quality parser that could be very time consuming to implement.Another way of implementing persistence consists of recording the following information for each saved object: the memory address range occupied by the object, the locations within the object of any pointers, and an ID specifying the class of the object. This will provide sufficient information to recreate the objects and remap the pointers. Since this method does not parse the C++ files, the database does not know how to reconstruct the objects on its own. It must use the program in which the persistence memory management scheme is running to do this. Then, after the new pointer values have been calculated, they are inserted at the appropriate places within the objects.  This method has the advantage of being simpler to implement (and therefore, easier to port to new compilers/operating systems) since a parser is not required, but it requires more effort to be expended in saving objects since the pointers must be specified, rather than identified by the parser.  It also requires more work on the part of those that use the persistence memory management.  This is the method that was chosen for this implementation.3. Persistence APIThe current implementation constructs many functions using macros as a crude imitation of templates in an attempt to maintain portability across a variety of compilers, many of which do not support templates.  There is a single macro, PO_DEFINE(<t>), that expands into many static inline functions and two classes (in the macro functions, the “<t>” stands for a type; e.g. if we’ve define a SHIP class, the “<t>” would be replaced by SHIP resulting in “PO_DEFINE(SHIP)”, PO_ADD_SHIP, etc).<t>* PO_ADD_<t>(<t>*& ptr SpPoDataBase* db = DefaultDataBase)<t>* PO_REMOVE_<t>(<t>*& ptr SpPoDataBase* db = DefaultDataBase)<t>* PO_NEW_<t>(SpPoDataBase* db = DefaultDataBase)<t>* PO_NEW_ARRAY_<t>(int num, SpPoDataBase* db = DefaultDataBase)<t>* PO_DELETE_<t>(SpPoDataBase* db = DefaultDataBase)<t>* PO_DELETE_ARRAY_<t>(SpPoDataBase*db = DefaultDataBase)<t>* PO_GET_FIRST_<t>(SpPoDataBase*db = DefaultDataBase)<t>* PO_GET_FIRST_BLOCK_<t>(SpPoDataBase*db = DefaultDataBase)<t>* PO_GET_NEXT_<t>(SpPoDataBase*db = DefaultDataBase)<t>* PO_GET_NEXT_BLOCK_<t>(SpPoDataBase*db = DefaultDataBase)int PO_GET_NUMBER_OF_<t>(SpPoDataBase*db = DefaultDataBase)<t>* PO_ATTACH_PTR_<t>(<t>*& ptr, SpPoDataBase*db = DefaultDataBase)<t>* PO_DETACH_PTR_<t>(<t>*& ptr, SpPoDataBase*db = DefaultDataBase)void PO_SET_NAME_<t>(<t>* ptr, char* name, SpPoDataBase* db = DefaultDataBase)<t>* PO_LOOKUP_NAME_<t>(char* name, SpPodataBase* db = DefaultDataBase)class PO_PTR_<t>class PO_PTR_PTR_<t>The first two functions, PO_ADD_<t> and PO_REMOVE_<t>, register and de-register allocated memory with the database.  The next two, PO_NEW_<t> and PO_NEW_ARRAY_<t>, allocate and register objects with the database.  The methods PO_DELETE_<t> and PO_DELETE_ARRAY_<t> deallocate and de-register objects in the database. The next 5 functions (PO_GET_…) allow one to traverse all instances of a class within a database.  A block is defined as a single piece of memory (which may be an array of class <t>) that has been registered with the database.  One can walk through the database block by block until one finds the correct block and then walk through the block, array item by array item.The next two functions, PO_ATTACH_PTR and PO_DETACH_PTR, are for attaching and detaching pointers with the database. Attaching a pointer simply means that the database now knows about that pointer and will be able to remap it correctly in the event of a restart. Similarly, detaching a pointer does not change the value of a pointer but simply de-registers that pointer with the database so that it will not be updated when the database is restored.  This means that the pointer may appear to be valid upon restoration but will most  likely point to  an incorrect area of memory.The final two functions, PO_SET_NAME and PO_LOOKUP_NAME, allow one to name a memory block within the database or look up a memory block by name.  This can be convenient, for example, if a database contains a tree and one desires a pointer to the root or some other item within the tree without having to search the tree.Finally, two classes of smart pointers are provided to simplify the process of attaching pointers: PO_PTR_<t> and PO_PTR_PTR_<t>.  The first is a smart pointer to an object of type <t> and the second is a smart pointer to an array of smart pointers.  Simply using these classes will automatically attach the all necessary pointers. It should be noted that any operations on smart pointers are automatically performed in the database pointed to by the global variable DefaultDataBase.  Since smart pointers are attached only once, this also means that smart pointers will only be attached in that one database.Another issue that must be addressed by the developer is that any class that has virtual functions must derive from the class PersistenceBaseClass. This is important because the location of the class’ virtual function table will almost always change for different runs.  The persistence database needs to know which classes have pointers to virtual tables and where in each class the virtual table pointer is located.  Here is an example of how this is to be done:class foo : private  PersistenceBaseClass{public:  virtual void PrintMe()     {cout<<”InPrintMe” <<endl;}  PO_PTR_char name;};class bar {public:  int size;  name foo;};Notice that foo inherits from PersistenceBaseClass since it has a virtual function.  On the other hand, bar does not have to inherit from PersistenceBaseClass since it does not have any virtual functions itself (even though bar contains a class, foo, that has virtual function tables). The persistence database will use the inheritance  from PersistenceBaseClass to identify the locations of virtual function tables within these classes.  Developers should be aware that this adds an additional if statement to each constructor so if speed of construction is of the essence, then a technique such as free lists should be implemented to reduce this overhead.A final concern is that the constructor of a class that is registered with persistence must have a “do nothing” branch in the zero-argument constructor if the static member SpPoDataBase::DoNotAllocateMemoryInConstructor is set to true.  The importance of this is so that the database can construct objects without fear of memory leaks or other potentially disastrous results and then set up the correct values when the database is restored.  This parameter is also used when the database tries to determine the size of a class along with the location of any virtual function tables within the class.  For example (replacing the above static SpPoDataBase member with DoNotAllocate):class foo {public: char* name;  foo(){  if (DoNotAllocate == 0 ){    name = PO_NEW_char(13);    strcpy(name,”Default Name”);  }}; There are also similar functions that are not macro generated which will provide similar functionality except using void* pointers:void* PO_ADD(void*& ptr, SpPoDataBase* db = DefaultDataBase)void* PO_REMOVE(void* ptr, SpPoDataBase* db = DefaultDataBase)void* PO_GET_FIRST(char* type, SpPoDataBase*db = DefaultDataBase)void* PO_GET_NEXT(char* type, SpPoDataBase*db = DefaultDataBase)int PO_GET_NUMBER_OF(char* type, SpPoDataBase*db = DefaultDataBase)void PO_SET_NAME(void* ptr, char* name, SpPoDataBase* db = DefaultDataBase)void* PO_LOOKUP_NAME(char* name, SpPodataBase* db = DefaultDataBase)These generic functions can be used instead of the class specific functions but they should be used with caution.  There are several reasons for this. First, the restoration of objects may not be done correctly if PO_ADD() is applied to a class that has virtual function tables.  Second, classes may be construction using different functions from what was desired.  For example, arrays of one class will be reconstructed as arrays of chars and will likely lead to a crash when these items are destructed.Several other functions are provided that create and/or manipulate buffers created by the persistence database:PO_SIZEOF_BUFFER(char*)PO_CREATE_BUFFER(int compressionType = SpPoDataBase::NO_COMPRESSION,                 SpPoDataBase * db = DefaultDataBase)PO_RECONSTRUCT_BUFFER(char * buffer, SpPoDataBase * db = DefaultDataBase)These functions allow one to find the size of a buffer, create a buffer, or reconstruct objects from a buffer.  This buffer can then be written to disk, sent over a network or otherwise saved for later restoration.3.1 Virtual Function pointersStroustrup states “… to implement polymorphism, the compiler must store some kind of type information in each object … and use it to call the right version of the virtual function…. In a typical implementation the space taken is just enough to hold a pointer.” [1] This pointer points to a virtual function table, which is a list of pointers to virtual functions. Our experience has shown that this is the most widely used implementation, so we designed our persistence database to take advantage of this information.  The essential problem here is caused by the fact that the loader will probably not locate the virtual functions at the same addresses upon restart, so a saved and restored virtual function table will probably not work.  Therefore, after restarting, we must somehow recreate all the virtual function tables, and insert a pointer to the correct table into each object that has a virtual function.  This means that we must know:  1) how to recreate the virtual function tables,  2) which virtual function table belongs with each class, and 3) where to insert the virtual function pointer into an object instance.To obtain the needed information, every class that will be made persistent and has virtual functions must inherit from SpPersistenceBaseClass.  This class is completely empty except for a constructor and a virtual destructor that forces the class to consist solely of a virtual function pointer.  Classes have only one virtual function table (save for contained classes which may have their own virtual function table).  As a result, the first N bytes of an instance of a class will be the address of that class’s virtual table, where N is the size of a pointer for a particular architecture.The SpPersistenceBaseClass constructor stores the address of the virtual function table in a list managed by the persistence database.  Each address is recorded only once.  When an object is reconstructed from a checkpoint and it belongs to a class that is known by the database to have a virtual table, the object’s virtual pointer can be set to the proper value.This does result in a potentially dangerous assumption.  It is entirely possible for a compiler to give an object multiple virtual function tables, or use something other than virtual function pointers, or do something else that will break this code.  This is something that must always be verified and test programs have been developed that check for many possible variations and differences between compiler implementations.3.2 Data Structures and designThe persistence database uses a combination of shared and specific data structures to maintain the requisite information. The shared information includes: class ids, class sizes, functions for Figure  SEQ Figure \* ARABIC 1: Main database data structureconstructing classes, and a list of virtual function table offsets.  The specific information relates directly to the set of memory blocks that are being managed: a list of all memory blocks, a list of named blocks, lists of blocks by class type, and a count of how many of each type is being managed.As shown in Figure 1, combinations of scalable structures such as binary trees and constant access time structures such as arrays are used to reduce data access times to a minimum.  The current implementation uses a splay tree mode.  Other schemes such as a heuristic to keep the tree of all memory blocks nearly balanced or unbalanced trees have been tried, but both of these options resulted in lower performance when a large number of memory blocks is managed.The tree of all memory blocks contains a pointer to each block of memory that has been added to the persistence database.  The tree of named blocks contains a pointer to each memory block that has been assigned a name.  The array of lists of classes by type contains pointers to the blocks of memory by type, for quickly walking through all items of a given type.  The array of counts of each type simply maintains a count of how many of each type is in the database.There are many static data members in order to share common data among different instantiations of persistence databases:The IDs given to each class type,The size of each class registered with the database,The functions for creating an array of a given type,The functions for creating a single item of a given type, andLists of the virtual function table pointer offsets for a given class type.Each memory block consists of a single piece of memory (which may contain an array of objects) that has been added to the persistence database.  A memory block holder is constructed for each memory block and inserted into the tree of all memory blocks.  A pointer to this holder is also added to the list of blocks for this block’s type; and, if the block has been given a name, a pointer to the block is inserted into the tree of named blocks.  As shown in Figure 1.1, a memory block holder consists of:A tree of all attached pointers within that block,The block’s name, if any,The size of the block,The base address of the block,The class type for this block, andA few additional bits of information contained within a bitfield.Figure 2 Memory block holderGiven this structure and the overall design of the database, the algorithm for attaching a pointer (i.e. taking note of the pointer and where it resides) is as follows: first search through the tree of all memory blocks for the one containing the pointer; then search through that block’s tree of attached pointers to see if this one has already been added to the tree;  if not, insert it into the tree. 3.3 DrawbacksThere are several drawbacks to this design for a persistence memory management database.  First, the persistence database can only store what is actually in an object.  This means that C++ static data members will not be saved unless one specifically requests that they be saved.  When the database is restored, static members will be restored (if they were added), but will not be linked to the class as desired, so this linkage must be explicitly re-established by the user.  For example, if we make the value of static member MyClass::X persistent, at restart the value will be restored into a memory block, not in the newly-created location for MyClass::X, so we will have to remember to assign the value to MyClass::X.  The same applies to global data. So, in order to make static data members and globals persistent, the user must save these items in named blocks and remember to assign the value contained in the named block back to the variable upon restart. A second drawback is that reference data members cannot be restored.  For example, the following is not allowed:class foo {public:  foo();private:  int & x;};The problem with this example is that a reference is really a sort of constant pointer (in many compilers it is implemented exactly that way) and there is no way to identify the offset of a reference within a class, since you cannot take its address. It should be noted that in the trivial example above, the address of the reference could be easily deduced. But in classes that contain more than one data member, the answer is not so simple.The third drawback is that one must register a class with a database before one can restore any classes of that type.  Since the persistence database uses the code in which it is contained to determine how to build a class, destroy a class, or find the virtual function tables of a class, we must register function pointers for each class that will be restored. The PO_DEFINE macro defines the function PO_REGISTER_<t>() which will register the function pointers and other information necessary for building a class of type <t>.  This service is automatically provided for you when you add the first class of this type to a persistence database since the generated function PO_ADD_<t> makes sure that the registration is taken care of.  Upon restart, it is recommended that the PO_REGISTER_<t> function call be among the first calls made in your program for every class that will be restored.Finally, the database can only save pointers that it is informed about.  If an object has five pointers and the database is only told to attach 3 of them, the remaining two pointers will not be correctly updated upon restoration of that object.4. Checkpoint and restart for SPEEDESIn order to checkpoint a simulation for restart, it is important to save the exact state of all of the objects within the simulation.  A simple way to do this (and one that has been done in the past) is to store a copy of the state of the executable and then restart from that copy.  This has the advantage of being relatively easy to implement but has several drawbacks.  First, it requires saving a great deal more information than really needs to be saved in order to restart the simulation Second, this results in the inability to repair the logic of the simulation upon a crash. Third, it requires the writing of a loader that is very platform specific.  Finally, it also does not allow third party software to browse the simulation objects for some other post processing of the simulation.Therefore, it is much wiser to save only what is absolutely essential in order to restart the simulation: all the simulation objects and their events.  Since events are generated from messages, we can simplify it further and only save the messages instead of the events, which reduces the amount of data that must be saved.  Since messages are only char* buffers, they are also simpler to restore than events and generally do not have pointers.4.1 Saving simulation objects SPEEDES creates all the objects during the construction of the time management algorithm.  Simulation Object Managers (SimObjMgrs) are plugged into the simulation and a single object known as the Master Simulation Object Manager (MasterSimobjMgr) is created. In its constructor, it calls the constructors for all the SimObjMgrs that were plugged in.  These SimObjMgrs then create all the Simulation Objects (SimObjs) of their type for their node. Figure 3 Arrangement of simulation objects within a SPEEDES simulationAfter this, all objects should have had their initial states and pointers registered with persistence and all changes to the actual object will then be recorded whenever a checkpoint is called.In order to perform a checkpoint, SPEEDES rolls back all objects to GVT (Global Virtual Time) and creates a buffer out of all the objects and their messages.  This buffer is then written out to disk and SPEEDES continues on by processing the next event as chosen by the time management algorithm.  It is important to note that messages are stored as char* buffers but may actually contain pointers to SimObjs, data within these SimObjs or other data in the simulation.  These pointers can be recorded within the database and will be restored upon a restart as well.Obviously, all data that pertains to a SimObj’s state must be saved at the time of a checkpoint.  Since SPEEDES is an optimistic discrete event framework, all state data for simulation objects must be contained in rollbackable data members and data structures.  This makes enabling persistence relatively straightforward for SPEEDES.  If all rollbackable operations, data structures, and classes are persistent, the SimObj state data is persistent as well. 4.2 Restoring objects after a restartSince the construction of objects is centralized, the reconstruction of objects after a restart is relatively straightforward.  When SPEEDES arrives at the point at which the MasterSimObjMgr is normally created, this process in interrupted, the checkpoint database is read in and the objects are created.  A pointer to the SpMasterSimObjMgr is found in the database and is assigned within SPEEDES.  Now, the ResetObjectForRestart() method is called on every SimObj and SimObjMgr so that the user can update any values that were not saved for restart. Once all the objects have been saved, SPEEDES goes through the database and pulls out all the messages, converts them to events and attaches them to objects as they are extracted. Once this is completed, SPEEDES can then proceed as usual with the startup and then begin processing events with the first one designated by the time management algorithm.5. Preliminary performance tests in SPEEDESThe changes detailed in this document were initially implemented using SPEEDES version 0.61 and an early version was released in SPEEDES version 0.7.  SPEEDES 0.73 (released June 30, 1999) contains a nearly complete implementation of persistence throughout SPEEDES rollbackable container classes and rollbackable functions.  SPEEDES 0.8 (to be released August 30, 1999) should have a complete implementation including support for object proxies and the full range of SPEEDES roll backable container classes and data structures.Several simulations were modified in order to make them persistent including qnet, a simple simulation of a queuing network. Executing on a single node with checkpoints enabled, qnet ran at approximately half the speed of the non-checkpointed qnet in preliminary tests on a Pentium Pro, 200mhz Linux workstation.  Checkpoint files were approximately 600kb and were written out to disk in just a few milliseconds.  The reduction in speed for qnet can be attributed to the overhead of inserting and removing messages from the database.  This overhead could be reduced through the use of free lists and active/inactive flags within messages, although this would have the consequence of increasing the size of the buffers, and forcing a different handling of non-standard-length messages.Another solution would be to add messages containing pointers to the database only at the time of a checkpoint and remove them afterwards.  Since most messages do not have pointers, this would result in a slight increase in the time required for a checkpoint, but a very large increase in the speed of the overall simulation.  The speed increase would come from not having to add and remove every message but there is a secondary benefit.  Since the database is now managing a much smaller set of memory ranges, the performance for other adds and removes will improve as well.6. ConclusionsA scalable persistence memory management scheme has been written that enables the saving and restoring of complex C++ data types.  In order to be used properly, the user must register memory regions with the database and notify the database of pointers within those regions. Macro-generated functions and classes have been provided to the user in order to make these tasks easier. This system has been successfully integrated with SPEEDES in order to provide checkpoint/restart capability for a demo simulation.  There are still many items open for improvement including reducing the overhead for message storage and removal, using free lists to reduce the number of insertions and deletions of common objects, adding compression to the database buffers, and other optimization improvements to the database management.7. References[1] StrouStrup, Bjarne “The C++ Programming Language, third edition, 1997, Addison-Wesley, Reading Massachusetts.[2]	Steinman, J. “SPEEDES User’s Guide Beta 2.0” 1994, The MITRE Corporation and The Jet Propulsion Laboratory[3]	Steinman, J. “Scalable Distributed Military Simulations Using the SPEEDES Object-Oriented Simulation Framework” 1998, In proceedes of the Object Oriented Simulation Conference, Pages 3-23[4]	Steinman J., Nicol D., Wilson L., and Lee C.  "Global Virtual Time and Distributed Synchronization", 1995.  In proceedings of the 1995 Parallel and Distributed Simulation Conference (PADS95), Pages 139-148.[5]	Shapirro, Marc, and Ferrera, Paulo, “Larchangt-{RDOS} a Distributed Shared Persistent Memory and its Garbage Collector”, 1995, Springer-Verlag LNCS pages 198-214, Le Mont San Michel (France)[6]	Hosking, Anthony L., and Moss, J. Elliot B. “Implementing Persistent Object Bases: Principles and Practice”, 1990, Proceedings of the fourth international workshop on Persistent Object Systems,  Martha’s Vinyard, Ma[7]	Singhal, Vivek, Kakkad, Sheetal, and Willson, Paul “TEXAS: An Efficient Portable, Persistent Store” Perstentent Object Systems: Proceedings of the Fifth International Workshop on Persistent Object Systems,  Sam Miniato Italy 1992 pages 13-22Author BiographiesRONALD VAN IWAARDEN is an analyst for Metron, Inc. (HPCD) and is currently the SPEEDES onsite support representative for War Game 2000 at the Joint National Test Facility.GARY BLANK is a senior software analyst for Metron, Inc. (HPCD). Gary is currently writing a high performance RTI for use with SPEEDESSCOTT SHUPE is a software analyst for Metron, Inc. (HPCD). Scott is currently writing a high performance RTI for use with SPEEDES