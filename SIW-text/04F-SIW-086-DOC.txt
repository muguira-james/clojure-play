Design of the Dynamic-Link-Compatible C++ RTI API for IEEE 1516Len GranowetterMÄK Technologies10 Fawcett St.Cambridge, MA 02138617 876-8085 x121 HYPERLINK "mailto:lengrano@mak.com" lengrano@mak.com HYPERLINK "http://www.mak.com" http://www.mak.comKeywords:HLA, RTI, IEEE 1516, DLCABSTRACT: The Dynamic-Link-Compatible (DLC) RTI API for IEEE 1516 is an alternative mapping of the semantics of the IEEE 1516 Interface Specification to C++ and Java APIs. It was developed by a SISO Product Development Group, which was led by representatives of the three leading commercial RTI vendors. In addition to becoming a SISO Standard, the DLC API is expected to be adopted by the HLA Evolved PDG as the basis for the C++ and Java APIs that are provided as part of the future versions of the IEEE HLA Standard.This paper introduces the Dynamic-Link-Compatible C++ API for the IEEE 1516 version of HLA, and describes the rationale for most of the key design decisions that were made by the PDG. First, we will describe the specific elements of the original IEEE 1516 API design that made it difficult for RTI developers to produce RTIs that could be swapped in or out of a federate without recompiling or re-linking. Then, we will discuss the improvements that the designers of the original IEEE 1516 API were trying to achieve through their design, compared with the HLA 1.3 C++ API. Finally, we will show how the Dynamic-Link-Compatible C++ API was able to retain the functional improvements intended by the original API designers, without sacrificing Dynamic Link Compatibility.As part of the discussion, we provide some insight into the level of effort required to port from either the HLA 1.3 C++ API or the original IEEE 1516 C++ API to the Dynamic-Link-Compatible C++ API for IEEE 1516.IntroductionOne of the key goals of HLA was to provide a standard interface to a Run-Time Infrastructure (RTI), so that simulation applications could write code that was independent of the specific mechanisms used to communicate data among them.  An application developer writes to the RTI API, and, at least in theory, the resulting federate should be portable with respect to RTIs.  That is, you should be able to run the federate with any compliant RTI.A recent poster to the HLA Evolved reflector put it this way: “…the intent from the beginning was for a federate developed under RTI A to be ported to RTI B with (little or no) effort.  By "little effort", I mean moving DLLs or Shared Objects around.  No code rewrites.” [1] Using the HLA 1.3 Specification, federates, for the most part, are portable between different RTI versions, and in many cases, you do not even need to recompile or re-link the federate.  It's true that the HLA 1.3 Specification is not perfect, and that there are places where different RTI implementations resolve ambiguities in the Specification differently (such as with regard to tick strategies).  Therefore, it is true that it is not as simple as it should be to write portable federates.  But there are a great many HLA 1.3 federates (including six of MAK’s COTS products) that are capable of running with the MAK RTI, RTI NG, or the Pitch RTI without recompiling or re-linking.  These federates are truly portable among different RTI implementations, merely by switching DLLs.IEEE 1516, however, is a different story.  The way the original C++ API for IEEE 1516 was designed, different RTI implementations could not easily be Dynamic Link Compatible.  Basically, this is because the original IEEE 1516 C++ API was (purposely) incomplete:  Because the API designers wanted to allow RTI developers the flexibility to choose different implementations for types like Handles (something that was not possible in 1.3), the API called for RTI vendors to “fill in the blanks” with some implementation-specific header files.  A federate developer could not successfully compile a federate against the set of header files dictated by the IEEE 1516 Standard without the API being “completed” by an RTI vendor.  Because there is no standard way in which RTI vendors are supposed to “fill in the blanks”, different RTI implementations are, in effect, implementing different C++ APIs.The fact that the original IEEE 1516 API chose not to fully specify a C++ API means that different RTI implementations are not Dynamic Link Compatible. When a federate is compiled, that executable is locked into the choice of a particular RTI implementation.  In order to switch to a different vendor’s RTI, the application must be recompiled against the new vendor’s API, and re-linked.  While this does not sound like a huge burden to a federate developer, it is a very large hurdle for an end-user to overcome.  An end-user is not free to choose an RTI implementation that is appropriate for a federation simply by swapping in a different RTI’s DLL.  Instead, he must go back to the federate developer or tool vendor to ask that the federate be recompiled specifically for the chosen RTI.This is exactly the problem that the Dynamic Link Compatible HLA API was built to solve.  The DLC API is an alternative mapping of the semantics of the IEEE 1516 Specification to a C++ API, in a way that supports Dynamic Link Compatibility.  It has been developed by a SISO Product Development Group (PDG), with representatives of three leading RTI vendors serving as editors, and the editor of the HLA Interface Specification for HLA Evolved as its Technical Area Director.  The DLC API, unlike the original IEEE 1516 C++ API, is designed specifically to allow federates to swap among different RTI implementations merely by switching DLLs.In addition to becoming a SISO Standard, the DLC API is expected to serve as the basis for the C++ API for HLA Evolved (the future IEEE version of HLA).Although the primary goal of the DLC API PDG was to alter the API in a way that supported Dynamic Link Compatibility, a secondary goal was to simplify the API where possible.  For someone who is used to looking at the C++ API for HLA 1.3, the IEEE 1516 API appears complex and daunting.  Whereas the 1.3 API consisted of just six header files totaling 2891 lines of code, the IEEE 1516 API employed 42 files totaling 5210 lines to cover roughly the same scope of functionality.  In the interests of making the IEEE 1516 version of HLA more accessible, and of easing the transition from 1.3 to IEEE 1516, the DLC PDG tried to use the most familiar C++ idioms wherever possible; electing to employ newer constructs only when the benefit of doing so was clear and convincing.  By taking this approach, we were able to reduce the size of the API back down to 14 files and 2949 lines of code without losing any of the power or extensibility that the original C++ API tried to provide.In developing the DLC C++ API for IEEE 1516, we started with the API defined by the DoD Interpretations Document, version 2.0, which contains several amendments and fixes to the original IEEE 1516 API that are unrelated to Dynamic Link Compatibility.Elements of API DesignHandlesOf all of the technical issues that the DLC PDG tackled, the most complex was developing an approach for representing handles.  A handle is an identifier that is generated by the RTI and used by both a federate and the RTI to uniquely designate something.  AttributeHandles designate attributes, ObjectInstanceHandles identify object instances, etc.In the 1.3 HLA API, unsigned longs were used to represent handles, for example:typedef ULong ObjectClassHandle;However, for IEEE 1516, there was a strong desire to allow different RTI vendors to represent handles differently.  Perhaps an RTI designed for small federations running over low-bandwidth connections might choose to use 16-bits instead of 32 to represent ObjectInstanceHandles.  Another RTI might want to use a 64-bit integer, so that a federate’s Local RTI Component can unilaterally generate unique handles by appending the value of a counter within a federate to the process ID and IP address of the host machine.  Yet another might choose to use the value of a pointer to the data structure used by the RTI internally to represent an HLA object.  This last implementation has some efficiency advantages: an RTI can avoid looking up a handle in a table in order to access the data associated with a particular object, since the handle points directly to the desired object.In the original IEEE 1516 API, the desire to provide flexibility in implementation of handles was achieved through the use of templates.  Simplifying quite a bit, Handle was a template class that looked roughly like this:template <class HandleImplementationType> class Handle {   ... };Specific kinds of handles were defined roughly like this:typedef Handle<   ObjectClassHandleImplementationType>   ObjectClassHandle;So the API defined an ObjectClassHandle, for example, as an instantiation of the Handle template, with ObjectClassHandleImplementationType as the template argument.So what is ObjectClassHandleImplementationType?  That depends on the RTI implementation.  An RTI provides a file called SpecificConfig.h, which contains definitions for a variety of implementation types such as ObjectClassHandleImplementationType.  For example, an RTI might choose to define this type as a long:typedef long  ObjectClassHandleImplementationType;This is what we meant earlier, when we said that an RTI developer was required to “fill in the blanks” in the original IEEE 1516 API.  When a compiler processes federate code, a specific RTI vendor’s version of SpecificConfig.h is compiled in.  And that is why the original API did not support Dynamic Link Compatibility.The challenge to the DLC PDG was to develop an approach to representing handles that supports Dynamic Link Compatible, while retaining the ability to allow different RTI vendors to choose different implementations for handles.Several designs were considered.  The most obvious was to define each handle type as an abstract base class, and allow different RTI vendors to provide different implementations through subclassing.  A factory mechanism could be used to provide an implementation-independent way to create implementation-specific handles, much the same way as this works for RTIambassador.The problem with any subclassing/factory approach is that it requires the objects that you create to be passed around by pointer or by reference.  Passing an instance of a derived class by value to a function that doesn’t know which derived class to expect results in “slicing”: the derived-class-specific information is lost, virtual functions don’t work, etc.  In cases like RTIambassador, this is not a significant limitation.  You wouldn’t expect to be able to pass RTIambassadors around by value, which would cause a separate copy of the object to be created.However, handles are exactly the kinds of things you want to pass around by value.  A handle already gives you a level of indirection.  Like a pointer, it gives you a way to identify or designate an object without passing the entire object around.  Dealing with pointers to handles leads to some really ugly syntax and confusing code.  And to a large extent, it defeats the whole purpose of handles: to have an identifier you can copy, pass around, and store without having to worry about managing the memory associated with the object you are identifying.  So after careful consideration, the abstract base class approach was rejected.Several other variations on the template approach were considered, but it became obvious that any template approach would suffer from the same limitation as the original.  Template instantiation happens at compile time, so the choice of implementation becomes locked into the federate executable.Finally, another choice emerged, first proposed by Mikael Karlsson of Pitch, and amended by Keith Snively of the RTI NG team: a solution based on what is known as the “pimpl” (as in “pointer to implementation”) idiom.[3]Each kind of handle is represented in the API by a concrete C++ class, e.g. ObjectClassHandle.  Included as a member variable of this class is a pointer to an instance of another class that contains the details of the handle’s implementation, e.g. ObjectClassHandleImplementation.  Various operators and member functions of ObjectClassHandle are declared non-virtual, and are intended to be implemented by calling a corresponding member function on the implementation class.  Because the API only needs a pointer to the implementation class, the definition of this class can be omitted, and a forward declaration can be used in its place.// Forward declarationclass ObjectClassHandleImplementation;class ObjectClassHandle {public:   bool operator==(      const ObjectClassHandle& rhs) const;   ... protected:      ObjectClassHandleImplementation* _impl;}bool ObjectClassHandle::operator==(   const ObjectClassHandle& rhs) const{   return (*_impl == *(rhs._impl));}A definition of the implementation class is provided by each RTI implementation, which preserves the ability for different RTIs to implement handles differently.  But because the definition of the implementation class is kept out of the API, it is no longer compiled into federate code as it was before.  A federate executable will have a reference to a symbol called ObjectClassImplementationHandle, and that reference will get resolved to whatever version of the class is provided by the RTI DLL (or DSO) at run-time.The ObjectClassHandle class (and similar ones for other types of handles) meets all the requirements of a handle:  it can be passed by value, has intuitive syntax, is compact, and can be copied efficiently (by copying a single pointer).  Further, it supports Dynamic Link Compatibility while still supporting flexibility of implementation.  This solution was unanimously chosen for inclusion in the DLC API, and the group’s biggest challenge was put to rest.ValuesThe original IEEE 1516 API contained a value template, which was used to create types to represent different kinds of values (AttributeValue, ParameterValue, etc.)  As in the case of handles, RTI developers were required to define implementation classes in SpecificConfig.h, to be used as a template argument to the Value template.  And as in the case of handles, this approach precluded Dynamic Link Compatibility.Although the pimpl approach that was used for handles was equally applicable to values, we initially thought we might be able to employ an even simpler scheme.  Because there was no immediately obvious reason that different RTI implementations needed to represent values differently, it appeared that we could just use a simple, concrete class to represent each kind of value.However, when we started examining the semantics of copying and storing values, some good reasons for potential customization emerged.  Specifically, we wanted to allow for implementations that use reference-counting schemes to avoid unnecessarily copying potentially large buffers of opaque data.  For example, when a federate gets a reflectAttributeValues() call, it may want to hold on to a copy of the AttributeValueMap.  We wanted to allow RTI implementations to support this logical copying without incurring the cost of actually copying all of the attribute values.  For reasons such as this, we decided that we should use the pimpl approach after all.We were able to simplify one aspect of the API for values, however, when we determined that it was not necessary to have separate types to represent the various kinds of values that the RTI required.  The stated reason for representing AttributeValue, ParameterValue, etc. as separate types was to provide type safety – so that, for example, an AttributeValue could not be passed where a ParameterValue was expected.  But because a value is really just a wrapper around a buffer of opaque data, the gain in type safety was mostly illusory.  For example, even in the original API, an AttributeValue could easily be initialized from a buffer that was intended to hold a ParameterValue. When we removed the value template, we were therefore able to replace it with a single class called VariableLengthData, that is now used to represent all of the elements of opaque data that are required by the RTI: AttributeValues, ParameterValues, EncodedHandles, UserSuppliedTags, etc.  Just like in the case of handles, VariableLengthData has a pointer to an instance of a class called VariableLengthDataImplementation, which is forward declared by the API, and provided by the RTI implementation DLL.Much thought was put into the interface of VariableLengthData to insure that it was both simple to use, yet supported efficient implementations.  We provided three ways of initializing a VariableLengthData from a buffer, allowing tradeoffs between efficiency and memory management responsibility:// Simple semantics, but a copy will occurvoid setData(void const* inData,    unsigned long inSize);// Hold a pointer to an unowned buffervoid setDataPointer(   void* inData, unsigned long inSize);// Take ownership of a buffervoid takeDataPointer(   void* inData, unsigned long inSize);Logical TimeThere were several issues regarding logical time that required thought and discussion.First, in the interests of simplifying the API, we considered whether separate classes for LogicalTime and LogicalTimeInterval were really necessary.  After all, both were represented using the same class in the 1.3 C++ API.  We determined that there really are conceptual differences between the two types – for example, you should be able to add an interval to a time, but adding two times does not makes sense.  We decided to leave the two classes in place; however, we combined the two factory classes into one LogicalTimeFactory that is used to create instances of both LogicalTimes and LogicalTimeIntervals.A more serious issue involving LogicalTime, is that the original API failed to support some of its own stated goals.  An idea that goes back to the 1.3 API, is that a federation can dictate how time is represented by providing subclasses of base classes like LogicalTime and LogicalTimeInterval.  In order to allow the RTI to create instances of the desired time subclasses, a factory must be provided to the RTI.  In the 1.3, the RTI used a static factory method to create instances of time, which means that only a single kind of time could be used within a particular application.  In the original 1516 API, the factory approach was amended to support applications that were members of several federation executions at once – each using a different implementation of time.  This is achieved by allowing an application to pass an instance of a time factory as an argument to joinFederationExecution().The problem is that many RTI implementations rely on a central server application such as an rtiexec, and there was no way to pass an instance of a factory across the network to that separate application.  So if the rtiexec loads a FedTime library that includes multiple implementations of LogicalTime, it has no way of knowing which implementation to use for each federation.The solution to this problem was to “name” each implementation of LogicalTime, and to ask a federate to provide the name of the LogicalTime implementation it would like to use to the RTI.  Because we wanted to avoid the situation where different federates that are joining the same federation may disagree on which LogicalTime implementation should be used, we made it the responsibility of the federate that successfully creates the federation execution to dictate the choice of LogicalTime.  In the DLC API, the name of the LogicalTime implementation is passed as an argument to createFederationExecution(), rather than joinFederationExecution().With this new approach, a federation developer can place several different LogicalTime implementations into a single FedTime library, along with corresponding factories that know how to create instances of each.  A single LogicalTimeFactoryFactory class also appears in the FedTime library, and when a federate passes the name of a LogicalTime implementation to createFederationExecution(), the Local RTI Component can ask the FactoryFactory for the LogicalTimeFactory associated with that name.  The LRC can pass the name across the network to an rtiexec, so that the rtiexec can also obtain the appropriate kind of LogicalTimeFactory from the FactoryFactory.If there is only one LogicalTime implementation in FedTime library (a very common case), then the federate that creates a federation execution does not even need to know the name of that implementation.  It can just pass the empty string (“”), and the LogicalTimeFactoryFactory will return the “default” LogicalTime Factory. EnumerationsThe HLA Interface Specification requires nine enumerated types; for example, TransportationType, which can take on values of BEST_EFFORT or RELIABLE, and OrderType, which can have values of RECEIVE or TIMESTAMP.  In the original IEEE 1516 C++ API, these types were represented as C++ classes, rather than the more natural C++ enums Enumerated values were represented as global const instances of those classes.Upon some investigation, it appeared that the reason enums were not used initially was because of a misunderstanding about type-safety.  C++ enums do in fact provide type safety, and a compiler will not allow you to inadvertently pass a value of type OrderType where a TransportationType is expected.By replacing the nine enumerated types with C++ enums, we were able to greatly simplify the API without any loss of functionality.  Eighteen of the 42 files in the original API were removed (1558 lines of code), and replaced with a single new file, Enums.h, consisting of 91 lines.SummaryAlthough there were many smaller decisions made by the DLC PDG, this paper has summarized the most important and most complex of the issues that the group considered.  For a full account of the changes that were required to go from the API defined by the DoD Interpretations Version 2.0 to the API defined by the DLC PDG, see the Bugzilla change-tracking database at  HYPERLINK "http://rtiapi.mak.com" http://rtiapi.mak.com.Porting to the DLC APIPorting a federate from the original IEEE 1516 C++ API to the DLC C++ API is fairly straightforward.  With the exception of a change to the namespace name (from RTI to rti1516), the names of most classes, files, and functions have remained the same.  For example, there were no changes to the names of any RTIambassador or FederateAmbassador member functions.  STL maps are still used to represent AttributeHandleValueMaps and ParameterHandleValueMaps.Even in the areas where the DLC API deviated significantly from the original API, the differences are largely transparent to federate code.  For example, even though an AttributeHandle is now implemented as a concrete class with a pointer to an implementation class (rather than a template instantiation), it is still called AttributeHandle, and you can still use operators such as “<”, “==”, and “<=” to compare them, and a function called encode() to encode one.  There are many places where handles are now passed by value, instead of by const reference, but since the syntax for these two methods of argument passing is identical, federate code typically does not need to change.That all being said, there are still a fairly significant number of places where API changes do require changes to federate code.  For example, when adding an attribute value to an AttributeHandleValueMap, you must create and pass an instance of VariableLengthValue instead of AttributeValue.  A few RTIambassador functions (such as queryGalt()) that used to return by auto_ptr now “return” by setting the value of an object passed in by reference.  LogicalTime used to have member functions such as isLessThan() and isEqualTo() that have been replaced by more conventional operators such as “<” and “==”.The bottom line is that while it’s definitely not just a recompile to switch from the original IEEE 1516 API to the DLC API, it will not require major design changes to federate code.If your federate is currently written to the HLA 1.3 C++ API, the transition to IEEE 1516 definitely takes some porting work due to changes in the semantics of many RTI services.  For example, “tick” has been replaced by evokeCallback() and evokeMultipleCallbacks(), and STL maps are now used instead of custom classes to hold AttributeHandle/Value pairs.However, because the DLC C++ API more closely matches the style of the 1.3 C++ API, porting a 1.3 federate directly to the DLC API is actually easier than porting to the original IEEE 1516 C++ API.  (Remember, one of the implicit goals of the DLC API PDG was to ease the transition from 1.3 to 1516).For example, while 1.3 federates will need to switch from the class name FedTime to LogicalTime regardless of whether they are choosing the original C++ API or the DLC version, they can continue to use operators like “<” and ”==” on these objects when they choose the DLC API.  The DLC API’s use of pass-by-reference semantics rather than pass-by-auto_ptr more closely matches the design of the 1.3 API.  And the use of C++ enumerations rather than static class instance, the use of concrete classes to represent Handles and Values, and the elimination of implementation-specific header files should all make the DLC API feel more “familiar” to developers who are used to working with HLA 1.3.  Status and Future of the DLC APIAt the time of publication of this paper, the IEEE 1516 version of the DLC API had achieved consensus within the PDG, and had begun the formal SISO Balloting process.  A complete implementation of the DLC API already exists in the IEEE 1516 version of the MAK High-Performance RTI.  Porting of the DMSO RTI Verification Tools to the DLC API is nearly complete, and the MAK RTI is currently undergoing IEEE 1516 verification testing using this API.As the HLA Evolved PDG works towards an updated version of the IEEE 1516 specifications, it is expected that the DLC API will serve as the basis for the C++ and Java APIs.  Because the DLC API used the US DoD Interpretations Document as a starting point, there is no conflict between the two.  With one minor exception, the DLC API either incorporates or supercedes all 29 of the C++-specific interpretations.References[1] Post by Dannie Cutts, Aegis Technologies, to the HLA-EVOLVED Reflector,  HYPERLINK "http://www.sisostds.org" www.sisostds.org, June 22, 2004.[2] Granowetter, Len: "RTI Interoperability Issues – API Standards, Wire Standards, and RTI Bridges", Proceedings of the 2003 Spring Simulation Interoperability Workshop, Orlando, FL, March 2003.[3] Sutter, Herb: Exceptional C++, Addison Wesley, 2000, pp. 99-118.Author BiographyLEN GRANOWETTER is the Director of Product Development at MÄK Technologies, responsible for MÄK’s COTS product development group.  He was the chief architect of the MÄK High-Performance RTI during its initial development.  He has worked on the VR-Link HLA/DIS toolkit and other MÄK simulation and visualization products for over 11 years, serving as MÄK’s Lead Products Engineer for several years during the HLA transition.  He is currently the Chair and a lead editor of the SISO Dynamic-Link-Compatible HLA API Product Development Group, and is a member of the Drafting Group for the HLA Evolved PDG with responsibility for the C++ API.  Mr. Granowetter holds a Bachelor of Science degree in Computer Science and Engineering from the Massachusetts Institute of Technology.