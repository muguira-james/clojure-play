Hierarchical FederationsGerry MageeGraham ShanksMarconi Electronic SystemsGEC Marconi RDS LtdDonibristle, FifeUKgerard.magee@gecm.com, graham.shanks@gecm.comDr Pete HoareDefence Evaluation and Research AgencyMalvern, WorcsUKpeteh@signal.dera.gov.ukKeywords: HLA, Multiple Federation, Simulator Components, Time ManagementABSTRACT: Now that the viability of the HLA as an standard to encourage interoperability has been established, there is an increasing amount of activity in the community to address the issue of federate development and re-use. Tools and guidelines to enable the creation of Federates from sets of components will certainly help to advance this cause. However as more tools and component frameworks are produced, the variation in inter-component interface will increase which will reduce the potential for re-use outside these tools and frameworks.We consider that the HLA interface specification, already adopted as the inter Federate interface, could also be used for intra-Federate (inter-components) communication. (Although we consider that changes to the OMT may be required.) This has the advantage of providing a STANDARD interface for components whilst allowing those components to be used directly as federates. We also consider that an RTI implementation could be modified to take advantage of higher-speed interconnectivity (intra-processor, shared memory or Myrinet) to allow a set of components to interact in an efficient manner to create a federate. Federations of components could be connected in a hierarchical fashion using specially modified RTI implementations without change to the HLA interface specification. At each level the Federation of components would present a Federate interface up to the next higher level.Consider the case where a Federation is developed and used to model a system (in which the Federates model sub-system components). Our proposed changes to the RTI implementation would allow this system to be re-used in a Federation of such systems without change to the components.This work was carried out as part of Technology Group 10 of the MoD Corporate Research ProgrammeIntroductionThis paper describes the results of a study carried out by the Synthetic Environments Group of GEC Marconi RDS, Simulation and Training Division (GMS&T) on behalf of Sensors and Processing Sector at DERA Malvern.This study aimed to address the issues associated with adopting the High Level Architecture (HLA) as a framework which would allow component models to be connected for simulation purposes. Although a variety of such frameworks exist, we have considered the particular requirement that components can be represented as HLA federates and that a group of components representing some system behaviour can be interoperate in a system level federation without modification.The types of HLA federations which have been produced to date tend to be constructed from “large” existing simulations. Both the proto-federation demonstrators in the US and the two experimental FlasHLAmp federations in the UK have been developed to demonstrate the pull through of simulations from DIS and ALSP to HLA. Whilst successful in demonstrating interoperability they have not yet shown the other main goal of the HLA, which is reuse.  Reuse of large federates is limited, especially those which have been developed to meet other requirements (the simulations for all of these early federations were in existence and did not address a specific federation requirement) and moreover, many of the federates used a gateway technique to address HLA compliance. Add to this the fact that most of these federates remained unchanged in their basic behaviour (whether required by the federation or not) and the resultant federations showed little more than a passing resemblance to what were the initial goals of the HLA programme. More recently, and following the US mandate that all simulations conform to the HLA standard, current simulation requirements will lean more toward the HLA goals and correct use of the Federation Development Process (FEDEP) there is still a need to identify potential reuse.As we consider more applications that could benefit from an architecture that spans language and operating system, we see the HLA as an opportunity for reuse at a sub federate-level. It is common to model a system as a collection of subsystem models, and we consider that it is beneficial to model that system as a federation of components. We consider the HLA interface specification to be sufficient to allow the implementation of a sub-federate (component) framework. This framework is able to take advantage of more appropriate intercomponent communications (through shared memory, parallel or cluster, backplane or high speed communications surfaces) and provide simple (possibly centralised) time management algorithms. We believe the ability to construct component level federates provides increased potential for reuse, performance increases in the Higher Level Federation Execution (HLFE) and by modification to the RTI implementation allow components that form a federation that may be represented through a single federate interface to a higher level federation.Our approach is to produce a modified Federation Execution implementation which will enable a Lower Level Federation Execution (LLFE) to present a Hierarchical Federation execution Interface (HFI) to a HLFE. This HFI federate will be implemented as an object within the Federation Execution process. We have chosen the UKRTI as a testbed in which to prototype our HFI implementation as we have access to the its source code and design documentation and because all the information that the HFI will require is available in the existing UKRTI Federation Execution implementation.In this paper we shall identify example component systems which may be amenable to a hierarchical approach, we shall outline the difficulties associated with integrating components constructed under existing frameworks into HLA federations and component based approaches from recent workshops, we shall describe how our approach differs from the use of bridging federates and finally indicate how our Hierarchical Federation Interface can provide a degree of FOM independence for our component federations.Example Component SystemsWe have considered a number of project areas within GMS&T their applicability to a hierarchical federation approach. The following features describe the kinds of simulations which may benefit from, or be more easily developed with, the capability to connect multiple federations hierarchically.Components that have been developed to simulate a system, which might then need to be integrated into a Synthetic Environment (SE) with other similar systems.Components which have a high data rate for data is not required by the rest of a federation. An example of this might be a set of platform federates (e.g. squadron of aircraft) which require positional updates at a high rate to maintain formation. If these aircraft form part of an SE which integrates with a C2 system which presents a theatre wide picture, then much less frequent positional is required (perhaps only the formation centre position is required).Components which pass information which is sensitive and should not be visible to other federates.Components that tend to synchronise their logical times more frequently than the rest of the federation. If within a time synchronised federation there is a significant difference in event granularities (or lookaheads) then federates could be grouped into federations of similar event granularities. Federations in which some of the federates use zero lookahead are of particular interest.We have identified two example component federations. The first is a set of real time components representing a land platform. The second is a set of time synchronised federates which have a distinct split in their lookahead values (half will use small or zero lookahead). These two federations are described in more detail below.Platform Component FederationThese components represent a simplified land based Armoured Fighting Vehicle (AFV) which has sensor and weapons capability shown in Figure 1. EMBED Word.Picture.6  Figure  SEQ Figure \* ARABIC 1. AFV ComponentsThe components are described below.Vehicle Dynamics ComponentThis component is responsible for modelling how the platform moves through the SE and generates the equivalent of Entity State (ES) information. The Dynamics model is “steered” by simple commands from the Commander model.Sensors ComponentThis component receives ES information from other platforms in the SE and determines how well this sensor type would “see” those entities. This information is passed to the Commander and Weapons System models.Commander ComponentThe controller model will determine how to manoeuvre or what entity to target based on the platforms position (from the Dynamics model) and the enemy entities position (from the sensor model). This model will generate dynamics commands and fire missions to the gunnery model.Weapons ModelThis will receive commands from the Commander model, positional information from the dynamics model, remote entity positions from the sensor and generate fire and detonate events.The external data required and generated by the platform ES information and Fire and Detonate interactions.This example demonstrates how a set of existing component federates which use the HLA interface can be integrated into a federation and be used to present a single platform interface. Some aspects of the internal data may be commercially sensitive (how the sensor determines if entities are visible or how the controller selects its targets). These aspects can be hidden from the rest of the SE federation.Time Synchronised FederationConsider a federation in which some federates operate with zero lookahead (i.e. they need to respond to data queries at their current logical time e.g. queries) whilst others provide non-zero lookahead. During zero lookahead exchanges the RTI can not allow the federates with non-zero lookahead to advance time and these zero lookahead exchanges may generate a high number of synchronisation events to be transmitted between federates. The performance of a federation of this nature could be improved if the zero lookahead federates are grouped into a separate federation which is controlled by a specially adapted federation execution. The time management within this federation could for example be controlled by a central event list (which copes quite well with zero lookahead exchanges), and this federation execution could present a single federate interface which has zero lookahead but does not pass the timeAdvanceRequestAvailable and nextEventRequestAvailable calls to the higher level federation. This should reduce the amount of time management calls within the higher level federation and possibly improve the overall performance.The nature of the zero lookahead components is such that they have non zero lookahead as a group (i.e. their group reaction time to events from the HLFE is non zero). Some means should be identified to allow the LLFE HFI to use this lookahead for all calls to the HLFE.Existing FrameworksWe have considered a number of existing “simulation” frameworks and the degree to which these could be applied to developing component federates. We had particular interest in their support for distributed simulation and time management.A common feature of each of these frameworks is that they are “large” software systems within which the user builds models (or enhances existing models). These models are highly dependent on the framework kernel. The scope for reuse of user models is limited to a large extent to reuse within the tool itself.Providing HLA interfaces to these frameworks would require detailed knowledge of the framework kernel and in trying to implement a HLA “bolt-on” interface it is likely that model interfaces will have to be extended to acquire the information to perform declaration and time management. Model data may have to be aggregated and/or transformed to the correct format for the HLA. If the time management model used within the framework does not fit well with that for HLA (i.e. no consideration has been given to distribution or lookahead) then major changes may be required to the kernel.For frameworks which have a HLA interface, it may be possible to develop each component federate with an instance of the simulation framework and use the HLA to co-ordinate their activities. However the licensing and resource requirements for the larger frameworks would make this an expensive optionComponent Reuse ActivitiesThere have been a number of papers at recent workshops which have described techniques and tools for federate development from reusable components and a new thread has been added to the Workshop.Work at the Applied Physics Laboratory of John Hopkins University has lead to the development of a HLA Foundation Class (HFC) Framework[1]. This framework allows federates to reuse code modules to handle common federate activities such as own object and reflected object storage, data marshalling, time management, data logging and configuration file parsing.Lockheed Martin Information Systems, have identified the need for federates to interoperate with FOMs other than the one for which they were originally designed to facilitate reuse at federate level and have developed an Agile FOM Framework[2] which provides FOM independence. The Naval Undersea Warfare Center describes a “DataWare” Framework[3] similar to the work described above.TNO Physics and Electronics Laboratory described a framework developed as part of  the SIMULTAAN project[4]. SIMULTAAN uses a Run-Time Communications Infrastructure Architecture RCI to allow federate components to communicate. A federate is made up of a federate manager, a communications server and a set of components. The communications server handles the internal communications between the components and communication with the federation. Each component will have a Component Object Model (COM) which defines the attributes and interactions that components publishes and subscribes to other components. The Simulator Component Object Model (SCOM) defines all of the attributes and interactions which may be passed between the components within a federation. The subset of the SCOM which represents the data which is exchanged with the federation is the federate’s SOM.Of all the activities identified at recent workshops, this seems most closely related to our ideas for a component oriented RTI. In fact this work appears to be a mixture of a component RTI and a simulation API like SimConnect. The major difference is that due to the fact that SIMULTAAN uses some proprietary communications interface between components it is unlikely that their reuse will be possible outside the framework itself and hence outside the SIMULTAAN consortium. With our proposed approach all components are HLA compliant federates and as such are potentially reusable in other HLA federations.Bridging TechniquesThere has been considerable interest in bridge federate implementation in the HLA community. [5] considers bridge federate as a candidate Security Guard federate to control the flow of potentially secure information between federates. [6] extends this work to consider how the transfer of attribute ownership between federations can be managed. [7] proposes the use of federate bridges to provide interoperability between different RTI implementations.Bridge federates are used to provide a link between federation executions. A bridging federate can join any number of federation executions but must create separate RTI ambassadors and federate ambassadors for each federation execution it joins. The component federation can be linked using a number of bridge federate configurations. Some of these are considered below. EMBED Word.Picture.6  Figure  SEQ Figure \* ARABIC 2. Bridging Pairs of FederatesFigure 2 shows how three federations can be linked using dedicated bridge federates between each fedex. The bridge federates must mirror any object in either of the fedexes it represents which is of interest to the other. This solution is unlikely to be scaleable for larger numbers of federations. EMBED Word.Picture.6  Figure  SEQ Figure \* ARABIC 3. Central Bridge FederateIn Figure 3. bridge federate 1 is joined to each federation executions A, B and C. Whilst this might appear to be the simplest technique to achieve bridgingbriding, it implementation will some require complex data storage. The bridgebrdge federate will require 3 RTI and federate ambassadors (one for each federation execution). If each of federation executions has one object which of interest to all federation executions then the bridge will need to register 3 pairs of objects. For example object “objA1” in federation execution A will need to be re-registered and have its updates reflected to federation executions B and C as objects A1B and A1C. Requests for object updates from fedex B must be passed on to fedex A by the bridge federate. The bridge federate must maintain a map of objects to federations and federates so that updates are passed onto subscribing fedexes and so that ownership transfertranfser requests are passed to the appropriate federates This solution is only appropriate for linking a small number of federates since the amount of memory required to enable the bridge federate to be linked to each federation is quite large (10s of Megabytes).  EMBED Word.Picture.6  Figure  SEQ Figure \* ARABIC 4. Bridge per Federation Figure 4. represents three component federations each represented by a bridge federate which couples the component federation to a higher level federation. Each bridge federate works in a similar way to the example above except that the higher level fedex co-ordinates the communications between the bridge federates. Figure 5. below shows an example trace of how object “objA1” of federate 1 in fedex A would be updated to federate 1 in federation B. EMBED Word.Picture.6  Figure  SEQ Figure \* ARABIC 5. Update Trace for Bridged FederationNote that in the above update sequence “objA1” is registered in fedex A, “objA1B1” is registered in main fedex and “objA1B2” is registered in fedex B. If a federate in fedex C was subscribing to this object then bridge federate 3 it would discover it as “objA1B1” and re-register it in fedex C as “objA1B3”.(???)Another potential strategy for bridge configuration is to use a combination of figures 1 and 3. In this case the bridge federates would be joined to the main fedex but may be representingrespresenting more than one component fedex.  This reduces the number of bridge federates required in a simulation, whilst increasing the complexity of each bridge federate.The choice of bridging configuration will be a trade-off dependent on the number of component fedexes, their FOM designs and available hardware resources. At any level bridging federates will introduce an overhead associated with object mirroring.The HLA interface specification does not provide enough time management information for bridge federates to adequately ascertain the synchronisation requirements of the federates it represents. Bridge federates must be able find the next event times of component federates to synchronise correctly with other fedexes. Currently this would have be implemented by sending interactions containing synchronisation information from component federates to the bridge federate. The bridge federate must then decide the next time to request from the higher level fedex.Hierarchical Federation ExecutionThe use of an RTI implementation that supports a hierarchy of federations provides a solution similar to that described above. The crucial difference between a hierarchical federation execution and a federate bridge is the level of information that can be gained about the component federates. A bridge federate can only access information about its component federates through the normal HLA interface. Our proposed solution involves modifying the Federation Execution code to provide an additional federate interface (HFI – Hierarchical Federation execution Interface) which represents the federation it controls. The additional modules would be linked into the Federation Execution module and would have access to its data structure. This should enable the HFI to acquire enough information to provide all of the capabilities of a bridge federate (and more) without affecting the federation components. In fact the federation components should not be able to determine if their Federation Execution has an HFI. A hierarchical federation representing our example is shown in Figure 6. EMBED Word.Picture.6  Figure  SEQ Figure \* ARABIC 6. Hierarchical Federation.The UKRTI implementation of its fedex maintains a centralised list of object and interaction publications and subscriptions and object registrations. The HFI will have access to this information and can map this onto the FOM requirements of the higher level fedex. Updates to these objects and interactions can also be sent to the fedex A by the components in that federation. This means that the HFI has no requirement to be a federate within fedex A. The HFI will still need to create mirror objects for updating within the higher level fedex. Requests to transfer ownership of attributes can be passed on directly by the HFI to its component federates. Figure 7. shows an example trace of how object “objA1” of federate 1 in fedex A would be updated to federate 1 in federation B.  EMBED Word.Picture.6  Figure  SEQ Figure \* ARABIC 7. Update Trace for Hierarchical Federation.The main difference between this attribute update trace and that for the equivalent bridged federation is that only the HFI attached to the fedex in which an object was created needs to mirror the object to the higher level federation. Updates received by HFI 2 for the object are sent immediately to the subscribing federates in fedex B. The “greyed” areas indicate that HFI is linked with the fedex.Time management information is already held by the UKRTI fedex component. The HFI will have access to this information and will be able to determine the next earliest event in the federation it represents and request advance to this time from the higher level fedex. Once the time advance grant is released by the higher level fedex it will release all of the federates which can safely advance to that time.UKRTI ExtensionsThe UKRTI implementation[8] was carried out by DERA to provide primarily as a testbed which could be used to evaluate time management strategies. The UKRTI provides a fully distributed Infrastructure. The majority of the operations are performed in a peer to peer manner rather than accessing services from a central RTI (although subscription and object registration information is mirrored by the federation execution to update late joining federates). The inter federate communications use CORBA software (Orbix and OMNIBroker) which provides all data marshalling. The basic architecture makes no assumptions about the means by which communications between federates are achieved and provides a common interface for both Best Effort and Reliable communications. Time management is performed by independent calculation of federation Lower Bound Time Stamp (LBTS), although the abstracted interface to the time management module allows this to be replaced easily. In fact, a time strategy optimised for Myrinet clusters was added to UKRTI and is described in detail in [9].To enable the UKRTI to provide a hierarchical federation execution we have added a HFI component into the fedex which can access the declaration management tables to add itself into the subscription list for attributes which are of interest in the HLFE. It will insert objects which are discovered from the HLFE which are of interest to components in the LLFE. (These objects will appear to be “owned” by the HFI but will not need to be created through the normal RTI ambassador calls.) Attribute updates and interactions from the LLFE will be passed to the fedex and immediately updated by the HFI to the HLFE.The UKRTI time management is currently fully distributed. Each federate determines the federation LBTS when it has LBTS data for all other federates. The HFI is added to the list of regulating federates so that it will have control over when the other LLFE federates make their LBST calculation. The HFI will request the minimum LBTS form the HLFE and then free up the LLFE to that time when the timeAdvanceRequest is returned by the HLFE.We are also developing some mappings to allow the LLFE data representation to be converted to the form used in the HLFE and vice-versa.Conclusions.In this paper we have described the characteristics of federates which can be used in different federations. We consider that the HLA interface specification is suitable at both system federate and component (sub-system) federate level. The increased potential for reuse is obvious and with some modifications to the RTI implementation we believe that there is scope for some performance advantage. We anticipate presenting results of our prototype component federations at the Workshop.References[1] A Framework-based Approach to HLA Federate Development. SIW Fall ’98 Paper 181, K Cox.[2] An Agile FOM Framework. SIW Fall ’98. Paper 025, D Macannuco et al.[3] A Framework for incorporating New FOMs without Recoding Applications. SIW Fall ’98 Paper 210, K Richards and R Provost.[4] A Component Architecture for Simulator Development. SIW Spring ’98 Paper 238[5] The High Level Architecture’s Bridge Federate. SIW Fall ’97 paper 078, W Braudaway and R Little.[6] Implementing Ownership Management Services With a Bridge Federate. SIW Spring ‘98 Paper 197, C Bouwens et al.[7] A Required RTI Gateway Standard as a solution to RTI Interoperability. SIW Spring ‘98 Paper 188, K Briggs.[8] UKRTI - Interface Design Requirements and Implementation Architecture. SIW Fall ‘97, Paper 036, D Clark and G Magee.[9] HLA RTI Performance in High Speed LAN Environments. SIW Fall ‘98, Paper 085, R Fujimoto and P Hoare.Author BiographiesDr. Peter Hoare is a Principal Scientist in the Parallel and Distributed Simulation section of the UK Defence Evaluation and Research Agency in Malvern. He has been working in parallel and distributed simulation since joining DERA in 1993. Currently he is the technical lead of several programmes in the UK researching the use of the DoD High Level Architecture including Project FlasHLAmp a joint UK MoD/Industry simulation technology transfer programme. Also he is currently a Drafting member of the HLA Standards Development group developing the IEEE standards documents.Gerry Magee is a Senior Software Engineer at GEC Marconi RDS Ltd, Donibristle. He has worked in parallel and distributed simulation technology since 1989. He is currently responsible for incorporating HLA capability into SE products. He previously worked at DERA Malvern where he lead the UKRTI implementation and was responsible for the development of the time management algorithm.Graham Shanks is the Chief Software Engineer at GEC Marconi RDS Ltd, Donibristle with responsibility for the definition of software standards, procedures and methodologies and for providing consultancy and advice to projects. He also acts as the technical lead on Synthetic Environments research and development topics within the division. He is an active participant in the Distributed Interactive Simulation (DIS) standards development process and in the transition from DIS to the successor High Level Architecture (HLA) technology.  He is an elected member of the Simulation Interoperability Standards Organisation (SISO) Conference Committee and the technical lead for the Real-time, Platform Reference Federation Object Model (RPR-FOM).( British Crown Copyright 1999/DERA. Published with the permission of the Controller of Her Britannic majesty’s Stationery Office.