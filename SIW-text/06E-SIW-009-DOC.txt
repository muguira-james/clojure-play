 An Approach to Intelligent Decision Making in Computer Generated ForcesDaniel DeutchLior GdaliahuAmit SirkisC.O.R – Battle Lab & ORGround Forces Command Israeli Defense ForcesTel-Aviv, Israel HYPERLINK "mailto:danielde@post.tau.ac.il" danielde@post.tau.ac.il,  HYPERLINK "mailto:liorgd@gmail.com" liorgd@gmail.com, sirkista@mcc.org.ilKeywords:Computer Generated Forces (CGF), Behavior RepresentationABSTRACTThe need for artificial intelligence and intelligent decision making as its core is in the very essence of Computer Generated Forces (CGF) research. It is crucial in order to obtain a realistic representation of both the natural habitat of the battle zone (citizens, vehicles, etc.) and of the threat the force will encounter. Three levels of decision making exist and differ by the models suitable for each one: reactive, short-term and long-term. Decision of all three types should be handled by the CGF, as well as combinations and compositions of decisions. Many models exist for decision making, each with its advantages and its faults. We at the Computer Generated Forces development team at Battle Lab had examined those models and found that none of the existing models is completely suitable for our needs. We have therefore developed a new, innovative model which combines two basic artificial intelligence models–fuzzy controllers and state machines–to create a whole greater than the sum of its parts. This model can serve to solve all three types of decision making, and by it nature is suitable for decision composition.  It is also built as an infrastructure, so that it can be used not only by the CGF, but by other applications in the simulation as well, where they require autonomous decision making or decision support for the human user.    This model is currently in use in the CGF, solving both algorithmic problems such as collision avoidance and behavioral problems such as crowding. Maintaining satisfactory behavioral solutions using conventional programming methods is much less intuitive and difficult to design and maintain.This paper discusses the behavioral problems that the CGF confronts, the generic artificial intelligence model that would solve it, and its applications.1.  IntroductionComputer Generated Forces (CGF) [1] and Decision Making are two terms that go hand in hand. Citizens wandering in the streets of a noisy city, terrorists planning a suicide bombing, an armored battalion fighting in the battle field – all should be simulated by the CGF. Where a large quantity of entities is simulated, a man-in-the-loop cannot control all of them at once, and autonomous behavior must take place. The simulation in the IDF BattleLab (IDF BL) is divided roughly to two parts, where the blue forces (Israeli army) are simulated by man-in-the-loop simulators of tanks, helicopters, etc., and the rest of the entities, which includes both the green forces (citizens) and red forces (enemy), are simulated solely by the BL CGF. Exceptions to this rule are the semi-autonomous simulators, simulating blue semi-autonomous vehicles, which can share some of the BL CGF capabilities. The need for AI was especially noticed when urban warfare [2] began taking its place in BL simulations. Urban warfare simulations require various types of decision making. It requires both simulation of the mass [3] as well as complex decision making at the individual level and, unlike warfare between armies, does not necessarily follow a combat doctrine.  Thus it was decided to create a unified model for decision making that will serve as an infrastructure.2.  BL CGF Before the AI Era     Up until the last couple of years, BL CGF was oriented to warfare in open territories [4] between armies. A pre-planned scenario of events was designed, allowing capabilities such as movement on user-defined routes, target acquisitions, and terrain analysis. The logic of the entities, defining their responses to events, could be defined as part of the scenario. It required the user, called the “scenario editor,” to plan in advance reactions to real-time states. This task could be rather difficult, and so another user role was added, a controller that controls the scenario at runtime, and can respond to unexpected events. The controller, acting in “god mode,” seeing the entire battle field, can overrule decisions dictated by the editor. BL CGF is composed of two parts: the BackEnd and the FrontEnd. The BackEnd is the engine that controls the entities. It is the core of the BL CGF, conducting all necessary computations for the simulation.   The FrontEnd serves as a control unit for the BL CGF. At edit time, it is the UI for the editor, supplying additional capabilities such as terrain analysis and 3D visual aid that help the editor in the process of creating scenarios. At run time, it serves as a command & control unit for the controller, allowing him to view the entire battle field, and communicate with the backend for responses. Multiple FrontEnds can connect to a single Backend so that more than one controller can be used at once.As warfare in open territories is relatively static and can be well defined by known combat doctrines, those capabilities sufficed.3.  CGF And Urban WarfareSimulation of urban warfare is very different from its parallel in open territories. When considering urban warfare, citizens must be simulated; the threats to the armed forces consist of guerilla fighters that do not necessarily follow a combat doctrine rather then an army; the urban terrain (houses, trees, etc.) must be considered; and so on.  For more on simulation of urban warfare, refer to [2]. These differences affect all parts of the simulation, but are noticeable especially in the CGF and simulation of autonomous vehicles, which now deal with a whole new range of threats and possibilities. 4.  Behavioral Problems Confronted By CGF The set of human behaviors and decisions is enormous, even in regular situations. In warfare, the decisions are much more crucial and must be made at a much higher rate. BL CGF should simulate intelligent and natural decision making in various situations. The situations handled vary from a peaceful atmosphere (where urban noise is required) to a large number of possible threats. When simulating behavior in a peaceful atmosphere, many actions can be taken into consideration. For our needs, the emphasis was put on creating urban noise–creating an appearance of a natural, living habitat, where citizens wander from place to place. Within the innocent crowd, trying to disguise themselves as part of it, terrorists may exist. Threats can be either real or events considered by the entity as a threat. It may be an event of gunfire, an approaching tank, or the sound of a combat helicopter flying overhead. Once the threat is recognized, a decision should be made upon the response–running away, staying put, etc.. These decisions may be further divided into sub decisions, such as where to run to, at what velocity, etc. Below we shall describe in further details some of the behavioral problems and solutions.    5.  Possible Standard AI Solutions  Many common AI models exist, and we started our work by examining those models and analyzing their faults and merits in the context of our BL CGF. The main models checked but not used are finite state machines, game trees, and neural networks. For space considerations we omit the details here. The reader is referred to [5] for a description of these models. A model that was found appropriate as a basic block for our solution is fuzzy controller. The reader is referred to [6] for a detailed description of fuzzy controllers. The main limitation of the fuzzy controller model is its locality. For local, stateless (or such that require ‘simple’ states), problems, such as collision avoidance, fuzzy controller is a sufficient solution. However, a generic AI solution, suitable for a CGF, should provide answers to further behavioral problems.      As the common solutions of decision making are not sufficient for the needs of BL CGF, it was decided to create a new model, a sort of combination between state machines and fuzzy controllers, along with other mechanisms. This model was named ‘FuzzyGraph’. 6.  The ‘Fuzzygraph’ ModelThis section refers to a number of basic graph theoretic concepts. The reader not familiarized with those concepts is referred to [7].  6.1  Requirements for the Decision ModelThe decision model must be a generic one, suitable for assimilation of all kinds of decisions. The decision model must be external to the BL CGF and allow usage as a stand-alone library so it can be used by other applications in the BL, such as simulators of semi-autonomous vehicles.As the simulation is conducted using regular PCs rather than powerful workstations, the computational resources are quite limited, and the decision model must not use a great amount of resources, with emphasis put on CPU resources. 6.2  Model Brief DescriptionThe core of the model lies in the observation that every (discrete) decision is either local or composed of sub decisions. This recursive nature calls for a tree-like structure. We represent each decision point as a node in the graph. We suppose that a decision D has n possible outcomes, each of which in turn can lead to other decisions. Then the node representing D will be connected to n nodes. The (not necessarily connected) graph is built manually and is given to the infrastructure as input (through a configuration file). We define the “evaluation” of a node as the process of decision making in the node. When the mechanism is required to evaluate a decision D, it is marked as a root. Once a decision is made, new sub-decision points can rise (e.g. see Figure 1).The meaning of the decision made at a node is twofold. In one sense, it can have a direct impact upon the entity. In the other sense, it creates a new set of possible decisions for the entity–the sub-decisions of the chosen node. After the decision has been made, the new node needs to be evaluated. The process then repeats itself.Nevertheless, not only the next decision should be examined. Decisions made in the past need to be re-examined periodically, to ensure their relevance to the current state of the world. Thus, the entire path in the graph from the root to the last decision node reached is maintained at all times. Periodically, each decision in the path need to be re-examined, and the path rebuilt as appropriate, according to the new decision made. The evaluation process, starting at each node of the path can be initiated in two different manners. It can be either event driven – the application using the model can specifically ask for evaluation of a node, in case it needs to make a specific decision –  or time driven – every Xk seconds, the k node in the path is re-evaluated. Any decision A can be connected to another decision B in the graph, which means that B is a possible sub decision of A. The graph (or rather the induced undirected graph) is not necessarily a tree, since sub-decisions can be shared by different decisions. The infrastructure must, however, require that the graph is acyclic (to prevent mutual dependencies eventually leading to a loop). Actually, we require (and verify, using an algorithm from [7]) the graph to be a directed acyclic graph. SHAPE  \* MERGEFORMAT The evaluation of a single node, i.e. the local decision making, can be implemented in various ways, and the infrastructure does not enforce a single solution, as it does not enforce a specific structure of decisions. Nevertheless, users of the infrastructure are advised to define the graph in a manner such that each node represents a local decision problem, and then use a fuzzy controller to solve it, as demonstrated below.   6.3  Model UsageThe first phase in using the infrastructure is the creation of the graph and the controllers corresponding to each node, which together can be considered as the database of the mechanism. The graph and controllers most certainly are not required to be built completely. A bottom-up development of nodes is recommended and is applied at the BL.  An application (e.g.. BL CGF) can use the infrastructure at two different levels. The first level, reactive decision making, is intended to solve a local problem – for a specific node, not connected to any node in the graph, deliver the parameters required and receive the output. This is the plain usage of the mechanism.The second level, and perhaps the more interesting one, is usage at the graph level. When complex decision making is required, the application should address the node representing this decision. It is now marked as the root of the process. For each node N (reachable from the root in the graph) two callbacks are assigned (marked here Nin and Nout). The callbacks are functions belonging to the using applications, and are called by the infrastructure. Nin is called upon arrival to the node, and has no other parameters. Nout is the method delivering the decision reached at node N, and thus contains the output parameters of the decision. In this manner the user is informed of each decision made by the mechanism – both numerical decisions and discrete decisions6.4  Model DesignThe basic class in the model is, naturally, the class representing a node. It is an almost abstract class (implements only functionalities related to the graph structure, e.g. keeping track of nodes connected to it), where the decision function of the node is implemented by the controller inheriting it, and the input filling function and callback functions are implemented by the application creating a class inheriting each controller class.  The application requests a decision from any node, gives it the appropriate inputs, and acts accordingly.The main algorithm is sketched in Figure 2. The basic idea is to keep track of the path of decisions made, so that on a regular basis all prior decisions are re-examined.6.5  Programming above the modelThe design of a graph for solving a specific problem can be viewed as a programming problem. It is an example for the case of usage in the ‘regular’ way, of fuzzy controllers in each node. Connecting a node to an external solution is done in the manner explained above, and in this case the rule base of the specific node is empty. Syntax details are mostly technical; however, it is worth mentioning that the semantics conforms to object oriented rules, noticeable in two aspects:1.  Code reuse – each node is assigned a name tag which is used as its unique identifier, and thus more than one node can be connected to a single node. In terms of decision making, this feature corresponds to a sub-decision that is shared by several higher level decisions. This ability is naturally assimilated within the model.  2. Inheritance – when using fuzzy controller in a high-level node (nodes that are connected to some node), nodes reachable from a certain node can inherit some of its rules, and extend the rule base with new rules. 6.6  Model Advantages 1. The model is flexible, constituting on the one hand a unified infrastructure for developing solutions for behavioral problems, and on the other hand allowing assimilation of various methods for different problems, interacting through the interface supplied by the infrastructure.2. When using the model in its standard form, where fuzzy controllers are assigned to the nodes, the model of fuzzy controllers can be utilized to its greatest benefit. If the graph is built in the correct way, each node is assigned to a local, reactive and relatively small-scale problem, which can be solved quite easily by a fuzzy controller. As mentioned above, fuzzy controllers do not excel in solving problems of large scale or those requiring planning, and here it is not required to do so.3. The model takes advantage of several common practices in “ordinary” computer programming, as described above, and utilizes it in the area of fuzzy controllers. 4. The model dictates a structured and well-organized decision making process. This feature, by itself, has a big impact on the development process in the area of AI. Instead of viewing each problem by itself, each decision should now be decomposed to small sub-decisions. A connection to other decisions becomes much more intuitive.5. The model calls for a “bottom-up” development, as the nodes solving local problems are developed before solving the higher level problems. This manner of development raises the odds of success in the development process, as each node developed has an added-value by itself, as well as it contributes to the development of the solution for the higher level problem.6.7  Model Applications and Scenarios of UsageThe hierarchy of controllers defined above is currently in use within the CGF, especially in the area of urban related behaviors. Each controller has its own contributions and can be used in scenarios as a single unit or as a composition. To illustrate, we list three of the main usages of the model. For space considerations, implementation details of the blocks are abbreviated.    1. The basic block is situation awareness in the context of predicted collision detection.  Using Line Of Sight (LOS) queries, the controller finds the obstacles that are in proximity of its route. This resembles the ideas of the first layer in the implementation of [8]. 2. The next block in the hierarchy is collision avoidance. This block uses the outputs of the situation awareness block as inputs to its fuzzy controller. This controller is implemented using the FreeFuzzyLogicLibrary (FFLL) [9]. See also the work of [10].Nearly every urban scenario now uses this controller where it requires movement. The scenario editor, who previously had manually to draw exact paths avoiding houses, a task both tedious and error prone, can now simply place an approximate path and the entity will have the ability to navigate itself in a manner that is closest to the path, but that avoids obstacles. 3. Using collision avoidance enabled us to define a crowd. The crowd is a large set of citizens, placed for each scenario within an editor-defined circle. They move using collision avoidance from point to point, changing their target points from time to time randomly. The benefit of the model is well observed here, as the usage of collision avoidance rather than movement on pre-defined paths creates a random, changing, and natural movement of the crowd (note that collision avoidance handles dynamic objects as well and thus the pathways vary greatly). Up to hundreds of citizens were simulated successfully using this method.7.  Future EnhancementsAs the area of AI has only begun to evolve in the BL, many enhancements are possible. Following is a list of some of those possible developments.1. We may extend the model to allow cooperation between entities. As the model gives us a full picture regarding the chain of decisions made by each entity, it can form the basis of cooperation and co-influence between entities. For one, entities that share a decision path are conducting a similar activity and can communicate to achieve better results; for example, if one entity had already been at a certain decision point on the same path as another entity and had chosen a certain sub-node, this could influence the decision made by the entity confronting this decision now. 2. Item (1) relates to cooperation between entities, where each entity acts as an individual, without the role of a command level. A different kind of cooperation can be maintained by a common management of the entities’ graphs. In particular, a high level decision that corresponds to a node n such that long paths start from n can be made once for an entire unit, and is equivalent to it being made at each single entity. Decisions that are more reactive, lower-level ones, can be made by each entity according to its own state.3. Learning methods can be used to learn rules, in similar manner to that done in SOAR [11].      4. We may continue development of controllers for other problems, specifically those involving higher levels of aggression (controllers for combatant units). SHAPE  \* MERGEFORMAT  8.  ConclusionsThe area of intelligent decision making can be addressed in many manners, and for each problem a different solution can be most appropriate. The model suggested in this paper combines models relating to several areas of computer science, including fuzzy controllers, graph theory and implicit state machines (as each node serves also as a state of the entity). It defines a framework for developing solutions in a manner that takes advantages from different approaches while maintaining flexibility, and can serve a basis for modeling group behavior including cooperation and co-influences.9.  References[1]	Pratt D.R. .2002. “Weaving an entity-based CGF”, Proceedings of the Eleventh Conference on Computer-Generated Forces and Behavior Representation, Orlando, FL: UCF Institute for Simulation & Training, 340-348.[2]	Ceranowicz A. & Torpey M. 2004. “Adapting to Urban Warfare”, Proceedings of the 2004 Interservice/Industry Training, Simulation and Education Conference (I/ITSEC) (Orlando, FL, Dec.6-9), 487-497.[3]	Ulicny B. & Thalmann D. 2002. “Towards Interactive Real-Time Crowd Behavior Simulation”, Computer Graphics Forum 21, Issue 4 (Nov.), 767 - 773.[4]	Stytz M. R. & Banks S.B. 2003. ”Progress and prospects for the development of computer-generated actors for military simulation”, Presence: Teleoperators and Virtual Environment 12, Issue 4  (Aug.), 422-436.[5]	Rabin S. 2004. “AI Game Programming Wisdom 2”, Charles River Media, Inc., Hingham, Mass.[6]	Jantzen J.1998.” Design of Fuzzy Controllers”, Technical Report 98-E 864(design), Technical University of Denmark, Department of Automation, Lyngby, Denmark. [7]	Cormen T.H., Leiserson C.E. ,Rivest R.L & Stein C.1990. “Introduction to Algorithms” (Second Edition), MIT Press and McGraw-Hill, Cambridge, Mass.[8]	Doitsidis L., Valavanis K.P & Tsourveloudis N. 2001. “Fuzzy Logic Based Autonomous Skid Steering Vehicle Navigation”, IEEE Transactions on Robotics and Automation 17, No. 4, 490-497.[9]	Zarozinski M. 2002. “An Open-Source Fuzzy Logic Library”, “AI Game Programming Wisdom”, ed. Steve Rabin(2002), Charles River Media, Inc., Hingham, Mass., 90 – 101.[10]	Fayad C. & Webb P. 2000. “Fuzzy Logic Based Collision Avoidance Algorithm for a Mobile Robot”, Advances in Soft Computing: Soft Computing Techniques and Applications, Physica – Verlag, 252-260.[11]	Laird J.E., Newell A., Rosenbloom P.S. & Tuck C.M. 1987. “SOAR: an architecture for general intelligence“, Artificial Intelligence 33, Issue 1 (Sep.), 1-61.Author BiographiesDANIEL DEUTCH has been a developer in the Computer Generated Forces development team in the C.O.R (Center of Operational Research)at GFC (Ground Forces Command) of the IDF (Israeli Defense Forces) for the last 4 years, conducting software engineering in the area of modeling and simulations, system analysis, and testing.  During his military service, he dealt with developing BL infrastructures and methodologies for testing new military combat systems and new concepts.He holds a degree (cum laude) in computer science from Tel Aviv University and is currently a graduate student, studying computer science there, as part of a special “exceptional student” program, encouraging young talents to continue their academic research parallel to their military service. He intends to continue his research in the area of artificial intelligence for thesis and doctoral work.LIOR GDALIAHU is a project manager and team leader of the Computer Generated Forces of the ground research lab at the Israeli Defense Forces. He holds a degree in computer science and math.  He has over than 7 years of experience in management, research and development in the simulation world.AMIT SIRKIS has over twelve years of experience in developing military combat systems, with emphasis onmodeling and simulation (M&S) technologies, system engineering, system analysis, and testing. He was one of the Israel Defense Force (IDF) Ground Force Command (GFC) Battle Lab (BL) founders and deals with developing BL infrastructures and methodologies for testing new military combat systems and new concepts. Amit has grown up from being a junior engineer who writes software for M&S,to become the BL R&D manager in the past four years. These days, together with his colleagues he draws the futurevision for the BL.Figure 1 - An example of a layered decision graphDecision7Decision6Decision5Decision4Decision3Decision2Decision 1For any node in pSavedPath starting from X do{   InputStructure in;   GetAppImplementation(pNode->GetType())->FillInputStructure(in); //goes to the application that inherits the controller.   OutputStructure out;  Double decision = pNode->decide(in,out); //goes to the controller  node* pNextNode =   pNode->FindClosestNode(decision);  if (pNextNode is not in pSavedPath) {     GetAppImplementation(pNode->GetType())     ->ReportDecision(out);//goes to the application, a new decision have been taken// A decision was made that deviates from the path saved,so change it pSavedPath ->RemoveSubPath(pNode); pSavedPath->AddChildInPath(pNode,pNextNode);}else{//nothing new… }Figure 2- Main Algorithm