Using A Custom Rule Model to create Customizable SystemsSal JamesInnotiv Incorporated8799 Balboa AvenueSan Diego, CA 92123619-268-1102 x209james@innotiv.comSabrina S. KwanInnotiv Incorporated8799 Balboa AvenueSan Diego, CA 92123619-268-1102 x208kwan@innotiv.comJames AuginsInnotiv Incorporated8799 Balboa AvenueSan Diego, CA 92123619-268-1102 x203augins@innotiv.comGary GaringoInnotiv Incorporated8799 Balboa AvenueSan Diego, CA 92123619-268-1102 x206garingo@innotiv.comKeywords:Interoperability, Business Rules, Template, MSRR, RepositoryABSTRACT: In support of defining interoperability standards for DoD Modeling and Simulation repositories, a Custom Rule Model is in development that is isolated and customizable. It is an effective practice to separate the business rules from the front-end presentation tier and the back-end data tier.  The Custom Rule Model will be presented as an object abstraction that can be applied to business rule representation.  The Custom Rule Model enables the creation and maintenance of repository site-specific rules from rule templates. System managers can use the templates to specify rules for tailoring content display, resource protection, and the business review cycle. The rules are built to function within interfaces and objects defined by the repository component/object model.  The rule model will define a set of interfaces in a platform independent manner that can be referenced and/or developed by different organizations, on different computing platforms, and in different computer languages.BackgroundThe Modeling and Simulation Resource Repository is a Department of  Defense information system which supports discovery, registration,  cataloging, and access of various types of resource objects pertinent to the Modeling and Simulation community.  The MSRR is sponsored and operated by the Defense Modeling and Simulations Office (DMSO).  Other MSRR  systems have been created for the services such as the Army, Navy, Air Force, and BMDO.  The MSRR "system of systems" calls for a federation of resources hosted on a distributed system of resource servers.  These servers are interconnected through the World Wide Web (WWW). The MSRR provides a layer of services such as the registration of resources and users, description of resources, and specialized search capabilities. Business rules are a set of practices and policies that define how an organization does business. A resource repository, likewise, has policies on how to formulate a search request to other repositories, order the results, and format the consolidated results for the user. As repositories and their practices change, so will the code that implements the practices. It is hypothesized that the separation of business rules from the presentation layer, or graphical user interface (GUI), and from the back-end or data layer of a system results in a more robust and flexible system.  Business rules can be implemented implicitly as part of the coding of the system application objects or explicitly as separate business rule objects.  The business rule objects may be generated from a collection of rule templates that can be manipulated by a separate, clearly identified process framework.  The latter explicit approach enables the creation and maintenance of site specific rules from templates without changing the application object. Such an implementation would thereby reduce maintenance and life cycle support costs.  An experiment will be undertaken to separate a resource repository system's business rules from its application objects.The Custom Rule ModelThe System Architecture diagram in Figure 2.1 illustrates the desired partitioning.  In the middle Business/Application layer of this diagram, the business rules are implemented as explicit objects that are separate from the User, Resource, and Repository application objects. Note that these three application objects are only an example subset of the repository application objects.  This explicit approach enables the creation and maintenance of site-specific rule templates that do not require the application objects to change.  System managers can use the templates to specify rules for tailoring content display, for sorting, and for resource protection.  Figure 2.1A natural application for the rules template approach, for example, would be to specify a set of repository-specific business rules for each new repository system added to a distributed repository search system.  The rules would control the querying of the new repository and the merging of search results with the results from the other repositories and do so without the need to modify the application object code.The Presentation or topmost layer in the System Architecture diagram in Figure 2.1 illustrates the front-end browser or application window that presents the search request options to the user and forwards the request to the middle Business/Application layer.The bottommost layer in the System Architecture diagram below illustrates the backend or Data layer of the system, which constitutes the permanent storage for the application and rule  objects.An application object is a collection of attributes and methods that implement an entity within an application domain.  Examples of MSRR application domains are registration, discovery, and security.  In the above diagram, examples of application objects are User, Resource, and Repository objects.A rule object is a specialized type of object that enforces or implements a business practice in an interaction with an application object.  Characteristics of a rule object: It is executable, since it operates on application objects.It manifests the fundamental intent of a business rule, i.e., a rule object contains at least one procedure, the end result of which accomplishes what a business rule expresses. It can transition and/or change the state of an application object.  For example, a search result set object contains a list of resource objects to be displayed.  One rule object may modify the order or contents of the list, while another rule object might tailor the attributes of the resource objects in the list.Application objects and rule objects interact to provide the flexibility and tailoring needed to meet the varying requirements of an application domain.A rule template contains a set of conditions, which when satisfied, proscribe an action to be performed.  An example of a rule template fragment with two conditions and an action that operates on objects A and B is:if list A exists and resource B is not in list A	then add resource B to list AA rule template is generally written in a common but well-specified procedural language.  It is best presented to managers or to any rule-specifiers in a graphical user interface, so that the business decision-makers who stipulate the rules can do so easily in a manner that enhances communication.  Implementation components of a rule object framework:A process for compiling a rule template into an executable rule object.  A set of interfaces that enable the application objects to interact with the rules objects.A notification / event handling mechanism that activates a rule object to check whether the conditions of the rule object are true.A business rule processor that manages the execution of the framework. The current MSRR repository search system is already coded in Java for portability.  For this paper, we searched for an application/rule environment that would offer a rule template compiler, an object-oriented rule and application object interface, an event-handling framework, and a friendly rule-specification capability in a Java application environment.  Two such application/ rule environments were identified which could be used to implement the search business rules: ILOG's JRules [1] and the Java Expert Shell System (JESS) [2].  JESS has everything except the user-friendly rule-specification capability and is based on an established expert rules engine, CLIPS.  ILOG's JRules can pre-compile rule templates to enhance execution performance and can also interpret rule templates just added at run-time, which is flexible and speeds up the development cycle. The JRules implementation of the RETE Algorithm enables speeds of thousands of rules per second.  Both JESS and JRules are commercial off-the-shelf packages.  JESS  is also available at no cost to U.S. federal government agencies, universities, nonprofit agencies, and U.S. national laboratories for their own internal research and development. 3.  Planned Experiment The Modeling and Simulation Resource Repository is a DoD information system which supports discovery, registration, cataloging, and protection of various types of resource objects pertinent to the Modeling and Simulation community.  The MSRR is sponsored and operated by the Defense Modeling and Simulations Office and participant organizations.  The experiment discussed in this paper will be conducted between a DMSO MSRR Interoperability Service Node and one or more participant or Peer Nodes. This interoperable node will be developed through modification of the current DMSO MSRR operational system.Implementation ViewFor an interoperability experiment, Figure 3.1 presents our planned implementation.  In this implementation, the Distributed Search GUI in the Interoperability Service Node gathers the search request from the user, and forwards the search request to the Distributed Search Object. Based on the repositories selected by the user in his request, the Distributed Search Object consults the Rule Templates to re-formulate and to send the search request to each of the user-selected repositories, one of which is shown in the diagram as a Peer Node.  The Peer Node according to its own Rules Templates, receives and parses the search query, performs the search, and returns the results in a rule-defined format to the Interoperability Service Node, which in turn consolidates, formats, and presents the results to the user. Figure 3.1Object SpecificationIn order to define the Business/Application layer further and to set the stage for the experiment, we will specify the primary application and business objects for a repository search system that returns resource data from several heterogeneous systems in response to a user's search request. The middle tier or Business/Application layer consists of application objectsrule objects compiled from rule templatesnotifications to the rule objects through their interfaces when the application objects satisfy the conditions  of the rule objectsExample MSRR application objects and their attributes are these:Application Object	AttributesResource		titleURLprotection flagResourceOwner info (User)date last modifiedUser			first namelast nameusernamepasswordorganization nameemail addresstelephoneResource Repository	nameURL to direct search request tosite-specific search parametersSearch Results List	linked list of Resource objectsThese Application Objects can be implemented as Java classes that are instantiated within the system as a user's search request is processed. The Attributes are Java fields for each Application Object class. An Application Object notifies the framework when the object is created, modified, or deleted. The framework in turn triggers any Rule Object that has registered an interest in that Application Object's creation, modification, or deletion. Thus a Rule Object monitors the set of conditions that will ultimately lead to an action.Since the code for these classes previously contained the search rule logic implicitly, this experiment aims to separate the rule logic from the application objects and move it to this preliminary set of rule objects:Rule Object		Attributes and MethodsTranslate Query		site to query			query text			Translate Method 1			Translate Method 2, etc.Query Repository		site-specific attributes			Query MethodFilter Result		filter type			Filter Method ,1 etc.Pack Result		site-specific attribute			Node-specific Pack Method Parse/Unpack Result	node-specific attribute			Node-specific Parse MethodSort Result		result field to sort on			Sort Method 1, etc.Display Results		result field to displayDisplay Method mapping from field to cascading style sheet Besides this rule model, a support tool for repository managers is required. It will need a user-friendly screen to enable the search rules to be specified as a rules template.  The rules template will supply the conditions that when satisfied will lead to an action. For example, the Consolidate Result rule template is interested in objects A and B; it checks for two conditions on A and B to be satisfied, and then performs an action when they are:if list A exists and resource B is not in list A	then add resource B to list A The experiment will initially use the ILOG JRules Rules Builder to present a friendly user interface for business rule specification.  A detailed description follows for the six types of rules that will be extracted from our search rule logic.Translate Query rules map the user's search request to the syntax of the repository selected to be searched.  One peer node may require a date range to be specified, so that before the interoperability node submits the search request to the peer node, the date is mapped from the user-supplied MM/DD/YY format to YYYY-MM-DD.  If the user is interested in all dates, the interoperability node supplies default dates (1970-01-01 to the present) to the peer node as a means of translating the user request.  Query Repository rules might be implemented at the peer node, where the (translated) query is converted to a specific peer node's SQL syntax.  The Query Result rule template in Figure 3.2 could request resource owner information to be returned for all protected resources that answer a user query. Query Result Rule Template Example.Figure 3.2The ResourceOwner information is helpful as Point-Of-Contact information if a User is not authorized to view the protected resource.The Filter Results rules are foreseen in a less-than-ideal situation where the peer node has returned a result set to the interoperability node that contains duplicate resources or resources that are not meant to be displayed.  The Filter Result rule template in Figure 3.3 examines each resource's protection attribute in a given repository and removes the protected resources from the ResultsList.  A repository may specify many Filter Result rule templates.Filter Result Rule Template ExampleFigure 3.3The Pack Results rules at the peer node and the Parse/Unpack Results rules at the interoperability node work hand in hand. These rules may specify a field name mapping from one repository to another. For example, a rule might map the peer node's data field from 'POC' to the interoperability node's data field called 'Resource Owner.'  These rules may also specify a control character that designates the beginning and end of a resource, or the beginning and end of a result set.  In short, any rule that determines the way the result set is written at the peer node and read at the interoperability node belongs in this rule set.The Sort Results rules invoke sort-specific algorithms based on the field to be sorted.  A sort can be specified by ascending or descending order.The Display Results rules map each field in a resource to its presentation mechanism.  Cascading style sheets or XSL can be used for this experiment. These rules are useful for guaranteeing a uniform display for result sets both on the same repository and across multiple repositories [3].Our experiment plans to implement examples of each type of rule set.Beyond the ExperimentFurther search rule templates to be considered are:to convert a generic search query having AND, OR, and NOT operators in the text to a specific site's search query structure.to include percentages of certainty based on weighted query terms, or on the presence or absence of  terms.In summary, this experiment plans to employ a rule model approach to isolate the business rule logic from the MSRR application logic.  It is expected that an easy-to-specify rule template user interface will enhance the communication of common repository functions, reduce the maintenance, and improve interoperability of the repositories.References[1]	E. Friedman-Hill: "Java Expert Shell System (JESS)"; Sandia National Laboratories; Livermore, CA.; http://herzberg1.ca.sandia.gov/jess/ [2]	"ILOG JRules 2.0; Intelligent Agents for Java Application Control; ILOG Inc., Paris, France;  HYPERLINK http://www.ilog.com/products/jrules/index.cfm http://www.ilog.com/products/jrules/index.cfm[3]	G. Garingo and J. Augins; XML to Facilitate Interoperability between Repositories; Simulation Interoperability Workshop, Spring 1999; http://www.sisostds.org/Author BiographySAL JAMES is a Senior Software Engineer at Innotiv Incorporated, San Diego, CA. At Innotiv, for the current MSRR project, she specified, designed, and implemented the administrators' portion of the repository using Java servlets to query the database at the server, and to dynamically  generate the results as Web pages. Ms. James obtained her B. A. in Math at Bowling Green State University, and her M. S. in Computer and Information Science at Ohio State University. She is a Microsoft Certified Professional in NT 4.0 and has taught several programming language courses and seminars in the high school, university, and corporate settings.  SABRINA KWAN is a Senior Software Engineer at Innotiv Incorporated, San Diego, CA.  At Innotiv, she integrates Internet software to facilitate information registration, access control and resource delivery.  She is a certified system administrator and designer for MSSQL 6.5.  She obtained her B. S. at Brock University in Ontario, Canada, and her M. S. at University of Western Ontario in Canada.  She has written a graduate thesis on “Logic as an implementation language for legal expert systems”, and has implemented expert-system prototypes in PROLOG.JAMES AUGINS is a Senior Engineer and President at Innotiv Incorporated, San Diego, CA.  He has been active in DMSO Repository and Data Engineering projects and working groups.  He obtained his B. S. and M. S. in Electrical Engineering at Syracuse University.GARY GARINGO is a Senior Software Engineer at Innotiv Incorporated, San Diego, CA.  At Innotiv, he integrates Internet software to facilitate information access and retrieval.  Gary is a System Engineer for the MSRR Technical Support Team.  He obtained his B. S. in Electrical Engineer at California State Polytechnic University, Pomona and his M. S. in Software Engineering at the Naval Postgraduate School. EMBED PowerPoint.Slide.8   EMBED PowerPoint.Slide.8  