A FOM Flexible Federate Framework Regis DumondSoftware Engineering InstituteCarnegie Mellon UniversityPittsburgh, PA 15213-3890412-268-6310rdumond@sei.cmu.eduLaMI-UMR CNRS 8042Evry UniversityBD. Francois Mitterrand91025 Evry Cedexdumond@lami.univ-evry.frKeywords:HLA, RTI, Framework, Design Patterns, Java, XML, FOMABSTRACT: The concept of framework as reusable software component has become a state-of-practice technique in software developing companies. A number of frameworks based on HLA are available commercially and more are developed for internal use in companies. Using a framework reduces development time and allows the developers to focus on the unique aspects of the simulation. However, the development of reusable component in order to support the dynamic re-configurability appears as a challenge. Indeed, existing frameworks use a static object model representation which requires full knowledge of object model components at the time a federate is built (“at compile-time"). This paper describes an approach to design a domain framework which encapsulates expertise in development of HLA federate by hiding RTI internals from the developer. This approach is based on the use of Java virtual machine and a DIF or XML parser to map dynamically object representations of FOM elementsIntroductionThe Object Model defined by HLA OMT specifications [1] is a foundation to promote interoperability between simulations.The chief advantage to implementing an HLA framework lies in software reusability and productivity. It implies that the framework design must be independent of any particular object model [2]A federate software Framework may provide two fundamental methods for representing object model:Static object model representation, which requires full knowledge of object components at the time a federate is built (“compile-time”),Dynamic object model representation, which is determined at run-time.This paper describes a new Object-Oriented Framework currently in progress to support re-configurability of SOM/FOM at run-time.Our approach is based on dynamic representation by using the concept of meta-representation. This concept offers more flexibility to reconfigure dynamically a federate.We also used a set of design patterns to encapsulate and hide RTI mechanisms for reducing development time to adapt simulation applications to the HLA.Object-Oriented Framework2.1 DefinitionAn Object-Oriented Framework is a reusable software architecture made of both, design and code. It represents a partial design and implementation for an application in a given problem domain. The most frequently used definition is by Johnson and Foote [3]:A framework is a set of classes that embodies an abstract design for solutions to a family of related problems.An object-oriented framework is characterized by a set of classes and control flows and provides a precise structure for the definition of new applications.Whitebox  vs.  Blackbox FrameworkFrameworks that can be extended by inheritance only, are called whitebox frameworks. Frame-works that can be extended by enhancing existing components are called blackbox frameworks.Blackbox frameworks are easier to use. The internal mechanism is hidden from the developer. Our framework is a blackbox framework; users customize the behavior by configuring components. Inversion of controlContrary to the traditional class library where the application code invokes routines in the library, the framework works differently. It has the thread of control and calls the application code when appropriate. Our Framework calls objects in the federate when they are needed.Metamodel and FrameworkA metamodel is a model that describes the structure of something like an application, a process, or a group of related objects. An object metamodel might define object types, their attributes, the types of those attributes, and the relationships allowed between the objects. These descriptions are stored in concise formats, which can be processed by a framework that knows how to interpret the information. With this information, the framework is able to make decisions without adding or modifying code.  Using a metamodel, our framework can load the data from a SOM/FOM file and reconstruct the objects in memory, without recompile the code.Meta-RepresentationOne way to develop a framework that supports multiple FOMs without requiring modification on the code is to use the concept of Metaclass [Figure 1]. If a class may describe objects, we can distribute classes and instances onto two hierarchical levels; instances belong to the lower level and the models or classes on a superior level. To design the class notion, it is necessary to have a supplementary level containing the models required to describe the classes. The notion of Metaclass consists in applying this modeling to the classes themselves. It is realized by describing in a particular class (meta) the attributes and the methods that characterize a class.EMBED UnknownFigure  SEQ Figure \* ARABIC 1: 3 System levels RepresentationAlthough the HLA is not strictly object-oriented, it provides a two level system that defines object classes and instances with distinct identity. We introduced the third level by using the descriptions of object and interaction class structure defined in the Object Model Format (OMT). With this definition, we created a metaclass representation of elements which compose the FOM/SOM; the following UML Class diagram [4] shows this representation [Figure 2]. EMBED Visio.Drawing.6  Figure  SEQ Figure \* ARABIC 2: Metaclass RepresentationMetaclass are entities located at a meta-level with regard to instance and classes [5].  Classes are instances of metaclass. To induce metaclass, the problem is similar to simple generalization but more complex. Classes have properties that may be of a complex type, and so therefore, difficult to generalize. However in HLA, the number of possible types for such properties is finite. OMT defines classes of objects; each one has a name and a set of named data called attributes. Objects classes form a single inheritance tree. These properties are used to build the metamodel. An object class model provides a set of useful information about the federate, like subscribable or publishable, which can be inserted into a metaclass.Attribute and parameter models are also converted to their appropriate meta-attribute. An Attribute metadata is composed of a name, a set of properties (e.g. ownership, transport and delivery order, update/reflect permission, etc.) and a datatype. A datatype is a metadata to represent the notion of value type, common to both OMT attributes and parameter.Figure 3 shows how the data types are represented within the framework. EMBED Visio.Drawing.6  Figure  SEQ Figure \* ARABIC 3: Metadata RepresentationWe use some Java mechanisms and design patterns to fix value types at runtime:The base types are built with classes provided in java to represent primitive type (e.g. Integer, Byte, Double, Float, Long and Short) and String. Java is particularly useful in this case, for creating a base type at runtime and fixed its value.Enumerated types use a hash table structure to associate name to value.Complex types are represented by the pattern composite [6] which composes objects (DataTypes) into tree structures to represent part-whole hierarchies.This metamodel is the foundation of our framework. We use it to translate the FOM/SOM details into a framework object model repository at run-time and make its content available through intuitive interfaces.A parser was written to process the Data Interchange Format (DIF) to map FOM/SOM information into node structures used to build the object model repository. However, the new format OMT IEEE 1516.1 [1] defines the FOM/SOM with the extensible Markup Language (XML), so we made a new parser to interpret it with a SAXParser interface provided by XML4J [7]. Currently, we are converting the new format XML to be compliant with our architecture. Framework Architecture OverviewThe framework is a set of java classes that have been designed to provide a layer between the federate application and a Java RTI (pRTITM) [8].The Exploration Edition of pRTI is a multi-threaded RTI and it does not require the federate to call a tick() function periodically.Figure 4 present an overview of the framework. EMBED Visio.Drawing.6  Figure  SEQ Figure \* ARABIC 4: Framework Architecture OverviewThe framework is composed of different modules:FW-HLA manages module activities and provides an interface to configure and use the framework with a federate,ObjectModel Factory uses a SOM/FOM file to build a meta-representation of a HLA Object Model,RTI Manager is the communication layer between the RTI and the Framework,Declaration Manager publishes and/or subscribes object attributes and interactions,Object Manager manages local and remote proxies, registers object and updates attributes values,Interaction Manager sends interactions,Time Manager coordinates event activities within the framework,Process Event Manager manages all events, scheduled or not, within the framework.The following sections describe the mechanisms used inside each module.4.1 FW-HLAFW-HLA is the entry point of the framework for the federate developers. It loads a configuration file containing run-time federate parameters (e.g. SOM/FOM file location, Federation name, Federate name, Time Management parameters, etc.) to initialize the federate.It also provides a set of methods to:Create/Join and resign a federation,Publish/Subscribe object attributes and interaction (i.e. Declaration Manager),Register listeners on RTI callbacks (e.g. ReceiveInteraction, RemoveObject, etc.) to be notified each time an event occurs.Send interaction, create/delete object proxy instance, update attributes (scheduled or not).Query Remote/Local object proxy.Modify Time Management parameters (e.g. time constrained/regulated, lookahead, time step, etc.)4.2 ObjectModel FactoryThe ObjectModel Factory uses the parser to read a FOM/SOM file. A metaclass is created for each object and interaction class definition. These metaclasses are maintained in a tree to provide quick lookup. The root of this Object tree is the “ObjectRoot” node from the OMT file and in the same way; “InteractionRoot” node is the root to the interaction tree. The ObjectModel Factory can create a specific kind of metaclass based on either a string name or an integer id for the class type as shown in Figure 5. When the Object Manager or Interaction Manager want to create a proxy object, the ObjectModel Factory finds the metaclass under the specified name in the corresponding tree, copies it and passes the copy back to the requester.EMBED UnknownFigure  SEQ Figure \* ARABIC 5: ObjectModel Factory4.3 RTI ManagerThe RTI Manager is a layer above the RTI that it implements the FederateAmbassador interface and provides an Event mechanism to notify many objects or components of invocations on RTI-initiated services.The Event Generator Java idiom enables interested objects (listeners) to be notified of a state or events experienced by an “event generator” [9].RTI Manager implements this idiom to invert dependencies between the FederateAmbassador and the components included in the framework. Figure 6 depicts the structure of an example based on the reception of DiscoverObject RTI callback. EMBED Visio.Drawing.6  Figure  SEQ Figure \* ARABIC 6: Event Generator ExampleWhen the callback DiscoverObject occurs, the RTI Manager creates a DiscoverObjectEvent containing information needed, and propagates it to each registered listeners [Figure 7]. EMBED Visio.Drawing.6  Figure  SEQ Figure \* ARABIC 7: UML Sequence Diagram of Event Generator ExampleFor each category of callbacks being in the FederateAmbassador, the framework provides an Event/Listener pair.This functionality introduces a variability point to the framework to add future features or extensions.In this way, a component may be added to the framework by subscribing and implementing the interface listener, which corresponds to a special event provided by the RTI Manager. RTI Manager also encapsulates the RTI ambassador services to be compatible with types defined into the framework and performs new services to resolve thread concurrency problems.The RTI implementation used in the framework is multi-threaded, the RTI-initiated services occur in a separate thread of control from any held by the framework. Dr. Frederick Kuhl [10] recommends use of Barrier to coordinate activities of the main thread with other threads. The Barrier is an advanced thread patterns presented by Doug Lea in Concurrent Programming in Java [10] to put the main thread to sleep until a signal is given. We use it wherever the main thread invokes an RTI service and must wait until a corresponding RTI callback occurs. An example of utilization of the Barrier in the Framework comes up when the main thread enables the time constraint by invoking ENABLE TIME CONSTRAINED. The main thread doesn’t do anything until the RTI invokes the callback TimeConstrainedEnabled.Instead of waiting in a loop for a variable state changeover and waste computation, RTI Manager uses a Barrier to put the main thread to sleep until the callback thread notifies the barrier’s state to awake it.4.4 Declaration ManagerThe Declaration Manager is responsible for publishing or/and subscribing attribute classes and interactions. The process of declaration to RTI is made automatically by using information contained in the Metaclass trees. The users can subscribe or publish interaction or object classes by using three different modes:All publication/subscription. Declaration Manager subscribes or publishes all classes defined in the SOM/FOM. This mode is particularly useful when the framework is used to develop a logger.Examining the Publish/Subscribe capabilities of Attribute/Interaction contained into the MetaClass Trees.Publish or subscribe a class by specifying its String name.4.5 Object ManagerObject Manager provides support to maintain a list of local and remote proxies.An Object Proxy is a mechanism commonly used in distributed object technology. It represents an object present in a federation and mirrors its public attributes. When an HLA object instance is discovered in a federation or registered by the framework, the Object Manager creates a proxy by cloning the Metaclass associated with the instance type, and inserts it into a list.Once the proxy is created, the Object Manager updates the attributes of local objects or reflects the attributes of remote objects automatically. The Framework allows a developer to update an object attribute by invoking a method with the name and the new value as arguments. The framework fixes the value into the local object proxy and then sends the attribute updates to the RTI when the developer invokes the Update() method.In the same way, when the RTI reflects attribute values, the framework retrieves the object proxy associated in the list and automatically stores the new values. So the developer is able to query locally remote object proxies for obtaining their current attribute values.  4.6 Interaction ManagerThe Framework uses the Interaction Manager to send interaction to the RTI. Like the Object Manager, the process required to prepare the request to the RTI is made automatically and hidden to the user. To send an interaction to the federation, the federate developer has to use an instance of a specific interaction metaclass, fix the parameter values, and pass the instance on to the Framework.The Interaction Manager implements an event mechanism (i.e. RTI Manager) to notify all registered listeners when an interaction occurs. It also maintains a queue of all interactions received, which may be consulted by the federate. 4.7 Time ManagerTime Manager utilizes the RTI Management services to synchronize time advancement of the framework among the federates in a federation. A federate asks to advance its time, and awaits a callback from the RTI to grant the advance.The Time Manager supports currently two types of time management simulation:Time Stepped Simulation that uses the Time Advance Request service to advance time, andEvent-Driven Simulation that requests an advance of its clock by invoking the Next Event Request service.The Time Manager uses an advanced thread mechanism (i.e. RTI manager) to await the reception of Time Advance Grant callback from the RTI.For example, when the framework uses an Event-Driven Simulation, it seeks to advance its time to the time of the smallest event contained into priority queue of Process Event Manager. When it is granted at that time, the RTI Manager checks if the logical time is greater or smaller than the requested time. If it is greater, the RTI Manager sends a signal to the Process Manager to process the corresponding callback events. If the logical time is smaller than the Next Event Request time, the Time Manager waits until the requested time expires to avoid a callback event with an earlier logical time.In the same way, a Time-stepped simulation uses Time Advance Request to move its logical time forward in equal steps. The size of the step is a parameter of the configuration file, but it may be modified at run-time by a method provided by FW-HLA.4.8 Process Event ManagerProcess Event Manager is responsible for invoking all actions or modification inside the Framework. In general, each RTI services are implemented by a corresponding event callback [Figure 8]. EMBED Visio.Drawing.6  Figure  SEQ Figure \* ARABIC 8: Process Event CallbacksAn event callback is composed of a LogicalTime attribute, representing an execution time, and a procedure containing a set associated behaviors.An execution time specifies when the Process Event Manager has to invoke the procedure code. For example, an UpdateAttributes event can be scheduled to execute at a time specified by the federate.The Process Event Manager implements a set of listener interfaces associated to RTI-initiated services (See RTI Manager). In response to callback RTI events or a message from the federate (e.g. CreateObject, UpdateAttributes, etc.), the Process Event Manager creates an event callback based on the message and places it in a priority queue of scheduled event callbacks, ordered in increasing time order. When the Process Event Manager receives a signal (supplying a time t) from the Time Manager, it processes the event callback in correct time order. The sequence diagram below shows an example [Figure 9]. EMBED Visio.Drawing.6  Figure  SEQ Figure \* ARABIC 9: Process Event ExampleAn event callback performs a set of actions that calls functions within components from the framework. A ReflectAttributesEventCallback uses methods into the Object Manager for updating a remote object proxy, but the developers are free to create or extend an event callback by providing a new behavior.Like the RTI Manager, the Process Event Manager is vulnerable to access from several threads. It uses a monitor thread mechanism [11] to coordinate its queue activities between callback instances placed on the queue in response to the callback thread from RTI and dequeued actions in response to the Time Manager Thread. Future EnhancementsThe HLA Framework is currently a work in progress. Several enhancements are planned:Architecture compliant with IEEE 1516.2 interface Specification [12].Incorporate Retracting Event features in the Time Manager.Supporting the Data Distribution Management (DDM).Adding Management Object Model functionalities to obtain information about the federation and each federates.Conclusion The Framework provides a flexible architecture to participate in a federation using different SOM/FOM without important code changes. However, the users should make a compromise between flexibility and performance to use this architecture. The dynamic representation may decrease performances when a federate manages a lot of objects. Message traffic on the Event mechanism may generate a bottleneck. The federate developer should evaluate the federate requirements to verify if it can insert the framework architecture into the federate application.References.[1]	Proposed IEEE Standard P1516.1 “Standard for Modeling and Simulation High Level Architecture - Object Model Template Specification,” draft 5, 2000.[2]	Kevin Cox: “A Framework-based Approach to HLA Federate Development”, Fall Simulation Interoperability Workshop 1998, Orlando. [3]	R. Johnson et B. Foot, « Designing Reusable Classes », Journal of Object-Oriented Programming, 1 (2), 22-5.[4]	G. Booch, J. Rumbaugh, and I. Jacobson, The Unified Modeling Language User Guide. Reading, MA: Addison-Wesley, 1999.[5]	Masini G., Napoli A., Colnet D., Leonard D. and Tombre K. Les langages a objets. InterEdition, 1989, ISBN 2-7296-0275-5.[6]	Erich Gamma et al: “Design Patterns, Elements of Reusable Object-Oriented Software”, Addison-Wesley, 1995.[7] 	IBM Corp.:“XMLParser for Java”http://alphaworks.ibm.com/tech/xml4j/[8]	Pitch: “portable Runtime Infrastructure (pRTI)”  HYPERLINK http://www.pitch.se/prti/ http://www.pitch.se/prti/.[9] 	Venners B. “Event Generator Idiom”  HYPERLINK "http://www.artima.com" http://www.artima.com[10]	Kuhl F., Weatherly R.,and Dahmann J. Creating Computer Simulation Systems : An introduction to the High Level Architecture. Prentice Hall, 1999, ISBN 0-13-022511-8.[11]	Lea, Douglas. Concurrent Programming in Java: Design Principles and Patterns, Addison-Wesley 1996.[12]	Proposed IEEE Standard P1516.2 “Standard for Modeling and Simulation High Level Architecture - Federate Interface Specification,” draft 5, 2000.[13]	Dumond R., Lalanda P.: “The Publish/Subscribe pattern”, Fall Simulation Interoperability Workshop 1998, Orlando.Author BiographyREGIS DUMOND is a Ph.D student in Computer Sciences at the Laboratoire de Methodes Informatiques (LaMI) of Evry University and software engineer at Thomson-CSF Training & Simulation (TT&S). Regis Dumond is also a resident affiliate at the Software Engineering Institute (SEI), in the Product-Line team.His primary research interests include object-oriented frameworks, simulation systems, and patterns for design.