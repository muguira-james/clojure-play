Consuming SEDRIS Transmittals – A Pragmatic ApproachJesse CamposScience Applications International Corporation (SAIC)12479 Research Parkway, Suite 600, Orlando, Florida 32826Ph: 407-207-2700, Fax: 407-277-5395 HYPERLINK "mailto:jesse.campos@saic.com" jesse.campos@saic.comJon WatkinsScience Applications International Corporation (SAIC)12479 Research Parkway, Suite 600, Orlando, Florida 32826Ph: 407-207-2700, Fax: 407-277-5395 HYPERLINK "mailto:jon.e.watkins@saic.com" jon.e.watkins@saic.comKeywords:Synthetic Natural Environment, Database Generation, SEDRISABSTRACT: SEDRIS core development to date has focused primarily on a data representation model for SNE capable of representing a wide range of input data and domains, development of a strong read/write API, and establishment of a SEDRIS community (the SEDRIS associates) to coordinate development. With these areas successfully addressed through SEDRIS 3.0, core development can address new challenges, including better support for data consumers.Consumers have the challenge of mapping data from SEDRIS' wide-ranging and comprehensive data model into their system specific representations.  While consumers of visual data have generally fared well with writing generic consumption algorithms, consumers who require a "semantic" understanding of data have struggled with making the SEDRIS-to-native system mapping.  Solutions used to date have focused on either detailed requirements specifications or developing data driven applications that require tailoring on a per-transmittal basis.This paper will discuss current consumption approaches, including practical examples from multiple programs, and follow with a discussion of planned technologies to make consumption of SEDRIS transmittals easier.IntroductionOne of the main purposes of SEDRIS is provide an interchange mechanism for environmental data. In order to achieve this goal, five technology components have been developed.  For a complete description of all of SEDRIS goals and history refer to [1].The five technology components are as follows:A Data Representation Model (DRM) allowing the full representation of any environmental piece of dataThe Spatial Reference Model (SRM) allowing for an extensive definition of Spatial Reference Frames (SRF) supported. An Environmental Data Coding Specification (EDCS) that provides complete classification and attribution for environmental data.An Interface Specification, the SEDRIS API, which allows the user to develop applications to consume and produce environmental data.The SEDRIS Transmittal Format (STF), specifically designed for the SEDRIS DRM. [3]The focus of SEDRIS has been to incrementally address each of these components, starting with the DRM.  Each component has now reached a high level of maturity.  This is proven out by the relatively few changes to each component in recent releases and by international standardization of the components.  In order to complete the DRM, it was essential that it could handle all possible representations of environmental data.  As a result, greater emphasis has been placed on being able to produce SEDRIS transmittals (i.e. prove that producers could represent their data using the DRM).  This was compounded by the drive to establish initial data sets from producers so that consumers could start taking advantage of the benefits of re-use.  Hence, a greater focus has been placed on meeting the needs of producers.  With the maturity of the DRM and API, and with stable production capabilities, attention can now be focused on consumption, especially reducing the barriers of entry for consumers.This paper describes consumption methods for SEDRIS data and discusses upcoming work intended to provide the tools necessary for easier consumption.  We will begin by describing consumption in SEDRIS.  A simple consumption model with steps involved in consuming SEDRIS data will be presented. Next, general consumption issues are presented and the pitfalls associated with them.  Three different types of consumers are presented and how they deal with consumption issues. Different consumption philosophies are presented, including how these lead to requirements for consuming.  The final section will deal with providing the functionality required for easier consumption and solving all of the consumption issues.SEDRIS Consumption Model“Consumer” is a generic expression for any tool, application, or program that retrieves SEDRIS data for some purpose.  When the software that extracts data is referred to specifically, it is the “consuming application”; some call this a compiler or converter. Consumers can use SEDRIS data for two basic purposes.  The first is to import, translate, or convert SEDRIS data into a native format or native data model.  This is the classic SEDRIS consumer where SEDRIS is the means by which data producers and data consumers interchange data; in this case, consumers go from STF to their native format.  An example of this type of consumer is SEDRIS2CTDB.  The second purpose of consumption is to add value to SEDRIS Transmittals.  For this purpose, consumers take SEDRIS data and add value to it by visualizing, inspecting, or correcting and leaving it as SEDRIS data.  These are SEDRIS based tools such as SEE-IT and the Side-By-Side viewer.  These consumers analyze or evaluate an STF without attempting to export data to an end application.Consumption StepsRegardless of the purpose of consumption, the pitfalls and steps for consumption are the same.  The first step is to analyze the native data requirements. If the consumer is a toolmaker, what does the tool require?  If importing into a native format, what type of data does the native format contain?  The second step is to map the native data model to the SEDRIS DRM and document this via a Mapping Document.  This document describes the native primitive data and its organization, together with the translation from SEDRIS to the native data.  It describes what data maps from SEDRIS to the native data model, the data that needs to be derived, what algorithm will be used to derive native information, and what SEDRIS data is going to be ignored. It also captures any run time data requirements of the consuming application.  It is important that when mapping data, that the consumer always focus on the primitive data.  The third step in consuming is to learn the necessary SEDRIS capabilities in regards to extraction and the DRM.  The final step is to create the consuming software.  In order to do that, a consumer must determine a consumption philosophy in order to deal with the more complex issues of consuming the wide range of data available.Consumption IssuesSEDRIS addresses a complex problem: a comprehensive data exchange mechanism for environmental data.  To name but three sample communities, SEDRIS is addressing the needs of data producers (e.g. NIMA), visual systems, and SAF/CGF systems.  Each of these communities has its own history of competing standards and data exchange problems. This section describes the issues relevant to consumers when using SEDRIS data.Data QualityWhile SEDRIS provides a mechanism to exchange data, it does not enforce data quality and does not ensure that all consuming applications can operate on all data.  In fact, the community in general has not dealt with data quality and data validation effectively.  With SEDRIS, tools can validate content in one place (i.e. a SEDRIS transmittal) as opposed to requiring separate tools operating on each of the myriad native formats.  In order to consume, consumers must verify the data is fit for their use.  In other words, does this piece of data conform to their consumption requirements? End Application LimitationsTransmittals may contain data that a consuming application cannot handle or represent.  Phrased another way, the fact that SEDRIS can convey something doesn’t mean that all applications can operate on it.  Transmittals may contain excessive density or represent data at a wholly different level of abstraction.   For example, CCTT represents terrain skin as regularly spaced elevation posts, so transmittals using arbitrary polygons for the terrain skin cannot be accurately represented in CCTT.  This results in a mismatch between the input transmittal and the capabilities of the consumer.  Few run-time formats can represent all of the data the SEDRIS DRM can, and the consumer must take this fact into account.Insufficient ContentProducers can only export the data they have available to them.  In addition, they are unlikely to export data that they deem useless or redundant.  Producers with a visual background tend to focus on geometry rather than attributes.  For example, in the visual domain, a stamp with a texture is sufficient to define a tree, but an application that cares about the distinction between foliage and trunk will be left with a challenge to derive this information.  On the other hand, a producer that starts with no visual data (e.g. WARSIM databases) will not include textures, leaving significant effort for a visual consumer.  Consumers must be aware of the content provided in a SEDRIS transmittal and if this content is appropriate for their consumption software.  A consumer will have a minimal set of data that must be present for a viable translation: a “critical mass” of content.  Because producers inevitably focus on the data of interest to them, this critical mass will not be reached in all producer/consumer pairings.  Thus, consumers need some mechanism to determine if a transmittal matches their minimal needs.Consuming Application FunctionalityPractical constraints, such as funding and time, will limit the functionality of most consuming applications, potentially limiting their ability to import a broad range of SEDRIS transmittals.  This will restrict the Spatial Reference Frames (SRFs), attributes, and/or classification codes that a consumer can properly ingest. For example, a given consumer may fail to properly handle time-based hierarchies (i.e. selected the correct representation of a tree), if their target application does not understand seasonal changes.  SEDRIS provides greater incentive to consume a wider range of datasets because it is so widely used.  In contrast, if consuming a specific DRM structure or organization, there is a stronger tendency to limit the acceptable transmittal structure, tying the consuming application tightly to a special case transmittal.  Consumption based on a limited set of transmittals can be mitigated by focusing on constructs that are relevant to the consuming application, i.e. visual systems can focus on the geometry data as opposed to feature data. The Transmittal Dependence TrapConsumers invariably focus implementation on objects known to exist in transmittals.  This bypasses the proper consumption model.  It is done because consumers are interested in certain data sets and make assumptions that should not be made in order to consume specific data.  What then happens is that consumption applications are written to consume specific transmittals instead of focusing on the type of data the consumption software should consume.  For example, CCTT and UKCATT were among the first programs to use SEDRIS <Feature Model Instances> (FMIs).  Since few, if any, producers had used feature models in the past, it was discovered that several well-established SEDRIS tools didn’t process feature models at all. As a result of this condition, data a particular end application could handle may be present in the transmittal but not correctly interpreted or extracted by the consuming application.  There are numerous practical examples of this:WARSIM operates on a TIN terrain skin, and a TIN is included in WARSIM transmittals.  As a result, WARSM’s run-time database compiler does not search for or process regularly-spaced elevation posts.  CCTT and UKCATT database producers always break linears up at intersections, so their import tools do not search for or break up intersecting linears.  However, the OTB/ModSAF CTDB compiler does handle this, implying that at least some data sources consumed by CTDB did not split intersecting linears up.  The CCTT/UKCATT compilers would therefore fail to generate a valid road network from such sources.   Neither of these programs have an incentive to implement this functionality since it is not known when, or if, such a data source will ever need to be consumed.UKCATT transmittals include roads as linears inside feature models (instanced via FMIs).  Many consumers would expect to find linears only as, say,  linear features, not instanced via FMIs, and thus would have no reason to establish object searches in that manner.Producer versus Consumer View In order to lower the barriers to data interchange, SEDRIS provides producers with substantial leeway to produce data in a cost-effective manner.  The assumption has always been that consumers would demand better data from producers and that they would improve transmittals because the market would demand it.  This allows for more data for consumers, but demands more work on the consumer’s part.  For example, SEDRIS hierarchies that represent ordering or organization (e.g. by LOD or location) allow the producer to set a flag indicating that they are not strictly following that hierarchy’s tenets, leaving the consumer to handle the result. In addition, nothing prevents a producer from throwing all polygon data, say, under a single Union of Geometry (basically, a bag of polygons).  Classification codes are optional, so a model may contain geometry data, but no indication of whether the polygons represent a sonar buoy, tank, tree, or a political boundary.  Associations between different representations of the same thing are optional.  An application attempting to handle a wide range of transmittals must often fall back to the least common denominator to avoid reliance on an optional construct. In short, SEDRIS provides a container for data, but it is each producer’s responsibility to make reasonable use of that container.There are many variations of this issue, some of which have already been discussed elsewhere in this section.  We will briefly mention three issues.RepresentationWhat is a tree?  Is it a stamp with a texture?  Is it a cylinder (defining the foliage boundary)? Two cylinders (foliage and trunk)?  An abstraction based upon location only (i.e. “tree is here”)?  A billboard (SIMNET treelines)?  A hollow 3D boundary made up of a dozens of polygons (SIMNET canopy)?  An areal feature with a distribution function?  An areal feature with an average density?  An areal feature with no attribution other than “forest here”?  A collection of predefined tree stamps (CCTT basis sets)?  All of these, and more, are valid representations.  Most consumers cannot conceive of all of these variations and in fact have one, or at least a very few representations they would prefer to consume.  Why only one best form? Because their formats are optimized for their application needs, and there will be one, or at most only a few, ideal or even viable mappings.  If a consumer has no concept of a SIMNET “canopy”, then they may not know how to search for it or, if they find it, they may have no way to convert it into a data structure they understand.  As a more mundane example, consider the case of a building, which many producers would represent as a set of polygons with textures.  Those textures may include “images” of windows and/or doors.  If a consumer cares about windows and doors as geometry (not as a “picture”), the translation will not be complete.ClassificationThe EDCS provides a comprehensive set of classification and attribute codes.  However, any consumer who must distinguish “what” something is faces two possible challenges: 1) the producer may use the wrong classification codes or 2) the classification codes are spread throughout the data incoherently.  The first case is a matter of data error, while the second is a data representation issue.  For example, if an airport is composed of both a control tower and a runway, then the tower and runway could be separately or collectively classified with airport and it is left up to the consumer to distinguish the parts.  Because representation can vary, it seems reasonable to use the EDCS’ classification codes in configuration files to facilitate data-driven decision-making.  Unfortunately, this approach can fail depending upon how loosely a producer uses the classification codes.  For example, for the airport example above, an application that wants to treat the runway and control tower differently will need to use more than just an EDCS classication to distinguish between them.Primitive Representation DifferencesThe flexibility of the SEDRIS DRM provides many opportunities for abuse or, more fairly, unexpected representations of data.   Typically, SEDRIS provides at least one way to present data that would eliminate these concerns, but there is no guarantee a producer will use all of the options at their disposal.Consider the representation of <Linear Features> such as roads.  Depending upon your application, you might view roads as, for example, a set of polygons (e.g. visual) or a centerline (road network for routing).  SEDRIS provides clearly defined means to present roads either or both ways, including a means to associate between the two representations.  However, producers may use either or both, with or without the associations.  Consumers are thus faced with mapping both representations into their application’s representation.  In the case where both representations are present, but no associations exist; the consumer must determine which, if any, of the instances appear to be the “same thing” (e.g. to avoid duplicating data derived from two representations of the same thing).As another example, how should a consuming application handle a case where a transmittal contains terrain skin data that overlaps without a deconflicting hierarchy to provide context (such as Level of Detail or Time-Related)?  This data could appear as duplicate polygons (with or without different attributes), or as a mixture of property grids and polygons.  Should the application assume they are geometrically equivalent, or verify they are?  If attempting to verify, what should be done if they aren’t identical?  Numerous variations of this exist.  In these cases, misinterpretation of the producer’s intent can easily be confused with data quality problems (or vice versa).Types of Consumers For the purposes of this paper, we will bin SEDRIS consumers into three groups, providing examples of each. The full range of existing and potential SEDRIS applications defies clean categorization; however, we believe these three groupings fit most existing applications and capture the primary consumption issues.For each consumer type, we provide some sample applications, a general description, and discuss the flexibility of the consumer application to process a wide range of producers and SEDRIS content.Generic or Syntax-Based ApplicationsThese consumers provide utilities such as Java Browser, Syntax/Rules Checker, and Depth.  These applications provide generic capabilities that attempt no (or very limited) “interpretation” of data.  They operate based upon the rules of the DRM.  Because the DRM and business rules are clearly defined and allow finite permutations, these applications will be generally be able to handle a wide range of transmittal producers and content without per-transmittal tailoring or configuring.These applications provide very little or no interpretation of the content of the SEDRIS transmittal. For example, the SEDRIS “viewers” (such as Depth and Transmittal Browser) display a transmittal’s contents without understanding what a “tree” is, or whether a polygon is properly formed.  The syntax and rules checker verify the “structure” of a transmittal but cannot say if it contains valid or meaningful content.  It follows, then, that these utilities tend to be applicable only to general problems or tasks (i.e. related to SEDRIS itself), providing little application-specific support.These consumers are able to avoid a wide range of data interpretation and processing issues faced by the other two consumer types, including many of the problems described in Section 3.  For example, none of the example utilities listed for this consumer type need to deal with search bounds, translation between SRFs, or translation of classification codes into an application-specific space.Visual / Geometry ConsumersThis category includes utilities such Side-by-side and model viewer, as well as numerous applications intended to import SEDRIS transmittals into visually oriented tools or formats.  These consumers are able to focus primarily on the geometry side of the DRM, and generally care little about “what” something is as long as they can map its geometry into their application space.These consumers face greater difficulties in achieving true transmittal-independence when compared to the generic applications described above, however we claim that they face an easier task than the “Semantic” consumers defined below.  To grossly simplify the task of a visual consumer, they must:Identify each <Polygon> in the transmittalAssociate a texture with itDetermine a context or state during which the polygon should be rendered (e.g. level of detail, model damage state, etc.)Translate all of this information into the application’s solution space (e.g. coordinate system, color model, etc.).  Obviously, these steps factor out numerous challenges such as interpretation of animations or IR characteristics.  However, the key point is that both the DRM and supporting SEDRIS functions provide substantial support for the steps described above.  For example, conversions between different SRFs and color models are provided and the DRM explicitly represents Level of Detail.Visual and geometry consumers are well supported by SEDRIS partly because this problem domain is well bound (“polygon” is a well understood term, “level of detail” is used as a general concept in many visual applications).  In addition, the visual community has had substantial success in finding commonality across applications (e.g. OpenGL and OpenFlight).  Finally, a significant majority of both SEDRIS producers and consumers, especially prior to 1999, were interested in image generation.  In short, both the state of technology in the visual domain and the experience of the SEDRIS associates facilitated SEDRIS’ definition of visual data.Despite the above, most visual consumers would not be willing to claim that their application could make full use of any SEDRIS transmittal containing “valid” content.  This is a reflection of exposure to more of the consumption issues described in Section 3.Interpretive or Semantic ConsumersInterpretive consumers include SEE-IT and applications creating CGF databases.  These consumers must understand “what” different SEDRIS objects are in order to determine where they fit into their application space. Many such consumers make little or no attempt at transmittal independence; that is, they have limited ability to automatically consume any SEDRIS transmittal.  Where transmittal independence has been attempted to date, the results have required per-transmittal tailoring by a user, such as configuration files.  Section 5 describes these approaches in greater detail.  Because these applications do require a deeper understanding or interpretation of the data, they are far more likely than the other consumer types to suffer the problems described in Section 3.“Semantic” Consumer Approaches As described in the preceding section, the authors believe that “Semantic” consumers face the greatest challenges among the various consumer types.  This section captures existing approaches to resolving these challenges, within the experience of the authors. Fully Automated ClassificationThe authors are not aware of a consumer that we would classify as a “Semantic” consumer who has attempted to fully automate the process of mapping objects into their application space.  However, several have addressed specific areas in a largely automated way.  For example, the SEDRIS2CTDB compiler analyzes terrain skin locations to determine if there is regular “spacing” to the triangles, thereby allowing an automatic selection of the different terrain skin representations CTDB supports. Interactive ClassificationInteractive applications use broad, generic search strategies to determine all of the “kinds” of things in a transmittal, provide this information to the user, and then allow the user to classify each object as appropriate to the application.  SEE-IT is the example in mind for this approach.  SEE-IT uses a configuration file to bin various objects as primitives for tests, as with the “Classification-Based” approach described next, but helps the user in creation of the file via an interactive classification session.This makes the classification process significantly easier when new data types are encountered, but still requires a manual effort involving someone familiar with the transmittal content and its relationship to SEE-IT test cases they wish to use.  In addition, this approach could become cumbersome if a producer uses a wide range of attribute types for fundamentally similar objects, because the sheer number of permutations can become overwhelming.  On the positive side, transmittals with similar content can reuse the configuration files, at least in part.Classification DrivenClassification-driven applications use a configuration file to map a particular SEDRIS classification code to a “type” of object in the consuming application’s domain.  The purest example of this is the SEDRIS2CTDB compiler, although the CCTT/UKCATT CGF compilers   partly rely on this approach.  Again, similar transmittals may be able to wholly or partly share classifications, allowing an opportunity for reuse.However, a purely classification-driven approach is easily defeated because a single classification code can be legitimately used on very different objects.  Consider, as a single example, a database where there are four different representations of airports to be used in different regions:a feature model, containing three 3D buildings and a runway (for use in areas where ground vehicles move).a point feature representing an air control tower (which ground vehicles only see from a distance). a linear feature representing an isolated runway (for regional airstrips)a polygon with a texture map intended to look like an airport from above without use of a 3D object.  All four of these representations could legitimately use the same SEDRIS classification (e.g. “airport”).  However, from a CGF perspective, all four of these cases could result in different mappings (building & linear, building only, linear only, and perhaps abstract areal for the texture version).  In this situation, identification by classification codes alone breaks down.SpecificationsIn this case, the consuming application enumerates and publishes its requirements.  Consequently, any transmittal that fails to meet the minimal requirements set forth cannot be fully processed.  The primary examples of this are CCTT and UKCATT.  In these cases, the developers of the compilers that import SEDRIS to generate all of the non-visual databases enumerated their requirements.  The requirements were negotiated between the producers and consumers on these projects to define what is required to fully populate their systems’ non-visual databases.  This approach is described in greater detail in [2].  A variation of this may be found with WARSIM’s TCDM, which serves as a system-wide data-driven specification for WARSIM’s SNE.  This approach is most applicable to use of SEDRIS within a “system” or family of related projects.  At a project-level, this approach sharply reduces risk by ensuring the program’s producer exports all data required for the system as a whole, while the consumer’s effort is limited to only the indicated requirements.The weakness of this approach is that the consumer has little incentive to strive for a more generic consumption capability, since the boundaries of his problem domain are sharply defined.Program SpecificA program-specific approach is similar to the specification approach, except that the conventions in use between producer and consumer are not formally documented.  In practice, this means the consumer applications are using knowledge, consciously or not, of their familiar producer’s use of SEDRIS.  For example, SEE-IT and SEDRIS2CTDB were clearly influenced, at least in early implementation, by their S1000-related legacy.  This approach can be used as a purposeful mechanism to minimize investment in data exchange.  For example, on the WARSIM program, the same development team creates and consumes the program’s transmittals, so the transmittal’s content is not an issue for team-level requirements or interface definitions.  As a result, investment in a detailed requirements document or a complex, flexible consuming application is wasteful in the context of the WARSIM program, especially given WARSIM’s data-driven mechanism (TCDM) for specifying the data content across the life cycle (from source to run-time representation). Consuming SEDRIS TransmittalsThis section presents how to minimize and deal with all of the issues that have been presented so far.  This section describes what to properly focus on when consuming and how SEDRIS will make consumption easier.A Primitives FocusIn order to properly ingest environmental data from SEDRIS a consumer must focus on primitives.  In version 3.0 of the DRM, there are over 360 classes, but all of them break down into three categories: primitives, attributes, and organizers.  Primitives are what SEDRIS stores, features, geometry, and model instances.  Attributes describe the primitives, classification, attributes, locations, and so forth. Organizers are just different containers that hold the primitives.  When consuming SEDRIS transmittals it is therefore imperative that consumers derive the information needed down to the lowest common denominator, namely primitives with attributes.  For some consumers, this means polygons classified as terrain containing a set of vertices.  For others it is a linear feature classified as a road. The objective is to achieve a clear understanding of what is needed in terms of primitives with attributes.  This allows a consumer to determine what would be present in an ideal transmittal for their needs.Balancing Producer/Consumer ExpectationsIt is important to note that producers and consumers have a somewhat adversarial relationship.  Each has expectations about the data and the work that must go into that data.  Previously, consumers and producers met and negotiated how the data was to be provided and in what format.  The problem then became matching each requirement and finding the mechanism by which the gap between the two sides can be bridged.  SEDRIS assists by bridging the gap between one consumer and many producers without this negotiated arrangement.  It does not preclude some sort of negotiated arrangement, but the arrangement is not required.  The problem that a consumer will have is whether a producer will store data in SEDRIS in a way that is most convenient for their production software.  In some cases, small changes on the production side could save large amounts of effort on the consumer’s end.  But how would a producer know this without some insight into the consumer’s world?  As an additional twist, legacy data may not be in production any more, i.e. there is no possible change on the production side.  So in this case, the consumer has legacy data that is in a suboptimal organization.  This is the most common case regardless of whether the data is still in production or not.  The following discussion addresses the best manner to use SEDRIS as the bridge over the troubled waters of environmental interchange.Defining the ProblemThe first step in any engineering solution is to define the problem.  In this case we must define the consumer requirements and the producer’s capabilities.Consumer RequirementsLet us begin with the consumer.  As mentioned above, a consumer can determine unequivocally what his needs are in SEDRIS terms, and the ideal or best method by which the data should be stored for the consumption software.  Again, this demands a focus on the primitives.  A consumer can document their needs in a Transmittal Content Requirements Specification (TCRS).  The TCRS is a specification of the requirements of the content in a SEDRIS transmittal.  It is not a content specification, because it does not state how much or what content will be contained in a Transmittal.  It is not a content agreement because it only specifies the consumer capabilities and requirements, not the intentions of a producer to meet said requirements.  This is not to say that it cannot form the basis for a content agreement, but by itself the TCRS is just a specification.  It documents what a consumer will be able to handle and flows directly from a consumer’s mapping document.  It provides different SEDRIS representations that a consumer will and will not handle.  .  The TCRS defines what the data needs to look like in SEDRIS terms and how it needs to be labeled.  It is important to note that it needs two components 1) proper classification associated with 2) proper DRM structure.  The reason is that these two components solve the consumption problems listed in Section 3 and touched in Section 5.  Since the TCRS defines the requirements of a SEDRIS transmittal, it allows a user to evaluate transmittal content and the validity of using a particular transmittal for consumption purposes.  Because anyone can meet a specification: the TCRS does not limit participation to specific parties.  Thus, the required pairing between producers and consumers is broken.  Furthermore, with a TCRS, consumers can unequivocally state that they can properly consume any Transmittal that is TCRS compliant.An example of a TCRS is the CCTT/UKCATT TCRS.  It enumerates the minimal requirements that a data set must meet in order for the CCTT/UKCATT consumer to properly ingest the data.  The CCTT/UKCATT TCRS allows these two programs to use a common set of database compilers despite having two different database producers.  If a third producer is to provide data for either of these programs then it will need to provide a Transmittal compliant with the CCTT/UKCATT TCRS.As another example, consider the SEDRIS2CTDB application, which has an accompanying TCRS.  In it are described the requirements for creating a CTDB from a SEDRIS transmittal, such as which classification codes and attributes a building must have.  Has anyone agreed to provide the data?  No, no “agreement” has or needs to be made.  What this TCRS does is tell all producers that if you want to have a CTDB created, your transmittal must meet this specification.  It also allows for a validation mechanism of the transmittal. This illustrates that a TCRS is a method for defining the requirements for consumption that heretofore has not been considered.  Previously, a consumer was told to grab a transmittal and attempt to consume it.  Now, it is imperative that a consumer states what is required in a transmittal for proper consumption.Producer CapabilitiesThe same mechanism that consumers can use to specify their requirements can be used to specify a producer’s capabilities.  Once again, this is done by specifying the primitives with attributes.  Furthermore, this can be derived from SEDRIS transmittals with specialized tools.  So for example, one producer might decide that their application defines a tree to be a point in space with a height.  Another could decide trees are just single polygons, while another could provide very complex trees with many polygons and many attributes such as the type of tree.  In all three cases, each has a unique representation for trees.  Applying the same idea to the complete transmittal allows the creation of what we call a Transmittal Content Specification (TCS).  This is a sister specification to the TCRS.  It could look almost identical, except one is a requirements specification and the other is a capability specification.  In other words, the TCRS defines “what I want” and the TCS defines “what I have”.Solving the Consumption ProblemOnce a consumer has specified their requirements through the TCRS, the sobering realization hits that it is unlikely that most producers will conform to their TCRS.  Obviously, this is not an issue in the case of programs where producers and consumers are working together to meet a specific program’s goals.  However, any attempt to look further afield for reuse opportunities will present problems. So what are the options available?First, the consumer can choose to deal with any representation possible in SEDRIS; this is a limited task that can be done given enough time and money.  But with time and financial constraints, most consumers focus on only the most used or relevant representations for their problem space.  Furthermore, dealing with any possible SEDRIS representation would produce a large amount of duplicated code and effort.  Why? Because consumers will be working on handling as many variations of SEDRIS representations as they can instead of focusing on solving the SEDRIS to native conversion problem.  Hence, all consumers will write the same code to handle typical DRM constructs instead of writing code for the ideal representation suitable for their consumption needs.  Consumers are experts at their native formats and should need to learn only the SEDRIS technologies relevant to their consuming applications, i.e. consumers might only need to learn 50 of the 360+ DRM classes.  Furthermore, the expertise base is greater for SEDRIS re-organization than for native format conversion and is hence easier to accomplish at the SEDRIS level as well as being easier to share with the rest of the SEDRIS community.The second option is for consumers to limit consumption to their native TCRS compliant transmittals.  This would require a second piece of software to evaluate transmittals and, if possible, transform them into a transmittal compliant with their TCRS.  The authors term the second software piece a “Recompiler”.So, is theire a difference between the second and the first option?  The amount of effort is exactly the same except that it is organized differently.  The second approach provides a separable application that can be incrementally built up and reused across programs.  In the first approach, all the work is tied to one piece of software, which must attempt to address both translation to native data and recognition of a wide range of SEDRIS representations.  The translation to a native format is application-specific, a task for which each individual consumer will have the unique skills required.  However, the software handling the task of recognizing many SEDRIS representations can be isolated from the specialized native conversion software. Thus, this functionality can be incrementally built up in isolation, allowing for a better handling of financial and timing constraints.  Furthermore, the capability of reorganizing or “Recompiling” SEDRIS transmittals can begin to evolve in a global sense.  In other words, other parties can start solving portions of the reorganization problem and then share the results.  For example, UKCATT uses a recompiler to produce terrain grids from a polygonal representation.  The CTDB compiler solves a similar problem in a more generic way. A piece of the consumption problem has been solved (twice, at least), but there is no mechanism for all of the community to share the work…until now.Sharing Solutions Similar representation and conversion issues are being solved repeatedly because there is no easy mechanism for SEDRIS consumers to reuse software that is not part of SEDRIS Core.  What is needed is a mechanism to allow tools to interact, which will allow users to more easily exchange solutions.  Such a mechanism is described in [5].  So what needs to be shared and developed for slaying the consuming dragon?Machine Readable SpecificationTo date, each TCRS written has been in the form of a document.  So, one of the first steps is to have these requirements presented in a machine-readable form, which will then allow for tools to help consumers create these specifications.  Furthermore, a machine parsable language will allow for the inclusion of specific hierarchies expected.  This language will allow for reusable tools to be developed across the SEDRIS community, just as the SEDRIS DRM already has.For example, consider a consumer who must find trees.  In SEDRIS, as discussed above, that could mean looking for any of a number of representations. Instead of dealing with all of these variations, a consumer can state their requirements in his or her preferred representation, i.e. individual CCTT trees with models or CTDB tree canopies.  Furthermore, this language can define such standard representations and translate from one to another.  For example, if a user creates a conversion from CCTT trees to CTDB trees or vice versa, this component can be reused or extended by anyone that uses the machine-readable TCRS language.  This can then build on itself as more users publish using the TCRS language.  This is also the method by which consumers limited by their own TCRS can expand their consumption base.  As an example, the CCTT CDB folks could extend their recompiler through reuse to take a transmittal compliant with the CTDB TCRS and create a transmittal compliant with the CCTT CDB TCRS.  Then the CCTT compilers will be able to consume any transmittal created for the CTDB without making their own specialized applications unnecessarily complex.  Thus, consumers can start leveraging the consumption ability of others to create a consumption multiplier.This approach also serves to directly document exactly what conversions are taking place.  For example, if each consumer converted from one representation to another in their own unique way, no outside consumer has a SEDRIS-based mechanism to know what the output of another consumers’ translation was.  If a SEDRIS recompiler were available, the CCTT representation of terrain skin and trees will be explicitly captured in a SEDRIS transmittal, not hidden in the specialized CCTT software doing the conversion “under the covers”.Validating TCRS Compliance One of the first benefits of a machine readable TCRS will be the ability to create one tool to validate any transmittal against any TCRS.  CCTT has developed a compliance checker for their TCRS, which will report failures to conform to selected TCRS requirements.  Each TCRS could have its own similar application, but with a TCRS language, one tool can be written to validate a transmittal based on any TCRS.  Thus, a transmittal could be deemed or certified compliant with any number of specifications.  More importantly, the producer of said transmittal will then be able to get instant feedback on their production techniques.  From the consumer’s standpoint, once a producer passes the TCRS validation then there is a guaranteed consumable piece of data.Automatic Conversion Building upon a common tool mechanism and a machine-readable specification, utilities can be written that will do some automatic conversions between one TCRS construct to another.  Tools can be developed that will measure how well one TCRS matches another and to convert from one to another.  Furthermore, with a common tool mechanism, transmittals may be converted from any TCRS to any other TCRS.  We make this claim because individual consumers will continue to solve the specialized conversions (e.g. polygon to elevation post) by adding them to the tools capability and through reuse.  This will allow the community to incrementally build the complete interchange solution.Conclusions This paper has discussed issues with consumption of SEDRIS transmittals and presented a pragmatic approach to addressing these issues.  We have presented a model to use when consuming environmental data stored in STF.  We have presented the problems that may be encountered as a SEDRIS consumer and how to minimize these through the use of a TCRS.  We have further highlighted how the power of a TCRS can be increased through the use of a TCS and how the TCRS will flow into the tool sharing mechanism described in [5].  Much progress has been made in supporting consumers, but there are problems that, while difficult, are still manageable.  By effectively using a machine-readable specification and supporting tools throughout the community, we will be able to advance quickly on the consumption problem in the near future.Future WorkWork is proceeding on developing the tools necessary to effectively use the TCRS concept to solve the consumption problem.  Presently, the mechanism for sharing tools is under development [5].  Initial discussions indicate the development of a machine parsable language for expressing a TCRS will not take long.  Once this is developed, then the tools to validate and then reorganize/recompile SEDRIS transmittals will start in earnest.  In order to develop this capability it is necessary to have acceptance and wide spread use by the community of the principles laid out in this paper.  As a community, the best way to solve the large and complex problem of consuming environmental data is to push the solution into a central location where everyone benefits through reuse and everyone can solve a smaller piece of the problem.  SEDRIS is that central location and this paper presents how we will go about slicing up the cake and then eating it as well.References[1]	 B. Horan, Dr. R. Cox: “SEDRIS Past, Present, and Future – Technically Speaking”. Simulation Interoperability Workshop, April 1999.[2]	 HYPERLINK "http://www.sedris.org" http://www.sedris.org[3]	 J. Carswell, J. Campos, R. Cox: “The SEDRIS Transmittal Format”. Simulation Interoperability Workshop, April 1999[4]	K. Donovan, K. Stump, J. Watkins: ``Virtual Database Production Experience with SEDRIS”. Simulation Interoperability Workshop, September 2001.[5] 	M.A. Pigora, D. Shen, J Campos: “Innovation with SEDRIS Tools”. Simulation Interoperability Workshop, September 2001.Author BiographiesJESSE CAMPOS is a Software Engineer with SAIC.  He has been working the SEDRIS project for almost four years.  His primary expertise is in software development as it applies to databases.  Mr. Campos graduated from the University of Central Florida with a B.S. in Electrical Engineering.  He can be reached at 12479 Research Parkway, Suite 600, Orlando, FL 32826, 407-207-2796, FAX 407-381-8436, Jesse.J.Campos@cpmx.saic.com.JON WATKINS is a senior software engineer with SAIC.  He has contributed to a variety of constructive and virtual simulation systems over the last ten years, primarily in the areas of SNE and entity-level movement control.  He is presently working on CCTT/UKCATT database development.