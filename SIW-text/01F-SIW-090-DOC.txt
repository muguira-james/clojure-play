Time Management Services in the RTI-NGFrank HodumDavid EdwardsDistribute Computing Technology DivisionScience Applications International CorporationSuite 1105400 Shawnee RoadAlexandria, VA 22312 HYPERLINK mailto:Fhodum@dctd.saic.com fhodum@dctd.saic.com, dedwards@dctd.saic.comKeywords: RTI-NG Time Management Service, RTI::FedTime, Custom FedTime implementationABSTRACT: Simply put, the Time Management services within the RTI specification provide a means to correctly order the delivery of timed messages across a federation. The actual execution of this ordered delivery in a distributed system, however is quite complex as will be illustrated in this paper. We will describe the algorithms utilized by the RTI Next Generation (RTI-NG) Time Management services, the known limitations and impacts on the federation and best practices for federations using the RTI-NG Time Management services. Additionally, the High Level Architecture provides for the concept of a user defined Federation Time data type. This feature is infrequently used, but represents a very powerful means for federations to modify the behavior of the RTI-NG when using Time Management. We will explain the mechanism and reasons for utilizing this feature within the RTI-NG implementation.Brief Overview of Time ManagementThe Time Management Service is intended to provide a means of synchronizing a distributed group of federates with regard to any arbitrary point within the time continuum of the simulation execution.Simply, Time Management Services insuremake sure that all participants know their own local time as well as the minimum time they can receive a packet from another participant.what time it is, so that actions and events occur as they should. This is done achieved by allowing federates to send messages to each other that contain a time in the future at which the message should be delivered. in addition to other data. The RTI guarantees to a federate using Time Management Services that each timestamped message will be delivered in order, and no timestamped message will be delivered to a time in the past. Basic AssumptionsTerminologyTime Management users often conceptually treat "time" as an axis, with the origin at the start of the simulation, and a time being a distance along an axis from that origin. When placed in this context, the viewer is assumed to be at the origin, so that the later times are more distant. This choice of model allows words like "before" and "after" to mean the same thing regardless of if the viewer considers a sequence of events in time, or a sequence of locations along a time axis. In either case, given a time A that is before some other time B, A can be trivially compared to B in such a way that A is found to be less than B. As is noted later in this paper, the actual representation of time in the RTI-NG is largely left to the user, with nearly any representation being acceptable so long as an operator is provided that can evaluate this 'less than' relationship.One of the assumptions made when dealing with Time Management Services is that time always increases, and that all times prior to the current time are immutable. Time Managed Federates can send timestamped messages to their current time, or to some future time, but they cannot send timestamped messages to any time prior to their current time.DefinitionsThe 'Lower Bound Time Stamp', or LBTS is defined to be the earliest time at which a time-stamped message can be delivered. If it possible that a time-stamped message can be received at a given time, it is important to not allow the federation time to advance beyond that time, because doing so would allow that message to arrive at a time in the past.The Federate Time is defined to be the earliest time that a regulating federate will associate (timestamp) an outgoing message with. It is possible for a regulating federate to send a message to a time later than the current federate time.Time Advancement is defined as the process by which a federate attempts to advance the local federate time. The HLA standard defines several time advancement methods, each with varying characteristics. The impact of these methods upon Time Management Services will be discussed later. It is important to note that federates do not directly advance the LBTS, rather they contribute to the calculation of the new LBTS which in turn advances the LBTS. The Time Advancing State of a federate is defined as the condition of either requesting an increase in the federate’s logical time or being idle, maintained as a flag that indicates if the federate can attempt to advance time. A different way of looking at it is as an indicator of whether the federate successfully advanced time on its last attempt or is waiting for the RTI to grant permission to advance. It is possible that a federate has attempted to advance time, but has not yet been given permission to advance yet; if this is the case, the federate is in a state referred to as an advancing state. While in an advancing state, a federate cannot attempt to advance time again.The Lookahead of a federate is an interval between the current federate time and the earliest time the federate can use to timestamp a message. It is possible to have a lookahead of zero (referred to as "zero-lookahead mode"), in which case the effective lookahead of the federate can be epsilon (which is defined to be the smallest possible value of a timestamp) depending upon the method of time advancement. A lookahead value is necessary to maintain deterministic causality; in the absence of a lookahead value, it is possible for the outcome of a sequence of events to be determined by such things as network propagation delays. In many of the explanations, the role of the lookahead time will be neglected; if lookahead is not mentioned, it is reasonable to assume that the presence or absence of a lookahead time does not affect the concept being presented. ExplanationThe concepts of "regulating" and "constrained" were briefly introduced earlier; it is important to consider them in greater depth now in order to understand how they relate to Time Management Services.The concept of the Regulating Federate was initially introduced as a federate that can arbitrarily advance time. Later, the idea of time calculations based on the earliest timestamp on an incoming message was introduced, along with comments regarding the role of Regulating Federates in the time calculation. It is now time to offer a full, complete, and exact definition of a Regulating Federate.A Regulating Federate is a federate that can send time stamped messages.Given this definition, the federation time calculation process becomes simpler. Because regulating federates cannot send messages into the past, the earliest time a regulating federate can send a timestamped message is the federate time plus the lookahead of that federate. Since only regulating federates can send timestamped messages, the earliest such timestamp for the entire federation must be the federate time plus lookahead of the regulating federate with the lowest effective federate time. The LBTS is defined as the earliest time at which a timestamped message can be received, so this time is equal to the federate time plus lookahead of the earliest regulating federate.The concept of the Constrained Federate was initially introduced as being a federate that is constrained by the current federation time, that cannot go beyond the current federation time. With the introduction of message timestamp based federation time calculation, the meaning of this restriction has changed. The full and complete definition of a Constrained Federate is:A Constrained Federate is a federate that can receive timestamped messages.Given this definition, along with the ordered delivery of time stamped updates, Constrained Federates cannot advance their time any further then LBTS; If timestamped messages cannot be sent into the past, a federate that receives timestamped messages must not advance its time beyond the earliest time at which another federate could send a timestamped message. If a federate that receives messages advances beyond the earliest time at which a timestamped message could arrive, it becomes possible for that federate to receive a message in the past.Because some mechanisms for time advancing are dependant upon all timestamped messages being received, it is important for all timestamped messages to be delivered. So, it is a necessary condition for time advancement for all timestamped messages to be delivered before time can advance. One simplistic implementation might be to pause the sending of time stamped messages during the calculation of the LBTS until all outstanding time stamped messages have been delivered. This effectively stalls the entire timed portion of the entire federation during LBTS calculations, which is not acceptable.As a second implementation, consider the concept of a consistent cut or time calculation.  A consistent cut is one in which all packets sent before that arbitrary cut are verified as having been received before completing the cut. Any packets sent after the current cut will be verified as having been received before the completion of the next cut. The period of time in between the cuts is called a time interval. In this way, federates can continue to send packets during the calculation of a consistent cut.  The LBTS can now be calculated on this consistent cut, insuring that all packets are tracked.Each of these intervals is assigned a unique identifier (in this case, the value of a counter that increments with each time calculation). This unique identifier is referred to as a 'color'. Each time-stamped message sent during this interval specifies 'color' in its message header. Each federate keeps a count of the number of colored packets it has sent, as well the number of colored packets it has received.When the time calculation is started, each federate receives a message, directing the federate to increment its color counter and send a reporting message to the LBTS master that contains the federate time, the federate advancement state, and the counts for sent and received time-stamped messages.The LBTS master counts the number of responding federates, sums the differences, and keeps track of the earliest effective federate time of all of the regulating federates. When all federates have responded, the sum of the differences of the counts of all sent and received messages should be zero, indicating that all sent messages have been received. The LBTS master will wait until the counts are zero before calculating and send ing the LBTS. It is important to note that all federates have a new color at this time, and continue to execute using this new color while the LBTS master waits for the final difference for the previous color to reach zero.If a federate has already sent in its time calculation information, any messages it receives with a color earlier than its current color will indicate that the message is from the prior interval, and has not yet been counted. At this time, that federate will submit an updated reporting message to the LBTS master.Once the LBTS master has responses from all federates and a sent/receive difference of zero, it can send out the lowest time of any of the regulating federates as the new federation time. A note: Because of the way that LBTS has been defined (as the earliest time incoming timestamped message can be delivered to a given federate), there are actually two LBTS times defined: the federate that contributed the lowest time to the LBTS calculation (the lagging federate) will receive for its LBTS, the lowest time of the next lowest federate since that is the minimum time on any time stamped packet that it can receive. All other federates are always given an LBTS equal to the time contributed by the lagging federate. federate time.Forms of Time ManagementWall Clock TimeThe simplest form of Time Management is to use 'wall clock' time. This is not as horrible as it may seem at first glance; it is reasonable for a group of workstations on a LAN to synchronize their local time-of-day clocks to sub-millisecond levels using NTP or similar protocols. For some applications, such as real-time person-in-loop simulations (that are not intended to be perfectly deterministic), using this type of Time Management can be a good fit. In this form of Time Management, a distinction can be drawn between federates that have time-dependant calculations and, as a result, are constrained by the current time ("constrained federates"), and federates that do not have time dependant calculations and, as a result, are unconstrained by the federation time ("unconstrained federates"). Generally, a constrained federate is one that is limited by the federation time (in this case, wall clock time), and is either in the present or in the past, but never in the future. Logical Time Fixed-Interval AdvancementA similar, but more advanced, form of Time Management is to have a federate act as the master clock for the federation. This 'master clock' can be decoupled from 'wall clock' time, allowing the federation to advance its time more quickly than 'wall clock' time, or more slowly, or even at a varying rate. The 'master clock' federate periodically issues a new federation time to all other federates. This type of Time Management is good for simulations where all of the federates run at a more or less consistent speed and are either run in lock-step or in a largely time-independent manner. In this system, the distinction between the 'master clock' federate, which is a federate that can regulate the rate at which the federation's logical time advances ("regulating federate"), and a federate that cannot ("nonregulating federate"), emerges. In this case, a regulating federate is one which has a local time that can advance without regard to federation time, while federation time is dependant upon the federate time of this regulating federate.Logical Time Voting Fixed-Interval AdvancementSome simulations have large numbers of federates, where a given step of execution may require an arbitrary amount of time to complete. In such a system, it is difficult for a single master clock to calculate an optimal time interval between logical time advances. If the interval is too short, not all federates will finish their calculations before the time is advanced. If the interval is too long, all federates will finish their calculations and the whole of the federation will spend time in an idle state, extending the duration of the simulation run. Such a simulation can achieve an improvement in execution speed by allowing the 'master clock' federate to be dependant on a voting system, where time is advanced after all federates have voted to advance time. In such a system, the federates that vote to advance time would be regulating federates.Logical Time Voting Variable-Interval AdvancementHowever, it is possible that such a federation will have periods where many of the participating federates enter extended idle periods; in such circumstances, unneeded time advancement elections will take place, with each idle federate voting to advance, waiting for the time to be sent out, and then voting to advance again. A better system would allow a regulating federate request to advance to a designated time. Logically, the lowest time of all of those requested will be the time the federation should advance to; that time is the latest time the federation can advance to without advancing federation time beyond the time of a regulating federate still involved in some aspect of simulation behavior.Unfortunately, this 'better system' still has the federates relying on the federation being paused between time advances to ensure that all time-stamped messages are received by their intended recipients. Obviously, this is less than ideal in terms of running a simulation as fast as possible. To further improve time management system in such a system, it becomes important to be able to perform time calculations as needed without bringing the entire federation to a halt. It is this system that the RTI Time Management Services implements; this paper is intended to describe the mechanism by which it does so, as well as explain how to best take advantage of this service.The Fujimoto Developed AlgorithmThe distributed synchronization algorithm that the RTI Time Management Service is based on was originally developed by Dr. Richard M. Fujimoto [Fujimoto] specifically for the High Level Architecture. This algorithm was chosen because it allowed the RTI Time Management Service to perform distributed time calculations without pausing all of the participants inhalting the federationes. Using this algorithm, regulating federates are allowed to advance arbitrarily, while constrained federates are prevented from advancing beyond the  ccurrent federation time.DefinitionsThe Federation Time is defined to be the earliest time at which a time-stamped message can be delivered. If it possible that a time-stamped message can be received at a given time, it is important to not allow the federation time to advance beyond that time, because doing so would allow that message to arrive at a time in the past. More formally, the concept is referred to as 'Lower Bound Time Stamp', or LBTS. The Federate Time is defined to be the earliest time that a regulating federate will associate (timestamp) an outgoing message with. It is possible for a regulating federate to send a message to a time later than the current federate time.Time Advancement is defined as the process by which a federate attempts to advance the local federate time. The HLA standard defines several time advancement methods, each with varying characteristics. The impact of these methods upon Time Management Services will be discussed later. It is important to note that federates do not directly advance the federation time; the federation LBTS time is calculated separately, based on the federate times of the regulating federates. The Time Advancing State of a federate is defined as the state for the federate regarding Time Advancement, maintained as a flag that indicates if the federate can attempt to advance time. A different way of looking at it is as an indicator of whether the federate successfully advanced time on its last attempt or is waiting for permission to advance. It is possible that a federate has attempted to advance time, but has not yet been given permission to advance yet; if this is the case, the federate is in a state referred to as an advancing state. While in an advancing state, a federate cannot attempt to advance time again.The Lookahead of a federate is an interval between the current federate time and the earliest time the federate can use to timestamp a message. It is possible to have a lookahead of zero (referred to as "zero-lookahead mode"), in which case the effective lookahead of the federate is epsilon (which is defined to be the smallest possible value of a timestamp). A lookahead value is necessary to maintain deterministic causality; in the absence of a lookahead value, it is possible for the outcome of a sequence of events to be determined by such things as network propagation delays. In many of the explanations, the role of the lookahead time will be neglected; if lookahead is not mentioned, it is reasonable to assume that the presence or absence of a lookahead time does not affect the concept being presented. The Effective Federate Time is the federate time plus the federate lookahead.ExplanationThe concepts of "regulating" and "constrained" were briefly introduced earlier; it is important to consider them in greater depth now in order to understand how they relate to Time Management Services.The concept of the Regulating Federate was initially introduced as a federate that can arbitrarily advance time. Later, the idea of time calculations based on the earliest timestamp on an incoming message was introduced, along with comments regarding the role of Regulating Federates in the time calculation. It is now time to offer a full, complete, and exact definition of a Regulating Federate.A Regulating Federate is a federate that can send time stamped messages.Given this definition, the federation time calculation process becomes simpler. Because regulating federates cannot send messages into the past, the earliest time a regulating federate can send a timestamped message to is the effective federate time of that federate. Since only regulating federates can send timestamped messages, the earliest such timestamp must be the effective federate time of the regulating federate with the lowest effective federate time. The federation time is defined as the earliest time at which a timestamped message can be received, so this time is equal to the effective federate time of the earliest regulating federate.The concept of the Constrained Federate was initially introduced as being a federate that is constrained by the current federation time, that cannot go beyond the current federation time. With the introduction of message timestamp based federation time calculation, the meaning of this restriction has changed. The full and complete definition of a Constrained Federate is:A Constrained Federate is a federate that can receive timestamped messages.Given this definition, a Constrained Federates being limited to a time no later than the present also becomes obvious; If timestamped messages cannot be sent into the past, a federate that receives timestamped messages must not advance its time beyond the earliest time at which another federate could send a timestamped message. If a federate that receives messages advances beyond the earliest time at which a timestamped message could arrive, it becomes possible for that federate to receive a message in the past.Because some mechanisms for time advancing are dependant upon all timestamped messages being received, it is important for all timestamped messages to be delivered. So, it is a necessary condition for time advancement for all timestamped messages to be delivered before time can advance. Unfortunately, for all messages to be delivered, each federate would need to stop sending messages and wait for all outstanding messages to be delivered, which would progressively bring the federation to a halt as a synchronization mechanism, which (as already has been stated) is not acceptable. As a solution, consider the concept of time advancement as a series of discrete time calculations, seperated by intervals. In order for each time calculation to complete, all timestamped messages sent prior to that time calculation must have been received by all federates.If all the messages sent prior to the time calculation at the beginning of a time interval have been received, then those messages have already been accounted for in a previous time calculation, and can be safely ignored in the next one. Since these earlier messages can be ignored, the only messages that a time calculation needs to account for are the messages that have been sent in the interval between the current time calculation and the previous time calculation.Each of these intervals is assigned a unique identifier (in this case, the value of a counter that increments with each time calculation). This unique identifier is referred to as a 'color'. Each time-stamped message sent during this interval specifies 'color' in its message header. Each federate keeps a count of the number of colored packets it has sent, as well the number of colored packets it has received.When the time calculation is started, each federate receives a message from the 'master clock' federate, directing the federate to increment its color counter and send a reporting message to the 'master clock' federate that contains the federate time, the federate advancement state, and the counts for sent and received time-stamped messages.The 'master clock' federate counts the number of responding federates, sums the differences, and keeps track of the earliest effective federate time of all of the regulating federates. When all federates have responded,  the sum of the differences of the counts of all sent and received messages should be zero, indicating that all sent messages have been received. If all federates have responded and the difference is not zero, it indicates that messages have been sent that have not yet been received, and the 'master clock' federate cannot send out a new time to all constrained federates yet;  it will enter a pending state until the difference between sent and received messages is zero. It is important to note that all federates have a new color at this time, and continue to execute using this new color while the master clock federate waits for the final difference for the previous color to reach zero.If a federate has already sent in its time calculation information, any messages it receives with a color earlier than its current color will indicate that the message is from the prior interval, and has not yet been counted by the 'master clock' federate. At this time, that federate will submit an updated reporting message to the master clock federate,  which should have found a non-zero difference between the number of sent messages and received messages for the federation and entered a pending state awaiting updates.Once the master clock has responses from all federates and a sent/receive difference of zero, it can send out the lowest time of any of the regulating federates as the new federation time. A note: Because of the way that federation time has been defined (as the earliest time incoming timestamped message can be delivered), there are actually two federation times defined: If the federate with the lowest time is both regulating and constrained, it is given a federation time equal to the second-lowest effective federate time; if it is only only constrained, it is given the lowest effective federate time. All other federates are always given a federation time equal to the lowest effective federate time.ImplementationImplementing the Fujimoto distributed synchronization algorithm as the core of the RTI Time Management Service implementation was fairly trivial. Some minor changes were necessary:An exact implementation of the Fujimoto's algorithm would require the have the RTI to only countting ttimestamped messages sent from regulating federates to constrained federates. While doing this minimizes the number of messages that need to be counted and the number of federate nodes that are involved in the calculation, it introduces a need to maintain a great deal of global state information at each node (including a list of regulating federates, a list of constrained federates, message routing information, subscription information, and so forth). While maintaining such state information is possible, it was realized during the preliminary analysis of the time management design for the RTI-NG that there would be far less overhead associated with each node by simply counting all timestamped messages sent and all timestamped messages received regardless of the sender’s or receiver’s time management state.Queuing And DeliveryGiven a mechanism for calculating the federation time without pausstopping federation execution, it is now possible to address the other aspects of Time Management.One of the primary concepts in the discussion of distributed Time Management Services is the timestamp ordered queue (referred to hereafter as the TSO queue). Conceptually, the TSO Queue is a priority queue for timestamped messages, ordered by the timestamp onf the messages stored in it. Each constrained federate has one TSO Queue, and all incoming TSO messages are placed in it after being counted for the LBTS calculation. (If a federate is not constrained, TSO messages are counted and then delivered to the federate in the order they were received as non-timestamped messages.)As the constrained federate's time advances, the RTI-NG checks the timestamp on the message at the head of the TSO Queue. If the message's timestamp is less than the time that the federate is advancing to and is less than LBTS, the message is delivered, and the process repeats until the condition for issuing a time advance grant has been met, which is defined by the method used for advancing time.timestamp on the message at the head of the queue is no longer less than the time the federate is advancing to. If the constrained federate is attempting to advance to a time beyond the current LBTSfederation time, it enters an advancing state. While it is in this state, timestamped messages are delivered as if the federate time were equal to the LBTSfederation time, until it receives the message that brings it out of its advancing state, but the local federate time does not change until the time advance grant is issued..Mechanisms for time advancementGiven a system as described thus far, the question of how and when federates can advance time arises. The interplay of the time regulating and time constrained state of a federate with the time advancement mechanism affect the conditions for providing time advance grants. We will discuss the various time advancement mechanisms in this section.Due to the participation of Regulating and Constrained federates, each maintaining their own Federate Time, the answer, though simple, has many facets.TAR – Time Advance RequestThe most basic form of time advance is through the Time Advance Request  (TAR) mechanism. This can be considered a time stepping form of time advancement. The Time Advance Request tells the RTI-NG that the federate intends an unconditional move forward from its current time to the requested time. When a TAR has completed, the requesting federate has received all timestamped messages with timestamps less than or equal to the request time, and has a federate time equal to the request time. All messages received after the TAR completes will have a timestamp greater than the TAR request time.If the federate is neither time constrained nor time regulating, Wwhen the federate makes the Time Advance Request call via the RTI-NG, the RTI-NG checks that the federate is not already in a time advancing state. If the federate already was advancing, an exception is thrown. Otherwise, the RTI-NG places the federate in an advancing state, puts a Time Advance Grant (TAG) timestamped at the requested time into the requesting federate's TSO queue, and sets that federate's time to the time associated with the Time Advance Request. If the requesting federate is regulating (but not constrained), the TAG can be immediately placed in it's TSO queue and will be converted to a Receive-Ordered message and delivered to that federate after any other messages that arrived previously. When the TAG is delivered to the federate, the federate moves out of its time advancing state, and an RTI-NG callback is made into the user-provided interface.If the requesting federate is constrained, the RTI-NG will continue to deliver messages until the TAG message is delivered. If the TAR request time was before the current LBTSfederation time, the TAR can be inserted into the priority queue immediately.it is likely the TAG will be delivered almost immediately; iIf the TAR request time was for a time beyond the LBTSfederation time, the RTI-NG will deliver timestamped messages from the TSO queue as the LBTS value increases, thus insuring there will be no other packets with a smaller time delivered. if the federate  This continues time were equal to the federation time until the LBTS valuecurrent federation time becomes larger than passes the TAR request time and the TAG message is delivered. The mechanism is identical in both cases.TARA – Time Advance Request AvailableIt is possible that, in some circumstances, a federate may want to advance to a certain time, but still send and receive messages receive messages sent at the time it has advanced to. For this, the TARA call is available. This call is identical to the TAR in all cases except when using zero lookahead. In the zero lookahead case, the federate will be provided a time advance grant callback as soon as the LBTS value equals the time being advanced to. This means that the federate could still receive packets at that time. It also means that the federate can send out packets at that time since the federate current time plus lookahead will be the time of the grant. This time advancement mechanism is used in very specialized cases. TARA is almost identical to TAR, with the exception that a federate that has submitted a TARA for a certain time may still receive messages timestamped at the requested time following the TAG.NER – Next Event RequestThe next form A slightly more advanced form oof time advance is provided by the Next Event Request. The Next Event Request (NER) tells the RTI-NG that given the current information, this federate wants to move to a certain time in the future, unless something is received from another federate before then.  If so, deliver the event (an all other events at that same time), only grant time to the time of the event and allow the receiving federate to respond to that event. This is used in a discrete event type of time managed simulation the federate is done with the current time, and wants to advance time based on the next timestamped event in the requestor's TSO queue. A request time is included to limit how far forward in time the federate moves; in the absence of a next event in the TSO queue, a NER is treated like a TAR. At the completion of a NER, the federate has received all messages with a timestamp equal to or less than the current federate time.When the federate makes the Next Event Request call to the RTI-NG, the RTI-NG confirms that the federate is not already in a time advancing state. The RTI-NG then checks for an event in the requestor's TSO queue with a timestamp less than the requested time. The federate time is updated to the lesser of the request time or the next event time.If the federate is regulating (but not constrained), it doesn't have a TSO queue, so it doesn't have a 'next event', and the time advance completes similarly to a TAR.If the federate is constrained, and NERing to a time before the current LBTS timefederate time, all possible timestamped messages have been delivered, which means that finding the next event is a matter of checking the TSO queue. An implicit TAG will occur at either the time of the next event after all the events have been delivered, or, in the absence of a next event, at the request time.If the federate is constrained, and NERing to a time beyond the current LBTSfederate time, the queue is checked for messages before the current LBTSfederation time, and if there is one, this case becomes identical to the previous one. If there is not one, the federate will remain in the advancing state advance to the federation time, and then wait until either the LBTSfederation time passes the request time (at which point an implicit TAG occurs), or until an event is delivered from the TSO queue at which point a TAG will occur to the timt on the event..NERAANER, like TAR, has a second form that allows a federate to move forward to a new time, and then receive and send messages at that time. This is the Next Event Request Available (NERA) command, and it is identical to NER except for having only received all messages with a timestamp less than the current time. Following a NERA, a federate can still receive messages with a timestamp equal to the current time and in the case of zero lookahead, send messages at that time.FQRThe final other major mechanism for time advance is the Flush Queue Request, which will cause the federate to deliver all messages currently in the requesting federate's TSO queue, regardless of the relative LBTS times of the federate and the timestamp on the message. The federate will then advance time to the minimum of the LBTS, next event or advance to time(in a manner similar to a TAR) to the request time associated with  of the FQR call. Note that since the RTI will deliver all queued messages, some messages may have a timestamp lager then LBTS and messages with smaller time stamps may arrive in a subsequent time advance step. This time advancement mechanism is used in a technique called optimistic time scheduling sometimes called time warp and rollback. This is most often useful in loosely coupled federations where actual interactions among the federates are relatively infrequent later than this time may have been delivered as part of the FQR. Usage of the FQR is not encouraged, as it defeats the entire purpose of Time Management Services.SpeedPerformanceThe current benchmarks for time advancement are somewhat contrived (as most benchmarks are). They represent the maximum performance a federate could hope to achieve since they effectively sit in a tight loop requesting time advancements, wait for the grant and then request a new time advance. In a realistic federate, other actual simulation calculations and processing would need to go on between time advance requests, which would slow the rate of advancement. That being said, the v4 and all previous versions of the RTI-NG time management services achieved 99 Time advance grants per second. Using an internal beta v5 product, the rate of time advance grants has been doubled to over 200/second with two unloaded machines on a fast switched network. It is hard to compare the RTI-NG's Time Management Service to any other product; the RTI-NG Time Management Service is currently the only fully verified implementation of the Time Management Service.How fast can the RTI go? Using the 'On Demand' patches, the best performance that has been observed (using an obviously contrived benchmark) has been on the order of 350 time advance grants per second between two otherwise unloaded machines on a switched development network. This rate of TAG delivery is not a realistic expectation in any simulation where any amount of useful work is being done by the RTI-NG or the federate. Any sort of other communication by the RTI-NG will significantly impact this performance, as will any other network traffic.How fast can the RTI-NG reasonably be expected to go? Our goal has been to try and keep the time advance rate on the order of 30 grants per second among a dozen or so moderately loaded machines on a local network, and maintain a minimum of several grants per second on large federations running across a WAN.Known LimitationsThe RTI Time Management Service was designed to be a completely standards-compliant, generic time service. For the bulk of the HLA community, the results have proved to be entirely adequate. However, as a result of being designed with the dual requirements of "standards compliance" and "general purpose usability", there are some users for whom the RTI Time Management Service is a less than ideal solution.One design assumption that was made during the development of the time management services was that is one federate was using time management, then all the federates within a federation would be time managed. Sadly, it has become obvious as the RTI has been used in the community, that this was a flawed assumption.  Because of the decision to count all sent and received time-stamped messages on all federates, all federates participate in the time calculation, even if the federate is not a regulating federate or a constrained federate. This implementation detail has a number of impacts. First, it limits the rate of time advance based on the number of federates in the federation, rather than the number of federates using time management (since the calculation of LBTS requires responses from all federates on their sent and received TSO packets). It also has a counter intuitive impact on the fault tolerance of time managed federations.makes simulations using the Time Management Service more brittle; Since the LBTS master must receive packet count information from all federates (even those that are not part of time management and do not really affect the LBTS value), a single node terminating abnormally (without calling resign) willcan cause the calculation of the LBTS value entire federation to hang, which will cause all time advancements to stop. With manual intervention, it is possible to cause the federation to resume operation, but this dependency still limits the fault tolerance.robustness and scalability.The Time Management LBTS calculation must inform each federate of each time calculation, and then receive at least one response from each federate in order to complete the time calculation. As a result, the current system does not scale well to very large federations; the amount of time spent performing each calculation increases at least linearly with the number of federates, which means the frequency with which the calculation can be completed drops. Furthermore, the likelihood of a federate taking longer than expected to respond increases with the number of the federates in the federation; this delay will delay the completion of the LBTS calculation for the entire federation. As a result, large federations cannot use the RTI-NG in simulations that require time advances with a frequency greater than a few advances per second. (For many very large applications, this is not a significant barrier; such applications perform a relatively large amount of calculation between time advances.) Hard-realtime applications that seek very frequent time advances or time advances at rate with deterministically calculated jitter, will likely face insurmountable difficulties with the Time Management Service as provided by the RTI-NG. The underlying foundation of the Time Management Service is based on reliable traffic carried over an unreliable transport, CORBA remote invocation calls, multiple levels of queuing, and the possibility of waiting for a message currently in some federate’s queue. Each of these add a degree of uncertainty regarding timing, which combine to give a service that will perform reasonably well on average, but cannot offer any specific performance guarantees.User-defined Federation Time ClassThe RTI provides a mechanism for the federate developers to utilize their own implementation of time.  This is highly recommended for any but the simplest of federations. The FedTime implementation class that is provided with the RTI-NG is meant as a reference implementation only and provided to insure that the RTI is useable “out of the box”.  The current implementation uses a double to represent time and as such can have problems related to rounding and other anomalies familiar to numerical computations using floating point quantities.The base class for all time stamps is RTI::FedTime, which is a C++ abstract base class. Any actual usage of Time Management Services requires an instantiation of RTI::FedTime as a container class, as well as the"less than" operator. However, RTI-NG does not perform any operations directly upon the contents of the container class, and as a result, a great deal of flexibility is afforded to the implementer.Several implementations of the RTI::FedTime class are packaged with the RTI-NG. The default implementation, which has been used by the vast majority of the RTI-NG users, is based on the C type "double float". There is also an implementation based on the C type "long long int", which supports fixed-point decimal operation. Source code for both implementations is provided as an example for users who would benefit from their own implementations.Default ImplementationsThe default implementation of the RTI::FedTime class is based on the C "double float" type, which implicitly limits the precision available to roughly 15 (decimal) digits. For many implementations, this is more than adequate; it allows a time step of 1 over the range of [0 .. 10^15], or 0.001 over the range of [0 .. 10^12]. However, for some federations, precision may eventually be lost resulting in the federation losing time steps, such as when the unit time is defined to be a second of simulation time and the time step is defined in nanoseconds, it is possible that eventually, precision will be lost, resulting in the federation losing time steps. Problems such as this can be resolved by either shifting the unit time step to be a nanosecond, or by writing a customized FedTime class.Writing FedTime ImplementationsBecause the RTI-NG makes no assumptions about the nature of a FedTime implementation, it is necessary for the FedTime class be able to encode its internal state information into a form that can be transferred over a network, ideally in a form that does not suffer from endian-related issues.The "long long int"-based reference implementation of the RTI::FedTime class treats the long long int that stores the FedTime as two 32-bit integers, with each integer converted into network byte order and then stored in a string of bytes. This string of bytes can be saved to disk (as part of a federation save) or be transmitted across a network.Decoding the encoded FedTime is done by a convenience Factory class, which will cause a new FedTime instance with the appropriate value to be created. Decoding can be done by the factory; alternately, the factory can create a new FedTime and pass the encoded value to a decoding method in the FedTime class.The encoded FedTime will take the form of a string of bytes, along with an integer containing the size (in bytes) of the encoded FedTime; the Factory will be presented with this string of bytes and length, and will return a FedTime class with the appropriate time. The only limitation on encoded length is based on the 32-bit length parameter; however, it is not recommended that implementors use encoding systems where this length restriction may become an issue, as runtime memory size and network performance is likely to suffer as a consequence.Necessary OperatorsMany of the internal queues of the RTI-NG are based on C++ STL containers, which can deal with arbitrary data types. Several of these queues, notably the Time Stamped Event Queue, are actually priority queues, where events are queued in order of increasing Time Stamp. Because the RTI-NG does not make any assumptions about the nature of the FedTime that makes up the time stamp, the RTI-NG needs a comparison operator to put the time stamps in increasing order. Traditionally, the 'less than' operator is used for this comparison, and for that reason, the RTI-NG uses the 'less than' operator. Implementors are encouraged to consider that the 'less than' operator is used extensively, so an computationally expensive 'less than' operator should be considered harmful to performance.The operators defined by RTI::FedTime should be considered a minimal set. There is no restriction with regard to adding additional operators or methods to a derived class, and it is expected that private data members will be added to the derived class to hold state information.The RTI::FedTime Abstract Base ClassThe relevant abstract base class definition is the RTItypes.hh header file (included in the RTI-NG distribution) is as follows. In order to implement your own FedTime class, you will need to publically inherit from the abstract RTI::FedTime class, and implement each of the methods defined in it. In order to clarify what each method does, annotations have been added as necessary.class FedTime {public:  virtual ~FedTime();  virtual void setZero() = 0;  // Set some bit of internal state   // to indicate that this a zero  // timestamp, such that calling  // "isZero" on it will return  // true. In all of the RTI's  // reference implementations,  // this method will actually set   // the fedtime to numeric zero,  // but this is not actually  // necessary, so long as isZero  // will return 'true' after this  // has been called.  virtual Boolean isZero() = 0;   // Check if this timestamp has a  // zero timestamp. We encourage  // implementors to set timestamps   // to numeric zero, and check  // their value against numeric  // zero, but this isn't required.  virtual void setEpsilon() = 0;  // Epsilon is the smallest   // possible value for this   // FedTime.  virtual void  setPositiveInfinity() = 0;  // PositiveInfinity can be a  // constant defined by the  // implementor, or an internal  // flag, or any other   // representation. However it's  // defined, it should be set to   // positive infinity according to   // that definition.  virtual Boolean isPositiveInfinity() = 0;  // Check if this timestamp is set   // to be positive infinity.  virtual FedTime& operator+= (const FedTime&)  throw (    InvalidFederationTime) = 0;  virtual FedTime& operator-= (const FedTime&)  throw (    InvalidFederationTime) = 0;  virtual Boolean operator<= (const FedTime&) const  throw (    InvalidFederationTime) = 0;  virtual Boolean operator< (const FedTime&) const  throw (    InvalidFederationTime) = 0;  virtual Boolean operator>= (const FedTime&) const  throw (    InvalidFederationTime) = 0;  virtual Boolean operator> (const FedTime&) const  throw (    InvalidFederationTime) = 0;  virtual Boolean operator== (const FedTime&) const  throw (    InvalidFederationTime) = 0;  // The equality operator  virtual FedTime& operator= (const FedTime&)  throw (    InvalidFederationTime) = 0;  // The value copy operator, not   // the copy constructor.  virtual int encodedLength() const = 0;  // The number of bytes needed for  // a network-transportable  // representation of all    // currently-defined state for   // this timestamp. For the   // reference implementations,   // this is a constant.  virtual void encode(char *buff) const = 0;  // Create an encoded sequence of   // bytes containing all necessary  // state for this timestamp; the   // length of the sequence of  // bytes can be discovered by   // calling encodedLength(),   // above.  virtual int getPrintableLength() const = 0;  // Returns the number of   // characters needed to display   // the contents of this timestamp   // as a printable string.  virtual void getPrintableString(char*) = 0;  // Returns a null-terminated C-  // style string containing a   // printable representation of   // the contents of this   // timestamp. It has a length  // that can be obtained from the   // getPrintableLength() method. };A factory class to create FedTime classes from the encoded FedTime representation is also expected. It is trivial in scope, consisting of class RTI_EXPORT_FEDTIME FedTimeFactory {public:static FedTime* makeZero()throw (  MemoryExhausted);  // Returns a new instance of   // FedTime with a time set to   // zero.  static FedTime* decode(const char *buf)  throw (    MemoryExhausted);  // Returns a new instance of   // FedTime with a time set to the   // decoded value of the encoded   // fedTime.};More details can be found by consulting the reference implementation.; it is beyond the scope of this paper to explain public inheritance in C++. At this  time, the RTI-NG does not support writing FedTime classes in any language other than C++.References[Fujimoto] Fujimoto, R. M., and R. M. Weatherly  (1996) Time Management in the DoD High Level Architecture. Proceedings of the 10th Workshop on Parallel and Distributed Simulation.    Author BiographiesFRANK J. HODUM is a Deputy Division Manager with Science Applications International Corporation (SAIC) in Alexandria, VA.  He currently holds a B.S. in Engineering Physics from Worcester Polytechnic Institute and a M.S. in Engineering Management from the University of Central Florida.  His is the program manager for the RTI-NG (Next Generation) program and has been involved with HLA related development for four and a half years.  He has worked on distributed simulation infrastructures for a variety of simulation domains from engineering level simulations to real time human in the loop training simulations to very large scale virtual event driven simulations over the past seven yearsFrank Hodum is an Assistant Division Manager of the Distributed Computing Technology Division of SAIC, one of the original authors of the RTI-NG Time Management Service implementation, a proud father of two small children, and a darn fine programmer. David Edwards is a software engineer for the Distributed Computing Technology Division of SAIC. He has a BS degree in Computer Science from the University of Missouri at Rolla, and is pursuing an advanced degree at George Mason University.