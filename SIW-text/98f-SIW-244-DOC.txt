Java Real-Time RTIMichael D. MyjakThe Virtual WorkshopP. O. Box 98Titusville, FL  32781 HYPERLINK mailto:mmyjak@imtinc.com mmyjak@imtinc.comSean T. SharpThe Virtual WorkshopP. O. Box 98Titusville, FL  32781 HYPERLINK mailto:Ssharp@imtinc.com ssharp@imtinc.comKEYWORDSHLA, Real-Time, Java, RTI, M&S, SimulationAbstractThe Java Real-Time Run Time Infrastructure (RTI) is being developed for the High Level Architecture (HLA) community by The Virtual Workshop, Inc. for commercial distribution though HLA Products, Inc. The Java Real-Time RTI features several innovative concepts and design approaches targeted to meet the needs of the compile-once, run-anywhere, real-time RTI user.  This paper describes the overall architecture and features of the Java Real-Time RTI.  The paper will discuss the architectural tradeoffs required to satisfy the overarching goals of the RTI development: 1) Broad platform and network independence, and 2) Maximum throughput with absolutely minimal latency, 3) Support for streaming data types, and 4) Federate and federation "cut-through" functionality.  Specifically, the paper details the system architecture for the RTI and includes the results of trade-off studies investigating RTI hierarchy, RTI transport protocols, and the maintenance of global RTI state information.IntroductionIn the early days of simulation, modeling was simple.  There were continuous simulations and there were discrete simulations. Continuous simulations were generally comprised of solutions to differential equations, while discrete event simulations caused objects to be subject to temporal causality. Then Monte Carlo simulations followed, employing analytical representation based on repetitive statistical trials. Natural evolution saw that various combinations were also interesting, such as combined discrete event simulation with continuous simulation, or discrete event simulation with analytical modeling.There were also several variations or extension types of simulation systems (based strictly on their underlying architecture).  For example, parallel simulations may run on one multi-threaded processor (or parallel platform), while distributed simulations operate over several physically autonomous platforms.  Then of course, when you add a human-in-the-loop to the equation, you have an interactive simulation.  Finally, when dissimilar simulation components are generated independently and brought together in order to interoperate, the result is what we now call a federated simulation.Naturally, different simulation methodologies can be combined with any of the various extension types.  A parallel discrete event simulation for example, typically involves functional decomposition, perhaps message passing, and even shared memory architectures. Such systems are often used to speed-up execution time over stand-alone systems.  They’re also used in feasibility studies where the problem domain is often too large for a single computer.  And of course, they are often used in research.  Distributed simulations typically involve a network of processors sharing a common communication architecture or infrastructure (e.g., the Internet, WWW, etc.).  Distributed simulations and distributed interactive simulations are used in feasibility studies, in organizational collaboration, or in training. Furthermore, interactive simulations are often characterized as being real-time or quasi-real-time.The motivation behind the development of federated simulation systems is the reuse of legacy systems, data acquisition and confirmation, as well as system integration. In particular, this includes the integration of disparate simulation systems and extension types. Today, this integration of federated modeling components is evolving around the High Level Architecture (HLA).  HLA, through a designated Run time Infrastructure (RTI), provides this integration so that complex federations can be generated that are more involved than the individual components (i.e., federates) could produce alone.  BackgroundWe can trace the roots of HLA back to the development of the SIMulator NETworking (SIMNET) project sponsored by DARPA, and the Aggregate Level Simulation Protocol (ALSP), originally proposed by The MITRE Corporation.  ALSP was created to investigate ways to generalize and systematize a (con) federation in which disparate constructive simulations would work together to support joint military training exercises [Fischer, 95].  In the live and interactive communities, SIMNET also gave rise to Distributed Interactive Simulation (DIS).In this lineage of HLA, constructive or “aggregate level” (i.e., ALSP based) simulations demonstrated 3 unique requirements beyond those identified in SIMNET and DIS:Time management - simulation time must be a coordinated event so that causality can be maintained for all joined simulation applications.Data management - each simulation application (or application process) uses its own database, so a common method of sharing information was required.Architecture - simulations used their existing architectures, and would also be enable to exist in an ALSP Confederation. Like ALSP simulations [Miller, 96], HLA adopted three (3) major principles from the “entity level” environments using DIS:A federation has no central node (i.e., no server). Simulations can be geographically distributed (i.e., they can reside in different locations).Information between simulation applications (i.e., federates) is distributed using a pre-defined interface resembling message passing in object-oriented design.Today, federated simulations are based on HLA and have no requirement for a central computational process.  Nor is there any requirement to support and sustain a centralized database, as federates themselves are responsible for the data being passed through the federation, via the RTI. And the federates (e.g., simulation applications, loggers, wide area viewers, etc.) are permitted to join and depart from the federation at will.Better control over exercise design is also facilitated with HLA because federates, like DIS-based simulation applications, can be geographically dispersed. Interactors and federates can be co-located with their controllers or conversely, exercise managers can make better use of often limited computational resources at geographically dispersed locations.On this last point we begin to see some divergence with HLA.  With DIS and ALSP, a message-based low-level protocol was used, and it operated at the transport layer. This is in keeping with the open systems interconnect initiative in that it provided system and vendor independent functionality to user-level applications. [Stallings, 87] [Henshall, 88] [Knightson, 88] DIS used standardized Protocol Data Units (PDUs) at the transport layer [IEEE-1278.1], while ALSP data was formatted in plain text. [Miller, 96]  HLA on the other hand, claimed more of an object-oriented interface, as defined in the Federate Interface Specification [IFSPEC, 98].  But this specification does not explain how geographical distribution will work over heterogeneous environments.If we look more closely “under the hood” of HLA, the Federate Interface Specification identifies the Application Program Interface (API) between HLA federates and the RTI.  In the OSI model, this is referred to as the seventh or application layer agent process that manages the API. [Comer, 91] These layer standards were designed to provide reliable, end-to-end communications between computers of different origin, thus removing an applications constraint of commercial dependency from a particular vendor [Chapin, 89].  It is precisely this layer that best describes the services offered by the HLA RTI.  The Federate (or RTI) Interface Specification clearly describes an Application Program Interface that, like any application layer entity, communicates with its peers (i.e., cooperating RTI application instances) by identifying the relationship between its API and the underlying communication protocol (i.e., the “bits on the wire”).  Typically, this is a 1:1 relationship.  Hence, the RTI describes and defines the system independent services used by a cooperating federate application, and thus operates according to ISO-7498. [Myjak, 97a]Without an RTI, federates cannot interoperate. Therefore an RTI is quintessential to supporting federation interoperability.  However, without a standardized communication protocol as an underlayment to support the HLA RTI, interoperability as we’ve known it (i.e., end-to-end, in a heterogeneous environment), is not to be achieved.  Instead, only well-defined, homogeneous environments will be supported where vendor and platform dependencies exist. And perhaps to some, that is sufficient.If we analyze how Application Layer Protocols implement their system independent functionality, we note that they employ system dependent services. In other words, each implementation is platform and vendor specific. Similarly, the same is true for the DMSO versions of the RTI. Different implementations are required to operate over different hosts, and thus utilize different supporting services.  To the user’s application (in this case, the federate), the RTI interface may still appear to be the same. But an RTI compiled to run on a Sun platform is not the same animal when compiled to run on an Intel platform, even if they implement the same RTI interface!  Since no attempt has yet been made to define how any two RTIs will interoperate with one another, the simulation community is left with a framework that provides an interoperable solution only for heterogeneous equipment supported by a particular vendor. In other words, under HLA, simulator interoperability is being “stove piped.” [Briggs, 98]Why JavaThis is precisely the environment where Java excels, with its “compile once, run anywhere” metaphor. In Java, platform independence is virtually guaranteed by the Java Virtual Machine (JVM)! An RTI developed upon a virtual machine, such as the JVM, would be capable of being transportable to a wide variety of platforms; at least to as many platforms as are support by the JVM. So unlike the transport layer interface used by DIS and ALSP, the JVM-based Network Application Program Interface (NAPI) would not have to be redeveloped every time a new host or platform was targeted for deployment.  And clearly, Java can support a higher level of abstraction (for the interfacing application). This is particularly evident in the object-oriented sense, where this paradigm is native to Java. This then sets the stage for TVW, Inc., to develop an RTI that addresses the original HLA mandate: create an infrastructure which provides “… a common technical framework to facilitate the interoperability of all types of models and simulations … as well as to facilitate the reuse of modeling and simulation (M&S) components.”  And to evaluate and test this hypothesis, a fledgling HLA RTI, developed in Java, is currently under development, with initial product offering to be made available during the first quarter of 1999.The remainder of this paper describes the overall architecture and features of the Java Real-Time RTI. Specifically, the paper details the system architecture for the RTI and includes the results of trade-off studies investigating RTI internal hierarchy, RTI transport protocols, and the maintenance of global RTI state information in support of real-time applications.Platform And Network IndependenceSeveral architectural tradeoffs were required to satisfy the overarching goals of this RTI development.  Perhaps the most significant was the goal to provide a broad spectrum of platform and network independence.  As indicated above, platform independence is typically guaranteed by employing standard (and de facto standard) network communication approaches, as outlined in the OSI or Internet protocol stacks.  However, the current homogeneous development of the DMSO HLA RTI precluded this level of interoperability.  Since heterogeneous interoperability was our goal, we investigated several alternative solutions.  One opportunity, the success of which was not assured, was the development of a real-time CORBA environment.  As in the original DMSO RTI development, the Object Request Broker  (ORB) infrastructure of CORBA would have been sufficient, if a real-time implementation had been available.  Rumors were floating around that Iona, makers of Orbix ™, was developing just such an ORB.  However, in over a year and half, no such implementation has ever materialized.  Secondly, since by definition, CORBA is built upon the connection-oriented Transmission Control Protocol (TCP) where reliability in delivery is assured, there was no guarantee that such a real-time ORB (and consequently, an RTI) could support native IP Multicast. And native multicast appeared to be a requirement for some of the more complex services, such as Data Distribution Management, in an RTI.Another implementation alternative to using the CORBA infrastructure would have been to develop an RTI in “C++” (similar to the “C” versions currently being offered by DMSO, or under development by SAIC).  This approach was also dismissed, as it would have been fraught with the same kind of interoperability problems that plague the current implementations. Similarly, other languages, such ADA and the ILU were dismissed.  To ultimately resolve the issue of cross-platform interoperability, we realized that SISO would have to stand up a study group and ultimately determine the best course of action to take.  Since this might include the determination that an RTI-to-RTI interface was necessary, that approach would entail a large-scale rewrite of our development effort.  (Something that a small startup business couldn’t afford to do.)  Our final solution was to look to elsewhere.When we investigated Java back in late 1996, the metaphor of “compile once, run everywhere” was enticing, if not romantic.  Java at that time was also a bit slow, and not known for its performance. Still, the entire concept spoke of interoperability, and not just as a system-independent service, but instead as a complete and independent machine!  Without going into the details of how Java and the JVM accomplish this, even the layperson can realize the advantage of such an environment.  And when coupled with Sun Microsystems recent press announcement at Java-1, that recent releases will exhibit similarly performance characteristics to compiled C++ code, our risk factor appeared to be further reduced.Ok, so a Java Virtual Machine can be created for a multitude of platforms. Could such an implementation be used to create on RTI? According to [Karlsson, 98], it can.  So the next question we had to investigate was whether the Java environment, with its cross-platform functionality, would be able to provide the system independent functionality required by the RTI services.  The answer was a resounding, Yes! Well, provided some changes are made to the draft Federate Interface Specification appendix detailing the Java API.  Java v1.1.5, and the new Java v1.2-beta implement the Internet Protocol suite, thus ensuring that an RTI instance on one JVM could peer with a JVM on another platform.Maximum Throughput, Minimal LatencyOur second design objective with the Real-Time Java RTI was to provide an infrastructure which produced maximum throughput with absolutely minimal latency.  One might say that on the face of it, this appears to be a support contradiction.  However, maximum throughput is not the same thing as maximum bandwidth. Our objective is to produce, when required, a near maximum amount of data throughput between any two instances of the Java Real-Time RTI.  High throughput therefore, implies low(er) overhead Similarly, minimal communication latency is also a desired characteristic of the Java Real-Time RTI. To achieve this in a multi-function application such as an RTI, a multi-threaded solution is needed. We therefore plan on making full use of Java’s multi-threaded capability in the Java Real-Time RTI.  So low overhead, in addition to low latency, is exactly what’s called for in order to support real-time, distributed interactive simulations.Since an RTI operates a couple of levels above the transport layer, more processing of the data is required in order to transport the attribute data from the source federate to the destination federate(s).  For example, DDM processing may be required in order to provide source and destination relevance filtering of the data.  While this is accomplished by the RTI under HLA, no similar metaphor exists within DIS, as most applications simply used a subnet broadcasting paradigm.  Relevance filtering and processing time, if employed at all, was done entirely by the receiving DIS application after the data had been transferred to the receiving application.  And since this data was broadcasted to every host, the impact of irrelevant data may have been deemed costly.Still, broadcasting the data to all receivers within a subnet is still more efficient than say unicasting the same data to each host in the simulation exercise, particularly when the number of hosts involved number more than a few.  Similarly, one, two, or a few IP multicast groups can be used in a similar fashion.  The technique chosen by the developers of the Java Real-Time RTI was to provide an interest map of data relevant to each RTI and federate instance.  Upon receipt of an inbound datagram, the local RTI instance will compare the compound update with its local interest map.  Only those items (indicated by the interest map) relevant to the process(es) on the local host, will be passed up to the resident federate(s).  As updates or changes are made to the routing spaces (for DDM) or through the internal RTI declaration, ownership or object management tables, these changes will be reflected in the local RTI’s interest map.  This technique should provide for an absolute minimal amount of RTI-to-RTI transport latency, while still maintaining a high degree of throughput between federation entities.Streaming Data TypesSupport for streaming data types, URL references, and “out-of-band” communications from within the DMSO RTI are not currently indicated as being directly supported by the draft Federate Interface Specification [IFSPEC, 98].  In our design, we have chosen to address these data types as being fundamental to support seamless, cross-platform interoperability. Here is why.At the last DIS workshop (a.k.a. the first SISO Interoperability Workshop or SIW), Dr. Don Brutzman made a presentation to the Communications Architecture and Security (CAS) Working Group entitled “The Virtual Reality Transfer Protocol [VRTP] or Cyberspace Backbone (Cbone) Design Rational”.  In this presentation, he demonstrated four principal components of VRTP that “… if done really well, can support scalable interactivity on the scale of the Internet.” The four key components identified as required by Dr. Brutzman for VRTP were: 1) 	Support for Lightweight entity interactions (e.g., ES-PDUs), 2)	Network pointers (e.g., URLs), 3)	Support for Heavyweight objects (e.g., HTTP Client/server requests), and 4)	Real-Time Streams (e.g., Mbone audio video). And so began our work to develop a VRTP, capable of supporting HLA.Taking the last of Dr. Brutzman’s goals first, we recognized the need to support real-time streaming data.  Initially, this appears to be is something that is outside the scope for the HLA framework.  However, upon closer examination it becomes quite clear that the Federate Interface Specification is silent on precisely how an HLA RTI might go about implementing real-time data streams.  Obviously, support for streaming data is warranted in the M&S communities, as there are many examples of this kind of data in real life.  Radio, Radar and other electromagnetic emissions for example, would benefit greatly from support for streaming data types.  Similarly, the very act of exercise management over a geographically dispersed area would be greatly enhanced if the same HLA RTI could support interactive video conferencing between federation managers and other participants.So with this in mind, we began working on the design of VRTP with Dr. Brutzman.  Owing to good software design principles, we began our first step by selecting our transport and session layer protocol mechanisms first.  We chose to develop our VRTP implementation around the Real-time Transfer Protocol (RTP). RTP v2 is a protocol standard developed under the Audio/Video Transport Working Group (AVT) in Internet Engineering Task Force (IETF).  [For more information, see http://ietf.org.]We chose RTP for several reasons.  First, RTP supports a simple connectionless transport medium (i.e., UDP/IP).  On top of UDP/IP, RTP adds a minimal header consisting primarily of a time stamp, a sequence number, and a few other useful bits like protocol version number.  Like DIS PDUs, the time stamp is useful in determining when the data being transmitted was generated. Similarly, the RTP sequence number is useful in that it number permits TCP/IP-style serialization to occur at the receiver.  So by using RTP, we gain several distinct advantages over vanilla UDP/IP:1)	We can tell how long the data took to arrive at its intended destination, 2)	We can reconstruct the original message in sequence order, and3)	We have a simple mechanism available in which to implement time-stamp ordering upon receipt. For these and other proprietary reasons that we will not cover in this paper, TVW, Inc. has chosen to build VRTP around RTP, and use that as the basis for supporting the Java Real-Time RTI."Cut-Through" Functionality.The first goal identified by Dr. Brutzman indicates that lightweight interactions must be supported.  We believe that this is fundamental, and is in part a baseline design criteria behind the HLA framework.  The second and third goals however, are not directly supported by HLA.  In fact, the draft Federate Interface Specification does not mention or identify how network pointers (e.g., Universal Resource Locators) or heavyweight objects (e.g., peer-to-peer or client-server requests) are to be implemented.  One might even take the view that these operations are simply outside the scope of the HLA framework as it stands today.  Our belief is that these types of operations are indeed necessary and should be supported, at a minimum as extensions to HLA, and optimally, as embedded-data handler operations in support of higher level services.Our approach will be to ensure that internal support, within the RTI and its supporting VRTP will be capable of managing these data types.  Should future standardization of the HLA RTI provide this type of capability, then our implementation will of course, be readily adaptable.  On the other hand, if our customers require some specific enhancements, then we will gladly make these operations available to them, in support of RTI “cut-through” functionality.ConclusionUnlike DIS Entity State PDUs, HLA attributes and interactions are to be updated only when they change significantly in value. In sharp contrast, DIS Entity State PDUs bundle many discrete attributes together into a single, complex, yet standardized datagram. Since DIS applications where required to transmit the entire Entity State PDU whenever a single datum changed value, many discrete attributes were placed “on the wire” needlessly. This caused a measurable amount of redundant data to be passed between hosts.Furthermore, and in many instances, DIS updates were passed regardless of whether an entity had changed state.  HLA attempts to reduce this redundancy by limiting these “heart-beat” transmissions.  However, [Wuerfel, 98] showed that despite the fact that HLA only sends the data that changes, the RTI update packet was overall larger in size than its corresponding DIS Entity State PDU. In this case, their research showed that both processing time and protocol overhead were increased in HLA when compared to a similar exercise using DIS and DIS-Lite.Still, the notion of transporting only changed data while maintaining state consistency (with low overhead) is worthy of further study. By supporting the transmission of only changed data, HLA is in fact trying to be supportive of lightweight entity interactions.  With embedded support for Network pointers (e.g., URLs) as a native type, the Java Real-Time RTI can support federation “cut-through” functionality and heavyweight objects (e.g., HTTP Client/server requests).  In addition, Real-Time Streams (e.g., audio, video or electromagnetic emissions) will also enjoy native support. It is therefore up to the RTI implementers to discover how to support this level of interaction efficiently.  At TVW, Inc., we believe that we have developed a scheme which both supports the HLA paradigm of transmitting only changed data, while at the same time, meeting the lower overhead standards as set forth by our predecessor, DIS.  We can also say that early indications show that we have managed to at least accomplish the efficiency in communication transfer of DIS. Furthermore, we have good reason to believe that we can even surpass our own preliminary results.Bibliography[Chapin, 89]	Chapin, A.  L., “Status of OSI Standards,” Computer Communication Review, Vol. 19, no. 3, pp. 99-118, July 1989.[Comer, 91]	Comer, D.  E., “Internetworking with TCP/IP,” Prentice Hall, Englewood Cliffs, New Jersey, 1991.[Briggs, 98]	Briggs, Keith, “A Required RTI Gateway As A Solution To RTI Interoperability,” Proceedings of the 3rd Simulation Interoperability Standards Organization (SISO) Simulation Interoperability Workshop, 97s-SIW-188, Orlando Florida, March 1998.[FAQ, 98]	Defense Modeling and Simulation Office (DMSO) High Level Architecture (HLA) Website, http://hla.dmso.mil/ Frequently Asked Questions (FAQ), dated 1 July 1998.[Fischer, 95]	Fischer, Mary C., “Aggregate Level Simulation Protoc (ALSP) - Future Training with Distributed Interactive Simulations,” U. S. Army Simulation, Training and Instrumentation Command. Presented at the 1995 International Training Equipment Conference, at The Hague, Netherlands, 25-27 April 1995.[Griffin, 97]	Griffin, Sean P., and Ernest H. Page, Zachary Furness, Mary C. Fischer, “Providing Uninterrupted Training to the Joint Training Confederation (JTC) During Transition to the High Level Architecture (HLA),"Proceedings of the 1997 Simulation Technology and Training (SimTecT) Conference", Canberra, Australia, 17-20 March, 1997. [Henshall, 88]	Henshall, J., and Shaw, W., “ISO Explained: End-to-End Computer Communications Standards,” John Wiley & Sons, New York 1988.[IEEE 1278.1]	“Standard for Distributed Interactive Simulation - Application Protocols,” Copyright SYMBOL 211 \f "Symbol" 1995 by the Institute of Electrical and Electronics Engineers, Inc. 345 East 47th Street New York, NY 10017, USA[IEEE 1278.2-1995]	“Standard for Distributed Interactive Simulation - Communication Services and Profiles,” Copyright SYMBOL 211 \f "Symbol" 1995 by the Institute of Electrical and Electronics Engineers, Inc. 345 East 47th Street New York, NY 10017, USA. [IFSPEC, 98]	Defense Modeling and Simulation Office (DMSO) High Level Architecture (HLA) Website, http://hla.dmso.mil/ The Draft Federate Interface Specification.[Karlsson, 98]	Karlsson, Mikael, “Experiences from Implementing an RTI in Java,” Proceedings of the 2nd Simulation Interoperability Workshop, 98s-SIW-062, March, 1998.[Knightson, 88]	Knightson, K.  G., and Knowles, T., and Larmouth J., “Standards for Open Systems Interconnection,” McGraw-Hill, New York, 1988. [Miller, 96]	Miller, Gordon and Anita Zabek, March 1996, “The Joint Training Confederation and the Aggregate Level Simulation Protocol,” The MITRE Corporation, published in the June 1996 edition of Phalanx, a MORS publication.[Myjak, 97a]	Myjak, Michael D., and Sean Sharp, “HLA RTI: An Application Layer Protocol,” Proceedings of the 1st Simulation Interoperability Standards Organization (SISO) Simulation Interoperability Workshop, 97s-SIW-112, Orlando Florida, March, 1997[Myjak, 97b]	Myjak, Michael D., and Raymond E. Giroux, Sean Sharp, “DIS To HLA Integration, A Comparative Analysis,” Proceedings of the 1st Simulation Interoperability Standards Organization (SISO) Simulation Interoperability Workshop, 97s-SIW-131, Orlando Florida, March, 1997[Rose, 90]	Rose, Marshal T., “The Open Book: A practical Perspective on OSI,” Prentice Hall, Englewood Cliffs, New Jersey, 1990.[Stallings, 87]	Stallings, A., “Handbook of Computer-Communications Standards, Volume 1: The open Systems Interconnection (OSI) Model and OSI-Related Standards,” Macmillian, New York, 1987.[Stevens, 90]	Stevens, W.  R., “UNIX Network Programming,” Prentice Hall, Englewood Cliffs, New Jersey, 1990.[Weatherly, 96]	Weatherly, R.M., and A.L. Wilson, B.S. Canova, E.H. Page, A.A. Zabek, M.C. Fischer, “Advanced Distributed Simulation Through the Aggregate Level Simulation Protocol,” published in Proceedings of the 29th Hawaii International Conference on System Sciences, Volume 1, pp. 407-415, Wailea, Hawaii, 3-6 January 1996.[Wuerfel, 98]	Wuerfel, Roger, Lt. Purdy, Steven G., “A Comparison of HLA and DIS Real-Time Performance,” Proceedings of the 3rd Simulation Interoperability Standards Organization (SISO) Simulation Interoperability Workshop, 98s-SIW-188 Orlando Florida, March1998.About The AuthorsMichael Myjak Is Vice President of The Virtual Workshop, Inc., and is chief architect of the Java Real-Time RTI.  He was formerly a Senior Research Scientist at the Institute for Simulation and Training, at the University of Central Florida. Mr. Myjak recently completed a tour as Chair of the Run Time Infrastructure and Communications Forum, and was recently elected to the to SISO’s Standards Activity Committee (SAC). Mr. Myjak also Chairs the Internet Engineering Task Force’s (IETF) Large Scale Multicast Application (LSMA) working group, and is active in the Web 3D consortium and the Internet Research Task Force Reliable Multicast Research Group. Sean Sharp is a recent graduate of the University of Central Florida, where he graduated Magna Cum Laude in Computer Science. Mr. Sharp is currently the Principle Software Engineer at The Virtual Workshop, and comes to TVW as former research assistant at the Institute for Simulation and Training, where he has several years of experience in simulator networking and analysis. For his contributions to the performance analysis of the Platform Proto Federation, Mr. Sharp received the 1997 Student Researcher Award from IST.  In the near future, Mr. Sharp will be looking to obtain his Masters Degree in Computer Science. This refers to the protocol layering mechanism known as the Open System Interconnect (OSI) initiative, and standardized under the International Standards Organization (ISO). [Chapin, 89] [Comer, 91] The Application Layer entity is unique among the various layer entities in that it supports both entity interaction with the layer beneath it, and an agent process to manage the API to the cooperating application above it. The reader should note that because the two RTIs in this example support different platforms, they are indeed, different. Thus the chances of obtaining interoperability between these two are not the same as if the same RTI was utilized over a common platform. Under these conditions, simulator interoperability can only be achieved when a single, homogeneous version of the RTI, procured or produced by a single vendor, is provided. Under version 4 of the Internet Protocol, IP Multicast is managed as a separate (i.e., Class-D) address space.  Since reliability for IP multicast is as yet undefined, the only transport mechanism available would be connectionless (IP/UDP). Throughput is a measurement of the ratio of total data transmitted relative to the communications overhead. ACK or NACK based recovery is not directly supported by RTP.Measured as a percentage of throughput over total bandwidth utilized.