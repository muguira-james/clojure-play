The JSAF Control Protocol Bill HelfinstineChristopher YoungSheetal BrahmbhattMatthew LeVanLockheed Martin Simulation, Training, and Support164 Middlesex TurnpikeBurlington, MA  01803 HYPERLINK "mailto:bill.helfinstine@lmco.com" bill.helfinstine@lmco.com HYPERLINK "mailto:chris.a.young@lmco.com" christopher.a.young@lmco.com HYPERLINK "mailto:sheetalsemail@lmco.com" shital.a.brahmbhatt@lmco.com HYPERLINK "mailto:matthew.levan@lmco.com" matthew.levan@lmco.comKeywords:JSAF, HLA, Control Protocol. ABSTRACT: The JSAF simulation system is a distributed system that is capable of simulating a large scenario on many independent processors.  The means that it previously employed to provide this capability is the Persistent Object (PO) protocol, which it inherited from the legacy ModSAF simulation.  In the course of supporting the scalability and control needs of the Navy Warfare Development Command's Fleet Battle Experiments, and the Joint Forces Command's Joint Experimentation events, the PO protocol has reached the limits of its scalability, and has become an impediment to achieving the goals of these experiments.This paper describes the new protocol that we have designed to replace the PO protocol, which we call the JSAF Control Protocol (JCP).  It is designed to allow much expanded breadth of control, with significantly lower processing and bandwidth requirements.  It allows explicit specification of the responsibilities of each JSAF operator, and allows simulation controllers to reassign control of simulated units as necessary.  Furthermore, it is designed to use simulation capacity that is possibly located long distances from operators, such as High-Performance Computing resources in centralized locations. Finally, the protocol is documented in a fashion that allows it to interoperate with non-JSAF simulators, while still allowing JSAF developers the flexibility to rapidly modify and extend behaviors.1. IntroductionThe Joint Semi-Automated Forces (JSAF) simulation is a large system that provides a rich environment for performing a number of different styles of simulation events [1].  It is an HLA-compliant simulator that participates in a wide range of roles, all the way from large-scale joint experimentation events [2], through large-scale fleet training exercises [3], and highly-detailed large-scale urban discovery experiments [4], all the way to detailed individual soldier training systems [5].  The JSAF simulation is the result of fifteen years of development through its heritage in the US Armyâ€™s ModSAF (Modular Semi-Automated Forces) simulation, and the DARPA Synthetic Theater of War program.  It has come to be a major simulator system that is used by the Navy Warfare Development Command and the US Joint Forces Command, both of which are engaged in large-scale events that require dozens of operators to provide input in a human-in-the-loop style of operation.1.1 The Persistent Object protocolA major component that JSAF inherited from the earliest versions of ModSAF is the Persistent Object (PO) Database [6], which is a networked database of command and control data that is shared using a DIS-like broadcast protocol.  This protocol is referred to as the PO protocol, the data shared using this protocol are referred to as PO objects, and the collection of the PO objects is known as the PO database.   The typical way that JSAF is used is to configure one workstation to run the graphical user interface (GUI) and to configure two to four workstations as simulators, all of which share a PO database.  The operator will then control and monitor the vehicles simulated by those machines, which will interact with other vehicles in the simulation produced by other simulators.  This group of three to five machines is then repeated as many times as necessary to simulate the scenario of interest.  1.2 Issues with the PO protocolIn the previous several years, JSAF has evolved quite a bit.  The advent of the High Level Architecture (HLA) [7] has brought a number of capabilities to simulations that were not available in the early 1990s when ModSAF was designed.  The JSAF simulation has been expanded to take advantage of these capabilities to provide much better scalability and higher fidelity [8] [9].   Much larger scenarios are now run on a regular basis, both with realistic vehicle densities run in urban areas, as well as million-plus vehicle counts run over much larger areas [10] [11].However, the PO protocol has not scaled well compared to the rest of the JSAF simulation, with the number of machines capable of being grouped together into a PO database remaining capped at around ten for reasonable usage.  This results in a number of restrictions in how exercises are structured, with each operator being fully in control of their vehicles for the entire lifetime of the vehicle, and there is no way to hand off simulation to balance load or to concentrate a focus on a particular interaction of interest.  Since each operator is effectively isolated in a separate area of control, this also makes it impractical to share graphics and do collaborative operations.Additionally, the PO protocol is a very heavy consumer of bandwidth, and works very poorly in the face of large latencies, which makes it unusable over wide-area network links.  This makes it very problematic to use distant computing resources to operate JSAF simulations, and since there is a great deal of interest in using supercomputing centers to operate simulations, this has become a significant barrier to accomplishing the goals of the simulation [12].Finally, the PO protocol is a heritage protocol that was designed to be used on DIS or SIMNET networks, and it therefore is limited to relatively small object sizes, due to its restriction that all objects must fit into a single Ethernet packet.  It also means that in order to interoperate with the PO protocol, it is necessary to implement the whole protocol, which runs over HLA using an opaque block of data inside a single interaction class.  Therefore, for practical purposes, it is impossible to interoperate with the PO protocol without using the JSAF implementation of PO, which requires the JSAF networking infrastructure.  This essentially means that it is far too difficult and intrusive for non-JSAF simulators to control JSAF-simulated vehicles in a detailed or complex fashion.  Due to this complexity, there have been a number of special-purpose control protocols designed, rather than having a general solution [13] [14] [15].1.3 What we are doing to address these limitationsOur primary goal in the project is to improve JSAF to allow more flexibility in assigning operators to simulated units.  An additional goal is to allow us to locate simulators geographically distant from the operators, in order to optimize network loads over wide-area networks.   Moreover, we need to make sure that we avoid introducing usability difficulties into the system when we add this flexibility.  Finally, as a secondary goal, we want to open up the protocol as much as possible, so that it can be documented in a way that enables interoperability.In order to accomplish these goals, we have decided that the PO protocol needs to be replaced.  We have designed an HLA Base Object Model [16] that encapsulates a set of objects and interactions that provide a means of controlling the capabilities of JSAF simulators without requiring constant updating of a large number of objects on the network.  There are four ways we have structured the data in order to better match how each category of data is used, and these different methods have different tradeoffs in ease of use, latency, and bandwidth.  These four categories are referred to here as graphics, units, unit-associated, and tasking.Additionally, we have determined that this new protocol will allow all operators in a simulation to share data between each other.  In particular, graphical overlays are very useful for planning operations, and operators have been asking for the capability to share notes and map notations more easily for years.  However, operators have also noted that it is very easy to accidentally modify or retask graphics or units that are another operatorâ€™s responsibility if there is no safeguard in place.  This safeguard is currently taken care of due to the isolation of each operator from othersâ€™ section of control.  Once we can share everything with everyone else, this safeguard needs to be provided explicitly by the software.  We have designed a permission scheme to accomplish this capability.2. Permission HierarchyIn many of the events that have used JSAF in the past to control large scenarios, the operators have been organized in a similar fashion to a military command hierarchy.  Because of this, we have designed the operator control to be able to break down into more and more detailed areas of control, with the ability for an area commander or exercise controller to step in and provide direction as the scenario dictates.The permission hierarchy is therefore built in a tree structure to provide this hierarchy.  The root node of this tree represents control over all simulated objects and graphics.  The subnodes of the tree represent finer and finer divisions of authority as you descend the tree.  See Figure 1 for an example of a permission tree.Units and graphical overlays are associated with a particular permission node.  This node represents the level of permission that is necessary to view an object, as well as what level of permission is necessary to modify or command the object.  Parent nodes have permission to view, refer to and edit objects owned by their children, while children have permission to only view and refer to objects owned by their parents.  A node has no access to its siblingâ€™s objects.  Each operator is then assigned a permission role.  Their JSAF Graphical User Interface (GUI) will then be set to the permission node that implements the role that they are assigned.  This would then allow a commander to create routes and units that subordinate operators would be able to use as a reference, or even to refer to directly in the case of a route to travel on.  Meanwhile the commander can edit or delete a route created by the subordinate and take control of the tasking of their units if need be.  The routes owned by a sibling node would not be displayed on an operatorâ€™s GUI and therefore he would not be able to use them.In short, there are two basic rules for determining what operations a GUI can perform.  If the GUI is the owner of a graphical overlay or a simulated unit, or the owner of the overlay or unit is a subordinate of the GUI, it can see, use, and modify the graphic, or monitor or command the unit.  If the GUI is a subordinate of the owner of a graphical overlay or unit, it is allowed to see, use, and monitor the object or unit, but not modify it.  See Figure 2 for another description of how this works.Additionally, each GUI can change its permission role if necessary during the simulation run.  For flexibility in changing assignments, it can be necessary to temporarily elevate a GUIâ€™s permissions, and when shifts change, operators might move from machine to machine.  To change a GUIâ€™s permission to a higher one, a password is required, but to release permissions and move down the tree, no password is required.Also, each graphical overlay or simulated unit can be reassigned to a different permission node than the one that created it.  This operation requires that the assigner have enough permission to modify both the node it is being assigned to as well as the node it previously was assigned to.  3. Graphical overlaysJSAF has the capability to create a number of different types of objects that are used to refer to places, routes, times, or as operational notes.  Most of these objects are used in graphical overlays that are drawn on top of the tactical map.  The basic graphic objects are points of various styles, lines/routes, and text notations, although there are several additional variations on these basic concepts.  These objects are grouped together into overlays, which are then able to be toggled on and off as a group.The way that we have implemented permissions for graphical objects is that we have given each overlay a reference to a permission node.  Therefore all the graphics in an overlay are owned by a particular permission role, and the access controls operate according to the rules we discussed in section 2.  See Figure 3 for an example of how graphical objects are handled. We implement the overlays and graphics objects as HLA objects.  They are created by whichever machine wants to create them, and are then owned (in the HLA sense) by that machine.  If another machine then wants to modify an object that is owned by another machine, and it has passed the permission rules we have set up, that other machine will use HLA ownership management to acquire ownership of all the attributes of that object.  It will then continue to own and update that object until some other machine decides it needs to take ownership.As a further enhancement, we have added an additional capability to the RTI-s partial RTI implementation [17], which we often use in a number of JSAF simulations.  This optimization allows attributes of a specially flagged transport type have the ability to transfer ownership of an object simply by a simulator starting to update it.  The former owner would then be informed that it no longer owns those attributes.  This lets us transfer ownership of graphical objects much more easily, without the overhead and latency of the full HLA ownership acquisition transaction.  Of course, this feature is not available in compliant RTIs, so performance does suffer in that case.Figure 3: Graphics Object Creation Message Flow4. Taskable UnitsThe main focus of JSAF is the simulation of virtual vehicles.  These vehicles are usually modeled as belonging to a military organization, and are therefore grouped together into units.  The TaskableUnit HLA object is the representation of one or more vehicles that can be controlled.  Each simulated vehicle in JSAF has a matching TaskableUnit object, as does each aggregated command group that JSAF models.In fact, in JSAF, vehicles are created in response to the creation of a TaskableUnit object.  That object then represents a unit that can accept commands. TaskableUnit objects may only be created by a simulator capable of modeling units.  Simulators announce their capabilities by means of a Simulator HLA object.  This object class also contains data concerning the simulation load, which is used to decide which simulator to assign a new unit to. Since JSAF GUIs do not have the capability to create TaskableUnit objects, there needs to be a way for operators to create, delete and modify units.  This is done by adding a UnitModRequest interaction.  The interaction specifies the assignment of the permissions node, the simulator on which to create the unit and the parameters required to fully describe the unit.  An example of the unit creation process is shown in Figure 4.Each JSAF GUI is responsible for making sure that the requests it sends are consistent with the permissions that it has been assigned.  The simulator assumes that any request it receives has already been checked for proper permission to modify, since only the GUI has the knowledge of what permissions it has.  In order for the GUI to do these checks, the TaskableUnit has a permission node assigned to it on creation.  This permission can also be modified at runtime through the use of a UnitModRequest asking it to change.  In response to the creation of a TaskableUnit on a particular simulator, that simulator will then create the vehicles that comprise the requested unit.  The simulation components that are used to model the vehiclesâ€™ physical details and behaviors are created based on the information that is passed in the TaskableUnit object6. Unit-Associated DataThe main reason that TaskableUnit objects exist is to provide a way of referring to a unit that can be tasked.  Additionally,  since TaskableUnit objects are available to any HLA federate that wants to receive them, they are suitable for top-level information GUIs that provide an overview of what is happening in all the JSAF simulators.  However, since the data in these objects is sent out to receivers continuously, we do not want to burden the network with a lot of detail about what is happening.  There is a large amount of simulation state that is associated with each unit, and we do not want to flood the network with that data.  Therefore, we have implemented a scheme where there is additional data associated with each unit that is not available on the network until someone has a need for it.  Figure 4: Unit Creation Message FlowVarious models that help compose the simulation of a particular unit will provide a way to create various subclasses of the UnitAssociatedData object class.  Then, if a GUI or other federate wants to ask to see data associated with a particular TaskableUnit, it would create a RequestUnitAssociatedData object that refers to the TaskableUnit that it is interested in.  In response, the simulator would then create the UnitAssociatedData objects for that TaskableUnit in the federation, where anyone who wants to see them can do so.  Therefore, if one or more RequestUnitAssociatedData objects that refer to a TaskableUnit are present, the data is sent out to all consumers.  Additionally, in order for GUIs to be able to modify unit-associated data, there is a SetUnitAssociatedData interaction base class, with subclasses that match the UnitAssociatedData subclasses.  This lets the GUI manipulate some of the details of the simulation of the units directly.  This is used quite a bit to provide direct operator control over the sensors and weapons that are mounted on ships, for instance.This arrangement allows us to have additional data about a particular unit available to operators that need to drill down into more detailed parts of the simulation, while still keeping the majority of data from overwhelming the network while nobody is interested in seeing it.  An example of the data flow in the unit-associated data is found in Figure 5.6. Tasking of UnitsBehaviors in JSAF are organized using a concept called TaskFrames [18].  Each user-level behavior is called a TaskFrame, which consists of a name and a set of lower-level Tasks that execute in parallel to implement a behavior.  To instruct a simulated unit to perform a course of action, an operator will assign a series of frames to a unit, possibly with conditions for transitioning from one frame to the next.  The graphical representation of this sequence of TaskFrames is called the JSAF Execution Matrix, and is usually drawn to show the TaskFrames that are being run by a unit and its subordinates.  An example of this representation is shown in Figure 6, which shows a tank platoon commanded to perform a Simple Move TaskFrame, followed by a Hasty Occupy Position TaskFrame, followed by a Hide TaskFrame.The execution matrix for a unit is represented in the federation as a TaskingState object.  This is a subclass of the UnitAssociatedData class, so it uses the unit-associated data system we describe in section 5 to manage when the data is shared on the network.  Figure 5: Unit-Associated Data Message FlowFigure 6: JSAF Execution MatrixAdditional detail beyond the TaskingState of a unit is provided by a set of TaskParameters objects, which are unit-associated as well.  These objects contain the actual input data that is used by the Tasks that comprise the TaskFrame.  This data is used by the GUI to allow inspection of the details of the behaviors, and modification of the behavior as necessary.Another monitoring object is also present in the form of a BehaviorStatus object, which is also unit-associated.  This object contains a set of text strings that describe the current status of the behaviors running on a unit.  The modification interaction that is used to request changes to the tasking is called ModifyTasking.  It contains an enumeration that describes how the tasking for a unit should be changed, the name of a TaskFrame to be added or modified, and any Task parameters that are required to drive the underlying behavior.7. Better Exposure of Data RequirementsOne of the main barriers to interoperability in the PO protocol has been the lack of documentation of large parts of the protocol.  This lack is done deliberately, in order to make development of behaviors easier and more flexible.  It is a very important characteristic of JSAF that new behaviors be as simple to add as possible.  This allows us to experiment with new concepts as they are developed, and also helps avoid bug-prone issues with not-quite-matching data structures, if they are required to be documented both in the implementation of the behavior as well as in a protocol definition.  As part of this project, we are converting all the formerly-documented parts of the PO protocol into fully-specified HLA object classes and interaction classes.  The behavior-specific data needs to be specified as well to provide a fully interoperable command and control system.  However, we cannot lose the benefits of having a single point of definition of all the behavioral data structures.  Therefore, as part of the JSAF compilation process, we are producing a data file that documents the structures that are used by each behavior.  This document is structured as a machine-readable description of all the available TaskFrames, all the data fields for each Task, and whether each data field is required to be specified, or whether it can be defaulted, and if so, what the default is.This document is similar in concept to an XML schema, but at the present time, we are not using XML for the data transfer requirements of the Tasks.  In the future, it is likely that we will switch over to using XML, simply because it is becoming the data interchange format of choice for many of the other simulations being used nowadays.Therefore, for any particular version of JSAF, there will be a document that provides the data requirements of that revision.  We believe that this provides a good balance between having a documented protocol and having the flexibility to modify the system rapidly.8. ConclusionThe new JSAF Control Protocol provides a much more friendly interface to the capabilities of the JSAF simulation.  It has a fully-documented protocol that is usable without requiring the use of JSAF code to implement it.  The span of operator control is much more flexible, dynamic, and powerful.  The protocol is drastically lighter-weight, and works well over long distance networks.  The capabilities that the new protocol brings to the system will help keep it functioning, relevant, and scalable well into the future.9. References [1] A. Ceranowicz, P. Nielson, and F. Koss: "Behavioral Representation in JSAF"  Proceedings of the 9th Conference on Computer Generated Forces and Behavioral Representation, Paper 9TH-CGF-058.[2] A. Ceranowicz, M. Torpey, B. Helfinstine, J. Evans, and J. Hines: "Reflections on Building the Joint Experimental Federation"  Proceedings of the 2002 Interservice/Industry Training, Simulation and Education Conference, Paper 322.[3] S. Gallup, G. Schacher, J. Jensen: "Fleet Battle Experiment Juliet Final Summary Report"  Naval Postgraduate School Report NPS-97-03-004, April 2003.[4] A. Ceranowicz and M. Torpey: "Adapting to Urban Warfare"  Proceedings of the 2004 Interservice/Industry Training, Simulation and Education Conference, Paper 1554.[5] P. Muller, J. Cohn, D. Nicholson: "Developing and Evaluating Advanced Technologies for Military Simulation and Training"  Proceedings of the 2003 Interservice/Industry Training, Simulation, and Education Conference.[6] J. Smith and A. Courtemanche: "Lib PO"  ModSAF Programmerâ€™s Guide, Loral Advanced Distributed Simulation, Cambridge MA 1993.[7] J. Dahmann, R. Fujimoto, and R. Weatherly: "The Department of Defense High Level Architecture"  Proceedings of the 1997 Winter Simulation Conference.[8] B. Helfinstine, M. Torpey, and G. Wagenbreth: "Experimental Interest Management Architecture for the DCEE"  Proceedings of the 2003 Interservice/Industry Training, Simulation and Education Conference, Paper 1435.[9] D. Moyer and D. Speicher: "A Road-Based Algorithm for Dead Reckoning"  Proceedings of the Spring 2005 Simulation Interoperability Workshop, Paper 05S-SIW-067[10] D. Speicher and D. Wilbert: "Simulating Urban Traffic in Support of the Joint Urban Operations Experiment"  Proceedings of the 2004 Interservice/Industry Training, Simulation, and Education Conference, Paper 1888.[11] S. Prager, D. Bakeman, S. Haes, and G. Goodman: "Malls, Sprawl, and Clutter: Realistic Terrain for Simulation of JUO"  Proceedings of the 2004 Interservice/Industry Training, Simulation, and Education Conference, Paper 1884.[12] R. Lucas and D. Davis: "Joint Experimentation on Scalable Parallel Processors"  Proceedings of the 2003 Interservice/Industry Training, Simulation and Education Conference.[13] D. Macannuco, J. Jones, R. Painter, C. Snow: "Multi-level Resolution Engagement Modeling Through a JWARS-JSAF HLA Federation"  Proceedings of the 2005 Spring Simulation Interoperability Workshop, Paper 05S-SIW-107.[14] M. Salisbury, L. Booker, D. Seidel, and J. Dahmann: "Implementation of command forces (CFOR) simulation"  Proceedings of the Fifth Conference on Computer Generated Forces and Behavioral Representation.[15] R. Moore, J. Dowding, H. Bratt, M. Gawron, Y. Gorfu, and A. Cheyer: "CommandTalk: A Spoken-Language Interface for Battlefield Simulations", Proceedings of the Fifth Conference on Applied Natural Language Processing", 1997, Association for Computational Linguistics.[16] P. Gustavson, J. Hancock, C. Stapleton: "The Base Object Model (BOM) Primer: A Distilled Look at a Component Reuse Methodology for Simulation Interoperability", Proceedings of the Spring 2001 Simulation Interoperability Workshop, Paper 01S-SIW-086.[17] J. Calvin, C. Chiang, S. McGarry, S. Rak, D. Van Hook, and M. Salisbury: "Design, Implementation, and Performance of the STOW RTI Prototype (RTI-s)"  Proceedings of the Spring 1997 Simulation Interoperability Workshop, Paper 97S-019.[18] R. Calder, J. Smith, A. Courtemanche, J. Mar, and A. Ceranowicz: "ModSAF Behavioral Simulation and Control"  Proceedings of the 3rd Conference on Computer Generated Forces and Behavioral Representation.Author BiographiesBILL HELFINSTINE is a developer and integrator of JSAF, as well as primary maintainer and developer of the RTI-s experimental RTI.  He has worked in M&S for 11 years, with the last several in support of JFCOM-sponsored exercises, culminating in Urban Resolve 2004.  He is a Senior Staff Software Engineer at Lockheed Martin Simulation, Training, and Support Advanced Simulation Center in Burlington MA.  He received his B.S. in Computer Science and Engineering at the Massachusetts Institute of Technology.  He was the protocol designer and software architect for the JSAF Control Protocol.CHRISTOPHER YOUNG is a Staff Software Engineer at Lockheed Martin Simulation, Training and Supportâ€™s Advanced Simulation Center.  A graduate of Boston University with a B.S. in Aerospace Engineering, he has a background in simulation and analysis and has led development efforts on JSAF and in the integration of HLA simulation in both constructive and virtual simulators since 2000.  He was the lead developer on the development team that implemented the JSAF Control Protocol.SHEETAL BRAHMBHATT is a Software Engineer at Lockheed Martin Simulation, Training and Supportâ€™s Advanced Simulation Center.  She holds a B.A. in Computer Science from the University of Central Florida and has been a JSAF developer since 2002.  She was a key contributor on the development team that implemented the JSAF Control Protocol.MATTHEW LEVAN is a Software Engineer at Lockheed Martin Simulation, Training and Support's Advanced Simulation Center.  He received his B.A. in Computer Science from Vassar College, and has been a JSAF developer since 2000.Examples (refer to  Figure 1):Blue.Ground.Infantry:RW to all  objects owned by Blue.Ground.Infantry.R to all objects owned by Blue.Ground, Blue and Root.No access to objects owned by Blue.Ground.Mech or Blue.Air.Blue.Ground:RW to objects owned by Blue.Ground.Infantry, Blue.Ground.Mech, Blue.Ground.R to objects owned by Blue and Root.No access to objects owned by Blue.Air.Figure  SEQ Figure \* ARABIC 2: Permission RulesFigure  SEQ Figure \* ARABIC 1: Permission Node TreeInherent permissions:Owner:	RWParent: 	RWChild: 	RSibling:	NonePermissions Definitions:Read (R)Is displayed on JSAF GUI and can be used as a target for taskingWrite (W)Can edit or delete graphic or change tasking for a unitCan transfer ownership of simulated object to another nodeCan create or delete a child node