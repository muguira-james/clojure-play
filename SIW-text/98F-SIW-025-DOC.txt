An Agile FOM FrameworkDavid MacannucoBrett DufaultLorie IngrahamLockheed Martin Information SystemsAdvanced Simulation Center37 North AvenueBurlington, MA 08103dmac@lads.is.lmco.combdufault@lads.is.lmco.comlingraham@lads.is.lmco.comKeywords: RTI, FOM AgilityABSTRACT: A major issue in the development of an HLA compliant simulation is the ability of a single federate to participate in multiple federations using different FOMs.  Current efforts to mitigate these problems through the use of standard names and formats, while important and necessary, do not solve the problem since the ability to use different representations is a powerful feature of the HLA.This paper presents information representing the HLA development process underway by the DMSO and the DoD AMG.  It describes a framework that addresses these FOM agility issues.  The Agile FOM Framework (AFF) provides the simulation with a set of classes that automatically map the internal SOM representation to the external FOM representation using data driven mapping definitions.  Through the use of the AFF, it will be possible to use a single simulation with multiple FOMs without code changes.IntroductionUnlike previous simulation interoperability standards, the HLA does not specify a protocol.  Rather, it provides a framework for documenting protocols and a flexible run-time infrastructure (RTI) for supporting the distributed execution of simulations using those protocols. [1]  Therefore, in the HLA, the RTI and a Federation Object Model (FOM) provides interoperability.  Federation developers are free to create FOMs using the data representations that suit the target application.  In order to promote the reuse of federates, standardization is being fostered through the use of reference FOMs, such as the Real Time Platform Reference (RPR) FOM and through the Object Model Data Dictionary which provides standard names and formats.  In addition, the object orientation of the Object Model Template (OMT), combined with the Declaration Management services provided by the RTI, provide simulation developers with methods to use only the portions of the FOM which are relevant to the particular simulation.  Therefore, it is possible to participate in multiple FOMs as long as the objects and interactions that the simulation cares about are the same.  The ability to have different FOMs for different federations is an important feature of the HLA.  However it also important that these federations are able to utilize certain types of general purpose simulations such as the ModSAF CGF.  The above techniques are not sufficient to provide the simulation with the ability to participate in multiple FOMs.  Since the thought of supporting multiple federations through supporting a separate ModSAF baseline for each federation, is not a pleasant one, an interface that provides FOM agility is clearly needed.  This paper describes an agile FOM framework (AFF) designed to enable ModSAF to participate in multiple federations using different FOMS.  Figure 1-1 Conceptual View of the AFFThe AFF is part of a larger effort to re-architect ModSAF for the HLA. [2]  The goal of the AFF is to allow the physical, behavioral and other models within ModSAF to be written to use the objects and interactions defined in the ModSAF SOM independent of the FOM being used for the current federation execution.  The AFF will use FOM mapping definitions provided in a data file to map the internal ModSAF SOM representation to the external FOM representation in a manner that is invisible to the rest of ModSAF.   Figure 1-1 illustrates this where the AFF is shown converting the SOM to the new SOM which is a subset of the target FOM.CapabilitiesThe capabilities that the AFF will provide were determined by examining a large number of FOMs and SOMs and determining the features needed to map between these different representations.  The AFF incorporates a wide range of capabilities, with the goal of having it support the largest possible number of FOMs.  What the AFF DoesThe sections below describe each of the important AFF capabilities along with the rational for providing them and examples when needed.  In these sections the federate’s internal representation is referred to as the SOM and the federate’s external representation is referred to as the FOM.  Unless otherwise noted, all capabilities that apply to objects and attributes also apply to interactions and parameters.Name IndependenceThe AFF makes no assumptions about the naming conventions of the SOM and FOM, and as such provides name independence between the two.  The AFF has no difficulty if a SOM class contains an attribute named Position while the FOM refers to the same data as Location in its classes.Attribute AtomicnessThe AFF can deal with attributes where the "atomicness" differs between the SOM and FOM.  For instance, the SOM may store position information in a single attribute, while the FOM contains three separate attributes for the same information (such as the X, Y, and Z components of a GCC coordinate).  The AFF's conversion processing can split complex attributes apart, and can also merge individual attributes together to form more complex ones.Attribute Determines ClassSOM and FOM class hierarchies may organize information differently; information that is considered an attribute on one side might be represented by having separate class hierarchies on the other.  As a concrete example, a SOM might have a Platform class containing a Vehicle_Type attribute which provides more information about the actual vehicle object, while the FOM might represent this using separate classes, perhaps having an M1 class, an M2 class, etc.  In cases like this, the AFF can perform run-time determinations of the appropriate FOM class based upon information contained in the SOM attribute, and (in the opposite direction) can fill in SOM attribute information based upon the FOM class received.  This will work well in cases where the SOM and FOM class hierarchies are organized along similar lines, and merely differ in whether a piece of information is represented as an attribute or as a new "leaf" of the hierarchy. Of course if the organization of the hierarchies are widely divergent, then it may be impractical or impossible to determine attribute/class associations.Unit and coordinate conversionsThe AFF permits the SOM and FOM to use differing units of measurement, with the AFF performing the necessary conversions between them.  This will span the range of relatively simple conversions such as meters-to-feet, and very complex conversions like GCS coordinates to GCC coordinates.Byte SwappingThe AFF can perform byte swapping to permit "little-endian" (such as Intel-based) and "big-endian" (SGI, Sun) hosts to interoperate.  Traditionally, ModSAF has converted data to big-endian form  before sending it out on the network, and the AFF will continue to support this.  The AFF, however, can be configured to support either byte-ordering for data.  This can result in improved efficiency in some circumstances, such as an exercise in which all computers are little-endian machines.  Instead of translating everything to big-endian format, sending it across the network, then translating everything back to little-endian format at each machine, the data can be sent in its native little-endian form and used without the overhead of byte swapping.DefaultingInevitably, there may be attributes in the FOM which do not have an equivalent in the SOM, or vice versa.  The AFF can provide default values that may permit the FOM and SOM to still work together.  For example, a SOM might have appearance information for a tank that includes whether a hatch is open or closed.  If a particular FOM omitted hatch information, then the AFF could provide the SOM with a "safe" default value such as "hatch closed".  While AFF defaulting is definitely not a panacea for all SOM/FOM differences, it provides a simplistic method of bridging over minor gaps between SOMs and FOMs.Enumeration MappingsIn many cases, SOM and FOM enumerations will not correspond exactly.  The same enumerals might exist on both sides but be ordered differently, or certain enumerals may not be present on both sides. The AFF's conversions can include mappings between SOM and FOM enumerations.  These mappings are essentially look-up tables that indicate which FOM enumeral corresponds to a given SOM enumeral and vice versa.  For enumerations where a one-to-one or many-to-one relationship exists, there should be no loss of information.  However, some information may inevitably be lost if there is a one-to-many relationship between the enumerals, or if there is no correspondence between certain enumerals. As an example of each case, consider the following:Table 2.1.7-1 Enumeration ExampleSOM Color EnumerationFOM Color EnumerationRedLight GreenGreenMedium GreenBlueDark GreenRedOrangeThe AFF can easily match the SOM's Red to the FOM's Red, and can similarly match any of the FOM's Light, Medium and Dark Green to the SOM's Green.  The limitations arise in cases like translating the SOM's single Green to one of the FOM's shades of Green in this case, the AFF would be configured to always select one shade (perhaps Medium Green).  For many applications, this may be perfectly usable.  A more serious problem might exist with the SOM color Blue.  Since there is no corresponding FOM color, an arbitrary decision must be made, such as mapping SOM Blue to FOM Orange.  For some exercises, this may be an acceptable solution, but for others this may be unacceptable.Attribute Maps to ObjectThe AFF can handle certain cases where the information represented by a single SOM class is represented by more than one FOM class (and vice versa, of course).  In this case, the individual SOM attributes must be mapped to the corresponding FOM objects.  This might occur if a SOM, for instance, has a Platform class that included Articulation information as an attribute, while the FOM put most of the same information into a Platform class, but has a separate class for Attribute information.  The AFF can then transparently handle the task of splitting the SOM Platform object into the corresponding FOM Platform and Attribute objects.  Attribute Maps to InteractionThe AFF will provide support for mapping between attributes and interactions.  An example of this is a SOM which stores transmitter information as part of its Platform class, and a FOM that considers transmitters to be interactions.  The AFF handles this by issuing a FOM interaction each time the SOM transmitter attribute is updated.  (Similarly, each time a FOM interaction is received, the SOM transmitter attributes are updated.)  Initially the AFF will only support this for the case where all the information required for an interaction is present in a single class's attributes.  A potential area for future research is the support of arbitrary mappings between attributes and interactions, such that an interaction could be formed from attributes belonging to multiple classes.DDM CapabilitiesThe AFF will provide some limited capabilities to allow flexibility in DDM routing spaces.  These include name independence for routing spaces and dimensions.  Also under investigation is flexibility in normalization, number of dimensions and other areas. What the AFF Doesn’t DoThe AFF is not a magical piece of software.  It has inherent limitations that must be made clear to avoid such a conclusion.  While some of these limitations may seem obvious, they are explicitly stated so that first readers will better understand the AFF’s design goals and have realistic expectations as to what the AFF can actually achieve.  Map to Any FOMHaving an AFF does not mean the simulation can participate in all FOMs.  While an attempt has been made to implement a wide range of capabilities, the underlying network representations of the simulation models must both be in the internal representation and the external representation.  So while,  the AFF will enable ModSAF to participate in a wide range of tactical military simulation FOMs, it can’t be used in a high fidelity quantum mechanics simulation.  It is also quite possible that some tactical military simulation FOMs cannot be supported by the AFF.SimulateThe AFF cannot be used to provide values for object attributes or interaction parameters when the simulation has no corresponding value.  The AFF does have a simple defaulting capability, but it provides a constant value that may be of some use to making the federation work.  It is not really simulating the value.Change the Time Management SchemeModSAF is a real time simulation that does not use the time management services of the RTI.  The AFF cannot make ModSAF run in a time constrained or regulating mode.  This is a potential area for future research, but it is not currently supported.AFF ArchitectureThe AFF is part of the RTI Interface Layer (RIL).  The RIL is a software layer that connects the application libraries with the RTI, as shown in Figure 3-1.Figure 3-1 HLA ModSAF Architecture OverviewThe RIL provides a set of abstractions designed to simplify coding for the RTI, to centralize RTI implementation and policy decisions and to provide FOM agility.   It is difficult to discuss the architecture of the AFF without also discussing the RIL, thus this section will discuss the RIL architecture as the context for performing the FOM agility operations and then provide more detail in the areas related to the AFF.RIL Architecture OverviewThe RIL is a set of C++ classes that have been architected to provide a convenient and powerful layer between the application and the RTI.  The goal is to provide:FOM agility as described in Section 2 of this paper.Convenient abstractions of RTI concepts.Automatic RTI processing when appropriate.Centralized RTI policy decisions.The RIL does not attempt to hide the fact that the simulation is using the HLA RTI.  The object/attribute and interaction/parameter paradigm is still used, however all calls to the RTI are made through RIL classes.  Figure 3.1-1 provides an overview of the RIL. EMBED Word.Picture.6  Figure 3.1-1 RTI Interface Layer Architecture DiagramThere are two loose groupings of classes.  One set, called classes, provides the connection between the application and the RTI.  The second grouping, known as services, provides functions that are not specifically related to connecting the application to the RTI, but are necessary to make the connection function.  Each of the following sections discusses the major components within the RIL.RTI Interface ClassesThe RTI interface classes are the RTI Ambassador Façade (RAF) and the Generic Federate Ambassador (GFA).  The RAF is a layer above the actual RTI Ambassador.  It provides one of following services for each of the RTI ambassador services:Pass through to the actual RTI ambassador callModification of the interface to be compatible with RIL data types and perform AFF functionality.Does not provide an interface, making it impossible for application layer libraries to call services that are restricted to RIL libraries.The GFA is a callback-based federate ambassador.  The application and RIL libraries can register objects to be called back when the RTI invokes a particular federate ambassador service.  This scheme inverts the dependencies between the federate ambassador and the rest of the application, creating a more extensible and maintainable application.Application Interface ClassesThe application interface classes consist of the Attribute Manager, the Parameter Manager and the Region Manager. Respectively, these classes are the primary interfaces to RTI objects, RTI interactions and RTI DDM regions provided by the RIL.   An instance of one these classes exists for each RTI instance known to the federate.  For example, if the federate has discovered 10 objects, then 10 Attribute Managers would have been created by the RIL.  These classes provide the following services for clientsAccess (sometimes indirectly) to relevant RTI services.  For example, the Parameter Manager supports a send service that causes the sendInteraction service of the RTI to be invoked. Automatic RTI bookkeeping.  For example, the Attribute Manager automatically tracks which attributes have changed so partial updates occur without intervention from the application.Automatic RTI callback handling.  For example, the Attribute Manager can automatically filter out any attribute transfer requests for attributes that are defined as non-transferable in the SOM.Coordination of AFF services.  For example, the Parameter Manager invokes the AFF conversion process when the send service is invoked.  Storage and Conversion ClassesThe storage and conversion classes consist of the Attribute Class and the Parameter Class, and the Converter Base Class.  The attribute and parameter classes store the data and state associated with a particular attribute or parameter instance.  For example, the Attribute Manager for an RTI object of class tank contains a collection of attributes, one for each attribute defined in the SOM for the tank class.  Since there can be large numbers of attribute instances care has been taken to keep the state associated with the attribute to a minimum.  Converters are an important part of the AFF and will be fully discussed in the following section. A Converter Base Class has been defined so that the conversion process can be performed without knowing the specific class of the converter.  The Converter Base Class also provides functionality required by all converters to simplify the task of creating converters.Creational ServicesThe creational services consist of three factory classes. [3]  These classes all serve the purpose of simplifying and optimizing the process of creating the objects for which they are responsible.  Since the AFF conversion process is data driven, converters are referenced by name in the AFF data file, e.g. “gcs_to_gcc.”  The Converter Factory allows individual converter objects to be registered by name and then retrieved by name when that converter is needed.  The converters use the prototype pattern [3], so when one attempts to retrieve a converter, the Converter Factory finds the object (known as the prototype) registered under the specified name, copies it and passes the copy back to the requester.  The Attribute Manager and Parameter Manager required for a particular object can be complex, especially when there are AFF data structures attached.  The Attribute Manager Factory maintains a prototype attribute manager, including all the required attributes and converters, for each object class.  When the application needs to create an object of that class or the RTI discovers an object of that class, the Attribute Manager Factory buildAttributeManager service is invoked.  This service copies the appropriate attribute manager prototype and provides the copy to the caller.  This process saves repeated lookups of the attributes and converters that need to be created for a particular object class.  The Parameter Manager Factory performs a similar service for Parameter Managers.  Database ServicesThe database services provide access to the data driven portions of the AFF, and include a special handle service.  The SOM and the FOM are read in by the RIL in the OMT format and this data is used to generate the RIL data structures.  The AFF mapping data is read in and also used to generate RIL data structures.  The RIL has specialized handle services that replace the RTI generated handles that are used to identify object classes, object attribute classes, interaction classes and interaction parameter classes.  These handles are full C++ objects, and provide capabilities to allow efficient access to data that is stored on a by object class, etc. basis.  Since internal and external attributes do not map one to one, these handles also provide AFF capabilities by associating internal and external handles.Object Name ServicesThe object name services consist of name/ID Hashing and the name assignment algorithm.  Each RTI Object is given a unique 64-byte name that is guaranteed to be unique and constant for the life of the object.  The name/ID hashing converts this name to a unique 32-bit ID that is needed by ModSAF.  The 32-bit RTI handle is not acceptable for ModSAF since it will change when the object goes in and out of scope and ModSAF has issues with this that are beyond the scope of this re-architecture.    Since the RTI allows the federate to assign the unique name, the name assignment algorithm has been encapsulated so that new assignment algorithms are easily inserted.AFF DetailsThis section provides more details into how the RIL converts data from internal to external representations.  The architecture discussion in the previous section does not provide a clear picture of how the AFF works at run-time. The details provided in this section explain the run-time process.   ConvertersThe key player in the AFF is the converter.  Converters are the primary means for manipulating the data from the internal representation to the external representation and visa-versa.  Converter requirements are listed in the table below along with the reason for the requirement.Table 3.2.1-1 Converter RequirementsRequirementReasonConverters must inherit from the converter base class. Allows for the easy addition of new converter types.Converters must register with the converter factory.Allows the application to access the converter by name.Converters are chainable.Increases the flexibility of the conversion process. Converters can be chained together, eliminating the need for special converters for each type of conversion.Converters are bi-directional.Allows a single specification for attributes that are being updated or reflected.  When a converter is invoked it is told which direction the conversion is going.Converters are actually application level code.  The RIL does not support any types of conversion directly.  Rather, through the Converter Base Class and Converter Factory, the RIL provides an extensible framework for converters.  As part of this effort however a robust set of converters has been created.  These include converters for unit and coordinate conversions,  a data-driven structure-mapping converter, and a data driven enumeration converter.An ExampleThe following example illustrates how converters are arranged for a typical type of conversion.  The example does not try to illustrate all the capabilities, but attempts to provide an illustration of some of the more common and interesting capabilities.  Assume the SOM specifies a position attribute in the global coordinate system (GCS), and the FOM specifies three position attributes (position_x, position_y and position_z) in the geo-centric coordinate (GCC) system. Figure 3.2.2-1 shows the run-time structure that would be created to perform those conversions.Figure 3.2.2-1 Example Converter ArrangementThe Attribute Manager contains an attribute object to for the SOM attribute position.  (Note: the Attribute Manager has an attribute object for each SOM attribute for the object class, not just a single attribute.)  The attribute object is linked to a converter chain that consists of four converters.  The first converter converts the GCS attribute to GCC.  The next three converters extract the individual components of the GCC vector.  These converters are responsible for writing the data to the data structure that is passed to the RTI.  The external attribute is specified in the reader file, thus the converters know when they should pass the output to RTI data structure.  This example shows the importance of chaining since a new GCS to GCC converter is not created for each combination of GCC components.  Note that the arrows point in two directions, thus allowing the same structure to be used for updating and reflecting attributes.  ConclusionsThe AFF provides ModSAF with the capability to participate in multiple federations using different FOMs without requiring costly code changes.  While the AFF cannot guarantee the ability to move to any FOM, the developers have attempted to provide a wide range of capabilities.  For cases where the AFF does not suffice, it is likely that it will greatly reduce the amount of changes required, or limit those changes to development of new converter types, or perhaps an enhancement of the AFF capabilities.  Through alpha-testing to be conducted in the fall and winter of 1998, we hope to determine which AFF capabilities need to be expanded or improved.   Additional future directions for the AFF include a graphical tool for developing the AFF mapping files, developing capabilities to allow the simulation to participate in federations using different time management schemes, and tools for instrumenting the  conversion process to allow federation developers to understand the computational costs of a particular mapping. References[1] US Department of Defense, High Level Architecture Interface Specification, Version 1.3, Draft 10, April 2, 1998.[2] D Coffin, D Wilbert, J Aaronson, W Helfinstine: “Developing a SOM for ModSAF,” Simulation Interoperability Workshop, 98F_SIW_024, September 1998.[3] Erich Gamma, Richard Helm, Ralph Johnson and John Vlissides, Design Patterns, Addison-Wesley, Reading, MA, 1994.Author Biographies  DAVID MACANNUCO is a Staff Software Engineer at LMIS ASC.  Dave has been involved in various HLA efforts, including working on the development of HLA ModSAF and the LMIS ASC RTI 2.0 design.  Prior to working HLA related projects, Dave was involved with ModSAF development for the STOW and ADST programs.BRETT DUFAULT is a Staff Software Engineer at LMIS ASC.  HLA ModSAF is Brett’s first major HLA project.  Prior to this he was involved in ModSAF development for the STOW Program.LORIE INGRAHAM is a Senior Staff Software Engineer at LMIS ASC.  Lorie is currently working on the development of the HLA ModSAF.  She has been involved in the development of various tactical and weapon systems simulator trainers, including LMIS CATT Core and Reconfigurable Simulator IRAD projects.