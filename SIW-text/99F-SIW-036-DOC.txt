WARFIGHTERS’ SIMULATION (WARSIM) 2000Contract Number: N61339–95–C–0051The WARSIM 2000 C4I Interface7 July 1999Prepared For:U.S. Army Simulation, Training andInstrumentation Command (STRICOM)Central Florida Research Park12350 Research ParkwayOrlando, Florida 32826-3276Prepared By:LOCKHEED MARTIN INFORMATION SYSTEMS12506 Lake Underhill Road, MP 855Orlando, Florida 32825-5002Copyright 1999(Copyright held jointly by:  Lockheed Martin Corporation; Dynamics Research Corporation; Logicon, Inc.; Science Applications International Corporation; Sterling Software, Inc.)Unlimited rights held by US Government  pursuant to Contract N61339-95-C-0051The WARSIM 2000 C4I InterfaceMichael NewcombJim GustafsonApplied Systems DivisionSterling Software, Inc.3504 Lake Lynda Drive, Suite 420Orlando, FL 32817-1484(407) 306-5138, (407) 306-5125 HYPERLINK mailto:Michael.Newcomb@sterling.com Michael.Newcomb@sterling.com,  HYPERLINK mailto:Jim.Gustafson@sterling.com Jim.Gustafson@sterling.comPhuoc NguyenLockheed Martin Information Systems12506 Lake Underhill Drive, Mail-point 855Orlando, FL 32825(407) 306-5237 HYPERLINK mailto:Phuoc.Nguyen@lmco.com Phuoc.Nguyen@lmco.comKeywords:Java, JSIMS, JNI, class loading, WARSIM, C4I, CMP, DII COE, USMTF, VMF, JCDBABSTRACT: The WARSIM 2000 C4I Interface’s function is to interface the Army Tactical Command and Control Systems (ATCCS) within a Tactical Operations Center (TOC), to the WARSIM 2000 simulation.  The five ATCCS systems targeted for support are the Maneuver Control System (MCS); All Source Analysis System (ASAS); Advanced Field Artillery Tactical Data System (AFATDS); Forward Area Air Defense Command, Control, Intelligence (FAADC2I); and Combat Service Support Control System (CSSCS).The goal is to isolate the TOC.  Isolating the TOC, or the training audience, minimizes the differences between an exercise and a real conflict both by imposing the affects of the simulation terrain, distance, meteorological and battlefield affects on communications and by simultaneously minimizing simulation centric unit requirements.  WARSIM 2000’s C4I Interface accomplishes isolation from the training audience from the simulation by communicating with each ATCCS system natively.  Communicating via training audience interactions requires the WARSIM 2000 C4I Interface to perform two tasks.  First, it translates training audience interactions to and from simulation interactions.  Second, it transmits and receives those training audience interactions via native protocols.Pretty straightforward … right?  Not hardly.Training audience interactions between ATCCS systems occur using a wide variety of messaging formats and transmission protocols.  Some formats have been identified and are being incorporated into the Defense Information Infrastructure (DII) as part of the Common Operating Environment (COE), which the ATCCS systems are built upon.  One of the key components of the DII COE is the Common Message Processor (CMP).  The CMP acts as a buffer between changing messaging formats and the ATCCS systems.  It provides the formatting, validation, and normalization capabilities for those messaging formats.  The process is complicated because some ATCCS systems communicate with other systems using non-standard formats and protocols, and because engineering designs must allow for future versions of the ATCCS systems.  Some future ATCCS systems plan to complement messaging with information retrieved from the Joint Common Database (JCDB).The WARSIM 2000 C4I Interface makes extensive use of Java’s (the implementing language) unique capabilities such as Class-Loading, Run-Time Type Information, and Reflection.  In fact, most of the unique capabilities within the WARSIM 2000 C4I Interface come from the correct utilization of Java.  One of the major differences between this design and others is that the translation between training audience and simulation interactions is performed at the source code level.  Another major difference is the incorporation and enhancement of the CMP, one of which is to enable Java reflection on training audience interactions!  This paper will discuss the WARSIM 2000 C4I Interface architecture and how it supports the addition of new training audience and simulation interactions.  It will also discuss the translation process from source code generation to loading and execution and the enhancements made to the CMP.IntroductionThis paper provides an in depth look at the software architecture of the WARSIM 2000 C4I Interface.  The focus of this paper is to highlight one of the most important features of WARSIM 2000, the ability of the training audience (TA) to interface to the simulation through their organic Command, Control, Communications, Computers, and Intelligence (C4I) equipment.  The WARSIM 2000 C4I Interface will support the five Army Tactical Command and Control Systems (ATCCS).  The five ATCCS systems targeted for support are the Maneuver Control System (MCS); All Source Analysis System (ASAS); Advanced Field Artillery Tactical Data System (AFATDS); Forward Area Air Defense Command, Control, Intelligence (FAADC2I); and Combat Service Support Control System (CSSCS).  The WARSIM 2000 C4I Interface provides a seamless interface from the ATCCS systems to the WARSIM 2000 simulation.  This paper will demonstrate that the architectural design of the WARSIM 2000 C4I Interface allows it to quickly adapt to changes in native formats and protocols as well as changes in simulation formats and protocols.  This is the first in a series of planned papers that will cover the C4I Interface as it evolves through the Initial Operating Capability (IOC) delivery of the WARSIM 2000 program.This paper will introduce readers to the C4I Interface development currently on going in the WARSIM 2000 program.  It begins with a brief overview of the WARSIM 2000 program, focusing on the C4I Interface requirements for IOC.  The C4I Interface Architecture section provides an in depth look at the C4I Interface architecture and how it meets the C4I Interface requirements of the WARSIM 2000 program.  The Interaction Translation section discusses the details of the translation that occurs between the C4I Interface and WARSIM 2000.  The final discussion topic takes a look at how the Defense Information Infrastructure’s (DII) Common Operating Environment (COE) Common Message Processor (CMP) was adapted to fit into the C4I Interface architecture.  The paper concludes with a review of the major advantages of the C4I Interface architecture.WARSIM 2000The Warfighters’ Simulation (WARSIM) 2000 is the Army's next generation command and control training environment.  In conjunction with the Joint Simulation System (JSIMS), it will support the training of unit headquarters and command posts from battalion through echelons above corps in joint and combined scenarios.  It is designed to allow units world-wide the capability to train in their command posts using organic organizational C4I equipment as their interface to the simulation [1].  A primary program goal is to reduce unit overhead requirements.WARSIM 2000 will meet emerging distributed interactive simulation standards and protocols, thus providing a comprehensive joint environment capable of linking its simulation based constructive entities with virtual (simulator based) and instrumented vehicles.  It will replace a number of existing legacy training simulations including the Corps Battle Simulation (CBS), Tactical Simulation (TACSIM), Combat Service Support Training Simulation System (CSSTSS), and Brigade/Battalion Battle Simulation (BBS) [1].WARSIM 2000 is divided into several Computer Software Configuration Items (CSCI).  Each CSCI has a primary focus or function.  The C4I Interface CSCI's primary function is providing the interface software between the TA’s organic C4I equipment and the Simulation Object Representing the Training Audience (SORTA).  Events originating from the TA are routed through the C4I Interface, into the simulation, and out through the SORTA so the simulation can affect communications based on environmental factors such as the terrain, distance, weather, and combat effects in the simulated environment.  Events destined for the SORTA are received by the SORTA and then routed to the TA through the C4I Interface.C4I Interface ArchitectureThe C4I Interface architecture provides modular, configurable, building blocks for interfacing to the training audience’s organic C4I equipment.  The C4I Interface architecture takes advantage of three object-oriented techniques:Class-Loading – the ability to load new classes (source code) into a running applicationRun-Time Type Information (RTTI) – the ability identify the type (class) of an object at run-timeReflection – allows applications to “discover” (view methods, fields, etc.) and manipulate (instantiate, invoke methods, get/set fields, etc.) classes unknown to them at compile timeBy correctly utilizing these techniques, the C4I Interface can effectively separate the development of training audience interfaces from the development of simulation interfaces.  Java was chosen as the implementing language because of its support of these techniques.The C4I Interface contains two main stand-alone components, the Mapper Generator runs during the pre-execution setup phase and the Communications Manager runs during the execution of the simulation.  The Mapper Generator creates the translation mappings between training audience and simulation interactions.  It is discussed in depth in the Interaction Translation section.  The Communications Manager sits between the simulation and the training audience’s organic C4I equipment.  It does not directly interface to the C4I equipment or the simulation, but it provides the process space and a common environment for the other objects of the C4I architecture that do.  In the WARSIM 2000 configuration, a Communications Manager is created for every training audience Tactical Operations Center (TOC).  Figure 2 demonstrates this relationship.The TOC is the command center for a unit.  Within each TOC numerous C4I devices are used to aid and automate the running of that unit.  This relationship can be mirrored in the C4I Interface architecture.  While Communications Managers associate individual TOCs to the simulation, Interface Managers associate individual C4I devices, within a TOC, to the simulation.  Figure 3 demonstrates these relationships.Interface Managers can be controlled individually or as a group.  When configuring a Communications Manager for a particular TOC, an Interface Manager would be created and configured so each C4I device would have the appropriate connection to the simulation.  Another way to describe the Interface Manager is as an abstract pipeline between the simulation and a C4I device.  When a C4I device initiates an interaction with a destination outside it’s TOC, the interaction enters the Interface Manager on one end, is converted to the appropriate simulation interaction, and then exits the other end directly into the simulation.  Likewise, when the simulation initiates an interaction with a destination outside the simulation, the interaction enters the Interface Manager on one end, is converted to the appropriate training audience interaction, and then exits the other end directly into the C4I device. Since C4I devices and simulations communicate in very distinct ways, the Interface Manager must be modular enough to handle changes in either the simulation or the C4I device.  This is accomplished through the use of Interaction Managers.  Interaction Managers are responsible for the communication, through interactions, between the simulation and the TA.  An Interface Manager could contain multiple TA or simulation Interaction Managers based upon the desired configuration.  Figure 4 demonstrates the internal makeup of an Interface Manager.InteractionsBefore discussing any further what Interaction Managers are responsible for, it is important to discuss what an interaction is.  Interactions represent any type of information exchange.  TA interactions represent communications between elements of the TA.  Likewise, simulation interactions represent communications between elements on the simulated battlefield.  US Message Text Format (USMTF), Over the Horizon – Gold (OTH-Gold), and Variable Message Format (VMF) messages are good examples of TA interactions.  Each message represents an information exchange.  The TA will use USMTF A423 messages to issue orders and VMF K02.4 messages to request fire support while WARSIM 2000 will use an Order and Request for Fire C2DIF.Every type of interaction is represented within the C4I Interface architecture as a Java class.  Java provides the common language necessary for translation between TA interactions and simulation interactions.  Using Java as the modeling language is just the first step.  Even though interactions are modeled in Java, each interaction was modeled after it’s native counterpart and therefore translation between interactions is still necessary.  The steps necessary to perform the translation between interactions will be discussed further in the Interaction Translation section.Interaction ManagersAs discussed earlier, Interaction Managers are responsible for the communication, through interactions, between the simulation and the TA.  TA Interaction Managers use native C4I formats and protocols to communicate with C4I devices.  Each TA interaction can be delivered via several native C4I protocols.  For example, USMTF messages can be delivered using standard email protocols.  Therefore, an Email Interaction Manager would receive USMTF email messages and convert them into USMTF TA interactions.  The Email Interaction Manager would also be responsible for converting USMTF TA interactions back into email messages for delivery to the TA.  Another example of a TA interaction would be Joint Common Database (JCDB) updates.  These updates would come through a JCDB Interaction Manager and then be converted into JCDB interactions.  Simulation Interaction Managers perform the exact same duty except they interface to simulations using simulation-specific interfaces.  The JSIMS Interaction Manager communicates C2DIF messages with the simulation using the High Level Design (HLD) interface.When configuring the Interface Manager to interface a particular C4I device to a simulation, different TA and simulation Interaction Managers are selected based upon the capabilities of the C4I device and simulation.  The selected Interaction Managers are then dynamically loaded into the Interface Manager using a Java Class Loader.  This ability to dynamically load classes is the key to the modularity and flexibility of the C4I Interface architecture.  It allows Interaction Managers to be developed independently of each other.  Once the selected Interaction Managers are loaded, the Interface Manager is responsible for the associations between the loaded TA and simulation Interaction Managers.Interaction TranslationAs discussed earlier, Interaction Managers convert native communications into Java interactions.  This is just the first step in the entire translation process because even though all native interactions are modeled as Java classes, they are still distinct and it is the responsibility of the Interaction Translator to convert specific TA interactions into simulation interactions.  When interactions come into the Interaction Translator, the class of interaction is identified using Java Run-Time Type Information (RTTI).  Once the class of interaction has been determined, the Mapper for that specific type of interaction is dynamically loaded to translate it.  Figure 6 demonstrates a high level view of the run-time translation process for a TA interaction (the process is the same for a simulation interaction) and how Mappers are dynamically loaded based upon the type of interaction detected.MappersMappers are classes that contain the information necessary to convert between TA and simulation interactions.  Mappers can be made up of individual mappings between interaction attributes and depending upon how complex the interaction is, other Mappers.  Mappers are built for one-way conversion and therefore one is built for every type of TA and simulation interaction.  Figure 7 demonstrates the basic concept of the TA Mapper.It is important to distinguish the differences between the WARSIM 2000 C4I Interface Mapper design and other C4I interface designs.  The most notable difference is that Mappers are classes.  That is to say they perform translation through source code.  Traditional C4I interface designs and thought processes disagree with the idea that the Mappers should be actual source code.  The disagreement stems from the fear that every time mappings change, the entire application would have to be re-compiled.  Therefore, traditional C4I interface designs used mapping tables and other “data driven” (anything other than source code) methods to perform translation.  The reasoning behind this decision was that data could be modified and then reloaded without having to change the C4I interface.  With the advent of Class-Loading the distinction between data and source code vanishes.  Classes can be loaded without having to change the system.  By using Java’s Class-Loading capability, the Interaction Translator can load Mappers as necessary.  Mappers can be added or changed without any effect on the WARSIM 2000 C4I Interface.  Rather than investing time and energy developing a translation language with rules for performing translation and a parser/compiler for utilizing those rules, the Mapper uses Java as the translation language.  This gives Mappers the tremendous flexibility and power of the entire Java programming language.It is important to note that once a Mapper is built to associate interactions, that Mapper never needs to be rebuilt (unless there was an error in its creation).  Mappers are maintained over time using Java’s packaging system.  Mappers are placed inside packages based on the type of interactions they map from.  As TA and simulation interactions evolve, different implementation versions are assigned to the packages.  Interaction Translators can then be configured to load certain package versions.Mapper GenerationMappers are written using the Mapper Generator.  The Mapper Generator was developed as a tool to aid developers/maintainers in the creation of Mappers.  Mappers are generated for every type of interaction.  The Mapper Generator class-loads the interaction it is mapping from and the interaction it is mapping to.  Once the interactions are loaded, the Mapper Generator uses Reflection to present all of the methods and fields, of both interactions, to the user.  Now that the internals of the interactions are displayed, the user can select which attributes map between the interactions.  The user can also select different tools to aid in the mapping of attributes.  Details on what mapping tools are available and how they are created will be discussed in the Mapping Tools section, immediately following this section.  Figure 8 demonstrates a high-level view of how Mappers are generated.The Mapper Generator was designed to be very similar to modern GUI builders such as Microsoft’s Visual Workshop series or IBM’s Visual Age series.  The current implementation of the Mapper Generator utilizes a tree structure for representing the loaded interactions.  As it matures, the Mapper Generator will move towards a drag and drop approach to building Mappers.Since Mappers are actual Java classes, the Mapper Generator offers the ability to modify Mapper source code.  This is necessary because not every interaction will map cleanly to other interactions and it may be necessary to tweak the mapping.  This applies not only to newly generated Mappers, but existing Mappers may need to be tweaked/fixed for a particular execution.Mapping ToolsThe Mapper Generator provides a basic interface for the user to create Mappers.  It presents the user with the internals of the interactions being mapped.  However, as discussed earlier, there may not always be a clean mapping between two interactions.  To combat this problem the Mapper Generator uses mapping tools to produce the correct source code for each mapping.  Mapping tools are Java classes that help the user create mappings between different interactions.  Mapping tools range widely in their complexity.  The simplest mapping tool would allow the mapping of some String to another String.  A more complex tool would allow the user to break apart a String into several sub-strings or the composition of several Strings into one large String.  An even more complex tool would allow the user to walk down through a list of Strings searching for specific values and then, using the previous tool, break apart or compose those Strings.Each mapping tool is responsible for presenting itself to the user through the Mapper Generator.  As mappings are created, the Mapper Generator consults the tool being used to generate source code for each mapping.  Simple tools will just supply the Mapper Generator with a few lines of source code to make the translation.  More complex tools would insert references to themselves within the Mapper instead of inserting a large block of code.  When the Mapper Generator is loaded, it class-loads all available mapping tools.  It also allows the user to specify where new mapping tools can be loaded.  This allows developers of different projects to easily develop and then add new tools to the Mapper Generator.  Figure 9 demonstrates how mapping tools are loadedUsing the CMPThe CMP is the responsibility of ATCCS program office and it is an automated multifunctional message-processing system designed to enhance interoperability for Department of Defense (DoD) Systems.  All ATCCS systems are migrating to use the CMP as their message-processors.  It contains state-of-the-art technology to process both inbound and outbound messages using a standard Graphical User Interface (GUI).  The design is based on the leading-edge technology inherent in the Joint Automated Message-Preparation System (JAMPS), which was developed by the Air Force with participation by the Army and Marine Corps.  Some of the main responsibilities of the CMP are validation of inbound and outbound messages, extraction of data from a message, formatting data for a message, and normalizing message data to and from different data representations.  The CMP processes incoming messages using Message Text Format (MTF) tables derived from the Joint Interoperability Engineering Office (JIEO) Central Data Base System (CDBS) [3].CMP operates on a number of different platforms and is being written in two different languages.  The WARSIM 2000 C4I Interface uses the Java version of the CMP.  The Java version of the CMP uses a generic Java object to store message data.  Inbound messages are parsed into these objects and outbound messages are formatted from them.  Figure 10 demonstrates how the CMP parses inbound messages into generic CMP objects.Even though the CMP can produce Java objects, those objects are too generic for the Mapper Generator to take advantage of.  The true type of data within the CMP objects are captured as Strings within the CMP objects.  It is very similar to a hash table with the names of fields, sets, and segments as the keys.  The Mapper Generator relies on interactions that are very specific.  The WARSIM 2000 C4I Interface sidestepped this problem by using template MTF objects provided by the CMP, to produce MTF classes.  Once the MTF classes are generated, the Mapper Generator can then load them.  Figure 11 demonstrates how the MTF Class Generator uses these template objects to create MTF classes.Even though the MTF Class Generator produces Java classes from the CMP objects, those classes still rely upon the CMP for parsing and formatting message data.  The MTF class acts like a wrapper around the CMP object.  Any calls to set or retrieve data from the MTF class are forwarded to the underlying CMP object.  When MTF classes are instantiated with message data, they make calls to the CMP to parse the incoming data.  When MTF classes are converted to Strings, they make calls to the CMP to format the outgoing data.  Figure 12 demonstrates how the generated MTF classes act as wrappers around CMP objects.ConclusionAs clearly demonstrated by this paper, the WARSIM 2000 C4I Interface is taking a very different path than traditional C4I interfaces.  One of the more unique differences between the WARSIM 2000 C4I Interface and traditional C4I interfaces is the realization that source code (Java classes) is just another form of data.  With that realization the goal of a truly modular, extensible C4I interface is attainable.  Another unique difference is the utilization of the CMP.  Re-using resources developed within the C4I community is a first.  The WARSIM 2000 C4I Interface is far from complete and as it matures through the IOC delivery of WARSIM 2000, the modularity and extensibility of the architecture will aid in the overall success of the program.References[1]	System Specification for the Warfighters’ Simulation (WARSIM) 2000, Lockheed Martin/Army WARSIM Integrated Development Team (IDT)[2]	Warfighters’ Simulation (WARSIM) 2000 website,  HYPERLINK http://www.stricom.army.mil www.stricom.army.mil[3]	Common Message Processor website, HYPERLINK http://www.stricom.army.mil  www.monmouth.army.mil/peoc3s/atccs/CS/cmp.htmlAcknowledgmentsThe authors acknowledge the support of the Office of the Director for Information, Command, Control, Communications, and Computers (ODISC4), the SIMTECH Program, and the Program Executive Office for Command, Control, and Communication Systems (PEO C3S) in developing the concept and working prototype of the CMP as a C4I to simulation interface.  The authors also gratefully acknowledge the US Army National Simulation Center, and the Simulation, Training, and Instrumentation Command (STRICOM) for support of the Warfighter’s Simulation (WARSIM) 2000 Contract, Number: N61339-95-C-0051.Author BiographiesMICHAEL NEWCOMB is a Senior Member of the Technical Staff in the Applied Systems division of Sterling Software, Inc.  Michael graduated with a Bachelor of Science degree in Computer Science from the University of Central Florida.  Michael is the lead developer for the WARSIM 2000 C4I CSCI and is responsible for the design and development of the C4I Interface architecture.JIM GUSTAFSON is a Senior Member of the Technical Staff in the Applied Systems division of Sterling Software, Inc.  Jim graduated with a Bachelor of Science degree in Electronic Engineering Technology from the Arizona State University.  As a member of the WARSIM 2000 C4I CSCI, Jim is responsible for developing the CMP class generator and wrapping CMP for incorporation into the architecture.PHUOC NGUYEN is a Software Engineer for Lockheed Martin Information Systems.  Phuoc graduated with a Bachelor of Science degree in Computer Engineering from the University of Central Florida.  As a member of the WARSIM 2000 C4I CSCI, Phuoc is responsible for developing the Mapper Generator application and the Mapper Tool framework.Figure 2: Communications Manager locationTOCCommunications ManagerFigure 3: Mirrored RelationshipC4I DeviceTOCInterface ManagerCommunications Manager EMBED Word.Picture.8  Figure 1: Next Generation Army C2 Simulation [2] EMBED Word.Picture.8  MappersFigure 8: Mapper GenerationUserInteractionMapping Tool SetNative MessageFigure 5: Native Messages modeled as Java InteractionsModeled as Java InteractionsInteractioninteractionsFigure 4: Interface Manager MakeupC4I DeviceTA Interaction ManagerSimulation Interaction ManagerInterface Manager EMBED Word.Picture.8  Reflection Processload interaction we’re mapping fromload interaction we’re mapping toMapperSim InteractionTA InteractionIdentify ClassSim InteractionTA InteractionInteraction TranslatorAPI callsFigure 12: MTF Class as a CMP Object WrapperMapper GeneratorMappersMapperFigure 6: Run-Time Translation ProcessconvertloadclassMapper LoaderJmpscreateMsgTemplate("A423", 1993)Figure 10: CMP Message ProcessingMtfFieldName: " ADDNL ID"Data: "ID"generic APIsSpecific APIsMtfFieldName: " ADDNL ID"Data: "ID"MtfFieldName: " NICKNAME"Data: "NAME"MtfSetName: "EXER"MtfBodyName: "A423"CMP ObjectMTF ClassFigure 11: CMP Message ProcessingCMP TablesMTF Class GeneratorMtfFieldName: " ADDNL ID"Data: "ID"MtfFieldName: " NICKNAME"Data: "NAME"MtfSetName: "EXER"MtfBodyName: "A423"CMPObject TemplateMtfFieldName: " NICKNAME"Data: "NAME"MtfSetName: "EXER"MtfBodyName: "A423"CMP ObjectMessageMTF RulesCMP Tablesmp_commonJmpsMtfValidatorUserDefinedFigure 9: Loading of Mapping ToolsToolMapping Tool SetMapper GeneratorStandardToolsadd 11always “2”Sim Interactionattribute Xattribute Yattribute ZTA Interactionattribute Aattribute BMapperFigure 7: Mapper Concept