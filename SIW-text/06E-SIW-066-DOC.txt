Applying MDE for HLA Federation Rapid GenerationServantie EtienneDGA/DET/SAIS / Simulation Department18 rue du Docteur Zamenhof92181 Issy-les-Moulineaux Cedex, France   Phone: +33141462216, Fax: +33141462791 LIENHYPERTEXTE "mailto:etienne.servantie@dga.defense.gouv.fr" etienne.servantie@dga.defense.gouv.frLcL Lecinq XavierDélégation Générale pour l’Armement (DGA)DGA/DET/SAIS / Simulation Department18 rue du Docteur Zamenhof92181 Issy-les-Moulineaux Cedex, France  Phone : +33 141 462 621, Fax: +33 141 462 791  LIENHYPERTEXTE "mailto:xavier.lecinq@dga.defense.gouv.fr" xavier.lecinq@dga.defense.gouv.fr Capt Verron Olivier DGA/DET/SAIS / Simulation Department18 rue du Docteur Zamenhof92181 Issy-les-Moulineaux Cedex, France  Phone: +33141463739, Fax: +33141462791  LIENHYPERTEXTE "mailto:olivier.verron@dga.defense.gouv.fr" olivier.verron@dga.defense.gouv.frKeywords:Interoperability, Re-use, MDE, HLA, Code generation, Model, Meta model.ABSTRACT: Coding and testing interoperability of simulations are always time consuming phases in the simulation development, though not the most interesting in terms of added-value. Different initiatives have tried to reduce the duration of these phases, but are generally vulnerable to the evolution of underlying standards. As new IT paradigms are now available, among which Model Driven Engineering (MDE), this problem had to be reconsidered.  This paper will report on French recent work to improve interoperability between simulations. It will demonstrate how to concentrate on the design of simulations and re-use of the expertise in simulations. This work is a first result of an effort made by the French Ministry of Defense to apply a Model Driven Engineering (MDE) approach to simulation development. This effort was done through the ITCS (Common Technical Infrastructure for Simulation) advanced study, contracted at the end of 2003 by the Military Procurement Agency (DGA), and led by SAIS (Service d'Architecture Inter Système), which is in charge of the French battlelab development. During the ITCS definition phase, which ended at the beginning of the year 2005, one of the key technologies appeared to be the Model Driven Engineering (MDE). To research this point, SAIS instantiated two aspects of the MDE approach: high quality code design through a prototype of Domain Specific Language (DSL), and model transformation, through an HLA code generator, associated to the former DSL. This example demonstrated the MDE potentiality to address interoperability issues and to improve developers productivity: rapid HLA code generation, portability on several RTI, FOM agility, etc. This paper will insist on the following aspects: the MDE concepts and expected benefits, the federation development process using MDE approach, the main features of the realized architecture prototype, and a technical feedback on applying the MDE approach.IntroductionSince the late 20th century, France has committed in the use of simulations for systems acquisition. Hence, in the different technical centres, many simulations have been developed, based on various technologies: virtual simulations, constructive or hardware in the loop ones… In the late 90ies, with the digital revolution is born the concept of system of systems: an isolated platform had no more sense, if not considered in its environment and with its potential connexions with other systems. From the engineer point of view, this implied the need for new simulations, representing all the aspects of a system of systems. Considered the global cost of simulations, and without excluding the development of new ones, engineers had actually to cope with connexion of legacy simulations, and face the interoperability and reuse questions.  In this context, the French Defence acquisition service (DGA) launched in 2001 the ITCS project. It implied many of the DGA’s simulation experts, and aimed at tackling the various aspects of interoperability and reusability: organisation, knowledge, skill, and tools, with only one objective: get the ability to build, on demand, distributed simulations in a restricted delay. On a technical point of view, the project of course referred to HLA, but also ambitioned to generalize this architecture, as distributed simulation, practically, does not limit to exchanging dynamic data: distant teams need, among others, common processes, common tools and a shared knowledge of business concepts. Advanced studies, contracted in 2003 by SAIS (Inter systems architecture service), concluded that in terms of solution, the newly appeared concept of Model Driven Engineering was a key point: it could ensure a strong consistency and interoperability between the different tools that deal with each part of the global business, ranging from federation design, scenario generation, federation control, to result analysis and knowledge management…That is the big picture! We of course had to verify its feasibility, on smaller parts of the distributed simulation business. Firstly, we focused our efforts on HLA federation design.In this article, we will firstly remind the main principles of MDE, then illustrate how it can be applied in designing a simple federation, and then conclude on interest of this approach.MDEBasics : understanding the MDE conceptsFirst of all, we need to define the MDE concepts and vocabulary. This part is theoretical while the next one illustrates each concept through an example.In the MDE approach, the following terms are often used: models, metamodels, constraints, model transformations, model verification, code generation, platform independent model (PIM) and platform specific model (PSM).A model is a formal representation of a phenomenon, a behavior, a function, an architecture, or one thing of the real world. This formal representation is based on a well defined language (well defined form, meaning, and rules). This language could be graphical or textual. A model characterizes a part of the reality on the modeler point of view with a modeling purpose. That means that the same part of a phenomenon could be modeled differently.Figure  SEQ Figure \* ARABE 1: Model definitionA metamodel is a model used to build the former models. It specifies their abstract syntax: each concept and interrelation used by a model is defined in his metamodel. A model is compliant with (or conforms to) its metamodel. On one hand, the metamodel gives the meaning of each concept used in a compliant model, on the other hand, it constraints and guides the building of the model.Figure  SEQ Figure \* ARABE 2 : Relationships between models and metamodelsA metamodel contains all the interrelated concepts used for describing a business or a technology, but it is insufficient to describe each aspect for model creation, hence the need of constraints. Constraints are a set of rules on the metamodel defined to restrict and guide the modeler. A language called OCL (Object Constraints Language) can be used for this purpose. Finally, a model compliant to its metamodel and its constraints is coherent and can be interpreted without ambiguity.Applying the same reasoning, to build a metamodel, you need a syntax, and this is defined by a meta metamodel. As we have to stop the reasoning, the meta metamodel specifies also the concepts used to define itself. Several meta metamodel exist: for example, the OMG standardizes the MOF which stands for Meta Object Facility. A model can be instantiated in an instances diagram. In this diagram, the classes defined in the model are instantiated in objects. The instances diagram defines the number of objects and characterizes each object property.Figure  SEQ Figure \* ARABE 3 : HLA exampleOnce a metamodel has been defined, a model that conforms to it can be created. This conformity implies semantic rules are verified, and the syntax is correct.A well designed model can then be transformed into another model; this process is called model transformation.Figure  SEQ Figure \* ARABE 4 : Model transformation "To transform" means we want to create from a source model that conforms to a source metamodel a target model that conforms to a target metamodel. Therefore the transformation is a set of rules explaining how to map concepts between the source and the target metamodel. Generating code can be considered as a model transformation. The target is a text that conforms to the syntax of the language.The MDE approach aims at separating system specification from its implementation on a target platform. Thus, the MDE approach defines:  PIM which stands for Platform Independent Model. “The PIM is a view of a system from the platform independent viewpoint”. In other words, it describes the system, but doesn’t describe details of its target platform use.PSM which stands for Platform Specific Model. “This model is a view of the system from the platform specific viewpoint. The PSM combines the specifications in the PIM with the details that specify how that system uses a particular type of platform.”PM which stands for Platform Model. “It provides a set of technical concepts, representing the different kinds of parts that make up a platform and the services provided by that platform. It also provides, for use in a platform specific model, concepts representing the different kinds of elements to be used in specifying the use of the platform by an application.”Model transformation techniques are used to convert a PIM to a PSM for each PM defined, ensuring portability and reusability of the PIM through architectural separation of concerns (the model transformation techniques are not exposed in this paper).Supporting toolsSuch an approach needs supporting tools. You first need a tool that guides the designer and compels him to define the system according to the rules defined in the meta model. A graphical representation for this design can help but is not mandatory. We can quote here three tool approaches: 1- Using XSL to define a rigorous XML Schema and define the model with an XML Tool. 2- Using UML metamodel extended with the stereotype mechanism and defining the model with a UML graphical Modeler. 3- Using a 'toolsmith' also called metatool or 'DSLTool' (DSL for domain specific language) to design a metamodel that is almost automatically interpreted and converted to a new graphical tool which conforms to the metamodel, the user can then manipulate a tool dedicated to his business.You need tools to define transformation engines and use them. These tools may use specific textual languages (eg: QVT) or graphical languages (eg: GREAT) or simply be done using classic programming languages. We can quote here code generation which mainly relies on templates mechanisms (eg: JET and its editors). Let us now illustrate the MDE approach applied on simulation development through an example using DSL tools.MDE by exampleOverview This example will present an application of the MDE approach. This application may be theoretical, far from any consideration of actual “best practices” on HLA federation design, but we insist: its unique goal is to be pedagogical.The exercise consists in designing an HLA federation, composed of two federates: the first models a tank platoon and the second a transport vehicle, which will be the target of the former.The team in charge of this federation includes two profiles: the first is the army officer, whose expertise includes weapon system and tactics; the second is the HLA expert, who can’t talk of anything but FOM, RTI, interactions and attributes.The problem consists in enabling these two kinds of expertise to understand each other. The solution induced from MDE relies on using “expertise specific” modeling languages, and defining transformation between each other. Using the MDE semantics, that can be expressed this way:  Step 1: the army officer uses a modeler compliant with a weapon system metamodel (WSM2) to design the configuration of the platforms; Step 2: this model will be transformed in an federation one, compliant with the HLA metamodel (HLAM2); this transformation relies on rules that link the concepts of both metamodels,Step 3: the HLA expert can complete the federation model (it could be called a conceptual model!) with Publish/subscribe parameters for example, further the HLA expert could generates the corresponding code, if a code generator has been specifically designed. We may notice that this code generator is nothing but a transformation between HLA federation concepts and computer languages concepts.These different concepts are summarized on the figure below.Figure  SEQ Figure \* ARABE 5 : Example overviewMost meta tools or UML tools can be customized on a specific business. So we believe in the feasibility of a tool that could be used by both the army officer and the HLA expert. In the following, we will study the main requirements for such a tool, starting from simple federation requirements. We will also figure out the way the team will use the tool to get its simulation done quickly.Running the exampleThe primary requirement for this exercise is: ”A tank system composed by a canon a caterpillar with a thin shield must be confronted to a passenger vehicle. We want to test which power engine must be given to the passenger vehicle to escape two tank instances without damages”.The following paragraphs show how this primary requirement can be decomposed into technical sub requirements and how to meet them with MDE approach.Introductive work for STEP 1: Creating a DSL Tool for the Army officerThe following lines contains part of the requirements for the customization of the modeler that will be used by the army officer : “An Army officer should be able to define ground vehicles, to add embedded systems such as a C2 system, shield and weapons to it. A vehicle is characterized by a passenger number, its soil contact mean (wheels, caterpillar), its position and the power of its engine. A weapon can hit a shield. A weapon has an explosion power. A shield has a width and material characteristic […]. Embedded system can communicate with each others.”In this requirement, all bold words describe a concept of the metamodel. The underlined expressions represent a relation. The “add to it” can be considered as an aggregation relation in the metamodel, while the other underlined expression corresponds to an association. The words in italic represent characteristics that can be interpreted as attributes some of them associated to an enumeration.The resulting metamodel could be the one of  RENV _Ref130891749 \h Figure 6. The metamodel is formalized using a UML Like representation. Let us depict the figure.Figure  SEQ Figure \* ARABE 6 : Metamodel sampleThe used stereotypes (strings between commas) are some of the concepts of the M3 of GME: Model is a element that can have other elements inside. An Atom is an element that cannot contain other elements. The triangle signify an inheritance relation, say Shield, Weapon and C2 system have the same characteristics as the abstract notion EmbeddedSystem. A connection is a relation. For instance, Hit is a relation between a weapon and a shield. ComunicateWith signify that an Embeded Sytem can communicate with another. We can see that such a communication takes place only inside the GroundVehicle (due to the aggregation between CommunicateWith and GroundVehicle).Once the metamodel above is compiled with its graphical representation the Army officer has a dedicated modeling tool for his business, using his domain specific langage.STEP 1: Modeling of the weapon systemsThe DSL tool allows the Army officer to manipulate icons such as a tank, a weapon, a shield, a central system. He can link them and fill in the attributes of each. Thanks to constraints the user is obliged to conform to the metamodel: eg we can have naming rules. Below is an example that conforms to the primary requirement.Figure  SEQ Figure \* ARABE 7 : Modeling sampleThe Army officer may have decided the following architecture for the tank:Figure  SEQ Figure \* ARABE 8 : Tank modeling sampleThe graphical representation is fairly simple: a bitmap icon has been associated to each concept (model or atom). Connections are represented by lines between icons. To each object instances a property box is associated that conforms to the metamodel. For instance clicking on the shield opens the following box:  SHAPE  \* FUSIONFORMAT Figure  SEQ Figure \* ARABE 9 : Property box sampleWe can see the enumeration material characteristic (see the metamodel) is represented by a combobox.Once the diagram has been defined it can be checked. Among the test we can verify all ground vehicles have one central system, and that all weapon systems communicate with this central system. All these checks are whether written inside the metamodel or written through OCL constraints.Figure  SEQ Figure \* ARABE 10 : An OCL constraint sampleAnother very important aspect in model checking deals with the naming convention that is mandatory for the transformation engine that will read the model. For instance we can add a "white spaces" test that prevents them from being used for object names.After designing the tank model, the Army Officer has to instantiates the tank scenario, for instance to set up the initial position of these 3 ground vehicles and also their characteristics. The figure bellow shows icons having a "i" and a blue background. These are instances of the model depicted in  RENV _Ref130891749 \h  \* FUSIONFORMAT Figure 6.Figure  SEQ Figure \* ARABE 11 : A scenario sampleWe are now ready to go on step 2.STEP 2: Transform the weapons system model into an HLA tank federation modelThe requirement below defines the transformation rules to convert the Army officer’s design to an HLA federation: “for each groundvehicle designed with the WSM2, create a corresponding object having a position and passengernumber attributes, an enumeration attribute called soilcontactmean, complex type attributes for weapon, shield and C2 system. Add this object to the FOM. Create two interactions corresponding to Hit and CommunicateWith and add them to the FOM. Whenever a groundvehicle is designed a federate is created, it publishes its corresponding object (object publication is a facility provided by our abstraction layer). The source (respectively target) of a Hit relation is considered as the publisher (respectively subscriber) of the corresponding interaction. […].The following table describes few simple transformation rules given by these requirements. The first column describes concepts of the tank model and the second in which concept they are transformed in the HLA tank federation model.Tank ModelHLA tank federation modelGround VehicleHLA ObjectEmbededSystemHLA ComplexStructureHitHLA InteractionCommunicationHLA Interaction……Applying the transformation creates a federation design: two federates have been created a default RTI configuration is provided. A FOM has been deduced from the WS model.Figure  SEQ Figure \* ARABE 12 : A federation design sampleThe figure bellow shows a graphical form for the FOM.Figure  SEQ Figure \* ARABE 13 : A FOM design sampleSTEP 3: Achieving the federation modeling and generation of the federation filesIn the step, the HLA expert will use a DSL tool dedicated to his own business. The tool meet the requirement: “An HLA expert must be able to define the object model of the federation, the federates employed in the federation and which interactions and attributes are subscribed/published. […]”The tool provide also a code generator enabling to meet this requirement: “the targeted language is C++. Generate a set of classes that represents the object model to create an FOM dependent API relying on an RTI Abstract Layer. HLAAttributes of each object types is transformed into C++ attributes; HLAParameters of each HLAInteraction is transformed into C++ attributes […] For each federate, create a dedicated class, add to it a main method that publishes and subscribe to all objects and interactions it can, add also a createFromScenario method that can load a test file and instanciate objects as specified in the file. […]”The HLA expert tool has been realized, his features and architecture are described in the paragraph 4.You can see on the figure 13 the resulting file tree and a code sample. Each federate has its own development project and depends on the ObjectModel API which contains the binding code to the HLA RTI. The resulting code is ready to compile and a default main is created to test all possible publications/subscriptions. A method can load a scenario.The federation can be compiled now and the scenario generated using the scenario provided by the Army Officer. Two files are generated: one that contains all tank instances, another all PassengerTransport instances. These are transmitted to their respective federates thanks to the loadScenario method of each federate.Figure  SEQ Figure \* ARABE 14 : Code sampleAfter compiling the federation and feeding federates with their scenarios, we are now ready to run the federation.Let us see now how the step 3 of our example has been really implemented in our effort to apply the MDE approach to distributed simulation and especially to HLA federation development.The realized architecture for Step 3:Introducing Federation Rapid Generation architectureThis part focuses on the Federation Rapid Generation (FRG) architecture applying MDE approach for modeling and developing HLA federations. The architecture instantiates two parts of the MDE approach: a domain specific language supported by a metatool to design the federation, and, code generators based on the domain specific language to generate the federates code and theirs compilation and execution environments.The main purpose of this architecture is to research how MDE can support the federation development process and the productivity benefits. Moreover the underlying aim is to validate if MDE approach can address more efficiently the coding and testing phases of the interoperability parts, to save time for the coding and testing of the simulations business parts. The requirements are as follows:R1FRG has to generate an HLA federationR2FRG generation process has to be quickR3FRG generation process has to minimize the amount of code to write (must generate most of the HLA code more than 80%)R4FRG has to provide a graphical modeling environment using the HLA terminology and concepts to design the federation and its componentsR5FRG must generate empty HLA code containers for the business part of the federatesR6FGR has to enable to change quickly the RTI of the federationR7FGR has to enable to change the configuration executionR8FRG must enable to make federation packages easy to deploy on the target platformsR9FRG must enable FOM agilityR10FRG has to be based on free toolsResults The realized architecture provides a modeling environment enabling the HLA expert to design a federation and its component. This environment enables the user to handle the HLA concepts for the federation design:design the FOM (objects and attributes, interactions and parameters, complex types, enumerators),set the parameters of the FED file (delivery category, message ordering, …),design the federates and theirs SOM (objects attributes and interactions parameters published and subscribed),design the federation execution environment (RTI chosen, the libraries needed, the target platform).The modeling environment enables to reuse existing FOM stored in the OMT file format (the FRG architecture is able to load an OMT file).The FRG architecture provides an HTML documentation of the designed federation, describing its components and theirs characteristics (for stance it describes the FOM, the federates SOM…).After designing the federation, the HLA expert can generate the federates codes and theirs compilation environments (project files and makefiles for Microsoft Visual C++©).After compiling the federates codes with the generated makefiles, the HLA expert can used the FRG architecture to generate the execution environment of the federation. The FGR architecture enables to make a package of the compiled files with all the libraries needed for the execution. Furthermore, it generates the federation FED file needed by the federation.Figure  SEQ Figure \* ARABE 15 : Files generated by the FRG architectureTo summarize, FRG enable the HLA expert to realize the step 3 of our example. It enables to design graphically the federation and to generate all the files needed to execute the federation on the target platform with a very short process.FRG architecture descriptionThe FRG architecture is made up of a metatool, the FRG metamodel, the HLA framework, the FRG code generator, a documentation generator, and an execution and compilation environment generator.Figure  SEQ Figure \* ARABE 16 : Architecture descriptionFRG metatool:To support the MDE approach, we choose to use a metatool, instead of using an UML tool. The metatool used in the FRG architecture is GME which stands for Generic Modeling Environment. GME is a free metatool developed and distributed by the Vanderbilt University. GME main features are:to design graphically a metamodel compliant with the GME meta metamodel (which is different from the MOF).to compile the designed metamodel to be used by GME to specify compliant models.to define a set of constraint rules in OCL (Object Constraint Language) on the designed metamodel,to define a basic graphical customization of the model compliant with this metamodel. It allows associating all concepts of the metamodel with a basic graphical representation.to go through the metamodel with an C++ or Java API (these API allows to read or modify the models designed),to built code or documentation generators using the C++ or Java API,to check the metamodel compliance and consistency of the model on live or after design.FRG metamodel:At the core of the FRG architecture, stands the FRG metamodel. This metamodel is based on the HLA metamodel. It also includes the RAL framework concepts and some other basic concepts for designing the configuration of the federation. This metamodel defines all the concepts used in FRG to design and generate the federation. This metamodel is compliant with the GME meta metamodel. To compel the modeling and ensure coherency, constraints have been added to this metamodel. HLA framework:One of the main components of the FRG is the HLA framework called RAL which stands for RTI Abstract Layer. This framework was developed in 1998 by the simulation agency of the French Navy, the ANPROS. This abstraction of the lib RTI provides high level C++ classes useful to handle:FOM concepts: objects and their attributes, interactions and their parameters, complex types, and enumerates. HLA services: federation management, declaration management, objects management and time management.FRG generators:The FRG architecture is made up of several generators: the federate code generator, the documentation generator, the FED file generator, the makefile generator, the execution environment generator. All these generators are built in C++ and use the GME API to read the designed models.  To describe the FRG architecture we will only make a focus on the FRG code generator.FRG code generator:The FRG code generator generates the HLA code of the federate: first of all, the RAL API which is based on the FOM (Federation Object Model) and finally the code wrapper.Figure  SEQ Figure \* ARABE 17 : Federates architectureFor a better understanding, let us describe federates architecture generated by FRG:Federates logical architecture generated by FRG is composed of four layers. First one is the library provided by the RTI vendor. Second one is the RAL library provided by the HLA framework. Third one is the RAL API generated by the FRG on the basis of the FOM. These three first layers are common to each federate generated by FRG. The last layer is the code wrapper, which is partly generated by FRG. This layer enables to embed the business code part of the model. It provides states of the HLA objects, events when receiving interactions, methods to send interactions, methods to send objects updates, methods for time managing.Those four layers are in charge of the interoperability between the business parts of the federate which contains all the knowledge and expertise of this simulator (federate). The business part of the model includes the simulation loop, the state engines, the processing of the input and outputs values, the entities behaviors …Technical feedback on the MDE approachThe MDE approach for distributed simulation business can be decomposed in several main phases. This feedback describes each of them and gives guidelines based on the realization of the FRG architecture.  The first phase consists in a conceptualization work of the business or the technology to be addressed. Most of the time, it consists in developing (or reusing) a technological framework enabling the abstraction of the target technologies (for instance high level HLA API). This technological framework will solve low level technical problems, deliver high level services, and as a consequence will reduced code generation work, as well as code generators tests. Moreover, generators based on abstract technological layers are more durable to the underneath technologies changes, since not based on the technology itself. In other words abstraction of the target technology is better than massive code generation.The next phase consists in choosing a tool to support the approach. This tool can be either a DSL tool or an UML tool, having the following features:basic visual customization abilities to make the model design more readable. ergonomic user environment (ergonomics is the key for a good user appropriation) to design models and/or metamodel. For instance, when creating many objects, tables are better than graphical/icons manipulations.having a constraints manager. The constraints manager enables to compel the user and to complete the meta-model semantics.having a code generator based on a metamodel dependent API. This feature enables to write generators more easily and more quickly. having query features to explore models.Maybe the most important phase consists in designing the metamodel. When designing the metamodel, the real issue is not to define all the concepts needed, but to define these concepts as generic as possible to avoid most of the future modifications of the metamodel, because modifying the metamodel implies modification of the generators, modification of the existing models, and new education for the users.... To avoid these future changes, you must design the metamodel with a very generic core that will never change. All the others concepts of the metamodel will be related to this generic core (inheritance or association). At last, add constraints to the metamodel to restrict the user design possibilities thus you will reduce the variance between two models made by two different users.The last phase consists in writing the generators. The potency of the MDE approach is based on the fact that designing models is not a waste of time, as models are used afterwards to produce documentations, code, and other models by transformation. As code generator is nothing but a model transformation, it should thus get benefits from the abstraction frameworks realized in the very first phase.ConclusionIn this article, we have illustrated different benefits that can be expected from a MDE approach in simulations design:- as MDE dissociates the business issues from their technological implementation,, it prevents the business expert from bothering with technological details and allows him to focus on his expertise domain.- as the MDE approach enables among other possibilities to produce documentation and source code from the conceptual model, it offers to the project manager  a great reduction of risks of inconsistency between the pieces of information during the project life.- as the MDE approach allows a rapid development cycle for repetitive coding tasks (: with its code generator and its targeted abstraction framework), it shortens the loop modeling-coding-testing. From the developer viewpoint, most part of repetitive tasks is automated ensuring productivity. Among these time consuming tasks are the coding and testing of simulations interoperability, building the makefiles and execution environment, writing unit tests, or coding sample Helloworld application to test or stimulate the developed simulations.Of course, the example presented in this article was really simple, and does not really justify such an effort of conceptualization. But other use cases exist where the whole potential of MDE may be enjoyed; French MoD, for example, is applying these technologies for designing its future development environment for analysis simulations. Indeed, in this kind of simulations, MDE appeared really powerful to ease dialog between officers and engineers, and enable short developpment or modification cycles through drag&drop model reuse and automated HMI generation for instance. The metamodel  now exists and was build by merging concepts used in two different existing simulation environments : ESCADRE used by CAD (Defense Analysis Center)  and DUCTOR, used by ANPROS (Operational Research & Simulation division of the French Navy); tests are now in progress to check its completeness on real test cases. ReferencesJoaquin Miller and Jishnu Mukerji: “MDA Guide Version 1.0.1” Copyright © 2003 OMG, 2003-06-01OMG website:  LIENHYPERTEXTE "http://www.omg.org/" http://www.omg.org/GME website:  LIENHYPERTEXTE http://www.isis.vanderbilt.edu/projects/gme http://www.isis.vanderbilt.edu/projects/gmeDr. Andreas Tolk, 02F-SIW-004  “Avoiding another green elephant”Author BiographiesETIENNE SERVANTIE …LCL XAVIER LECINQ …OLIVIER VERRON …