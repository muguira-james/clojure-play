Extending standard UML semantics to Support PADS designHU Si-QuanGeneral Software LaboratoryInstitute of SoftwareThe Chinese Academy of SciencesBeijing 100080 HYPERLINK "mailto:husq@gsl.iscas.ac.cn" husq@gsl.iscas.ac.cnKey words: 	Parallel And Distributed Simulation; Unified Modeling Language; Simulation Modeling; Object-Oriented DesignAbstract:	Currently most parallel and distributed simulation system design employs different modeling methodology and tools in simulation modeling and simulation software system design. Simulation modelers use dedicated simulation languages such as GPSS, Matlab-SimLink, or specialized libraries such as GTW, HLA/RTI, DaSSF to describe simulation entity behavior and relationship. However, the entire computer simulation system always is a software system which the de-fact modeling language is UML. This different incurs the increased complexity of PADS construction. In this paper, we propose UML as a unified language to both simulation object modeling and PADS software system modeling. Our work focus on extending standard UML semantics to support simulation domain specific concepts including introducing virtual time in UML, using UML statechart diagram and interaction diagram with virtual time labels and constraints to describe simulation entity functional property. In addition, we create virtual time synchronization stereotypes to describe PDES time synchronization protocols, which separates the functional properties and synchronization property, thus alleviates the simulation modeling complexity and improves both simulation model reuse and synchronization reuse. A simple example is given to illustrate the extensions.IntroductionComputer Simulation is critical to many complex systems that can’t be analyzed by analytical methods. However, to apply simulations to experimentation, predication or decision the process is very time-consuming. On the one hand, the simulation participates should gain insights to the simulation models and master corresponding experimental techniques. On the other hand, factors including model complexity contribute to the long simulation execution time. One available way to conquer the constraints of computation resources in simulation is to execute the simulation on parallel computer systems with multi CPUs. It is straightforward to run the same simulation on multi-CPUs with different parameters. But most practical systems are comprised with different components that run parallelly, for instance routers [1] in computer networks, aircrafts [2] in aviation simulation. Apparently, these systems have inherent parallelism that could be effectively employed in multi-CPU environments. Their common characteristic is simulation model decomposition and this is a most important type of parallel simulation, named parallel discrete event simulation. In addition, the most common architecture in virtual synthesized training or distributed virtual environment is to link the simulators in different locations with gateways or middlewares to run the whole simulation through cooperation. This type of simulation is distributed simulation.The main target of parallel discrete event simulation is to speed up the simulation execution, while in distributed simulations most attention is on interoperation between simulators. However, they share much similarity on system design. Both of them require the description of simulation objects’ behaviors and interactions. Also both require the causality between simulation objects in different nodes, which is that simulation events should be executed according to their virtual time stamp and events happened latter should not be simulated before earlier events. It improves the complexity of constructing PADS systems significantly, which requires simulation modelers grasp both the techniques in constructing the domain models and parallel simulation time synchronization protocols that have not been encountered in sequential simulations.To conquer the complexity, convenient PADS construction tools or languages support is needed. At implementation level, it is commonly to modularize general simulation models as libraries. However, in this kind of simulation framework the abstraction is poor and C or C++ languages are often used with help from simulation libraries to express simulation models. At design level, some simulation modeling systems use their private languages or APIs, for example High Level Architecture OMT (Object Model Template) [12] requires 14 tables to express objects and interactions etc, which is inferior to a general modeling language such as Unified Modeling Language[3] in convenience and reusability.Currently simulation modeling and software design are not unified in methodology. Simulation modeling always employs private method or raw code or some specialized simulation description languages such as GPSS, HLA-OMT, Matlab-Simlink. Software design community generally adopts UML based object-oriented modeling method. However, computer simulation systems are always software systems too. Obvious benefits of unifying modeling tools or methods in both fields include more easy use, more conformances and thus less cost in simulation construction. This paper aims to extend the UML standard semantics to employ UML as a PADS modeling visual language.As the most prevalent software modeling language, UML can contribute to alleviate the complexity in simulation construction and enhance simulation models’ reusability. Unified language in simulation modeling and software design also reduce the cost to learn a specific simulation language. However, to support convenient PADS modeling, UML should be extended for it has no semantics of simulation virtual time and virtual time synchronization which are not included in standard UML document.Basic Architecture of PADS systemIn parallel and distributed discrete event simulation [4], the whole simulation model is decomposed into several regions and each region is indeed a time-space sub-space. Thus the simulation is comprised of several LPs (logical process) that communicate with each other. In HLA, a LP is also called a federate. In general sense, a region is maybe described as all events felled into a duration in the simulation time space, or all events felled into a simulation state subspace.Figure 1 illustrates the general architecture of PADS system organized with several LPs. Each logical process LPi includes following parts:A region Ri of the simulation;A Simulation Engine SEi, which is responsible for simulation of events belonging to the region Ri;A Communication Interface CIi, enabling LPs to send messages to and receive messages from peers.In multi CPU computers, LPs are mapped to different CPUs. If distributed memory is used, then each LP can only access a subset of the state variables. The simulation engine SEi processestwo kinds of events: internal events that have no direct causal impact on the state variables held in other LPs and external events that have to change the state variables in one or more other LPs. A external event can be a message routing by the communication system between LPs and is stored in input queues after received by the destination LP.Due to different virtual time progression within the various LPs, facilities should be taken to guarantee the causality relation. The causality principle can be expressed as that earlier state should not be affected by a latter event, which is the basic rule of the simulated world. A simple simulation example in causality is illustrated as followed:In a tank rivalry simulation, a tank A fires at another tank B, and B compute the damage following some probability. Tank A’s firing and Tank B’s damage are two events has causality relation. From the viewpoint of a viewer, if it is first observed that B is damaged and latter observed that A fires at B which direct causes the damage, then the simulation ruins the causality thus lacks any fidelity. Hence, in Viewer logical process, processes of the two events should follow correct time order.To guarantee correct causality in PADS, some synchronization mechanisms are needed. The two most commonly used synchronization protocols in PADS are the following:The conservative synchronization protocol developed by Chandy, Misra [5] and Bryant.The optimistic (or time warp) simulation protocol based on the virtual time paradigm [6]Figure 1:  PADS ArchitectureUML Brief SummaryThe Unified Modeling Language (UML) is a general-purpose visual modeling language that is used to specify, visualize, construct, and document the artifacts of a software system. It includes semantic concepts, notation, and guidelines and provides static, dynamic, environmental and organizational model elements. It is intended to be supported by interactive visual modeling tools that have code generators and report writers. It is intended to support most existing object-oriented development processes.UML concepts and models can be grouped into the following concept areas.Static structure enables definition of the universe of discourse, that is, the key concepts from the application, their internal properties, and their relationships to each other. This set of constructs is the static view. The application concepts are modeled as classes, each of which describes a set of discrete objects that hold information and communicate to implement behavior. The information they hold is modeled as attributes; the behavior they perform is modeled as operations. Several classes can share their common structure using generalization. A child class adds incremental structure and behavior to the structure and behavior that it obtains by inheritance from the common parent class. Objects also have run-time connections to other individual objects. Such object-to-object relationships are modeled as associations among classes. Some relationships among elements are grouped together as dependency relationships, including relationships for modeling shifts in levels of abstraction, binding of template parameters, granting of permission, and usage of one element by another. Other relationships include combination of use cases and flow of values. The static view is notated using class diagrams. The static view can be used to generate most data structure declarations in a program. There are several other kinds of elements in UML diagrams, such as interfaces, data types, use cases, and signals. Collectively, theses are called classifiers, and they behave much like classes with certain restrictions on each kind of classifier.In UML one way to model dynamic behavior is to according to the life history as it interacts with the rest of the world. An isolated object is viewed as a state machine, which is a view of a object as it responses to events based on its current state, performs actions as part of its response, and transitions to a new state. The other is the communication patterns of a set of connected objects as they interact to implement behavior. The view is a collaboration showed in sequence diagrams and collaboration diagrams.UML models are meant for both logical analysis and physical implementation. Certain constructs represent implementation items. A component is a physical replaceable part of a system that conforms to and provides the realization of a set of interfaces. It is intended to be easily substitutable for other components that meet the same specification. A node is a run-time computing resource that defines a location. It can hold components and objects. The deployment view describes the configuration of nodes in a running system and the arrangement of components and objects on them, including possible migration of contents among nodes.Within UML, the model organization is described by packages that are general-purpose hierarchical organizational units of UML models. They can be used for storage, access control, configuration management and constructing libraries that contain reusable model fragments. Models and subsystems are special packages.UML provides three kinds of mechanisms to extend its syntax and semantics. Stereotypes are used to describe new model elements, tagged values to describe new model attributes, constraints to describe new model semantics.Extensions to standard UML for simulated object behavior descriptionA key character of a simulation system is its simulated time that is the abstract from the time of the simulated world. To support simulation modeling, a language should provide the virtual time semantics. UML has its own time concept, however, the time in standard UML always is used to support model real-time system and they are different in respect semantics. In a real-time system some action should be finished before a accurate absolute time or relative one, or in a anticipatable continuous time duration. The time here is physically determined by the wall clock, often implicitly. It is the abstract of the time of the simulation software system, while simulation virtual time is abstract of the time of the simulated system. They should not be misunderstand and the different is more obvious in real-time simulation system.To support simulation virtual time semantics, we introduce virtual time concept into UML. Virtual time is a value representing an absolute or relative moment in time of the simulated system. Similar to the time description in standard UML, virtual time information are expressed using virtual timing mark, virtual time expression and virtual time constraints. A virtual time expression is an expression that resolves to an absolute or relative value of virtual time in simulated system. A virtual timing mark is a denotation for the virtual time at which a simulation event occurs. Virtual timing mark expressions are shown as text prefixed with VT, for example, VTa or VTb. A virtual time constraints is a semantic statement of the absolute or relative value of virtual time.Using virtual time, we can define simulation object and simulation event. Simulation objects are modeled by the stereotype <<SimEntity>>. (Table 1) Simulation events are modeled by the stereotype <<SimEvent>>. (Table 2) In essence, a simulation event is similar as a signal. Different from other ordinary signals, a simulation event has a tagged value – time stamp – recording virtual time at which the event should be processed.In addition, in PADS system, simulation objects are distributed in diverse location or nodes. Thus when an object need to refer to other objects in different location the relations between them should be provided. To model this publish/subscribe relation we introduce the stereotype <<subscribe>>. (Table 3)StereotypeBase ClassParentDescriptionConstraintsTagged ValuesSimEntity<<SimEntity>>ClassN/AA class whose state variables may change with virtual time.None.Virtual TimeVtime=t.Table 1: Simulation Object Stereotype StereotypeBase ClassParentDescriptionConstraintsTagged ValuesSimEvent<<SimEvent>>ClassN/AA class which has meaning at some virtual time location. A <<SimEvent>> instance can inspire a state change of some simulation objects.{Invariant: t}In its lifetime, the virtual time is constant.Virtual TimeVtime=t.Table 2: Simulation Event StereotypeStereotypeBase ClassParentDescriptionConstraintsTagged ValuesSubscribe<<Subscribe>>AssociationN/AA subscribe association between two classes states that objects of the source class (called the subscriber) will be notified when a particular event has occurred in objects of the target class (called the publisher). The association includes a specification of a set of events defining the events that causes the subscriber to be notified such as simulation state change and simulation event send..NoneNoneTable 3: Subscribe StereotypeTo model simulation object behavior, the elapse of time in simulated world should be described, i.e. virtual time event. A virtual time event is a special simulation event that models the forward of the virtual time. We introduce key words VTafter and VTwhen. We can use VTafter followed by a virtual time expression to model a virtual time event and use VTwhen followed by a virtual time boolean expression to model the virtual time condition.State charts are often applied to system dynamic model. After introducing virtual time, state charts can model simulation objects’ dynamic behavior. Typical behaviors of a simulation objects include computing new state variables and generating new future events. A state chart with virtual time is similar to an ordinary state chart except for additional virtual time related notations and semantics such as virtual time events, virtual time expression, virtual time of a simulation object and simulation events. Figure 2 gives 2 examples. （1）（2）Figure 2: State Charts with Virtual Time SemanticsSimilarly, with virtual time, interaction diagrams could model the interaction relations of simulation objects. Figure 3 gives an example.Figure 3: A Interaction diagram with Virtual Time Semantics In standard UML, nodes describe objects’ distribution. However, it is not enough in PADS system. In a node there may be one or several logical process. A logical process is a semantic unit organizing multi simulation objects. The notable character of a logical process is that all simulation objects in it share uniform virtual time and common simulation event queues (including internal simulation event queue, simulation event send queue and receive queue.) A logical process simulates a part of the whole system. It processes simulation events and generates new future events. Between logical processes, simulation events are exchanged as message with time stamps, i.e. virtual time at which the events occur. To support modeling above simulation objects deployment information, we introduce a new deployment unit – LP. In semantics, LP is a special component including some simulation objects sharing virtual time and send/receive buffer.Introducing Separation of PADS virtual time synchronization from simulation objects’ functional properties at design time.The main aspect of a PADS system different from a sequential simulation system is the introduction of virtual time synchronization protocols. In a sequential simulation system the schedule mechanism is very simple with a global event list, only the event with the earliest virtual time stamp is selected to simulate. In a PADS system, to guarantee the correct causality, some virtual time synchronization mechanism should be used.Object oriented modeling methodology is applied in current most PADS system. From the point of view in object oriented system, the world are a set of interrelated objects. An object is a unit that could not be broken down and it executes a set of actions or behaviors. The implementation code of an object defines the object’s behavior as a whole, i.e. all behaviors are implemented in the same place despite their objective are different, some are functional while others are non-functional such as synchronization, concurrency and real-time etc. In PADS systems, the main non-functional properties include virtual time synchronization and data distribution management. In this paper, only the former is concerned. The mixture of functional properties and non-functional properties produces well-known and well-researched problems such as inheritance anomaly, low adaptability and reusability degree.In order to conquer these problems, it is essential to separate concerns, in such a way that the simulation object basic behavior is defined in object implementation, while other non-functional properties, like virtual time synchronization, etc are defined separately in other entities and composed later at compile or run time.Based on these strategy, some PADS systems employ separation, more or less. However, all existed methods’ separation are at implementation level, i.e. objects' functional codes are separated from non-functional codes. Our method is at design level. Is it necessary in design level? If a application need high reusability or adaptability, separation at design level should be provided.  Simulation object functionality design separated from other non-functional properties, contributes to increase in design modularity and in degree of reusability. Moreover, these designs can be reused in different systems with an appropriate composition mechanism.To use UML as a language for PADS design and reuse the virtual time synchronization design in different PADS systems, we can create a stereotype for each virtual time synchronization protocol and then establish the map between the stereotype and related base simulation classes. As following we illustrate this method taking conservative virtual time synchronization protocol as a example.First we will define the basic elements composed of the conservative synchronization protocol. Virtual time synchronization is defined as the constraints, imposed on a simulation object, which decide to delay or accept its simulation event processing in order to preserve the virtual time causality. Its basic elements include:Synchronization sate: Information about the state of virtual time synchronization such as Safe, Blocked.Synchronization methods: Methods for changing virtual time synchronization state, perhaps including processing simulation events or generate new simulation events.Synchronization predicates: Represents an invocation of synchronization methods, including guard, preaction and postaction.To model the conservative virtual time synchronization strategy, a new stereotype named <<ConservativeTimeSyn>> is defined. (Figure 4) It enables specifying the properties of conservative virtual time synchronization. In a conservative synchronization protocol, a LP can only schedule safe events, i.e. current simulated event should have the earliest time stamp in all events to be processed. Thus LPs process simulation events following time stamp order. To a LP, two events to be processed e and e', if the time stamp of e is earlier than that of e', i.e.ts(e)<=ts(e’)then e should be simulated before e’. In reverse the generation of events flow of a LP follows virtual time order. If a LP has no any new event in some output channel, then a null message with a time stamp of current local virtual time plus a lookahead value is sent. A lookahead indicates no new future events in this channel.Figure 4: Separation Of Conservative Syncronization from Functional PropertiesFigure 5: Synchronization State ChartIf a LP has not received messages from every input channel, it has to wait. Until all input channels has incoming events received, the LP can select the earliest event. After comparing it with events in the internal events queue to determine a earlier event. If the selected event is from some input channel, it should be removed from the channel. To be simple we suppose all received messages are removed from channels but record the number of messages from them. If a event message is simulated, just decrease the channel’s message counter by 1. The dynamic semantics here is illustrated by a synchronization state chart (Figure 5). Num in figure 5 is the number of unempty input channels and Max is the total number of input channels.The functional properties of a simulation object include its states, changes of states and generation of new events responding to simulation events. They are reusable under different virtual time synchronization protocols. Encapsulating virtual time synchronization into stereotypes not only enhances the simulation object functional part, but also makes the virtual time synchronization stereotypes could be reused in different PADS system.A Simple ExampleWe use the classical machine interference problem to illustrate how apply the semantics extended UML to PADS design.In the problem, a set of N semi-automatic machines fail intermittently and are repaired by one technician. Machine failure rates are assumed to follow a Poisson distribution with parameter λ. Upon arriving at a failed machine, a technician can repair the machine in a time period that is exponentially distributed with parameter µ. A variety of service disciplines are possible that specify how the technician selects a machine to repair. The single technician services all machines. In this problem, hereafter referred to as the machine repairman problem, (MRP) the technician traverses a path amongst the machines in a cyclic fashion (0, 1, . . .,N − 1, 0, 1, . . .). The technician walks at a constant rate and only stops walking upon encountering a down machine. The technician takes constant time T to walk from one machine to the next.To design a PADS system to simulate above problem, we can take the technician as a simulation object. To be simple we take an alternative. We treat the technician as a transit entity and put its arrival and departure in a simulation event. Thus machine entities receive the event messages to model the technician’s arrival to or departure from them.Then this example has only one kind of simulation object – machine and every machine has 3 states: up, down, inrepair. It is depicted with simulation object stereotype as Figure 6.Figure 6: Simulation Object - MachineThe behavior of processing simulation events is described by a UML state chart with extended virtual time semantics as Figure 7. Figure 7: A State Chart of Simulation Event Processing.In this example, there is only one simulation event – the machine k schedule a new technician arrival event to machine k+1. The modeling of simulation events between simulation objects is depicted in an interaction view that describes the relation between the roles of the system function that exchange messages. We can use sequence diagrams or collaboration diagrams with virtual time semantics to describe the simulation events exchanged between the simulation objects. In our example, the simulation event is model as a class of stereotype <<SimEvent>>, and the schedule relation is illustrated by the collaboration diagram as Figure 8. Figure 8: The collaboration diagram of MRPIn the example, the virtual time synchronization protocol is conservative one. As to topology, 3 LPs are used, the deployment view is illustrated in figure 9. Obviously, the lookahead value is T. If apply a optimistic protocol, only topology information is needed.Figure 9: A deployment view of MRP’s LPsRelated work and discussionMost existed PADS systems employ methods at implementation level to alleviate the simulation modeling complexity in such a way that the synchronization protocols are provided to users as a library. A modeler should know much about the underlined protocols. The simulation model in these frameworks has low level reusability because it is mixed with specific libraries or protocols. For example, in Warped [8], a simulation object inherits from base class SimulationObject, and SimulationObject inherits from class TimeWarp which encapsulates Time Warp protocol, thus the simulation object could only applied to optimistic protocol and the Warped environment. Another example is PARSEC [9] that is a PDES language similar to C. The models are coded in C and use private send/receive primitives that make they are hard to be reused in other environment.The High Level Architecture [10][11][12] provides a simple interface thus enhances the convenience of simulation modeling significantly. HLA provides a dedicated service of virtual time synchronization to simulation members.  HLA modeling – HLA-OMT – only aims to the interaction between members and restricts its use in integrity of legacy systems lacking simulation objects’ functional properties description facility.Some papers [13][14] compare the difference between HLA-OMT and traditional object-oriented modeling and show the shortcomings of HLA-OMT. [13] attempts to extend HLA by introducing additional software layers to RTI, but may bring huge costs.This paper suggests extending UML standard semantics to support PADS design to conquer the shortcomings of reuse at implementation level and the shortages of HLA modeling semantics. Thanks to the rich semantics of UML and its extension mechanisms, our method unified the simulation objects’ internal functional properties modeling and their interaction modeling, reducing the complexity of PADS design. In addition, separation of PADS virtual time synchronization and simulation objects’ functional properties enhances both simulation objects’ reusability and synchronization protocols’ reusability.The easiness, interaction and reusability of PADS modeling are keystones in this field. The inherent complexity requires more strong methods. In [15], Tolk suggested combination of PADS research with UML, especially with the Model Driven Architecture [16]. The ultimate target may be that PADS systems are real simulation models oriented and appropriate code generation tools are developed to auto-build PADS systems from simulation model specification. Our future work will follow Tolk’s suggestion to consider the protocol independent model (PIM) and protocol specific model (PSM) of PADS.8 ReferenceZeng, X.., Bagrodia, R., Gerla, Mario. GloMoSim: A Library for Parallel Simulation of Large-Scale Wireless Networks. Workshop on Parallel and Distributed Simulation, 1998:154-161.Frederick, W. Practical Parallel Simulation Applied to Aviation Modeling, 15th Workshop on Parallel and Distributed Simulation, 2001: 109-116.James Rumbaugh, Ivar Jacobson, Grady Booch. The Unified Modeling Language Reference Manual. Addison Wesley Longman, Inc., 1999.Ferscha, A., Tripathi, S. Parallel and Distributed Simulation of Discrete Event Systems. Technical Report CS-TR-3336, University of Maryland, August 1994.Misra, J. Distributed discrete event simulation. ACM Computing Surveys, 1986,18(1):39-65.Jefferson, D.R., Virtual Time. ACM Transactions on Programming Languages and Systems, 1985, 7(3):404-425.Ernest, H.P., Abrams, M. Simulation Model Development and Analysis in UNITY. Annals of Operations Research, 2002, 104:181-212.Frey, P., Radhakrishnan, R., Carter, H. W., Alexander, P., Wilsey, P. A. A Formal Specification and Verification Framework for Time Warp based Parallel Simulation. IEEE Transactions on Software Engineering, 2002, 28(1):58-78.Bagrodia, R., Meyer, R. et al., “PARSEC: A Parallel Simulation Environment for Complex Systems,” IEEE Computer, Vol. 31, No. 10, pp. 77-85, October 1998.Page, E.H. Beyond Speedup: PADS, the HLA and Web-Based Simulation. Workshop on Parallel and Distributed Simulation, 1999: 2-9.IEEE Std 1516.1-2000, Draft Standard for Modeling and Simulation (M&S) High Level Architecture (HLA) – Federation Interface Specification. Apr2000.IEEE Std 1516.2-2000, Draft Standard for Modeling and Simulation (M&S) High Level Architecture (HLA) – HLA Object Model Template(OMT). Apr2000.Tolk, A. HLA OMT versus traditional Data and Object Modeling – Chance or Shoe-horn. 00S-SIW-011, Simulation Interoperability Workshop Spring 2000, Orlando, Florida, March 2000Lutz , R. A Comparison Of HLA Object Modeling Principles With Traditional Object-Oriented Modeling Concepts. 97F-SIW-025, Simulation Interoperability Workshop Fall 1997, Orlando, Florida, September 1997.Tolk, A. Avoiding another Green Elephant – A Proposal for the Next Generation HLA based on the Model Driven Architecture. 02F-SIW-004, Simulation Interoperability Workshop 2002 Fall, Orlando, Florida, September 2002.Joaquin Miller, Jishnu Mukerji: “Model Driven Architecture (MDA), Document number ormsc/2001-07-01, Architecture Board ORMSC, Object Management Group (OMG), July 2001PAGE  PAGE  9LP3:M5,M6Ch3,1:lookahead=TCh2,3: lookahead=TCh1,2: lookahead=TLP1M1, M2LP2M3, M4Machine id=(k+1) modN,Machine id=kTank2Tank1A:<<SimEvent>>FireB: <<SimEvent>>evaluateDamage{VTB – VTA = 5ms}VTB: FireNormalVTA: Fire<<SimEvent>>TargetInRangeVTafter 5ms{VTB-VTA>5ms}GenerateEvent(e’){ts(e)=CurrentVtime+△T}CI … Communication Interface    SE … Simulation Engine  R  … Region, Simulation Sub-Model  LP … Logical ProcessR1CI1SE1R2CI2SE2(S’)(S)RiCIiSEiCommunication System<<SimEvent>>Arrival（VTime=LVT+T）ArrivalArrivalDepartDownUP　VTAfter λ(self)In RepairVTAfterμ(self)SimulateAEvent (Event)GenerateEvent(Event)State: Enumeration (up, inrepair,down)<<SimEntity>> Machine<<SimEvent>> eNum<MaxNum=MaxSafeBlockedGetMinMsg->e, if ts(e) <ts(EVL) Dispatch(e), if InChannel(index(e)) empty Num--  GetMsg->e, if Inchannel(index(e)) empty, Num++SimulateAEventGenerateEventSimulateAEventGenerateEventSimObjectmStateAttribute1…StateAttributej;SimObject1StateAttribute1…StateAttributek;GetMSg; Dispatch;SendMsg;Vtime:float;OutChannel(n);Lookahead(n);InChannel(m); IB(n);OB(n);<<ConservativeTimeSyn>>nameAssociation:(SynMap)  ……