Challenges in Developing the JTLS-GCCS-NC3A FederationJeff NielsenMarnie SalisburyThe MITRE Corporation1820 Dolley Madison Blvd.McLean, VA 22102703-883-5679, 703-883-7064jnielsen@mitre.org, marnie@mitre.orgKeywords:JTLS, GCCS, NATO, simulation-to-C4I linkage, HLA, DDM, time management, Visual OMTABSTRACT: This paper looks at the recent effort to migrate the Joint Theater Level Simulation (JTLS) to the HLA, together with several elements of the JTLS exercise-support package.  A prototype federation is being developed with federates that interface to GCCS, NATO command-and-control systems, and commercial viewers.  We discuss seven technical challenges encountered during the development of this federation and explain the solutions reached for each one.  These challenges include: determining whether JTLS or GDS (the simulation data server) should provide attribute value updates, using the HLA data distribution management services to exploit the simulation's support for different perceptions of the game, defining a data-transfer format for sparse arrays, resolving cross-federation object references, and choosing tools for collaborative FOM development.This paper presents information representing the HLA development process underway by DMSO and the DoD AMG.IntroductionThe Joint Theater Level Simulation (JTLS) has been used successfully for many years as the basis for simulation-based training exercises in the U.S. and other NATO countries.  Over time, the JTLS exercise-support package has grown to include simulation-to-C4I interface modules and tools for response-cell players.  This paper looks at the recent effort to migrate JTLS and several elements of this support package to the Department of Defense High Level Architecture (HLA).An experiment is currently underway to construct an HLA federation consisting of JTLS and a multi-national set of command-and-control systems (none of which were previously HLA-compliant).  This prototype federation essentially replaces the communication mechanisms currently used between these systems with the HLA Runtime Infrastructure  (RTI).  Figure 1 shows the way that several of these systems presently work together in exercises, while Figure 2 shows the complete proposed federation.  A comparison of these two diagrams illustrates the intent of this effort.  The individual components of the federation (the "federates") are explained in more detail below.Experiment ObjectiveThe primary objective of this experiment is to develop the experience base in using the HLA for simulation-to-C4I system linkage.  Such linkage has always been one of the HLA's underlying goals.  Objective 1-1 of the DoD Modeling and Simulation Master Plan states that the purpose for establishing a high-level architecture is to "facilitate the interoperability of all types of models and simulations among themselves and with C4I systems" [1] (emphasis added).  At the time of this writing, the experiment is still in progress.  The plan is to conduct a proof-of-principle demonstration in September 1998.The FederatesFollowing is a brief description of each of the federates participating in the JTLS-GCCS-NC3A federation.  Please refer to Figure 2 for a conceptual diagram showing how the federates interact over the HLA RTI.  The various arrows labeled with letters indicate which data each of the federates will publish and subscribe to. The JTLS Combat Events Program (CEP) is the core process of JTLS.  The CEP does all the modeling of the combat units, the events, and the battlefield environment.  It contains the algorithms for computing the state of simulation objects, and reacts to orders created by human operators (players). GDS, the G-Protocol Data Server (also called the Genis Data Server), is used as the data management and distribution component of the JTLS system.  The CEP sends state information for all simulation objects to the GDS.  The GDS, in turn, services the information needs of a vast array of simulation "clients," including player consoles, data display terminals, and data translation modules that enable linkage to C4I systems.OTH-GEM is the Over-the-Horizon Genis External Module.  This program takes simulation state data as input, and produces OTH-Gold messages that can be delivered to real-world C4I systems (those that accommodate the OTH-Gold message protocol).GCCS, the Global Command and Control System, is the battlefield situation display and information-management system for theater- and joint-task-force-level commanders and their staffs.The MÄK 2-Dimensional Viewer is a commercial, HLA-compliant product that provides real-time display of federation objects (in the form of icons).  By adapting to a federation object model, the tool can be customized to run with different federations.The NC3A Land Order Translation Module (LOTM) is a response-cell support tool that enables role players to enter mission orders using more "natural" operational terms and graphics.  The LOTM then transforms this data into a set of orders for subordinate units that can be executed in JTLS.The NC3A Aggregator is a response-cell tool intended to reduce the role players' workload by making it easier to discover and report status information for aggregate units (made up of several smaller sized units that are explicitly modeled in the JTLS game). The aggregator calculates the status information for an aggregate unit from the data for the individual constituent units.The NC3A ICC Air Track Formatter is a software module similar to OTH-GEM.  It uses the simulation state data for aircraft, air missions, airbases, SAM sites, and radar sites as input and generates output in the appropriate format for several NATO C4I devices, including OPUS, ACBA, and ICC.The NC3A Bi-MNC Report Generator is a family of processes that translate a subset of JTLS simulation data into well-structured, formatted messages.  These messages can then be delivered to the training audience via real-world communications systems.  The modules accomplish the end-to-end process of preparing and injecting the reports into the communications backbone. The acronym "NC3A" in the above descriptions refers to the NATO Consultation, Command, and Control Agency (the former SHAPE Technical Center).Purpose of PaperThe body of this paper will highlight several technical challenges we encountered in the development of this federation, together with an explanation of the solutions reached for each one.  We hope that such a discussion will be beneficial to other federation developers who encounter similar challenges in the future.Technical Challenges EncounteredThe following seven questions represent issues we have had to deal with at various stages of federation development.Who should be responsible for simulation object attribute updates?How can DDM be used with different sides' perceptions of objects?How are sequences (arrays) represented over the RTI?How do federation objects refer to other federation objects?Which federates should be time regulating and/or constrained?How is federation initialization best done?What tools work well for collaborative FOM development?In the paragraphs that follow, we describe the technical challenges in more detail, the alternative solutions that were examined, and the pros and cons of those alternatives.  Finally, we discuss the solution that was adopted and talk about the current status of the federation.  Although these challenges are discussed in the context of this particular federation effort, we believe that some of the issues raised are applicable to a broader HLA audience. Who should be responsible for simulation object attribute updates?One of the first issues we encountered in developing the federation object model (FOM) was the question of who would be responsible for updating the attribute values of the simulation objects.  While it may seem obvious to assign this responsibility to the federate simulating the objects, it was not that simple in the case of JTLS.As alluded to in the federate descriptions, JTLS currently relies on the GDS to be the manager and distributor of the game data.  Although the CEP produces all of the data, it communicates this data only to the GDS.  Anyone else interested in receiving the data or otherwise interacting with the CEP—including all of the other JTLS components—must do so as a GDS client.  The rationale behind this approach is to permit the CEP to spend a minimal amount of effort in data transfer in order to use the bulk of its computation time for simulating the game.In our early planning, there was a strong desire to keep this model of data publication and distribution by using the GDS as the federation "refresh engine."  The CEP could then continue to publish new data only once, while the responsibility of re-publishing existing game data would fall to the GDS.  In this manner, the GDS would maintain the current game state for the benefit of late-joining federates or federates that crashed and then came back online, for example.  There was a big concern about imposing an unacceptable I/O burden on the CEP—to the point of slowing down the model itself—by requiring it to provide these "refresh" updates.In HLA terms, the initial goal was for the CEP to issue an "Update Attribute Values" service call for a game object only when the actual value of the attribute had changed.  The GDS would then call "Update Attribute Values" in response to any "Provide Attribute Value Update" callbacks.  The difficulty with this, of course, is the fact that the HLA rules allow attribute values to be owned only by one federate at any given time [2].  And only the federate that owns the attribute is allowed to update its value.  In fact, when another federate issues a request for an attribute value update, only the owning federate receives the "Provide Attribute Value Update" callback. We therefore found ourselves with a dilemma. The CEP needed to own the simulation objects in order to register them and update their values as the game progressed.  But we wanted the GDS to own these same objects in order to provide attribute value updates in "refresh" situations. We considered several potential solutions to this problem, including the following. One option was to handle "refresh" requests with a pair of special interactions rather than using the standard HLA services.  A late-joining or returning federate could send an interaction (instead of a "Provide Attribute Value Update" request) to indicate that it needed a general data refresh, and the GDS would respond with another interaction (or several) containing all of this data.  This option would allow the CEP to maintain ownership of all simulation objects.  But it would also require all of the other federates to write a non-standard RTI interface, and we would essentially be "reinventing the wheel" by creating our own attribute-value-update protocol.Another option was to use a set of mirrored object classes for private communication between the CEP and GDS.  For every conceptual class in the object model, there would be two corresponding classes in the FOM: one "real" class and one "mirrored" class with a slightly different name. The CEP would communicate the game data to the GDS using the mirrored object classes (which only the latter would subscribe to), and the GDS would then republish this data to the federation at large using the real object classes.  While this option is workable, it also has several drawbacks.  Besides doubling the size of the FOM, there is no way to enforce the restriction that only the CEP and GDS use the mirrored classes.  Any other federate could mistakenly or maliciously subscribe to these "private" classes and issue update requests.  More significantly, this solution does not take full advantage of the HLA goal of simulation reuse—it is really just a way of changing the communications protocol between the CEP and the GDS.  For the rest of the federation, the CEP/GDS combination would effectively be a single federate.  And other federates would be limited to communicating with JTLS only through the GDS (as they are today).  Yet a third approach that we considered was to use the HLA ownership management services to share attribute ownership between the CEP and the GDS.  After publication and object registration, the CEP would retain ownership of only those attributes which it needed to change frequently ("dynamic" attributes), but it would divest ownership of all of the relatively "static" attributes to the GDS.  In this way, the CEP would receive update requests only for those attributes that it was already updating regularly and the GDS could handle the rest.  While this solution takes full advantage of the HLA services, there was a concern about the potential latency involved with such a large number of ownership transfers.  Every time the CEP did need to update a "static" attribute, for example, it would have to regain attribute ownership, send the update, and then divest the ownership back to the GDS.  We also determined that it would be quite difficult to predict accurately which attributes fall into the "dynamic" and "static" categories.In the end, we decided that none of these three options was satisfactory.  The first two were more or less attempts to circumvent the intended use of the HLA and the latter was unworkable in practice.  The more we considered the options, the more we realized that the correct thing to do was to have the CEP be completely responsible for the game objects it models—including providing all attribute value updates requested by late-joining or returning federates.In essence, this became larger question of whether JTLS was going to become truly "HLA-compliant."  By definition, a compliant federate "interacts with the RTI in accordance with the HLA interface specification" [2], which includes being willing and able to respond to callbacks like "Provide Attribute Value Update."  Eventually we agreed that the CEP should implement a robust RTI interface for complete HLA compliance.  In the current federation, the CEP now publishes all of the data about the simulation objects to the RTI.  Other federates can subscribe directly to as much of this data as they are interested in—without needing to go through the GDS.  The principal role of the GDS in the federation is now to service those clients that are not yet HLA-compliant (such as the GIACs).Regarding the initial concern that the CEP's performance will be compromised by having to provide too many "data downloads," we have decided to adopt an experimental attitude and examine the validity of this concern during our testing.  We will measure the relative number of refresh updates to regular attribute value updates, particularly as this relates to the frequency of federates crashing.  With additional data, we will be better qualified to address concerns like this one in the future.How can DDM be used with different sides' perceptions of objects?A second large issue that arose early in our federation development was the question of how best to represent the different sides' perceptions of game objects.  One of the features of JTLS is its ability to model up to ten different sides in a game, each with its own perception of the battlespace.  Many of the game objects in JTLS have attributes that can be perceived differently by each of the different sides.For example, a ship object has attributes such as "location," "side," "strength," "posture," "mission," and "speed."  At any point in the game, each of these attributes has a value that is the "ground truth."  But each side in the game has its own idea or perception about the values for these attributes, depending on that side's sensors, intelligence reports, etc.  So while the red side thinks that ship CG-47 is at location (x1, y1) with speed 8 knots, the blue side might believe it is at (x2, y2) proceeding at 5 knots.  And neither perception may match the ground truth.The challenge was thus to determine the best way to publish all of this perception data to the federation.  The early drafts of the JTLS SOM grouped each set of perceived values for an attribute into an array, which was treated as an additional attribute (imitating the way that perception data is currently stored in the GDS).  So a ship object had one "location" attribute whose value was the actual location, and another attribute named "perceived location."  The latter was an array containing all of the different sides' perceptions of the ship's location.  The length of these "perceived value" arrays was equal to the number of sides portrayed in the game.The main problem with adopting this initial approach is that a subscribing federate would always receive much more data than it needed about an object, unless it was interested in every side's perception.  For example, if a GCCS system or other viewer were displaying the blue side's view, it would have to continually extract the single corresponding location value from the array of perceived locations and repeat this process for every attribute of every update.  (There is also the concern about whether a single-side federate should even have the access to other sides' perceptions which this method provides.)  This approach essentially creates bloated objects containing all of the perception information that anyone might ever need.  And these larger objects necessarily take longer to update, to transfer over the RTI, to reflect, etc.In the standard JTLS mode of operation, the GDS ensures that a client only receives the data corresponding to the side(s) that it is interested in.  We needed a way to reproduce this functionality with the HLA RTI.Our solution had two parts.  We first eliminated all of the "perceived value" attribute arrays from the FOM and determined instead to use multiple instances of each game object to represent the different perceptions.  For example, if there is a ship object in a game with five different sides, the CEP will actually register six different versions of that ship with the RTI.  One of these ship instances has attribute values corresponding to the ground truth, while each of the rest have values representing a single side's perception of the ship.  In this way, filtering can be done at the object rather than the attribute level.  So if a federate is only interested in the blue side's perception of the game, for instance, it simply ignores all but the "blue" objects.Having done that, the second part of the solution was to let the RTI do the appropriate filtering automatically by using the data distribution management (DDM) services.  These services allow federates to limit object registrations and subscriptions to a particular region within a routing space.In our case, we defined a one-dimensional routing space indexed by the perceiving side for an object.  All "perceivable objects" are registered in the region of the routing space that corresponds to their perceiving side.  For example, the "blue" objects are registered only with the "blue" region, the "red" objects with the "red" region, etc.  Figure 3 shows a simplified graphical representation of such a routing space with three sides.Subscribing federates can then tailor their subscription requests to get exactly the data they want without having do their own filtering.  A federate interested in seeing the game from the blue side's point of view simply subscribes to game objects only within the "blue" region. Likewise a "red" federate subscribes only to objects in the "red" region, while a federate interested just in ground truth subscribes to the "controller" region.  A federate can view multiple sides' perceptions by subscribing to the union of two or more of these regions, and the rare federate who wants information about all of the different perceptions could subscribe to the whole routing space.There are of course potential concerns with this scheme.  The biggest of these is that the number of federation objects is increased by a multiplicative factor—potentially up to 10-fold depending on the number of sides in a given game.  In our federation, this means scaling from tens of thousands of objects to potentially hundreds of thousands.  Besides greatly increasing the registration responsibilities of the CEP, having this many federation objects may exceed the performance limitations of the current RTI.  A second concern regarding the use of DDM is whether it will significantly increase the latency of attribute updates.  We do plan to examine these issues carefully in our upcoming testing, and we hope that using DDM will prove not to be a detriment to federation performance.How are sequences (arrays) represented over the RTI?In creating the JTLS SOM and the federation FOM, there were several situations in which an object contained large sets of related attributes.  For example, each "Unit" object in JTLS has a set of values representing supplies on hand, another set representing supplies due in, and another representing its supply stocking objectives. These sets can have a data value for each of 65 different supply categories.  Such data is more naturally grouped into arrays rather than listed as separate attributes in the FOM.  In the example above, our FOM has three arrays of length 65 rather than 195 distinct attributes.The current OMT specification supports the use of such array attributes (which it terms "sequences"), and these are straightforward to document in a FOM or SOM [3].  Nevertheless, questions arise about how best to send these sequence attributes over the RTI.  One such question is, "Does the entire sequence or array always need to be sent with each attribute update?"While there are a couple of commonly accepted ways to send atomic data types over the RTI, there really is no standard way to marshal array-type attributes.  Attributes with types like "long" or "double" are generally represented "on the wire" either with the actual bit pattern used to store such values internally (e.g., two's-complement signed integers, IEEE floating-point representations, etc.) or as ASCII strings.  However, sending sequences in a way corresponding to their internal representation would involve sending each element of the array in order.  This may or may not be appropriate.For example, the supply category arrays from our FOM are generally sparse arrays.  That is, while there may be 65 slots in the array, only a dozen of these slots might contain valid values for a given unit—the rest go unused. Furthermore, updates to the array are generally performed only on a handful of individual array elements at any one time.  In this case, sending all of the array elements for each attribute value update would clearly be wasteful.We therefore ended up defining our own RTI representation for such sparse arrays in our federation.  Our scheme is a simple one: each update for a sparse-array attribute consists of an integer value followed by of a set of tuples.  The tuples contain an array index and the value for that index, and the integer specifies how many tuples will follow in the set.  This is a self-defining data representation which allows a federate to send only data for those values in the array that have changed.This representation works well provided that it is understood and implemented by all of the federates.  Each federate has to know when it receives an update for a sparse array that it will be encoded in this manner.  To ensure this, the representation is documented in the "Data Representation Tables" of the Federation Execution Planners Workbook (FEPW).  As indicated by these tables, a federation is free to define any representation it desires for the data types in its FOM (although there is currently some controversy about this subject).  In our federation, defining our own sparse-array representation allowed us to do things in a much more efficient way while still keeping the FOM conceptually clean.How do federation objects refer to other federation objects?As in other object-oriented paradigms, there are many situations where one object needs to refer to another in a federation.  An object may hold a "pointer" or reference to another object to represent some sort of relationship between them, or an object may actually aggregate a set of other objects.  We have both kinds of object references in our federation.  Because of the many inter-relationships among the simulated entities in JTLS, most game objects contain references to others—for example, a "Surface" object holds a pointer to the object functioning as its "higher headquarters."  An example of a composite object in our FOM is a "Railroad," which consists of a group of "Arc" and "Node" objects.The HLA provides a mechanism to handle these sorts of object references.  Every object in the federation is assigned a federation-wide unique name string at registration time (note that this is a change in version 1.3 of the specification) [4].  This name can either be specified by the federate registering the object or generated automatically by the RTI.  The unique name is provided to subscribing federates in the "Discover Object" callback along with an object handle that is local to the federate.  RTI services exist for translating back and forth between the unique name and the local object handle.An object can therefore maintain a reference to another object by storing the second object's unique name as one of its attributes.  Other federates that reflect this attribute can then learn about the referenced object. We did encounter one potential pitfall with using object references as attributes, however.  Because each federate only knows about a subset of the federation objects at any given time, there is the possibility that a federate may encounter a reference to an object that it does not know about.  This would be manifested (among other ways) by an "Object Not Known" exception being raised when the federate tried to translate the unique name string of the reference into a local object handle.  Because the federate has not discovered the referenced object (even though it exists in the federation at large), there is no local handle for it.There are at least two reasons that a referenced object might be unknown to a federate.  The first is that the federate may not be subscribed to the class (or associated DDM region) of the object being referenced.  This can be remedied by ensuring that a federate subscribes to all of the classes in the FOM whose objects contain cross-references.The second possible reason for an unknown reference is subtler and reflects a situation we worried about for our federation.  A federate may in fact be subscribed to all of the correct object classes, but it may not yet have received the "Discover Object" callback for the object being referenced.  Because there is no message ordering associated with discovery callbacks, there is no obvious way to ensure that a federate will discover an object before receiving an attribute value update for a second object that refers to the first.  This is true even if the publishing federate registers both objects before sending out any updates—there is no guarantee that the corresponding discover and reflect messages will arrive in the same order on the receiving end.  We noticed this problem when working out the initialization procedure for our federation (see also section 2.6 below).  As mentioned, there many cross-references between the JTLS objects, and the GDS needs to be able to resolve all such references in order to populate its database correctly.  Furthermore, to simplify processing, it was desirable for the GDS to be able to store data for each object immediately upon receiving its initial attribute value update.  While we agreed that the CEP would register all of its objects before issuing any attribute updates, we realized that there was no way to ensure that all of the discover callbacks would be received by the GDS before updates started to arrive.  In this way, the GDS could receive references to undiscovered objects.A similar situation might also be experienced by a late-joining federate who subscribes to a set of object classes and immediately begins receiving discoveries and attribute value updates simultaneously. To solve the problem for the GDS, we decided to add extra information to all of the object reference attributes.  In addition to the federation-wide unique name, all object references now include the datatype of the object and the model it originated from (in case there are multiple CEP federates).  This information can either be encoded in a complex datatype or included in a federate-supplied unique name at registration.  This extra information is sufficient for the GDS to be able to correctly store an object even if it contains references to other objects which cannot be immediately resolved. Which federates should be time regulating and/or constrained?In determining how we would use the HLA time-management services in our federation, the biggest challenge we encountered was understanding which federates should be "time regulating" and which should be "time constrained."  Making this decision turned out to be more complicated than we had initially thought.  A brief summary of the evolution of our thinking on this topic illustrates the complexity of some of the issues involved. Before deciding whether or not a federate should be "regulating" or "constrained," it is important to understand what these words mean in the context of the HLA (regardless of what their English definitions may imply).  For instance, first-time federation developers may initially think of these terms strictly in the context of pacing the advancement of federation time: the  "regulating" federates control the advancement of federation time and the "constrained" federates must follow this time advancement. In our federation, for example, we want the CEP to control the advancement of federation time so that it can reflect the JTLS game time.  Making decisions based on the simplified explanation above could lead us to the following (incorrect) conclusions:  Since the CEP should have sole control over time advances in the federation, it should be the only time regulating federate.  Because we also want other federates with a notion of time to stay synchronized with the federation/game time, all other time-keeping federates should be time constrained.  Those federates without an internal representation of time should be neither regulating nor constrained.There are, however, more subtle issues that must be understood in conjunction with the time management services—it is not simply a question of who will pace and who will follow.  Specifically, it is important to note that "regulating" and "constrained" are defined in the HLA specification primarily in terms of the handling of time-stamp-ordered messages.  Only a regulating federate can send out messages (i.e., attribute updates, interactions, or object deletions) with a time stamp, and only constrained federates can receive messages with time stamps [4].  So the more appropriate questions to ask in determining candidates for "regulating" or "constrained" status are: "Which federates need to time-stamp outgoing messages?" and "Which federates need to receive messages based on their time stamps?"Another desire in our federation was for all of the federates to be able to see the time stamps the CEP placed on its messages.  To achieve this, though, every federate would have be constrained, regardless of whether it kept any internal representation of time.  We also wanted the other federates who would be issuing orders to the CEP (in the form of interactions) to be able to time-stamp these messages.  This means that these federates (specifically the GDS and the LOTM) would also have to be regulating.  Delving further into the implications of "regulating" and "constrained" brings us to the issue of causality.  Strict causality in message ordering is only guaranteed with messages that are sent and received in time-stamp order. Thus to ensure that events are received and processed in a coherent sequence throughout the entire federation, every federate needs to be both regulating and constrained.  In our federation we have an interesting situation.  Because JTLS has its own sequencing queue for incoming orders and because these orders carry their own internal time information, we do not need to worry about ensuring strict causality across the federation.  But we do need a way to guarantee that groups of orders sent to the CEP from the GDS (or other federates) will be received in the sequence sent.  This creates an even stronger case for why the order-issuing federates should be time regulating.  Even if no one cares about the actual federation time associated with an order (thus obviating one purpose for time stamps), time stamping is still the only way to ensure correct sequencing of messages.In short, then, we have the following situation. The JTLS CEP needs to be regulating and constrained.The GDS and other order-issuing federates need to be regulating and constrained.Other federates interested in receiving time-stamped messages need to be constrained.This combination is still not without its problems.  For example, how can we ensure that the CEP will be the one pacing federation time in the presence of multiple regulating federates?  And how can two federates which are both regulating and constrained exchange messages without advancing federation time (as the CEP and GDS sometimes need to do)?  We have found satisfactory answers to these questions as well, which are beyond the scope of this section.  They are mentioned here only to underscore the complexity involved with working out federation time management.  To summarize, there are many criteria that need to be considered when assigning "time regulating" and "time constrained" status.  Ultimately, the time management services deal with the ordering of messages received by each federate.  In this sense, one can think of them as "sequence management" services.  The issue of whether a federate cares about the federation time per se may not even be relevant in determining whether it should be regulating and/or constrained.  These decisions are ultimately based on federation-wide agreements about message sequencing and the need for ensuring causality. How is federation initialization best done?Federation initialization poses a number of interesting challenges. The HLA documentation emphasizes the runtime exchange of data among federates during a federation execution.  But in many federations there is a significant amount of information that must be communicated "up front" before federates can begin doing useful processing.  Much of this data is static and only needs to be shared on a one-time basis.  For example, as a large-scale combat simulation, JTLS utilizes an extensive set of reference and initialization data.  This data includes things like equipment and supply categories; unit and ship prototypes; the description of the terrain upon which the game will be played; and the name, composition, command hierarchy, and location for all simulated units at game startup.  Some subset of this data is also needed by each of the other federates in order to run (e.g., the Viewer needs the terrain, the Aggregator needs the prototype information, all federates need the starting location of game objects, etc.).What approach should a federation take to disseminate this type of initialization data in a practical and orderly manner?  In attempting to answer this question for our situation, we made two important decisions: (1) we would not send all of the initialization data over the RTI, and (2) we would use a synchronized procedure for federation startup.  More details are provided in the following paragraphs.A strict HLA "purist" approach would require us to define a set of object and interaction classes for all of the initialization data and pass it over the RTI at the beginning of federation execution. Due to the sheer size of items like the terrain database, this would entail a huge increase in the volume of object registrations and attribute updates.  This method seemed imprudent—particularly considering that much of this data does not change during runtime.  We opted instead for a more practical "hybrid" approach, in which most of the static reference data is shared among interested federates by distributing copies of the data files prior to execution—including the terrain description data.  All of the other initialization data (e.g., unit descriptions, equipment and supplies, etc.) is distributed at the start of execution using the normal HLA services.Even with a reduced quantity of runtime initialization data, however, we still need an orderly and efficient way to ensure that all federates receive the necessary game information before starting the actual simulation.  With multiple federates joining, publishing, subscribing, registering, discovering, requesting updates, and turning on time-management services all in the first few seconds of federation execution, the potential for confusion is great.To prevent such difficulties, we defined a federation initialization procedure involving five different synchronization points (based on similar approaches used in other federations).  The HLA synchronization service calls provide a mechanism for all federates in a federation to notify one another that they have reached a pre-defined point in their processing.  Our synchronization points are named "publish/subscribe/register," "update," "reflect," time_management_on," and "running," and each one indicates that a federate has completed the initialization action implied by its name.  Federates that reach these points before others can thus wait until all federates are "synchronized" at each point before proceeding. This way, we assure that all federates have the chance to subscribe before any updates are sent out, that all (needed) initial attribute values have been received before any federate becomes time regulating or constrained, that all federates turn on time management before any one requests a time advance, etc.  This procedure has worked well in our initial tests.What tools work well for collaborative FOM development?The final challenge we discuss deals with the issue of supporting tools for HLA development.  In particular, we have attempted to find appropriate and effective tools for working together as a federation team. To develop the FOM we held a series of meetings over a period of several months.  Our approach was to have the individual organizations work on their federates' SOMs and then bring the teams together to merge these SOMs, explain the contents to each other, and resolve any differences.  In the first couple of meetings, we found ourselves somewhat "bogged down" by the process of trying to present and discuss the large object models we were dealing with.  The original JTLS SOM, for example, had close to 300 attributes.  It was quite cumbersome to sort through pages and pages of hardcopy OMT tables in order to locate the information relevant to any given discussion. It was even harder to help all of the participants gain a good conceptual understanding of the complete picture.  We also had difficulty working collaboratively with the freeware OMDT tool. The tables on the screen were only a little better than the tables on paper.  And making edits as a group was a slow and awkward process, due both to our early inexperience with the tool and some non-intuitive aspects of its user interface.We had much better results in later FOM-development sessions when we switched to a more graphically oriented tool.  We participated in beta testing an early version of the "Visual OMT" product [5].  Figure 4 shows a display screen from this tool.  This particular screen allowed us to view and manipulate object class hierarchies, object attributes, and attribute data types from a single location.In addition to providing a more intuitive interface (e.g., many of the editing operations are accomplished with simple "drag and drop"), the graphical nature of the display made it much easier for federation participants to read and interpret the FOM and to gain a complete picture of the model.  It was also simpler and quicker to find the particular section of the FOM we wanted to discuss at any point.  We recommend the use of such a graphical tool to teams attempting development of large FOMs in a group setting. ConclusionThe JTLS-GCCS-NC3A federation project is an ongoing effort.  At the time of this writing, the federates are completing the implementation of their respective RTI interfaces and preparing for integration testing in the coming weeks.This paper recounts some of the interesting challenges we have faced to this point.  We hope that the discussion of these challenges and our solutions to them will benefit other federation developers.  During our upcoming testing we will be able to validate the quality of these solutions, and we will continue to present our experiences as appropriate.Acknowledgments The authors wish to thank the following members of the federation development team for the willing contribution of their creativity, energy, and experience to the project:  Jonathan Roberts, Ellen Roland, and David Ward (JTLS); Cheryl Ammann and Dennis Brockway (GDS); Sherry Barnes (OTH GEM); Chip Bulgin and Jennie Womble (GCCS); Steve McDonald (2-D Viewer); and Tom Koolen, Aad Van Stegeren, and Anton Van Weel (NC3A).  We appreciate Jean Graffagnini's efforts to keep the FOM up-to-date.  We also thank Dr. Dirk Coppieters for his efforts in coordinating and leading the NC3A participation in the federation.ReferencesUnder Secretary of Defense for Acquisition and Technology: “Department of Defense Modeling and Simulation Master Plan, DoD 5000.59-P,” October 1995.U.S. Department of Defense: "High Level Architecture Rules, Version 1.3," 5 February 1998.U.S. Department of Defense: "High Level Architecture Object Model Template Specification, Version 1.3," 5 February 1998.U.S. Department of Defense: "High Level Architecture Federate Interface Specification, Version 1.3," 20 April 1998.Pitch AB: "Visual OMT," see URL http://www.pitch.se/omtool.Author BiographiesJEFF NIELSEN is a Software Systems Engineer at The MITRE Corporation. As a member of the HLA Cadre team, he provides technical and management support to the JTLS-GCCS-NC3A federation.  Mr. Nielsen holds an M.S. in Computer Science and an M.A.Ed. in Instructional Technology, and is currently pursuing a Ph.D. in Computer Science.MARNIE SALISBURY is a Principal Engineer at The MITRE Corporation.  She has six years of experience in battlefield simulation and interoperability, including 15 months as Technical Director for the DARPA STOW program.  She holds a B.S. in Computer Science and an M.S. in Systems Engineering. Figure 4: Editing the FOM with Visual OMTFigure 1: Standard Configuration of JTLS Exercise-Support PackageFigure 2: Federation Conceptual ModelFigure 3: "Perceivable Objects" Routing Space