Federating Time-Stepped and Discrete Event Simulations for AnalysisEmmet R. BeekerGRCI, An AT&T Company1900 Gallows RoadVienna, VA 22182703-506-4894 HYPERLINK "mailto:ebeeker@grci.com" ebeeker@grci.comKeywords: AMP, Analysis, Discrete Event Simulation, Federation, High Level Architecture, Time ManagementABSTRACT:  The High Level Architecture (HLA) makes it possible to use a single runtime infrastructure to federate discrete event simulations with time-stepped simulations.  While the version 1.3NG Runtime Infrastructure (RTI) does not perform well for homogenous discrete-event simulation federations, it can perform quite well to federate a single discrete event simulation with time-stepped simulations.  Using the Advanced Mobility Platform (AMP), Model for Intertheater Deployment by Air and Sea (MIDAS), and Enhanced Logistics Intratheater Support Tool (ELIST) federation as the example, this paper demonstrates how to use a combination of receive-ordered and time-ordered messages to obtain analysis’ quality results from a federation of mixed simulation types.IntroductionDeployment analysis performed by US Transportation Command (USTRANSCOM), Joint Staffs J4, and Office of the Secretary of Defense (OSD) use “best of breed” models MIDAS and ELIST.  MIDAS produces “optimized” time phased force deployment data (TPFD) that is very strong in strategic utilization of the defense transportation system, but uses a low fidelity representation of intratheater movement.  ELIST provides a higher fidelity representation for intratheater movement, but TPFDD to already exist.  When analysis time permits, MIDAS and ELIST will be executed cyclically until the solution converges.  The analyst would like to be able to run the models interactively so that MIDAS could take into account road blockages, port bottlenecks, and alternate routing that ELIST uses.  Likewise, MIDAS could redirect strategic lift to avoid closed canals, minefields, and threat areas, resulting in a dynamic TPFDD for ELIST.  However, MIDAS and ELIST use two different time management modes.  MIDAS is a time-stepped simulation, normally using one day of simulation per time step.   ELIST is a discrete event simulation.  Until the HLA, integration of these two simulations would have required major restructuring of one or both simulationsThe High Level Architecture is designed to federate heterogeneous simulations that use three different time management modes: continuous, time stepped, and discrete event.  Of these three, time stepped and discrete event simulations are most often used for analysis.  This is because continuous simulation can produce temporal anomalies that are non-causal and simulation results that are not repeatable, discussed in section 2.1.  HLA makes possible the federation of simulations that would have been impossible before.  This paper describes how time-stepped and discrete event simulations can be federated using the AMP-MIDAS-ELIST federation as the example.Even though the HLA specification provides for multiple time management modes, in actual practice it is difficult to implement a time management protocol that is efficient for all modes.  Section 2 will explain the different time management modes used for computer simulation.  Section 3 will describe the capabilities and limitations of the version 1.3 NG RTI in synchronizing heterogeneous simulations.  Section 4 will give descriptions of the AMP simulations.  Section 5 will present the analysis used to synchronize ELIST, a time-stepped simulation, with MIDAS, a discrete event simulation.  Finally, section 6 will list observations and discuss why federation builder may want to convert discrete event simulations to time-stepped simulations when using the version 1.3NG RTI.Time Management ModesFigure 1 shows the three time management modes commonly used in digital simulation: continuous, time-stepped, and discrete event.  In continuous time management, each model generates messages to report state variables for the current time.  Time stepped simulations generate state data at fixed intervals.  Discrete event simulations generate messages at state changes.  Continuous simulation is, by nature, distributed – each model operates independently and sends messages about its status.  Time stepped and discrete event simulations can either be sequential (operating on a single processor) or parallel.  Parallel discrete event simulation can be further distinguished by synchronization protocol into optimistic and conservative.  Each mode has its advantages and challenges for distributed simulation.  The following sections describe their characteristics.Figure 1.  Simulation ModesContinuousContinuous time management mode is also known as real time simulation.  In this mode, each model sends out messages with the values of its state variables at the time the message was sent.  When other models receive the messages, they either assume the values to be current, or they extrapolate from the sending time to correct for latency.  Often messages are broadcast using unreliable transport, which can result in lost or dropped messages.  Messages are processed as they are received.  Since messages can arrive in any order, it is possible to receive event notification out of temporal order.  For example, the notification of a detonation may come before the notification of a round being fired.Because there is some latency in message delivery, all messages contain data from the past.  This means that there is always some error in the state data.  For many purposes, the error may be small enough not to affect the purpose of the simulation.  Training simulations and manned simulators use this mode successfully when the latency is small enough to be below the human response threshold.Time-SteppedTime-stepped simulations calculate state changes during a time interval.  First, they receive all of the messages for state changes from external models during the previous interval.  Then they calculate their internal state changes for the current interval and send out messages with the values for the end time of the interval.  All state changes take place at the end of the time interval.The size of the time interval is critical in a time-stepped simulation.  If the time step is small, then more processing must be accomplished to simulate the same time span as when the time step is larger.  However, if the time step is too large, important events may be missed.  Figure 2 shows the position of two billiard balls at the end of each time interval.  Because the interval is too large, the simulation missed a collision that should have occurred.Figure 2.  Results of a Too Large Time StepBecause events are constrained to occur at the interval boundaries, events cannot be ordered during an interval.  For example, if a tank is hit and disabled during the same interval in which it fires, both events should occur.  Figure 3 shows another example of an anomaly that results from time stepping.  Collisions are detected after they occur.  For some purposes this would be acceptable.Figure 3.  Collision of Two Billiard BallsDiscrete EventDiscrete event simulations calculate when a state change should occur and schedules an event for the planned time.  For example, the velocity of a billiard ball could be part of its state.  The simulation would schedule an event for any change in velocity, such as a collision.  There would be no state updates until the collision.  Events are scheduled by placing them on a queue.  The simulation process consists of removing events from the queue and processing them. The process could schedule additional events that are placed on the queue.  Because there is no processing for intermediate times between events, discrete event simulation can be more efficient than time-stepped simulation.Discrete event simulation is divided between sequential and parallel simulation.  Sequential discrete event simulation processes a single event at a time, thus guaranteeing causality.  Events are always processed in order.  After processing an event, the earliest event on the queue is removed and processed.  Any new events must occur after the current event (else we could change the past).Parallel discrete event simulation (PDES) allows the simultaneous processing of more than one event.  The difficulty with this is knowing when it is safe to process an event other than the earliest event on the queue.  If the earliest event will cause a change of state that would change the result of processing a later event, then the later event cannot be processed correctly until the earlier event is processed.  Correctness in PDES is when the results are identical to the results that would have been obtained if the simulation were executed sequentially.There are two approaches to this problem: optimistic and conservative.  The optimistic approach assumes that the local models have all of the correct state values and can always process the events it knows about.  When the local model receives a message from an external model that would change a state variable in the simulation’s past, the simulation “rolls back” to the time of the message and processes again.  All of the messages the simulation has sent about its previous state changes are now in error, so the simulation sends “anti-messages” to cancel them.  Depending upon the dependencies between nodes, the parallel simulation may spend most of its time rolling back.The conservative approach restricts the processing of an event until it can guarantee that the event will not be changed.  This is normally accomplished by using “look-ahead”.  Look-ahead is the amount of time between an external event occurrence and the internal state change that will be sent to other models.  For example, in a simulation of the Internet, the minimum time to pass a packet may be 10 microseconds.  Each node would have at least 10 microseconds from the time a packet is presented at the input until it appears at the output – yielding a look-ahead of 10 microseconds.  A node will not send an output message until it can guarantee that the message will not change.  Therefore, there will never be an anti-message.Figure 4.  A Simulated Internet NodeFigure 4 shows one node of the example Internet simulation.  The node has three input connections that are the outputs from other nodes.  The node has four outputs that are inputs to other nodes.  Since the look-ahead for this node is 10 microseconds and the earliest input is 330 microseconds, the node can send any messages with time stamps up to 340 microseconds.  However, after processing the event at 330 microseconds, the node cannot process the event on the second queue for 332 microseconds.  It is possible that another event at time 331 microseconds could arrive on the first queue.  Only after there is a message presented on the first queue can the node decide which event to process.RTI Version 1.3NGThe HLA specification allows for two message streams: receive ordered and time ordered.  Receive ordered messages are presented to a federate in the order received.  This order is not necessarily in order of the time of event.  Time ordered messages will be presented to the federate in order of their time stamps.HLA places no upper constraint on the time stamp for messages.  Federates can send messages with any time that is greater than the current federate time plus look-ahead.  Therefore, the RTI cannot use time stamps on sent messages to determine simulation time.  Rather, the RTI depends upon the federate to request a time advance.  When a federate requests a time advance, the RTI generates a series of special messages that will advance time. [1]The RTI uses all time regulating federates to establish a lower bound time stamp (LBTS).  The LBTS is defined to be the earliest time at which a time-stamped message can be delivered.  This is equal to the federate time plus look-ahead of the earliest regulating federate.  Before time is advanced, the RTI must guarantee that all messages with time stamps earlier than the new federate time have been delivered.  To do this, the RTI includes the number of sent and received time-stamped messages processed by each federate in the time advance messages.  When the total of sent and received messages is zero, then all of the sent messages have been received and time-advancement can proceed.  Because of message counting, all federates are included in the time advancement process.Time is calculated in the local RTI component and can only be advanced within a “tick” call.  The local RTI component uses a system call to check the buffers for input and output.  The minimum time for the system call to return is approximately ten milliseconds.  Therefore, if a federate asks for a time advance after every external event message, it can only advance time approximately 100 times per second.  This is a best case.  If the time advance requested is much larger than the look-ahead, then the RTI could take considerably longer as the RTI will advance the time by the look-ahead amount, sending a series of null time messages.  Each round of messages could take a separate system call.  As a result, time can only be advanced by (100 times look-ahead) in one second of real time. [2]The crucial time management question for a federation then becomes whether one hundred time advances per second is sufficient for the federation.  For many human-in-the-loop federations that operate at or below a frame rate of 30-60 frames per second, 100 time advances per second is sufficient.  An alternative for federations in which 100 time advances per second are insufficient is given in Section 6.AMP HLA FederationThe AMP HLA federation consists of an AMP Federate and modified versions of MIDAS, and ELIST.  The AMP Federate generates initialization data for MIDAS and ELIST and controls the federation.  The AMP Federate monitors and displays data provided by MIDAS and ELIST.MIDAS is a time-stepped simulation, normally processing one day at a time.  The time interval can be decreased, but this greatly increases the processing time required for a simulation run.  Normal run time for MIDAS to simulate 180 days of deployment is approximately 2 hours.  During an interval, MIDAS first adjusts state data based upon the results of the previous cycle.  Then MIDAS performs planning followed by execution.  Planning consists of building an airlift schedule for each deployment item in priority order, then comparing sealift for each item.  As items are moved from airlift to sealift, the airlift schedule is recalculated.  During execution, MIDAS will simulate the air movement and sea movement in separate modules, i.e., moving waiting ships into available berths, loading of ships already in berths, moving loaded ships out of berths, and moving ships at sea, perhaps arriving at ports.  Each module calculates all of the state changes for the interval before the next module executes.  There is no overlap within a module.  For example, a ship departing a berth makes that berth available for the following interval.ELIST is a discrete event simulation with events for ship and aircraft arrival.  As ships arrive, they are scheduled into berths for loading/unloading.  Aircraft are taxied to ramps and serviced/loaded/off-loaded as required.  Cargo is moved to marshalling areas and loaded on trains, trucks, planes, barges, or pipelines as required.  ELIST records the time cargo is unloaded and when it arrives at its final destination.SynchronizationPreviously, MIDAS and ELIST would be executed sequentially.  MIDAS would be executed first to create a list of ship and aircraft arrival events for ELIST.  ELIST would then perform higher fidelity port simulation to unload ships and aircraft.  Often the unload times for ships and aircraft would vary from the MIDAS times.  It was desirable to let MIDAS use the results from the higher fidelity ELIST simulation.  However, the synchronization of MIDAS and ELIST provided a challenge since they manage time differently.  What was needed was to gather ELIST events into time intervals to match MIDAS time steps and to sort MIDAS events into time-ordered discrete events to present to ELIST.  A secondary goal was to overlap MIDAS and ELIST processing as much as possible to decrease total execution time.MIDAS typically plans for 40-45 days during its planning cycle.  However, ELIST only cares about the next day’s events.  The next day’s airlift that is generated at the beginning of the planning cycle is never changed because nothing can arrive by sea in less than one day.  Therefore, all of the airlift events that ELIST cares about are generated in the first part of the planning cycle.  Ship arrivals in MIDAS occur during the Ships-At-Sea module processing.  Only ships already at sea can possibly arrive at a port.  By modifying the MIDAS processing loop to only schedule the first day of airlift and then process ships at sea before performing any other tasks, all of the events needed for ELIST could be generated at the beginning of the MIDAS processing cycle.  This allows nearly 90 percent overlap in MIDAS and ELIST processing.In order to synchronize ELIST to MIDAS, a new event, End-Of-Day, was created for ELIST.  This event is scheduled for midnight of every simulation day in ELIST to provide synchronization processing.  During this event, ELIST will ask for a time advance to the next day.  By asking for the time advance, the RTI will release all of its messages for the next day to ELIST prior to granting the advance.  When the advance is granted, then ELIST knows that it has received all of the messages from MIDAS and that it is safe to proceed.MIDAS operates in a slightly different manner.  MIDAS also makes use of the advance time request.  By asking for the same time as ELIST, MIDAS can be guaranteed that when the time advance is granted, all of the ELIST events have been delivered to MIDAS.  However, MIDAS does not ask for the time advance until after it has processed the first day’s airlift and ships at sea, as shown in Figure 5.  Thus, all of the messages that ELIST will need for the current day will have been sent prior to the advance time request.If time-stamped messages could be used, then the RTI would automatically sort and deliver the MIDAS messages to ELIST in time-order.  Unfortunately, the way the RTI handles look-ahead complicates the situation and prevents this straightforward approach.  The RTI requires that any message sent by a federate to have a time stamp greater than the federate time plus look-ahead.  Since federate time is the time granted by a time advance, all messages are required to be greater than the time in the advance time request.  MIDAS and ELIST both ask for the time they want to advance to, and when granted a time advance they simulate up to that time.  Any messages generated would have time-stamps before the granted time.  Therefore, time-stamp ordered delivery cannot be used.  Instead, receive ordered delivery is used and the time stamp becomes one of the parameters of the message.  ELIST must order the messages internally, instead of depending upon the RTI.This approach raises a second difficulty.  Time advances are controlled by messages in the time-ordered stream.  If there are messages in both the time-ordered stream and the receive-ordered stream, there is no guarantee of the ordering.  The time advance message could be processed before the receive-ordered messages, causing them to arrive late (i.e., in the next cycle).  To prevent this, a second small time advance was added to exhaust the receive-ordered message queue.  The processing shown in Figure 5 includes this extra time advance.SIM TIMEAMP FEDERATEMIDASELIST0.0requestTimeAdvance(1.0)tick()requestTimeAdvance(0.0001)tick()requestTimeAdvance(1.0)tick()0.0001RTI::timeAdvanceGrant(0.0001)Process day 0 aircraft and ship arrivals.RequestTimeAdvance(1.0)1.0RTI::timeAdvanceGrant(1.0)requestTimeAdvance(2.0)tick()RTI::timeAdvanceGrant(1.0)Process rest of day 0.requestTimeAdvance(1.0001)tick()Receive day 0 arrivals.RTI::timeAdvanceGrant(1.0)Process day sending updates.requestTimeAdvance(2.0)tick()1.0001Receive day 0 data from ELIST.RTI::timeAdvanceGrant(1.0001)Process day 1 aircraft and ship arrivals.RequestTimeAdvance(2.0)2.0RTI::timeAdvanceGrant(2.0)requestTimeAdvance(3.0)tick()RTI::timeAdvanceGrant(2.0)Process rest of day 1.requestTimeAdvance(2.0001)tick()Receive day 1 arrivals.RTI::timeAdvanceGrant(2.0)Process day sending updates.requestTimeAdvance(3.0)tick()Figure 5.  AMP-MIDAS-ELIST SynchronizationObservationsSuccessfully federating a time-stepped simulation with a discrete event simulation depended upon finding a subset of models in the time-stepped simulation that produced data of interest to the discrete event simulation.  Then, these models could be executed first in the cycle, allowing parallel processing for the remainder of the models.  MIDAS and ELIST were ideal for this.Because the RTI must accommodate all types of simulation, it must produce some degradation for particular types of simulation.  The constraint of 100 time advances per second limits RTI usefulness for PDES.  However, if events can be grouped into time segments, essentially turning the PDES into a time-stepped simulation, then 100 time advances per second may be sufficient.  Whether the loss of temporal resolution is acceptable must be weighed against the increased performance.Since the AMP federation is small, consisting of the AMP Federate, one MIDAS federate, and some small number of ELIST federates, the fact that time advances are coordinated over all federates is not a factor.  In a large federation, this may slow the federation unacceptably.  Time management for discrete event simulation should be handled in the same manner as data distribution management.Using a small time increment for synchronization can cause difficulties with the discrete event simulation.  In this example, ELIST should not create any events during the small time increment.  ELIST actually delays any events that would occur during the first 0.0001 of any day.  A better solution would be to use a compound time variable with a phase indicator.  Then the federation could move from one phase to another phase without having actual time increase.References[1]	Fujimoto, R.M., and R.M. Weatherly: “Time Management in the DoD High Level Architecture” Proceedings of the 10th Workshop on Parallel and Distributed Simulation, pp. 60-66, July 1996.[2]	Hodum, F, and David Edwards: “Time Management Services in the RTI-NG” Fall 2001 Simulation Interoperability Workshop, paper number 01F-SIW-090 available from http://www.sisostds.org.[3]	Tustin, J.P., W.F. Ferguson, C.N. Van Groningen, C.J. Keyfauver, E.R. Beeker, “Integrating MIDAS and ELIST into the AMP HLA Federation” Fall 2001 Simulation Interoperability Workshop, paper number 01F-SIW-057 available from http://www.sisostds.org.EMMET BEEKER is Chief Engineer, Modeling and Simulation, Advanced Systems Group of GRC International, an AT&T Company, Vienna, VA.  He was a member of the HLA Interface Specifications and Object Model Template working groups.  He is currently researching distributed simulation architecture for large military simulations.