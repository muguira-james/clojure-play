A Software Tool for Comparing Intervisibility Correlation between CGF and Visual Systems Dr. Guy Schiavone, Mathew Gerber, Judd Tracy, and Eric WoodruffIST/UCFUniversity of Central Florida3280 Progress DriveOrlando, FL  32826Todd KohlerRDECOM-STTCOrlando FL 32826Abstract: - With the continuing development of SEDRIS and related tools such as See-It and the Side-by-Side viewer, many of the correlation problems that have impeded the efficacy and advancement of distributed training simulations in the past are beginning to be solved.  However, one particular aspect of correlation of Synthetic Natural Environments between visual systems and Computer Generated Forces that has not been sufficiently addressed is the issue of intervisibility correlation.  For this case, the approach to computing point-to-point line-of-sight (LOS) intervisibility in the two respective classes of simulation applications is very different.  This is particularly true in cases where active entities in the simulation are partially obscured from the viewpoint of a sensor by complex features such as vegetation.  In visual systems, point-to-point LOS though complex, partially occluding objects is determined by the transparency values used in the particular texture maps being used to represent the occluding objects, with the result being dependent on both the characteristics of the textures and the programming and hardware capabilities of the particular graphical processing unit being used.  In the case of CGF systems, the LOS determination is done using a set of algorithms that cover a range of particular circumstances in terms of LOS through various objects.  In this paper we describe the development of a software tool for automatically calculating the LOS correlation between applications using terrain databases derived from OpenFlight and those derived from CTDB. Test results on large, production-quality terrain databases are presented, and recommendations for future improvements in LOS calculations are made. IntroductionIn the early days of distributed simulation for training, differences in representation of the synthetic environment were a major problem for simulation interoperability.  Some of the reasons for these differences included: 1)Lack of coordination between differing simulation applications in the approach to terrain  generation process, 2)Differences in source data used, 3) Differences in resolution required for various interoperating applications, 4) Proprietary competition for dominance in formats, 4) Lack of common agreement in a necessary and sufficient set of features and attributes, and 5) A lack of tools for assessing synthetic environment correlation between different formats.Since these early days, much progress has been made, with the development of the High-Level Architecture, the evolution of SEDRIS [1] and the corresponding EDCS [2] and SRM, and tools such as See-It [3] and the Side-by-Side viewer.  Progress proceeds with the continuing development of the Terrain Common Data Model [4] into a Common Data Modeling Framework.However, one area that has not been sufficiently addressed is that of intervisibility correlation between visual and non-visual representations of the synthetic environment.  Most past attempts at this have relied on interactive, side-by-side visualizations, implicitly converting the non-visual format geometry into a form that can be visualized.  However, most non-visual systems perform intervisibility calculations that are algorithmic in nature, and these algorithms can be quite complex.  Simple viewing of geometry leads to misleading conclusions regarding actual intervisibility correlation. Some notable observations and examples addressing this particular problem were made by Ashby, et al [5] and by Wannacott [6].In this paper, we focus on the intervisibility correlation between visual applications using the OpenFlight format, and intevisibility as calculated by the OneSAF Testbed (OTB).  The difference in our approach is that we do not rely on simple visualization of geometry, but rather focus on emulating the algorithms in OTB that are used to calculate intervisibility to give more accurate results in the comparison.  The goal of our work is to provide to the SNE community a tool that will use this technique for giving accurate assessments of intervisibility correlation between OpenFlight and CTDB datasets, both in automated and interactive modes.  Analysis – Visual and Non-Visual Intervisibility CalculationIn visual systems for training, geometry is commonly represented by polygonal surfaces.  Surface material types and cultural features are identified by the texture maps that are transformed onto individual or contiguous groups of polygons.  These textures may contain elements that are either partially or fully transparent.  The view frustrum parameters are determined by the particular sensor (or human viewpoint) that is being represented.  In the case of visual systems, intervisibility is actually a perceptual process that depends on many human factors (e.g. concentration, alertness, visual acuity), but we take a strictly engineering approach as a baseline.  As a simplification, in our initial experiments we neglect color blending and anti-aliasing, although we recognize the potential importance of these effects in the accuracy of analysis in a final product.  In our initial approach, we calculate intervisibility as the ratio of an entity’s visible pixels to the total number of pixels for the non-occluded entity at a particular range for a given screen resolution, including the effects of completely transparent occluding texture pixel elements.  Thus, the intervisibility measure for an entity from another entities sensor viewpoint is normalized as a floating point number that can range between 0 (not visible) and 1 (completely visible).The case of emulating visibility calculations in OTB is much more complex.  For example, the diagram below lists only a subset of the possible methods used to compute intervisibility in OTB, shown in Figures 1 and 2.The key user-exposed function call to determine intervisibility through libctdb is ctdb_point_to_point() [libsrc/libctdb/ct_ptop.c].  The function is not properly point-to-point, but point-to-cone.  It accepts, as its core parameters:A starting point,An ending point, andA width for the cone at the ending point.Optional parameters are:A minimum visibility level at which to “cut off”,Functions to specify the opacity of linear features, andA list of vehicles to test for visibility blocking.The function returns a 64-bit float corresponding to the area visible, and fills a passed 64-bit float address with the effective opacity (i.e., linear transmittance).Figure 1. Example of Major Function Flow for Line of Sight in the OneSAF Testbed (libctdb)Figure 2. OTB Intervisibility Checking Examples.Core Handling in OTBCTDB 5, as required by GCS, permits multiple terrain cells to exist.  LOS calculations are therefore not performed as a single point-to-cone function: in the case where an intervisibility cone traverses cells, intervisibility must be checked in the cone section across each cell and the results combined.ctdb_point_to_point() calls ctdb_traverse_ray() [libsrc/libctdb/ct_interv.c] to handle this inter-cell combining; ctdb_traverse_ray() must be passed a start point, an end circle, and a function to use for intra-cell intervisibility.  ctdb_point_to_point() uses ptop_cell_fcn() [libsrc/libctdb/ct_ptop.c] as the intra-cell visibility function.ptop_cell_fcn() is in turn a shell function that calls several functions to do its actual work: ctdb_vehicle_raster() to determine the effect of vehicles on intervisibility if vehicles are provided to the function.ctdb_terrain_element_intervis() [libsrc/libctdb/ct_interv.c] to check visibility against TINned terrain elements.  ctdb_terrain_element_intervis() is passed ctdb_update_visibility() and in turn passes it to ctdb_ptop_te_compare_init??() and ctdb_ptop_te_compare??() (functions existing in two fidelity levels, 08 and 16) which use it to actually determine visibility loss after edge intersection.ctdb_intervis() [libsrc/libctdb/ct_interv.c] to check visibility against gridded terrain elements and prepare masks for terrain features.  ctdb_intervis() is passed ptop_post_compare() and uses it to actually check for intersections with grid terrain.ptop_patch_compare() [libsrc/libctdb/ct_ptop.c] to actually process terrain features.  ptop_patch_compare() uses the feature comparison functions depicted in the diagram to determine the effect of each type of feature on intervisibility.ComparisonsPortions of libctdb’s line of sight systems can be directly translated into an arbitrary polygonal terrain representation.  Other portions, particularly those relating to grid terrain and terrain features, may require some CTDB-style representations to remain usefulSingle Cell CaseThere are actually several global variables involved in the line-of-sight operation: ctdb_visible_area and ctdb_linear_transmittance comprise the most critical tracked variables (since they are the results which will be returned) ctdb_block_from_top and ctdb_block_from_bottom are both used in internal calculations, ctdb_first_water is a Boolean flag kept for purposes of calculating refraction, and ctdb_minimum_vis stores the passed minimum interesting visibility.  Certain other variables are used to control program flow in the algorithm.The easiest way to understand the line of sight calculation is to look past the fact that libctdb is written in C to see its somewhat object-oriented architecture.  In essence calling the line of sight routine can be thought of as creating a short-lived object with the above variables as instance variables.  (The actuality of this is in fact exactly what would need to be done were a multithreaded line-of-sight function desired; the function as written makes no attempt whatsoever to be thread-safe.)  The information is lost as soon as the line of sight routine is called again—but the routine only “returns” two values anyway, one by stack return and one by passed address.  Since both returns add up to copies, we’re safe from globals collision as long as we stay single-threaded.Per cell, ptop_cell_fcn() initializes by converting metric coordinates to grid coordinates.  It then processes the line of sight calculation according to cases.Case 1: Grid terrain present, terrain elements enabled, only-terrain-elements flag off.  ptop_cell_fcn() calls ctdb_intervis() passing ptop_post_compare() as the comparator function to check grid terrain, find features, and determine if terrain elements are present.  If terrain elements are present, the next call is to ctdb_terrain_element_intervis() passing ctdb_update_visibility() as the visibility function to check TINned terrain.  Regardless, ptop_patch_compare() is finally called to check against features found by ctdb_intervis.Case 2: Grid terrain not present, terrain elements enabled, only-terrain-elements flag off.  ptop_cell_fcn() calls ctdb_terrain_element_intervis() passing ctdb_update_visibility() as the visibility function to check TINned terrain (even if it does not exist), calls ctdb_intervis() passing ptop_post_compare() as the comparator function to find features, then calls ptop_patch_compare() to check against features found by ctdb_intervis. Case 3: Grid terrain either present or not, terrain elements disabled, only-terrain-elements flag off. ptop_cell_fcn() calls ctdb_intervis() passing ptop_post_compare() as the comparator function to check grid terrain (if present) and find features, then calls ptop_patch_compare() to check against features found by ctdb_intervis.Case 4: Terrain elements enabled, only-terrain-element s flag on. ptop_cell_fcn() calls ctdb_terrain_element_intervis() passing ctdb_update_visibility() as the visibility function to check TINned terrain (even if it does not exist).Case 5: Terrain elements disabled, only-terrain-element s flag on. ptop_cell_fcn() trivially returns full visibility.Analysis – Geometric Comparison ImplicationsAlong with an origin point, five values are passed to ctdb_point_to_point for purposes of depicting the endpoint of the LOS “ray”.  These five components may be thought of as x, y, zl, zh and width.  The x and y values are the absolute position of the target on the map.  The zl and zh values are the heights of, respectively, the base and top of the target.  The width value should, ideally, be the width of the target with respect to the perspective implied by the origin point.  The line of sight functionality implicitly derives two structures from this information:A vertical line segment from zl to zh at (x, y) on the map.  The triangle depicted by the origin point and this line segment is known as the LOS ray.A rectangle of width corresponding to the width value, perpendicular to the LOS ray, bisected by the line segment above.  We will refer to this as the LOS rectangle.The libctdb LOS function uses two values and one structure to store information about the line of sight: the visible area, the linear transmittance and a visibility raster.The visible area and linear transmittance together are the return values of the LOS function.  The visible area is intended to be the aggregate fraction (from 0.0 to 1.0) of the LOS rectangle that can be seen from the origin.  The linear transmittance is intended to represent the aggregate fraction of light (again, from 0.0 to 1.0) that makes it from the LOS rectangle to the origin.The visibility raster is an internal 32x32 bitmap that is used only in certain parts of the LOS function.  At the conclusion of the LOS function, information from the raster is incorporated into the visible area.Function ComponentsThere are three distinct components to the basic libctdb LOS function, in which these structures are variously used:Check LOS against grid terrain.Check LOS against TINned terrain elements.Check LOS against features.Terrain Checks (gridded and TINned) -The checks against grid terrain and TINned terrain elements are fundamentally similar—and fundamentally obvious—intersection tests, differing mainly in how they transition between patches and elements.  However, they test intersection only with the LOS ray; they do not take into account side-blockage, or the LOS rectangle, at all.Feature Checks - The checks against features are performed feature-by-feature, and separate functions are used to check against each type of feature.  In particular, buildings that interfere with the LOS rectangle mark areas of the raster as blocked, and trees that interfere with the LOS rectangle either mark areas of the raster as blocked or reduce the linear transmittance (not both; see Function Call Cases).Function Call CasesThere are two ways in which the function can be called:The standard method, which is used by the OTB at all times, is to call the function as described in Values and Structures, passing the origin along with x, y, zl, zh and width.An additional method is to add a preloaded raster to the parameters.  This can be used to pre-specify blocked areas or to depict the (very) rough shape of the target.The calling method used influences how trees are handled.  If a raster is passed, then trees are fully opaque and mark all areas of the raster that they interfere with as blocked.  If a raster is not passed, then the presence of trees interfering with the LOS rectangle will cause reduction in linear transmittance and no effect on the visible area.  In either case, the tree model is rough.Comparison between OTB and Visual Algorithms The most direct comparison to our method is actually achieved using the raster-based function.  There are two weaknesses to this approach: we would need to fill the raster, and the OneSAF Testbed never uses the raster-based function.The best actual data to compare is probably our visual simulation intervisibility algorithm (i.e. pixels rendered ÷ potential pixels) versus libctdb’s (linear transmittance  · visible area).  Also of interest is the binary determination: “Is the object being viewed visible or not”?  This require setting a threshold on the visibility ratio of the object.Some Likely Areas of Difference:1.  Cases of hilly terrain blocking the target – cases in which terrain causes blockage from the side, or in which the height of the terrain as it interferes with the LOS ray is not the average height of the terrain as it interferes with the the LOS rectangle, will reveal significant discrepancies between our visual LOS readings and libctdb’s.2. Any case that relies on the shape of the target may display significant discrepancies between our LOS readings and libctdb’s, either due to libctdb using a simple rectangle or due to the small size of libctdb’s rasters.3. Any case that involves line of sight through trees may display significant discrepancies between our LOS readings and libctdb’s.  In non-raster mode, if two tree trunks block a target, it is easily possible for libctdb to report about 25% visibility when the target in fact cannot be seen at all!  In raster mode, the roughness of the tree models used will come into play. For foliage: transmittance = (1 - w_area) *(1 - h_area) * fullness.Where w_area and h-area are width and height of the bounding rectangles around the entities in the sensor projection.  .OTB and Visual System Threshold Visibility DeterminationIn the final comparison, we need to answer the question, “Is the entity being viewed visible or not?”.  Both the OTB algorithm and our proposed method for determining visibility return a floating point number that ranges between zero and one.  Obviously some threshold is needed above which the entity being viewed is considered “visible”.  Ultimately this is very much a perceptual issue in visual systems, but we have considered the question strictly from a deterministic viewpoint regarding the ratio of the pixels being displayed.  In OTB the determination is strictly algorithmic, although some consideration of perceptual issues may have been ”built-in” to the algorithms.  In order for a valid comparison to be made across the two systems, we must choose a threshold.  In doing so a difficulty arises in that OTB uses different thresholds depending on the calling function.  There is no one standard intervisibility minimum threshold within the OTB. Some tasks use a strict intervisibility threshold (i.e. zero), others record the intervisibility value returned for probabilistic purposes. Of those tasks that use a threshold, the most common are 5%, 10% and 50%. It is notable that libvsearch - the target searching task - has a strict intervisibility threshold of zero.  On the other hand, libsight, libvisual and libtactmap have intervisibility thresholds of 5%.  For the sake of simplicity, in our initial tests we choose to use the absolute threshold (i.e. zero) for the sake of comparing results.ResultsA scenario was generated using correlated versions of  the Fort Polk Shugart-Gordon databases.  The CTDB database parameters for the scenario region of interest follow: Table I Ft. Polk CTDB CharacteristicsDatabase ftpolk_r10-0000 created Wed Jul 17 10:37:15 2002 ------------------------------------------------------- Terrain Format 7 with the following features: UTM flat, MIXED TIN & GRID POST, ------------------------------------------------------- Grid Spacing     (METERS): 48 Fixed point basis        : 0.01907349 Origin at 3440189N 487129E in UTM zone 15R (datum WGS84) Minimum (SW Corner)(X,Y) : (      0.00,       0.00) Maximum (NE Corner)(X,Y) : (   3072.00,    3072.00) Minimum Elevation        : (     83.52) Maximum Elevation        : (    132.35) -------------------------------------------------------    The sensor view frustrum parameters were set at 0.619406 radians horizontal and 0.508736 radians vertical, with no far clipping plane applied. The results for the visual algorithm were generated using 1600 x 1200 screen resolution and the algorithm described above.  The OTB results were generated using emulation of the actual OTB calls to libctdb to determine intervisibility.  The scenario was configured manually so that some significant number of entities were expected to be within view of each other, and the number of total entity sensors used in the scenario was 68.  A top-down view of the scenario is shown in Figure 3, below.In this scenario view, the “sensors” are in blue, and it can be seen that the area is densely populated with individual trees, and also has significant variations in the terrain elevation.Intervisibility between all entities was compared, although in practice an “Area of Interest” (AOI) in the form of a far clipping plane on the sensor view frustrum would normally be set to reduce the computational load.  This resulted in 4556 total intervisibility calculations for each method (neglecting the trivial case of “self-visibility”). Using a threshold of zero for comparison, the results of the intervisibility correlation test are shown in Table II, below:Not Visible in Both Cases4453Visible in Both Cases40Visible in OTB Only64Not visible in OTB Only3Figure 3.  Ft. Polk Database view (urban features removed) and 68 entity scenario used for initial experiment (entity locations in blue).In the view above, the 68 entities are represented in blue, and the standard icons are used: green “X’s” for individual trees, green line segments for tree lines, red segments for roads, and brown line segments for elevation contour lines.  Figure 4, below, show the results comparing the intervisibility between the visual system and OTB, but using an AOI of 1 km..  Again, following the example set by the majority of most calling OTB functions, the intervisibility ration threshold was set to zero, that is, all non-zero intervisibility ratios are considered “visible”.  In this test cases, for the AOI used in this case, entities that are visible it the visual system are also visible in OTB, but there are many cases where entities are visible on OTB but not in the visual simulation.  Inspecting Figure 4, we find that almost all of the cases of intervisibility error are due to calculating visibility through tree lines.  This result is not really surprising, as OTB treats intervisibility as a transmittance, while visual systems can use geotypical or geospecific actual tree textures.   SHAPE  \* MERGEFORMAT Results and Ongoing WorkIn future work, we plan to accomplish the following.Provide numerical measures of the intervisibility correlation both in terms of binary intervisibility and the floating point percentage of visibility calculations.  The former can be accomplished by formulating an hypothesis test on a binomial distribution, while in the latter case we will consider the use of a non-parametric method such as the Kolomgorov-Smirnov test for two distributions, since the initial floating-point distribution is unknown. This will allow for automated testing of the correlation between the two data representations, either for specific scenarios or sets of scenarios.  Run more experiments on different scenarios and databases for both the purposes of increasing the statistical significance of our findings, and also to try and pinpoint from an empirical standpoint the “worst case” scenarios and specific situations that are likely to cause intervisibility miscorrelation.Finally, we will make a set of recommendations for future improvements and further topics that require additional research.References[1] Birkel, Paul A., “SEDRIS Data Coding Standard”, Presented at the Proceedings of the Spring Simulation Interoperability Workshop, March 1999, 99S-SIW-011.[2] Robert F Richbourg, Dale D. Miller, Paul G. Foley, and Guy A. Schiavone, “Standardizing the Codification of Environmental Objects: The Environmental Data Coding Specification”,  HYPERLINK "http://www.sisostds.org/doclib/doclib.cfm?SISO_RID_1002036" 00F-SIW-071, Presented at the Simulation Interoperability Standards Organization (SISO) Fall 2000 Simulation Interoperability Workshop, September 17 - 22, 2000, Orlando FL.[3] Dr. Robert Richbourg and Tim Stone, “ HYPERLINK "http://www.sisostds.org/conference/View_Public_Document_Info.cfm?Document_Num=03S-SIW-018&Phase_ID=2" Towards the Production of Syntactically and Semantically Correct Synthetic Environment Databases” Paper 03S-SIW-018, Presented at the Simulation Interoperability Standards Organization (SISO) Spring 2003 Simulation Interoperability Workshop, March 30th - April 4th, 2003, Orlando FL.[4] Birkel, Paul A., et al., “The Terrain Common Data Model (TCDM): A Joint Effort of JSIMS, STOW, and JWARS”, Proceedings of the 8th Conference on Computer Generated Forces and Behavioral Representation, May 1999.[5] Jill Ashby, Brian Mannlein, and Kirk Thomas, “Correlating Large Area Visual and SAF Databases: Challenges and Solutions” Proceedings of the Seventh Conference on Computer Generated Forces and Behavioral Representation. Orlando, FL, (1998).[6] Paul Wannacott, “Assessing the consistency of multi-resolution terrain database”, Paper# 00S-SIW-041, Presented at the Simulation Interoperability Standards Organization (SISO) Spring 2000 Simulation Interoperability Workshop, March 26-31, 2000, Orlando FL.. 