Implementation of the Data Distribution Management Services in the RTI-NGMark HyettSAIC5400 Shawnee Rd. Suite 110Alexandria, VA 22015mhyett@dctd.saic.comRoger WuerfelSAIC5400 Shawnee Rd. Suite 110Alexandria, VA 22015Roger.D.Wuerfel@saic.comABSTRACT:  The Runtime Infrastructure (RTI) Data Distribution Management (DDM) services provide a means to segment the delivery of messages within a federation.  DDM can reduce the network traffic a federate receives and will reduce the number of callbacks delivered to a federate that contain data not of interest to that federate.  The messages are segmented by assigning multidimensional regions to subscriptions and publications and calculating the overlap of these regions.  This paper begins with an overview of terms used when discussing DDM.  It then describes the mechanisms the RTI Next Generation (RTI-NG) uses to calculate region overlaps, to assign regions to network resources in order to segment the delivery of data, and the means to select among the possible DDM implementation schemes within the RTI-NG using the (RTI Initialization Data) RID file.  Building on this description, this paper then describes the impacts on the federation of these various mapping choices provided by the RTI-NG and some recommendations for federation developers in the early stages of federation development.IntroductionThe Runtime Infrastructure (RTI) Data Distribution Management (DDM) services provide a means to use interest management in order to reduce the transmitting and receiving of data that are not of interest to the federate.  The RTI Declaration Management (DM) services provide the means for a federate to express interest in data at the class attribute and interaction level; DDM extends this interest to the instance attribute and interaction instance level.  Federates that produce data use DDM services to assert properties of their data in terms of user-defined spaces, and federates that consume data specify their data requirements in terms of these same spaces.  The RTI will then match producers with consumers and distribute the data accordingly. [1]  This matching of interest allows the RTI to reduce the network traffic sent from and received by a federate.The RTI specification leaves specific details of the DDM implementation to the RTI implementers discretion.  Therefore, to make effective use of DDM with a particular version of the RTI the federation designers need to understand the DDM implementation of the chosen RTI.  This paper addresses the implementation of DDM in the RTI Next Generation (RTI-NG) implementation.  First, this paper gives an overview of the terms used when discussing DDM.  Next, this paper describes the mechanisms within the RTI-NG used to calculate interest matches, to assign regions to network resources, and the means to select among the possible implementation schemes within the RTI-NG using the RTI Initialization Data (RID) file.DDM TermsIn order to provide a common vocabulary to discuss DDM, the following definitions are provided for the reader.  Further clarification of these definitions can be found in “High Level Architecture RTI Interface Specification, Version 1.3.” [1]Routing Spaces - Routing spaces are a collection of dimensions.  A routing space is defined in the Federation Execution Data (FED) file.Dimensions - A dimension represents a coordinate axis of the federation problem space.  A dimension has a bounded range characterized by a “lower bound” and an “upper bound.”Extent - An extent is a set of bounded ranges defined on each dimension within a given routing space.Region - Regions are subspaces within routing spaces represented as a collection of extents.LRC - Local RTI Component.Sender-side Filtering - Updates or interactions are said to be sender-side filtered if they are not sent to a particular federate because it is known that the federate does not need the data.Receiver-side Filtering - Updates or interactions are said to be receiver-side filtered if a federate’s LRC receives an update or interaction but does not deliver the event to the federate due to subscription information.Default Routing Space - The default routing space is a routing space that is assumed for attributes and interactions that do not associate a space explicitly in the FED file.Default Region - Each routing space, including the default routing space, has a default region.  The default region is used for non-DDM updates, interactions, and subscriptions.RegionsOne of the core concepts of DDM is the region.  A region is a subspace composed of a set of extents that exist within a routing space.  Each extent is an Nth degree hyper-rectangle where N is the number of dimensions in the routing space and each edge of the hyper-rectangle is parallel to one of the routing space dimensions.DDM uses regions from publishing and subscribing federates in order to reduce the amount of data sent to each of the federates.  Updates and interactions are only sent to federates that subscribe to the data with a region that intersects with the publisher’s region.  A region R1 intersects region R2 if any of R1’s extents intersects (overlaps) any of R2’s extents.  The process of computing region intersection to determine whether updates or interactions should be delivered to a federate is called filtering.  From a performance perspective, computing region intersection becomes more computationally expensive as the number of extents increases.Filtering can occur in two general locations:  at the sender or at the receiver.  If a publisher knows that another federate is not interested in an update, then that publisher could avoid sending the update to the federate and thus save the expense of sending the data.  This is called sender-side filtering.  If the publisher does not know whether or not a federate needs an update, then the publisher must send the data and the subscribing federate’s LRC must determine locally whether to deliver the update to the federate.  This is called receiver-side filtering.  Sender-side filtering is more desirable but is also more difficult and costly to compute.The RTI Interface Specification does not address the question of how filtering is performed nor does it address how data is delivered over the network.  While this gives a lot of freedom to developers of RTI implementations, it also places an additional burden on federate developers.  Particular RTI implementations will have different DDM performance characteristics and thus any federate utilizing DDM may have to write specialized code to take advantage of a specific RTI implementation’s performance characteristics.  Switching RTI implementations may require modifications to the federate in order for it to perform as well with a different RTI implementation.The developers of the RTI-NG recognized that there would not be a single DDM implementation that would satisfy all federation developers.  RTI-NG was written to be extensible with respect to DDM.  Different DDM strategies can be added to the RTI-NG to accommodate different federation’s needs.  As new federations are developed with different needs, additional DDM strategies can be added without impacting the performance of existing federations.RTI-NG DDM StrategiesBecause the RTI-NG designers took the stance that there is not a “one size fits all” approach to segmenting network traffic, the RTI-NG was written to be extensible with respect to DDM strategies.  The RID file is used to inform the RTI-NG which particular strategy to use as well as the various options related to that strategy.  Currently, the RTI-NG supports three DDM strategies.The DataDistribution entry in the Federation section of the RID file controls the DDM behavior of the RTI-NG.  DataDistribution.StrategyToUse selects one of the three DDM strategies available:  Simple, StaticSpacePartitioned, and StaticGridPartitioned.  All three of these strategies must be set on a federation-wide basis.Within the RTI-NG, DDM uses logical channels to partition the network traffic.  Each DDM strategy creates, maintains, and uses reliable and best-effort logical channels.  Each logical channel is mapped to either a TPC/IP connection via Common Object Request Broker Architecture (CORBA) Event Channels or to a multicast group.  By default, reliable channels are mapped to CORBA Event Channels while best-effort logical channels are mapped to multicast groups.  CORBA Event Types are used in conjunction with Event Channels to further partition the network traffic effectively.  Generally speaking, only one inbound TCP/IP connection is set up and network partitioning is accomplished through Event Type subscriptions within CORBA.  Throughout the rest of the paper the word channel will refer to a logical channel and any reference to a CORBA Event Channel will be stated explicitly.There are two RID parameters that can be set to modify the mapping between logical channels and the underlying communications protocol.  DataDistribution.Options.BestEffortChannelType and DataDistribution.Options.ReliableChannelType may each be set to TCP or UDPmulticast.  While in general it is not a good idea to modify the default values for these parameters, occasionally is it useful to do so.  For example, if it becomes questionable whether multicast is set up properly on the network, setting the BestEffortChannelType to TCP and running the application could shed light on any potential issues.The following sections give a brief overview of the DDM strategies currently available within the RTI-NG.Simple StrategyOverviewAs its name implies, the Simple DDM strategy is simple, both in terms of its implementation as well as what benefits it provides to the user.  The Simple strategy was the first RTI-NG DDM strategy implemented and was originally designed to provide DDM compliance while maintaining an easy-to-debug environment.The Simple strategy uses exactly two channels:  one reliable channel and one best-effort channel.  By default, the reliable channel maps to a single TCP/IP connection while the best-effort channel maps to a single multicast group.  Attributes and interactions that are declared as reliable in the FED or through the RTI Application Programming Interface (API) are sent to the single reliable channel regardless of the region and space information.  Similarly, best_effort attributes and interactions are sent via the best-effort channel.The Simple strategy does not perform any sender-side filtering and therefore does not provide any improvement in network performance.  However, receiver-side filtering is performed on incoming data based on the subscription and publication regions.Simple Strategy UsesIn general, the Simple DDM strategy should not be considered for production federations.  The lack of any sender-side filtering severely limits the improvements that can be made using this strategy.  There are however, at least two cases where the Simple strategy could be useful for a federation:  debugging DDM federates and comparing DDM performance.Debugging EnvironmentMaking effective use of DDM is a challenge for federation developers.  As the number of participating federates, objects, interactions, and DDM channels increases so does the complexity of the federation as a whole.  In particular, there may be subtle, unintended dependencies between updates and interactions that federation developers did not expect.Consider a naive example where one federate sends an unspecified amount of reliable receive order (RO) attribute updates followed by an interaction signaling completion of such updates.  Other federates could then subscribe to the attributes and interactions and simply accept updates until the “completion” interaction is sent.  Such a federation could work for some time with the RTI-NG or other RTI implementations.  However, the RTI does not guarantee that RO updates and interactions are received in the order that they were sent and, in fact, are often not received in the same order.Though such out-of-order message delivery generally is rare, it still can occur.  In a pinch, the RTI-NG Simple strategy can be used to help reduce the number of updates or interactions received out of order.  This is due mainly to the fact that there is a single channel for a given transport type.  Switching to the Simple strategy can help diagnose the problem but it should not be considered a solution because of the performance penalty.Comparing PerformanceOften, the largest DDM gain for federations is sender-side filtering.  When updates and interactions are filtered out before they are sent, there are savings involved in the cost of sending the data (e.g., sender processing and network bandwidth), costs in receiving the data (e.g., receiver processing and filtering the data at the receiver), and finally the callback to the federate.  When an update is filtered out at the receiver’s side, only the callback to the federate is saved.Unfortunately, from the federate’s point of view there is no way to tell the difference between sender-side filtering and receiver-side filtering.  Sending federates update attributes and send interactions; where those updates and interactions go and how they get there is an RTI implementation detail and is generally out of the sender’s control.  Similarly, receiving federates simply subscribe to attributes and interactions; how the data is delivered to them is unknown, as is the data that is NOT delivered.  In other words, the federation has no way to tell (via the API) if DDM is performing well or not.Since the Simple DDM strategy does not do any sender-side filtering, potentially it could be used to test the performance of other DDM strategies.  For example, if a DDM based federation performed equally while using both the Simple DDM strategy and another DDM strategy that supports sender-side filtering, then one might conclude that either the federation is not taking advantage of the sender-side filtering available or that the performance bottlenecks lays outside of DDM all together.StaticSpacePartitioned StrategyOverviewThe StaticSpacePartitioned DDM strategy adds sender-side filtering to the DDM.  Network traffic is partitioned on a FED file routing space basis.  Since the network partitioning does not change throughout the course of the federation execution, this strategy is considered a static partitioning strategy.For each routing space defined in the FED file, the StaticSpacePartitioned DDM strategy will create two channels:  one reliable channel and one best-effort channel.  Two additional channels, one reliable and on best-effort, are also created for the default routing space.  By default, the reliable channels map to a separate CORBA Event Type while the best-effort channels map to individual multicast groups.  CORBA manages the reliable TCP/IP connection(s) and intelligent routing transparently.   Attributes and interactions declared as reliable in the FED or through the RTI API are sent to the reliable channel that corresponds to the routing space associated with the region used for the update or interaction.  A similar action is performed for best_effort attribute updates and interactions.  In short, the StaticSpacePartitioned strategy segments network traffic on a routing space basis.  Updates to attributes associated with routing space A (Figure 1.) are only sent to federates subscribed to attributes or interactions associated with space A.  Receiver-side filtering, based on the subscription and publication regions, is still performed at the receiving side.  EMBED Word.Picture.8  Figure 1.StaticSpacePartitioned Strategy UsesThe StaticSpacePartitioned DDM strategy has two nice properties:  1) it is relatively easy-to-use, and 2) non-DDM federations can take advantage of its sender-side filtering properties without using RTI DDM services.Recall that regions are associated with a particular routing space and that attributes and interactions must be associated with the same routing space as any associated or subscribed regions.  Also, recall that an attribute or interaction is associated with the default region if it is not explicitly associated with another region.  Therefore, an attribute or interaction is always associated with a region in the same routing space as the attribute or interaction defined in the FED, whether or not the federate has made the association explicitly or not.  That is, attributes and interactions of DDM and non-DDM federates are always associated with regions in the same routing space.The StaticSpacePartitioned strategy should be considered the first step towards converting a non-DDM federation into one that uses DDM.  Simply by adding routing spaces to the FED file, a federation can achieve very good DDM performance without creating a single region.  Associating each attribute and interaction with an appropriate routing space will result in good sender-side filtering without modifying any of the federate’s code base.Using the StaticSpacePartitioned strategy, simply by modifying the FED file, a federation can achieve good network performance without using DDM services.StaticGridPartitioned StrategyOverviewThe StaticGridPartitioned DDM strategy extends the StaticSpacePartitioned strategy by partitioning individual spaces into a grid network.  Each grid partition is assigned a separate reliable and best-effort channel.  Updates and interactions are then sent to the channels associated with the grid partitions through which any associated regions pass.  If used wisely, the StaticGridPartitioned DDM strategy can increase performance by adding additional sender-side filtering.  Used unwisely however, the StaticGridPartitioned strategy can seriously reduce performance and increase network congestion.For each routing space defined in the FED file the StaticGridPartitioned DDM strategy will, by default, create nm partitions (where ‘n’ is the RID parameter DataDistribution.Options.StaticGridPartitionedStrategyOptions.                                                 NumPartitionsPerDimension and ‘m’ is the number of dimensions defined in the given routing space).  For each partition, two channels are created:  one reliable channel and one best-effort channel.  By default, the reliable channels map to a separate CORBA Event Type while the best-effort channels map to individual multicast groups.  CORBA manages the reliable TCP/IP connection(s) and intelligent routing transparently.   Two additional channels, one reliable and one best-effort, are also created for the default routing space.  To limit the number of CORBA Event Types used, the RID parameter DataDistribution.Options.StaticGridPartitionedStrategyOptions.MaxNumberOfDataChannelsToUse places a cap on the number of Event Types created.  Event Types are reused if necessary.  Similarly, the RID parameters Networking.MulticastOptions.BaseAddress and MaxAddress limits the number of multicast groups used.  Attempting to create more best-effort channels than multicast groups will simply reuse the multicast groups as needed.  Note that reusing Event Types or multicast groups may result in additional receiver-side filtering.For the purpose of updates, interactions, and subscriptions, regions are mapped to a set of partitions that then map to a set of reliable or best-effort channels.  The mapping looks something like this:for each dimension in the region:  regionSpan = MAX_EXTENT – MIN_EXTENT    + 1;  // currently=0x100000000  partitionSize = regionSpan /    NumPartitionsInDimension;  if (regionSpan %      NumPartitionsInDimension) {     // always round up     partitionSize += 1;  }  region.dimension[dim].    partition.minimum =       region.dimension[dim].        getLowerBound / partitionSize;  region.dimension[dim].    partition.maximum =      region.dimension[dim].        getUpperBound / partitionSize;forendEach dimension’s partition range is then combined with every other dimension’s partition range to create a complete list of partitions through which the region passes.  Channels are then derived from the partition list.  Updates and interactions then are sent to each of the channels in the set.  Similarly, a set of channels are derived based on subscriptions that are used for subscribing to the logical channels.  Thus, larger regions cause more network traffic especially as the number of partitions grow.Let us examine a simple example.  Assume that we have defined the canonical spaces in the FED file:(space 1D    (dimension x))(space 2D   (dimension x)   (dimension y))(space 3D   (dimension x)   (dimension y)   (dimension z))Let’s assume also that we have specified in the RID that each dimension be partitioned into two pieces.  Then, space 1D will be decomposed into two partitions:Partition 1:  {x: 0x00 - 0x80000000} andPartition 2:  {x: 0x80000001 - 0xffffffff}Space 2D will be decomposed into four pieces:Partition 3:  {x: 0x00 - 0x80000000, y: 0x00 - 0x80000000}, Partition 4:  {x: 0x80000001 - 0xffffffff, y: 0x00 - 0x80000000},Partition 5:  {x: 0x00 - 0x80000000, y: 0x80000001 - 0xffffffff},Partition 6:  {x: 0x80000001 - 0xffffffff, y: 0x80000001 - 0xffffffff},Space 3D will be composed into eight pieces; an example of which is left as an exercise to the reader.So, in the above example, we have a total of 14 partitions (2 + 4 + 8).  Each partition is mapped onto both a reliable and a best-effort channel creating a total of 14 reliable channels and 14 best-effort channels.  If the total number of partitions were greater than the RID parameter MaxNumberOfDataChannelsToUse (default is 64), then the channels are reused.Each channel is mapped to a CORBA Event Type or UDP multicast address.  The mapping is determined by other RID parameters, for example:DataDistribution.Options.BestEffortChannelType, DataDistribution.Options.ReliableChannelType, Networking.MulticastOptions.BaseAddress, Networking.MulticastOptions.MaxAddress, and so forth.]A region within a given space is a collection of extents.  Each extent contains a minimum and maximum range for each dimension within the space.  Each extent passes through one or more grid partitions.  So, to further our example, assume that we have the following regions:Region R1D-1 in space 1D:   Extent 1: {x: 0xf - 0xff}Region R1D-2 in space 1D:   Extent 1: {x: 0x80001111 - 0xffff000}Region R1D-3 in space 1D:   Extent 1: {x: 0xf - 0x8fff000}Region R2D-1 in space 2D:   Extent 1: {x: 0x0 - 0x10, y: 0x0 - 0x10}Region R2D-2 in space 2D:   Extent 1: {x: 0x10 - 0x8fff0000, y: 0x8fff0000 - 0xffff0000}Region R2D-3 in space 2D:   Extent 1: {x: 0x0 - 0x10, y: 0x0 - 0x10}   Extent 2: {x: 0x8fff0000 - 0xffff0000, y: 0x8fff0000 - 0xffff0000}Region R2D-4 in space 2D:   Extent 1: {x: 0x0 - 0xffffffff, y: 0x0 - 0xffffffff}Region R2D-5 in space 2D:   Extent 1: {x: 0x0 - 0x09, y: 0x8fff000 - 0xffff0000}Given the above assumptions, the regions intersect the previously defined grid partitions in the following way:RegionIntersected Grid Piece SetR1D-1{1}R1D-2{2}R1D-3{1, 2}R2D-1{3}R2D-2{5, 6}R2D-3{3, 6}R2D-4{3, 4, 5, 6}R2D-5{5}Since each grid partition maps to both a reliable and a best-effort channel, we can consider the above grid piece set to be a channel set.  For example, region R2D-2 maps to reliable channels 5 and 6 as well as best-effort channels 5 and 6. (Figure 2.) EMBED Word.Picture.8  Figure 2.As mentioned previously, the partitioning is determined via RID parameters.  The parameter DataDistribution.Options.StaticGridPartitionedStrategyOptions.MaxPartitionsPerDimension (default is 1) specifies the number of partitions to use per dimension.  A value of 2 was used for the above examples.  If a value of 3 were used, then space 1D would be partitioned into three equal pieces, space 2D into nine pieces, and space 3D into 27 pieces.  If the value of 1 were used then spaces 1D, 2D, and 3D would all have a single partition. Using a value of 1 for the MaxPartitionsPerDimension RID parameter is functionally equivalent to using the StaticSpacePartitioned DDM strategy.In some cases, it may be desirable to have non-square partitions.  For example, suppose that you want to partition space 2D into 10 pieces along the x dimension and three pieces along the y dimension.  To do this, you may modify the SpaceOptions in your RID.  In this example, you would add the following entries (Figure 3.):(DataDistribution (Options  (StaticGridPartitionedStrategyOptions   (SpaceOptions    (2D     (DimensionOptions       (x (NumPartitions 10))      (y (NumPartitions 3))     )    )   )  ) )) EMBED Word.Picture.8  Figure 3.Any dimension not specified in the SpaceOptions section uses the MaxPartitionsPerDimension value.  All subsequent examples in this document will assume a MaxPartitionsPerDimension value of 2 and there are no relevant SpaceOptions specified.Each space has a default region that is used for non-DDM calls.  Each space’s default region contains the entire space.  The example region R2D-4 is equal to the default region for space 2D.  Note that in this example, sending an update to the default region of space 2D would entail sending the update four times.  Again, we need to emphasize the fact that larger regions, including default regions for spaces, can involve significant penalties when using highly partitioned spaces.  There is also an overall default region.  This default region has neither extents nor dimensions and uses a special channel 0 to which all federates subscribe (i.e., broadcast communication).When a federate updates an attribute that has been associated with a region, then the update is sent to all channels that the associated region intersects.  Similarly, when a federate subscribes to attributes using DDM, the federate "listens" to all channels that the specified regions intersect.  Non-DDM subscribed attributes use the appropriate space default region.  When a subscribed federate receives an update, the associated region is compared against the subscribed region in order to perform receiver-side filtering.  Once again, this is best shown by example.  Assume the following FED file entries:(objects (class ObjectRoot  (class A   (attribute x reliable receive 1D)  )  (class B   (attribute x reliable receive 2D)   (attribute y reliable receive 2D)  ) ))Also assume that we have three federates set up like this:Fed1.subscribe A.x with R1D-1Fed1.subscribe B.x with R2D-1Fed1.subscribe B.y with R2D-4Fed2.subscribe A.x with R1D-3Fed2.subscribe.B.y with R2D-2Fed3.subscribe A.x with R1D-1 and R1D-3Fed3.subscribe B.x with R2D-1Fed3.subscribe B.y with R2D-3 and R2D-4The following tables show which federates receive network traffic as well as which federates receive ReflectAttributeValue callbacks:Fed3.update A.x with R1D-1:FederateReceive NetReceive RAV   1YESYES   2YESYES   3NONOFed3.update A.x with R1D-2:FederateReceive NetReceive RAV   1NONO   2YESYES   3NONOFed3.update B.x with R2D-3:FederateReceive NetReceive RAV   1YESYES   2YESYES   3NONOFed3.update B.x with R2D-5:FederateReceive NetReceive RAV   1YESNO   2YESNO   3NONOFed3.update B.y with R2D-1:FederateReceive NetReceive RAV   1YESNO   2NONO   3NONOFed3.update B.y with R2D-5:FederateReceive NetReceive RAV   1YESNO   2YESNO   3NONOAn important observation to make is that DDM traffic is largely segmented on a per-space basis.  Used indiscriminately, the amount of unwanted network traffic may increase as the number of subscriptions within a space increases.  This observation arises from the way spaces and regions interact.  Consider region R2D-4.  If an update is sent to R2D-4, then any federate subscribed to ANY region in space 2D will receive the update even though the ReflectAttributeValue call may not be made.  Furthermore, if a federate is subscribed to B.x with regions R2D-1 and R2D-5 then that federate will receive an update from B.y with region R2D-2.StaticGridPartitioned UsesHere are some general observations about the StaticGridPartitioned strategy:1)  Finer grid partitioning does not equal better DDM filtering.  The best partition resolution is HIGHLY federation-specific.  If the partitioning is too fine, then more network traffic could be generated than if a 1X partition were used.2)  If possible, use spaces on a per-attribute or per-class basis.  In the previous examples, assigning A.x, B.x, and B.y to their own spaces would eliminate much of the unwanted network traffic.3)  Using the default value of 1 for the number of grid partitions coupled with suggestion 2 above is not a bad place to start using DDM.  From there, you can tweak the RID file along with the federation in order to maximize performance.The No Thinking ApproachOccasionally, time or other circumstances does not permit careful analysis or implementation of a federation to make good use of DDM.  In such cases, it is safe to use the StaticGridPartitioned DDM strategy using the default RID parameters.  In a non-DDM federation, the StaticGridPartitioned strategy in its default form will generally perform about the same as both the Simple and StaticSpacePartitioned strategies.  Without the use of DDM services, most of the network traffic will be directed towards one of two channels depending on whether the data is reliable or best_effort.  In other words, the default StaticGridPartitioned strategy will not hurt performance relative to the other strategies provided with the RTI-NG.A Little Thought Goes a Long WayAs already mentioned, in many cases large performance gains can be achieved simply by modifying the FED file.  Both the StaticSpacePartitioned and StaticGridPartitioned strategies partition based on routing space.  If possible, routing spaces should be added to the FED file and associated with individual attributes or interaction classes.  DDM will then segment the network traffic based on the routing spaces.  For example, consider the following partial FED file:(objects (class ObjectRoot  (class tank   (attribute lat reliable receive)   (attribute long reliable receive)  )  (class plane   (attribute lat reliable receive)   (attribute long reliable receive)   (attribute alt reliable receive)  ) ))Suppose we had a non-DDM federation consisting of some federates that subscribed to tanks only, some federates that subscribed to planes only, and some that publish both.  As tanks are updated, the updates are sent to both the tank subscribers as well as the plane subscribers that then filter out the update.  Now, consider what happens if we make the following modification to the FED file:(spaces (space Ground  (dimension doesNotMatter) ) (space Air  (dimension doesNotMatter) ))(objects (class ObjectRoot  (class tank   (attribute lat reliable receive Ground)   (attribute long reliable receive Ground)  )  (class plane   (attribute lat reliable receive Air)   (attribute long reliable receive Air)   (attribute alt reliable receive Air)  ) ))Now, when updates are made to tanks, only the tank subscribers will be sent the updates.  Network traffic is reduced and the plane subscribers do not have to filter out the updates.  Notice that dimensions here are irrelevant since the federation is not using DDM services.  In this example, we could have segmented the traffic further using more routing spaces and associating them with each attribute.  Of course, any gains are federation specific and depend upon the communication patterns used in the federates.Fixed RegionsThere is an understandable temptation for federate writers to center regions around moving objects.  For instance, an AWACS plane may subscribe to aircraft objects in a region surrounding the location.  As the AWACS moves, so does the region.  While this may seem like an intuitive implementation, it is also an expensive one within the RTI-NG.  The problem stems from two places, since the RTI has no concept of global regions, as regions change information must be broadcast out to the entire federation in order to guarantee proper behavior with respect to advisories.  This can be expensive especially in large federations with many moving regions.  The second area of concern emerges when using a highly partitioned space.  As regions move they tend to cross partition boundaries.  The larger the region, the more partitions a region can occupy  simultaneously.One way to help mitigate the problem is to use fixed regions.  Instead of centering a region on a particular moving target, try keeping the region stationary while moving the object.  As the object moves outside of the region, the object can be associated with a different fixed region.  The fixed regions then can be optimized to take advantage of the DDM strategy partitioning (e.g., attempting to create regions that reduce the number of partition boundary crossings).Point RegionsPoint regions and other variations give the developer the most control of network utilization.  The basic idea is to create a number of very small regions at locations within the routing space known to be associated with different network channels.  The regions themselves then act like channels to the federate.  The federate is then able to segment the network traffic as it sees fit simply by selecting the proper region.  As an example, consider the following FED and RID file snippets:FED:(spaces (space channels  (dimension bin) ))RID:(DataDistribution (StrategyToUse StaticGridPartitioned) (Options  (StaticGridPartitionedStrategyOptions   (NumPartitionsPerDimension 16)  ) ))The federate can now create 16 regions with one extent in routing space channels with the following dimension boundaries:Region R1: {bin: 0x0000fffe - 0x0000ffff}Region R2: {bin: 0x1000fffe - 0x1000ffff}Region R3: {bin: 0x2000fffe - 0x2000ffff}…Region R16: {bin: 0xf000fffe - 0xf000ffff} EMBED Word.Picture.8  Figure 4.The federate now has complete control over network traffic partitioning.  Updates for objects associated with Rn will only be sent to federates subscribed to objects with region Rn.  Of course, the number of channels used can vary from the above example.  The down side of using point regions is that it requires the federate developers to do most of the work regarding network segmentation.  The potential reward, however, is perfect network segmentation; something that no DDM implementation could hope to achieve.SummaryFederation designers need to understand a particular RTI’s DDM implementation to use DDM effectively since the RTI specification leaves many of the details of the DDM implementation up to the implementers.  This paper explained each of the DDM strategies available with the RTI-NG implementation and illustrated suggested uses of each.  Using this information federation designers should be able to analyze their federation scenarios and design effective DDM solutions to reduce network traffic and the computational burden upon receiving federates.References[1] Defense Modeling and Simulation Office, “High Level Architecture RTI Interface Specification, Version 1.3,” April 1998.Author BiographiesMARK HYETT is a senior software developer for Zhyatt Consulting, Inc.  For the past 3 years, Mr. Hyett has been with the Distributed Computing Technology Division of SAIC as part of the development team for the RTI 1.3 Next Generation.  Mr. Hyett has more than 7 years of distributed computing experience.  He received his B.S. in Computer Science from Muhlenberg College and his Masters in Computer Science from the University of Virginia.ROGER WUERFEL is a senior software developer in the Distributed Computing Technology Division of SAIC  He is currently the technical support manager for the RTI 1.3 Next Generation and has been working with the RTI 1.3 Next Generation development team for 3 years.  Mr.  Wuerfel has over 10 years experience with simulation, including real-time, human-in-the-loop flight simulation and real-time distributed simulation.  He received his B.S. in Aeronautical/Astronautical Engineering from The Ohio State University and is pursuing his M.S. in Modeling and Simulation from Old Dominion University.