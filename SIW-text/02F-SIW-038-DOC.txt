The Simulation Reference Markup Language (SRML): A Foundation for Representing BOMs and Supporting ReuseSteven W. ReichenthalBoeing3370 Miraloma AveAnaheim, CA 92803714-762-1612steven.w.reichenthal@boeing.com Keywords:BOM, XML, SRML, HLAABSTRACT: The Simulation Reference Markup Language (SRML) is a general-purpose schema developed at Boeing for describing both the structure and behavior of simulation models in XML.  SRML can be effectively used in concert with HLA to provide an even higher-level simulation architecture for simulation interoperability and reuse.  In essence, the models depicted using SRML provide a foundation for representing Base Object Models (BOMs) within the HLA interoperability constructs.1. IntroductionThis paper describes how the Simulation Reference Markup Language (SRML) can operate over HLA to achieve extreme levels of simulation interoperability and reuse, and how SRML promotes the development and use of BOMs.  It explores how models can be executed using a universal simulator that understands SRML, and how SRML provides markup elements that can add simulation behavior to virtually any XML [1] document; including an XML-based OMT.  Other areas of discussion include the application of a minimal XML Schema [2], which forms the foundation for reuse, and the integration of SRML models through the use of the Document Object Model (DOM), an object manager, an event manager, simulation primitives, and a plug-in manager.  An example that shows the implementation of both a trigger BOM and an interaction BOM in SRML is also provided.2. BackgroundHLA provides a standard means for individual simulations, called federates, to interoperate in a federation. For HLA to work, the interoperable federates share a common Federation Object Model (FOM) document that describes the types of information that they exchange. This meta-data not only includes information consumed by the Run-Time Infrastructure (RTI) software such as classes, attributes, and interactions, but also includes descriptive information such as the purpose and sponsor of the federation or federate. FOM documents are structured according to the rules of the HLA Object Model Template (OMT). A portion of a FOM that describes an individual federate is referred to as a Simulation Object Model (SOM). Potentially, a federate can be reused in many federations by merging its SOM into the FOMs of those federations—assuming that participating federates have temporal compatibility in their behavior.The amount of detail and complexity necessary for FOM development may demand an extensive amount of design and coordination among federation participants. Several approaches to the management of this complexity have emerged in the HLA community. Among them are tools for generating and editing FOMs, reuse libraries that hold cataloged FOMs and SOMs, a federation development process (FEDEP), reference FOMs, and Base Object Models (BOMs).By definition, BOMs provide a “distinct way to represent individual simulation interaction patterns and components that can be used to build or modify a federation or interoperable environment.”[3] For practical purposes, a BOM is a reusable package of information intended for use in generating FOMs and SOMs. A group of individual BOMs would be assembled into a FOM, thus facilitating reuse and rapid development. A BOM is manifested as a digital document that includes linked and embedded OMT information, along with other meta-data not officially included in the OMT, such as intent-of-use information. Along with BOMs comes a methodology for decomposing FOMs into BOMs (reverse engineering), and the subsequent recomposing back into FOMs (forward engineering).Since BOMs carry FOM information, they inherit the goals and features of reuse, interoperability, and catalog-ability. Yet, the additional meta-data carried in a BOM is intended to make it easier for object-oriented development tools and designers to discover and use applicable BOMs for the assembly of FOMs or SOMs using the familiar Rapid Application Development (RAD) component philosophy. The composition of individual BOMs for a purpose is called a Mega-BOM, and a transformation from a Mega-BOM to a FOM can be defined. XML can describe the data for FOMs, SOMs, BOMs, and Mega-BOMs. XML consists of elements specified using tags (words bracketed by '<' and '>'). Elements can have attributes (described by a name-value pairs), and can contain embedded elements: <elementname1 attributename1='value1' attributename2='value2' …> <embedded-element1 …>	…</embedded-element1>…</elementname1>These constructs can naturally describe hierarchically related and networked data—literal data and meta-data. An XML Schema is an XML document that permits a modeler to specify rules about element relationships and attributes that can be validated with software. The XML Document Object Model (DOM) [4] is an Application Programming Interface (API) that enables programming languages and scripts to load, validate, navigate, modify, and save XML structures with code. Software libraries and components for the DOM are freely available from several sources. DOM software implements elements and attributes with linked Node objects. For example, the previous XML construct can be represented in the DOM as:Node (NodeName='elementname1')Attribute(BaseName='attribute1', NodeTypedValue='value1')Attribute(BaseName='attribute2', NodeTypedValue='value2')	Node (BaseName='embedded-element1')	Use of plain XML does not imply semantic interpretation, presentation, or behavior of the data. Rather, schemas and higher-level specifications, such as Semantic-web for semantics, and XSLT [5] for presentation provide those elements. Typically behavior comes from other markup languages like DHTML [6] and XHTML [7]. However, those languages couple presentation and behavior more tightly than is practical for large-scale simulations.BOM classification takes place in several dimensions:Runtime vs. Design Time – specifying whether a BOM is compiled or provided in source code.Trigger vs. Interaction – specifying the form of communication used by a BOM as either direct or indirect.Abstract vs. Concrete – specifying a BOM’s level of generality.Interface vs. Encapsulated – specifying whether or not implementation logic (behavior) is included with the BOM.At minimum, these dimensions become meta-data associated with the BOM; at maximum, software would process the information associated with each dimension. The last dimension (Interface vs. Encapsulated) provides a great near term potential for evolving the state of the simulation community, and also forms the basis for ushering-in a higher-level simulation architecture for simulations. However, “…a specific XML format has not yet been designated for encapsulating behavior for [Encapsulated] BOMs by the BOM SG.” [8] The Simulation Reference Markup Language (SRML) provides a format for encapsulating that behavior.3. Need for a Higher-Level Simulation Architecture In addition to the perception that FOM development is an extensive amount of work, federate development carries a similar perception. One aspect of this perception derives from the design of the RTI as an intrusive piece of software that is fused with the federate. A typical federate architecture as shown in Figure 1 has RTI dependencies both above and below the simulation model. Two dependencies exist from above, because the federate needs code that inherits from the Federate Ambassador class, and that also makes calls to the model. In addition, the federate must stub out what remains unused from 42 pure virtual functions. Likewise, two additional dependencies are needed, one that the model has on the layer that insulates it from the RTI Ambassador, and one that the insulator has on more than 100 functions in RTI Ambassador and associated classes. Developers are often forced to create these wrapper layers to facilitate reuse among their own models. Thus, the RTI software is the only standardized layer of the architecture.Figure 1 – Typical Federate ArchitectureA simulation environment is data intense and FOMs/SOMs provide an interface describing the types of data to be exchanged through the RTI layer.  However, the logic required to model the objects and interactions represented in the simulation environment is isolated from the FOM and SOM.  It is instead independently developed and held within the code of the system or simulation to participate in the simulation environment.  While modern programming languages used for system and simulation development are well suited to represent the program logic of a model, the separation of this program logic from the data representation of that model (in a FOM or SOM) minimizes the opportunity for reuse and the ability for simulations to dynamically absorb new models.  Since logic is also a vital part of a simulation environment, a higher-level simulation architecture is needed that incorporates program logic with literal data.  BOMs require a vehicle for storing not only vital meta-data but the program logic as well.  The key is in determining and establishing a mechanism for storing program logic.A look at the architectural substance of typical HLA federates reveals code written in programming languages like C++, Java, or ADA; yet simulation requires data—sometimes lots of data. Generally speaking, programming languages deal poorly with literal data. Although they can easily describe a linear list or array, describing the literal data of a complex tree or graph becomes extremely awkward--especially when a model includes thousands of such data items. In these situations, developers resort to loading data stored in external files. Yet even when using XML as the file format, the structure of the files must usually be kept in sync with the program code. Also, since data persistence is not part of most programming languages, developers must usually put forth a manual effort to save model state, or resort to the unnatural use of macros or templates. These extra thoughts detract from the development of the simulation model itself. Similarly, the management of structured program meta-data inside these languages typically takes place within unstructured comments. Therefore, meta-data attached to program code when used for verification, validation, accreditation, decomposition, or re-composition of behavior, becomes an awkward parsing task. The reason why these problems exist arises from the evolution of modern programming languages, which has drawn towards a greater focus on the organization and processing of logic than the management and reflection of data. Since logic will always remain a vital part of a functioning simulation environment, the higher-level simulation architecture would place program logic on equal footing with literal data.4. A Formula for a Higher-Level Simulation Architecture: BOM := SRML / HLA Figure 2 depicts the proposed higher-level simulation architecture of a federate. This architecture realizes the goals of BOMs by placing XML models above a standardized universal simulator. By combining model data with behavior in a BOM, the amount of work needed to develop a federate is minimized.  Furthermore, a standardized universal simulator that processes the SRML contained within a BOM provides greater reliability and automation for a participating HLA federate. The paradigm of a standard simulator that utilizes XML with behavior parallels the highly successful architecture of web browsers using HTML documents with scripts. Hence, software development under the web paradigm is readily perceived as low cost and highly reusable.Figure 2 – Higher Level Simulation ArchitectureWith the web, linked documents in HTML format carry data, user interface, and behavior. Likewise, linked simulation models in XML format carry data and behavior. As standardized software, the HTML-based browser has revolutionized the way user interfaces are constructed. A standardized universal XML-based simulator makes a similar impact on simulation. Browsers have the ability to plug-in languages and other components, thereby extending their basic functionality. The universal XML-based simulator does the same. One main difference between the browser and the simulator is that while a browser primarily processes documents that follow the HTML schema, the universal simulator accepts documents that follow any schema or combination of schemas, and that include simulation markup.Therefore, a higher-level simulation architecture consists of the following:Models marked-up using a combination of arbitrary schemas and simulation markup.A standard simulation reference markup language.A standard simulation reference simulator and runtime environment.An extensibility feature that enables programming languages and other components such as the RTI to be plugged-in seamlessly.Most of the problems associated with literal data in programming languages disappear when including behavior in XML, because XML can naturally describe lists, trees, and graphs as objects—such objects would have both declarative and procedural semantics. With XML, documents may easily consist of large numbers of these objects. XML handles meta-data, and facilitates verification, validation, decomposition and re-composition. Most importantly, placing the simulation markup in a separate XML namespace from the domain-specific markup allows the behavioral definitions to coexist naturally with the data. The DOM also has a built-in persistence mechanism that can be used to “snapshot” the running state of a model at a point of time.5. The Simulation Reference Markup LanguageSeveral major projects within Boeing have adopted a flexible modeling and simulation approach based on SRML. The approach stemmed from several years of developing large-scale availability simulations [9] that included thousands of interconnected objects. With SRML, Boeing has been able to more effectively manage the complexity of models as their features increase. SRML provides the schema that allows simulation markup to be included in any XML document. Using XML, a modeler would construct a domain-specific schema and a corresponding BOM document, which also references the standard BOM schema. To encapsulate the BOM behavior, the model also references the SRML schema and then specifies the model behavior in the BOM document using SRML elements. The SRML schema specifies a minimal set of elements that provide object-oriented constructs for implementing identity, modularity, classes, associations, behavior, communication, inheritance, polymorphism, and extensibility--which form the foundation of reuse within highly sophisticated models. Just as in HTML, SRML is programming language independent through language plug-ins like JavaScript (ECMAScript). The plug-in architecture of the simulator also integrates the behavior of pre-compiled components. When combined with an interoperability layer provided by HLA, SRML enables the construction of distributed BOMs.SRML semantics define Items, Item Classes, Properties, and Locations interrelated as shown in Figure 3. Internally an item has a unique system-generated ItemID and a script. It has an association with a DOM node—from the element. It can both serve as a location, and belong at a location along with other items. It can have links to other items, and be a target for a link. Also, it can belong to an item class, which in turn can have super-classes. An item gets its properties directly from DOM attributes, and its behavior from script. The ItemClass element allows the modeler to generalize groups of common items, yet an item does not need to have a corresponding ItemClass.Figure 3 – SRML SemanticsThe modeler may use an <srml:Simulation> element to encapsulate the structure and behavior of a federate, while also using an <srml:Simulations> element to encapsulate the federation. The modeler may additionally specify generalization classes in the BOM document using the following element: <srml:ItemClass Name=’classname’ SuperClasses=‘class1 class2’>. To specify behavior, the modeler would attach <srml:Script Type=‘language’> tags to any individual item or item class. To make associative links between items in the BOM, the modeler adds <srml:Link Target=“XPath”/> elements, or uses standard XML IDREFs attributes. For representing multiplicity, the modeler places <… srml:Quantity=‘value’>  attribute into any item. The modeler additionally modularizes the BOM documents by adding <… srml:Source=‘target’> attributes that refer to external items, that are either embedded, linked, or plugged in based on the form of the target. Additional elements from the XML OMT could also be added in the BOM.5. The Simulation Reference SimulatorFeatures provided by most simulation engines are well understood, thus making it possible to define a standard set of primitive services for a universal simulator. For example, engines fundamentally provide item management, event management, random number generation, mathematics and statistics, and plug-ins for everything else. The Simulation Reference Simulator provides all of these services within a runtime environment that intrinsically uses the Document Object Model (DOM) in item management, and plug-in compilers for behavior. Event management services include functions to Send, Post, Broadcast, and Schedule events among local and remote items.Using an HLA Plug-In component, a Mega-BOM becomes an executing federate in a federation. Each HLA service becomes an intrinsic part of the simulator’s runtime environment under an automatic mode of operation. For the Federation Management services, the plug-in automatically reads attributes and sub-elements of the model during load-time and either creates or joins a federation execution through the RTI. Object and Declaration Management services are also automatic. The specification of published event classes in the SRML BOM results in published interaction classes in HLA. Subscribers use event sinks in SRML to receive interactions from other federates. Similarly, item classes may be published by adding RTI::Publish attributes in the XML. As an open architecture, Data Distribution and Ownership management services are directly callable as necessary by the model. Finally, Time Management services automatically synchronize the local simulator under any declared mode of operation. At run time, the RTI receives an OMT FOM that the HLA component generated from the Mega-BOM. Figure 4 shows the functionality for an individual federate operating under this scheme. SHAPE  \* MERGEFORMAT Figure 4 - BOM Simulation Using SRML/HLAModels can be transmitted dynamically either through the RTI or through plain TCP/IP connections. Likewise, the RTI may have the ability to dynamically accept changing FOMs.6. A Mega-BOM ExampleThe following XML text provides an example of an encapsulated Mega-BOM that includes both trigger and interactions BOMs<bom:MegaBOMName='ClimateSample'Type='Trigger-Interaction' Assembly='DesignTime' Category='Encapsulated'GeneralizationLevel='Concrete'/><bom:Meta-data><bom:Article Name='external-design' href='http://boeing.com/climate.ppt'/><Article Name='intent-of-use'>This is a BOM example.</bom:Article></bom:Meta-data><bom:Implementation><srml:Simulation Name='ControllerSimulation'><climate:Controller Name='TS293847' Operable='1' Pings='0' Health=''><srml:Script Type='text/javascript'><![CDATA[function poll() {Items(1).queryStatus();Items(2).queryStatus();}function receive(Name, Status) {Health=Status;Pings++;}]]></srml:Script><climate:Sensor Name='TSM5865' Quantity='2' Status='0' Threshold='100'><srml:EventSink Name='Reading'ItemClass='Equipment'  WithPropertiesChanged='Temperature'/><srml:Script Type='text/javascript'><![CDATA[function queryStatus() {Location.receive(Name, Status);}function Reading_TemperatureChanged(item, value){if (value > 100){Status='Overheated';}}]]></srml:Script></climate:Sensor></climate:Controller></srml:Simulation><srml:Simulation Name='EquipmentSimulation'><climate:Environment Name='Room101' Temperature='' Source='progid://Climate.Room'/></srml:Simulation></bom:Implementation><bom:MegaBOM>7. ConclusionThis paper makes the case for a higher-level simulation architecture based on BOMs using SRML that can operate in a universal simulator as a layer on top of HLA. The new architecture parallels web architecture and includes a greater degree of simulation standardization than currently exists. With Encapsulated BOMs using SRML and a universal simulation reference simulator, the cost to build simulations can decrease in the same way that building client application software has decreased since the entry of HTML and web browsers. The author recommends that the Simulation Interoperability Standards Organization should 1) continue with the development and standardization of BOMs; 2) begin a working group to standardize the interfaces and functionality for a universal simulation reference simulator based on a minimal Simulation Reference Markup Language.8. References[1]	XML is a standard under the World Wide Web Consortium (http://www.w3.org).[2]	BOM Study Group Final Report, SISO, May 2001.[3]	XML Schemas express shared vocabularies and allow machines to carry out rules made by people.[4]	The DOM is a language- neutral interface that allows programs and scripts to dynamically access the content, structure and style of documents (http://www.w3.org/DOM).[5] XSLT is a language for transforming XML documents (http://www.w3.org/DOM/Style/XSL)[6] Dynamic HTML is an extension of HTML provides more interactivity than standard HTML (http://msdn.Microsoft.com/workshop/author/dhtml.dhtmlovw.asp).[7] XHTML is the reformulation of HTML as an XML application (http://www.w3.org/TR/xhtml11)[8] BOM Methodology Specification, SISO, May 2001.[9] Reichenthal, Steven: “Case Study: Lessons Learned in Availability Modeling.” Proceedings of the 2001 Summer Simulation Conference. Simulation Computing Society International, July 2001.Author BiographySTEVEN W REICHENTHAL is a Simulation Developer at Boeing as part of the Logistics organization. He has a Masters degree in Computer Science and an MBA, and has taught software development courses at the California State University in Fullerton as an adjunct professor since 1993. PAGE \# "'Page: '#''"  May want to say 1.3 Interface (or reference it with a footnote)PAGE \# "'Page: '#''"  This needs further elaboration. What do you mean by distributed? Are all these true?…SRML enables the construction of Encapsulated BOMs (providing the behavioral meta-data)SRML enables the construction of Mega-BOMs (providing the behaviorila meta-data for a federation or an entire federation)SRML enables the BOMs to be distributed and understood by participating federates through  the use a universal simulatorPAGE \# "'Page: '#''"  How about a table mapping / comparing SRML and  what OMT provides? SRML Schema BOM Schema Mega- BOMX (XML) BOMX Document  (XML) BOMX Schema use Generate FOM OMT FOM Debug Test Run Validate Simulator RTI Edit Author Design Tool Configure Find Save Reuse Repository HLA Plug-In  