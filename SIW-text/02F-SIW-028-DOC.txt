Using Rapide to Simulate a Federation ArchitectureFrederic D. McKenzie1, Mikel D. Petty2, and Qingwen Xu21Department of Electrical and Computer EngineeringOld Dominion University231-C Kaufman Hall, Norfolk VA 23529fmckenzi@ece.odu.edu2Virginia Modeling, Analysis & Simulation CenterOld Dominion University7000 College Drive, Suffolk VA 23435mpetty@vmasc.odu.edu, xu_q@cs.odu.eduKeywords:  Architecture description languages; formal methods; HLA; simulation architectureForums:IMPL, FedPerfABSTRACT: Software architecture is high-level software design, dealing with the structure and organization of large software systems.  A software system's architecture is defined in terms of computational components and interactions among those components.  Architecture Description Languages (ADLs) are languages designed to represent software designs at the architecture level.  Different ADLs often have different intents; for example, Rapide supports architecture simulation and Acme is intended to be both an ADL and an ADL interchange format.Experimental applications of two ADLs were conducted to determine the utility and effectiveness of using ADLs for architecture-level design and analysis for simulation systems.  In this paper we report on one of those experiments.  Rapide was used to model the EnviroFed federation architecture and to analyze its run-time performance.  The experiment simulated dataflow in the EnviroFed federation.  The simulation was used to identify federates within the federation that might be unable to process the incoming data quickly enough.  The experiment showed that ADLs could be used to discover important features of simulation system architectures.Introduction & BackgroundSoftware architecture is high-level software design, dealing with the structure and organization of large software systems.  A software system’s architecture is defined in terms of computational components and interactions among those components.  Software architecture includes the allocation of functionality to components, designing data and control connections between the components, and achieving overall system performance goals.  Architecture Description Languages (ADLs) are languages designed to represent software designs at the architecture level and to allow the specification of architectures using language elements appropriate to the objects and structures at that level.  In addition, ADLs are often rigorous enough to enable automated reasoning and verification of aspects of the architecture.A surprisingly large number of ADLs have been developed.  Different ADLs often have different intents; for example, Rapide [8] supports architecture simulation, and Acme [1] is intended to be both an ADL and an ADL interchange format.Much of the simulation development community currently uses informal software architecture methods.  However, the use of formal software architecture design methods and ADLs would produce benefits in the areas of robustness, composability, knowledge transfer, and risk reduction.Architecture Description LanguagesOften, descriptions of large software systems include a representation of the system architecture, which is a positive fact, but those representations typically use an informal graphical notation known as a “box-and-line” diagram.  In box-and-line diagrams, boxes usually represent system components or layers, and lines usually represent some dataflow or control connection between the components.  Such diagrams are ubiquitous, widely understood at a general level, and are certainly better than nothing. Unfortunately, precisely because box-and-line diagrams are informal the semantic meanings of the boxes and lines vary from one box-and-line diagram to the next [3]; indeed, they often vary within a single diagram. Textual description is also used informally in software architecture practice.  The text may mention a particular architecture pattern, e.g. “client-server”, it is rare see a detailed explanation of how the architecture being described is consistent with, and differs from, the named pattern.  While such descriptive text is again certainly better than nothing, like informal box-and-line diagrams it is generally ambiguous and not amenable to analysis.  A characteristic of formal specification languages (FSLs) is their mathematical formality, including precisely defined syntax and unambiguous semantics.  FSLs are intended to be sufficiently formal to be the subject of logical analysis, proofs of correctness, and automated reasoning.  Perhaps the most widely used FSL, called Z (pronounced “zed”) was developed primarily at the University of Oxford.  It is based on first-order logic and set theory.  The reasoning potential provided by the formality of FSLs is appealing.  However, as can be readily seen in the Z example, the actual structure of the architecture pattern is difficult to discern in an FSL specification.  Moreover, the non-intuitive and unfamiliar syntax of FSLs can be an obstacle to their use by many practicing software architects.  Finally, though it is not shown in the Z example, FSL specifications can be and generally are used to specify the details of systems at the computation or interface design levels. An ADL is “a notation that allows for a precise description of the externally visible properties of a software architecture” [2].  In particular, ADLs “provide constructs for specifying architectural abstractions in a descriptive notation.  They provide mechanisms for decomposing a system into components and connectors, specifying how these elements are combined to form a configuration and defining families of architectures or styles” [4].  They generally contain language elements for components and connections that define those types of objects rigorously enough to perform architectural reasoning about them without delving too deeply into the lower-level details of computation and interfaces.  ADLs are “… aimed at giving practitioners better ways of writing down architectures so that they can be communicated to others and in many cases analyzed with tools” [1]. Components perform computation and retain state in a system and usually correspond to the boxes in informal box-and-line diagrams.  Components may be primitive, not further decomposable at the architecture level and generally implemented as compilation units in a conventional programming language, or composite, formed by composing other architecture objects.  Components have interfaces, through which they interact with other parts of the system.  They are “black box entities that encapsulates services behind well-defined interfaces” and “static abstractions with plugs” [2].  Components may have a type, such as “filter” or “manager”; these types are analogous to a type definition in a conventional programming language or a class definition in an object-oriented language.Connectors are relations between components; they “model interactions among components and rules that govern those interactions” [4].  They embody the expected patterns of communication and interactions between components.  Connectors mediate any type of interaction, such as dataflow and control, between components.  Unlike components, connectors do not generally correspond to compilation units.  Connector descriptions may specify which types of interactions they can mediate and which protocols are associated with those interactions.  Like components, connectors may be primitive or composite, and connectors may be typed, with the types definable in the ADL; “pipeline” and “event” are examples of connector types.Software Architecture of Simulation SystemsThe architecture of a software system can depend on both the computational requirements of the system and the application domain of the system.  Simulation systems are generally software systems, at least in part, so our discussion of software architecture and ADLs in general apply to simulation systems as a special case.  Beyond this general applicability, software design patterns specific to particular application domains, sometimes called “reference architectures”, have been receiving increasing research attention [1].  M&S is such an application domain.  It is clear that architecture patterns have emerged for simulation software.  Distributed simulation systems, for example, are assembled from sets of communicating simulations that cooperate to simulate a common simulated scenario.  Prime examples in the military domain are Simulator Networking (SIMNET), Distributed Interactive Simulation (DIS), and High Level Architecture (HLA). Another example, Discrete Event Simulation (DES), is a venerable and widely applied simulation paradigm [6] [7].  In a discrete event simulation, simulated object change state at discrete instants in time, called events, typically doing so while flowing through a series of discrete process steps.  DES is both a modeling method and a software architecture pattern; DES systems, for example, typically have a component that implements the event queue, a data structure where pending events are maintained and organized.The point here is to illustrate that architecture patterns exist in the simulation domain.  Note also that patterns exist at different levels; to use HLA terms, distributed simulation is a “federation” level architecture pattern and can be distinguished from a “federate” level architecture pattern for DES or Computer Generated Forces (CGF) models.Software architecture patterns are in many ways patterns of composition.  An architecture pattern describes a way to compose components, connectors, and other architecture objects.  As stated in [1], “composing a system from subsystems is unlike programming the algorithms and data structures that lie within the primitive subsystems”; the composition activity takes place at the architecture level.From this, it follows that the relationship between software architecture, composition, ADLs, and simulation composability is important.  Because software architectures are often developed by composition, an ADL should have a composition operator or notation or capability; ideally, the semantics of composition in the ADL should be equivalent to the actual effect of composing software.  Simulation composability is more than just architecture or software composition.  It is the ability to assemble sets of simulation components into simulation systems specific to particular applications. To achieve simulation composability it is not enough that the components can be combined as software modules; the composition must also produce a valid model of the system being simulated.  Hence architectural composition as defined here is necessary but not sufficient to support simulation composability.Rapide Capabilities as an ADLRapide is a language for defining and, unlike other ADLs, executing software architectures. Rapide, therefore, is an ADL oriented towards architecture simulation [5].  It simulates patterns of events that occur in an architecture as it executes [8].  The development of Rapide was initially funded by the Defense Advance Research Projects Agency (DARPA) and subsequently by the Air Force Office of Scientific Research (AFOSR).The output of Rapide after a simulation run is an event list that provides causal and timing relationships among the events.  Sets of causal events are termed partially ordered event sets or posets [10] [8].  These posets are powerful in that they may be searched and analyzed for patterns that could impose constraints on systems of interest.  This is a particularly powerful capability for simulations in that the notion of events and causality are central to the core of simulation architectures and may easily be applied to distributed and concurrent systems.  For example, one may develop a constraint (pattern) for a family of simulation systems or a particular federation and test the architecture model for compliance with the constraint.Rapide uses a method of encapsulating the outgoing procedure calls in addition to the typical public interface to a component into a structure called an interface [11].  Interfaces are then connected together instead on the components themselves.  This interface connection architecture (as opposed to an object connection architecture) may be used in two ways.  One way is to specify the expected behavior of underlying components in the interfaces themselves that allows the execution of an architecture model without actually creating models for the components.  The second way is to create models for the components and allow the outgoing calls of a particular component to access its own interface instead of the public interface of the target component.  This second method is a powerful feature for both static and dynamic composability.  For static composability, this feature can be used to ensure that composable components conform not only to a public interface but also to an internal behavioral expectation.  For dynamic composability, there is an added benefit that components that conform to a given interface can be mapped and executed at runtime.Using Rapide’s interface connection architecture, one can determine if a system’s design conforms to a particular architecture family, such as HLA federations.  Conformance may imply the following [5]:Components exist in the test system design that comply with all the interfaces in the reference architecture.Those components comply with the reference behavior identified by their interfaces.The components are also connected in a manner identified by the reference architecture.All constraints within the reference architecture are satisfied.The last point is important because constraints can define what an architecture can not do as well as what it must do.  Such constraints are expressed as an event pattern that may or may not appear in a poset.  When comparing two architectures, a test architecture and a reference architecture, Rapide uses only points 1 and 4 above.In addition to conformance testing, Rapide purports an “architecture-driven system development” capability [10].  The idea is to first model the system architecture from the system requirements using Rapide.  This is done with only interfaces and connections without implementing the components.  Then, Rapide’s analysis methods are used to verify and validate the simulated architecture.  Finally, components are added incrementally until the system’s modules are developed to the satisfaction of the architecture.In the actual simulation execution of architectures, Rapide uses three analysis methods – constraint checking, poset browsing, and animation.  Constraint checking is automatically done during the execution of the architecture.  Poset browsing is performed after the execution completes.  These posets may be searched and queried to find interesting sequences of events that occurred during the simulation of the architecture.  Animation occurs during the execution and is a human friendly visual check of the system simulation.Given Rapide’s close ties to distributed simulation architectures and defense, it is no surprise that Rapide has already been used to study HLA [12] [13].  These studies concentrated primarily on HLA interface specification robustness and compliance; for example, the mechanism and sequence of attribute ownership transfer was examined.  However, Rapide was deemed useful for other applications including the analysis of simulation behavior models and their conformance to standard architectures.Rapide’s architectural simulation capabilities allow consistency checking and performance analysis for race conditions and other execution sequence issues [4].  Additionally, Rapide can produce executable code in C, C++, or Ada.EnviroFed Experiment:  Using ADLs to Specify Federation ArchitecturesAn experimental application was conducted to determine the utility and effectiveness of using ADLs for architecture-level design and analysis for simulation systems. This study was interested in answering questions about the use of ADLs in analyzing federation architectures.  Specifically, we wanted to know how well ADLs could be used to analyze simulation architectures and what benefits an ADL provides over informal and graphical modeling methods for architecture-level design.A single aspect of the software architectures, run-time performance, was chosen for analysis. Run-time performance is often a crucial issue in simulation applications, so an ADL that supported automated analysis of expected performance at the architecture level could be quite valuable.  With its architecture simulation capabilities, Rapide was an easy selection for ADL with which to perform the experiment.Rapide was used to simulate the EnviroFed federation architecture.  The experiment had two objectives; first, to determine if an ADL could be effectively and usefully applied at the federation level; and second, to determine if ADL-based architecture simulation could be used to analyze a federation’s performance. The experiment simulated dataflow in the EnviroFed federation in two modes:  Data Distribution Management (DDM) in use, and DDM not in use.  The simulation was used to identify federates within the federation that might be unable to process the incoming data quickly enough.It is important to recall that the objective of this experiment was not to produce a high-fidelity model of a particular federation (EnviroFed) but rather to understand the effectiveness of Rapide at modeling and analyzing such architectures.  Our EnviroFed architecture model contains changes and assumptions with respect to the actual EnviroFed architecture.   In fact, our model architecture could more accurately be called “EnviroFed-like”, rather than EnviroFed, but we use the latter term for expository convenience. The changes and assumptions may affect the analysis results with respect to EnviroFed, but they do not affect the experimental findings with respect to using Rapide for architectural analysis of a federation like EnviroFed.  The EnviroFed federation was used as the test architecture to examine the usefulness of Rapide in analyzing a given HLA federation.  EnviroFed is a Defense Modeling Simulation Office (DMSO) project intended to “demonstrate the state-of-the-art with regard to the representation of the natural environment in DoD simulations” [9].  It is an HLA federation composed of a variety of models that either produce or make use of high fidelity environmental features or capabilities.  In the EnviroFed experiments, environmental impacts manifest as dynamic terrain and weather such as increasingly muddy soil and high winds and waves that result in differing battle outcomes or NBC dispersal.  The HLA compliant simulations in EnviroFed include:JSAF.  A constructive simulation contributing CGF entities.ModStealth.  A synthetic environment viewer.WARCON.  An aircraft carrier simulation that models the logistics of launching aircraft from a carrier including below deck operations.WALTS.  Weapons Analysis and Lethality Tool Set that calculates damage and provides realistic weapon effects.CUSP.  Combined Urban Dispersion Model models the dispersion of chemical and biological contaminants.OASES.  Ocean Atmospheric Space Environment Services provides current weather conditions.HydroSim.  Produces muddy terrain under wet conditions.DTSim.  Provides dynamic terrain polygons such as craters, etc. EnviroFed Architecture Model and Architecture SimulationThe research performed here examined the usefulness of Rapide in analyzing a given HLA federation.  The EnviroFed federation [9] was used as the test architecture for this experiment.  As much information as possible about the EnviroFed federation and its federates was gleaned from the available documentation, such as [9], while a significant amount of detail needed for the experiment but missing from the available documentation was assumed.  REF _Ref13380216 \h  \* MERGEFORMAT Figure 1 shows the Rapide model of the EnviroFed federates connected by a network component that represents the HLA RTI.  Rapide graphical models can be exported to a Rapide file with corresponding interface, module, and architecture components. The Rapide file may then be edited directly to add further complexity.  Note that this view is a logical view of the federation; some the logical federates, may actually be composed of more than one federate joined to the federation execution.  However, for the purposes of the experiment, this logical view was sufficient.Figure 1 also shows the simulation with animation of the EnviroFed model executing in Rapide.  The visualization capability in Rapide is called Rapide Animator (Raptor).  The shaded boxes indicate control and data flow events from/to a variety of federates occurring, in this case, concurrently.  The white alert box is a behavior implementation of an “overloading” constraint discussed later.  The constraint dictates that when a threshold amount of data is exceeded, a federate will display the overload alert message.Table 1 shows the data exchanged among the federates in the experimental EnviroFed model.  Unless otherwise noted, data exchanges are a one-time occurrence of 48 bytes occurring after an indicated sequence of activity.  The experiment compares an architecture employing DDM and one without.  The Comments column indicates the significance of DDM to a particular federate.Figure  SEQ Figure \* ARABIC 1:  Simulation of EnviroFed Model in RapideAs an example, the first row of data in the table indicates that JSAF publishes entity updates (tanks, troops, sonar, sensors, etc), crater requests, dynamic road requests, sensor information, contamination reports, and weapon target impact data. The frequency that this data is provided varies depending upon the type of information. For instance, entity updates are modeled to occur every ten seconds for each entity and the size of the data is arbitrarily chosen at 48 bytes per entity. The data subscribed column indicates particular information to which JSAF subscribes and/or the federates that produce information to which JSAF subscribes.The difference between DDM and no DDM is exhibited in the amount of data on the network and the amount of data passed on to the federate from the network interface, which in our model is also part of the network component. The amount of data on the network will increase when going from no DDM to DDM use in purely a LAN configuration. In a WAN configuration where different subnets are separated by routers, multicast addressed data have the opportunity to be screened and, therefore, the data on a particular subnet may be reduced. However, the only opportunity for the data to be screened on a purely LAN configuration (all federates on the same network) is at the network interface for each federate. Therefore, in our LAN configuration, data on the network increases as packets are repeated for each multicast address required for the data. Nevertheless, since there is screening before the data gets to the federate not all data has to be processed by the federate itself. This DDM benefit results in a decrease in the amount of data processed by the federate. So without DDM means less data on the network but more for the federate while with DDM means more data on the network but less for the federate.Federate NameData publishedData SUBSCRIBEDCommentsJSAFEntity updates: ~100 entities (Tanks, troops, sonar, sensors, etc)48bytes/entity/10secsVaried Requests:  48bytes / Request(Crater requests, dynamic road requests, etc) ContamSensor:  48bytesContamReport:  48bytesWeaponTargetImpact:  48bytes OASES, HYDROSIM,DTSIM, WARCON,CUSP, PC_SWATDDM supportWALTSAgentRelease to CUSP:48bytesWeaponTargetImpact  fromJSAFCUSPDosage per entity and2D contour updates to JSAF:1kB/entity/10secsContamDetect to JSAF48bytesSurface_Weather_UTM and CloudLayer_UTM from OASESAgentRelease from WALTSContamSensor andContamReport from JSAFOASESObject updates:  1kB/3minsRectangular Grid:  (Wind; waves; Precipitation; clouds; haze…)Curvilinear Grid:  (Salinity; Temp; U, V, W Current, Tides…)NODDM supportNot completed DTSIM(HYDROSIM)Repoly service:(Terrain modification, request report to JSAF)  1kB/RequestFeature Updates:  48kB/3minsVaried requests from JSAFOASESDDM supportMODSTEALTHNOALL WARCON(PC-SWAT)Aircraft launched:  48bytesProbability of mine detection to JSAF48bytesWind (for wind-over-deck)Environmental state: Visibility, Ceiling, Sea State from OASESSonar, Mine, and Environment data from JSAFHLA control and resultsNOALLTable 1:  Dataflow Among EnviroFed FederatesFigure 2 illustrates the Rapide interface descriptions for the JSAF federate.  The grayed dialog box allows one to choose the interface to edit where upon the rightmost dialog box may then be used to input actions and behaviors into the interface.  Actions indicate the public functionality of a module as well as the internal function calls of the module.  Behaviors define rules for executing the actions and provide the basis for executing the architecture.  Below is an excerpt from the behavior portion of the JSAF federate component interface. The behavior in essence says  to send out a comtamination report when a contamination detection event is received from CUSP.   (?t: time; ?ObjID : Integer; ?DATA : Integer)J_NTS.Packets_Receive(?ObjID, ?DATA, DDM_flag)where(?ObjID = CUSP_ContamDetect)=> J_NTS.Packets_Send(JSAF_ContamReport, 48, DDM_flag);;   Figure 2 also shows an example of a constraint that would check that JSAF never receives more than 1024 Kbytes of data in one time interval.  The constraint is commented out in the figure as this architecture is to be simulated.  If the architecture were to be used as a reference architecture, the constraint would be applicable while the behavior portion would be commented.Below is an excerpt of from the Rapide architecture definition file for the EnviroFed federation model. The excerpt shows the connections of the module interfaces to the RTI or network module interface.  Global constraints that cover many or disparate modules may be added here and just as the behaviors in interface components the connections in this architectural component would be commented.  Note that there is only one architecture component for each Rapide architecture model.  However, using a hierarchy of architectures may amend this rule.In this simple version, HLA details are not implemented and are assumed to be hidden in the federation modules. For complex software like EnviroFed we may have many different views of its software architecture. The Rapide language is flexible enough to simulate them at different levels: From the high abstraction level as we have implemented here to far lower level details as desired.ARCHITECTURE NTFED () is-- EnviroFed architecture: Top level module, containing -- a network module and eight federation modules.NETWORKmod : NETWORK;JSAFmod : JSAF;WALTSmod : WALTS;CUSPmod : CUSP;WARCONmod : WARCON;OASESmod : OASES;DTSIMmod : DTSIM;MODSTEALTHmod : MODSTEALTH;HLACRmod : HLACR;-- Architecture constraint rules can be added here, if any-- Below is a set of connection rules that define -- communication between the modulesconnect	JSAFmod.J_NTS => NETWORKmod.DJ_NTS;	WALTSmod.W_NTS => NETWORKmod.DW_NTS;	CUSPmod.C_NTS => NETWORKmod.DC_NTS;	WARCONmod.WC_NTS => NETWORKmod.DWC_NTS;	OASESmod.O_NTS => NETWORKmod.DO_NTS;	DTSIMmod.D_NTS => NETWORKmod.DD_NTS;	MODSTEALTHmod.M_NTS => NETWORKmod.DM_NTS;	HLACRmod.H_NTS => NETWORKmod.DH_NTS;END;Figure 2.  EnviroFed interface definitionsThis simulation is designed for studying data flow between the federations. We compared two methods of distributed data in EnviroFed: DDM and without DDM. A runtime parameter called DDM_flag is defined that decides which method is used when the simulation is running.Upon the completion of the simulation execution, Rapide produces a poset whose event causality and timing may be examined.  Figure 3 shows a portion of the poset generated from the execution of the EnviroFed model.  The full poset is quite extensive maybe 50 times as large and complicated.  Rapide provides a browser capability that allows queries on posets.  These queries may be used to search for anomalies or to verify that a certain sequence of events always or never occurs.  A sophisticated pattern language is available in Rapide to specify operations on as well as relationships among events.From Figure 3, the Contamsensor event in JSAF (highlighted in yellow) is sent to CUSP and eventually triggers a "ContamDetect" which is sent back from CUSP to JSAF.  The yellow Contamsensor is triggered by a "CURRENT_TIME" event.  "ContamDetect" is hidden in the C_NTS'PACKETS_SEND event that is located at the bottom left of the picture.  Between these two events are two sets of dual network events (four total) that indicate communication from JSAF to the network and communication from the network to CUSP respectively.Rapide FindingsThe Rapide model enabled the examination of the EnviroFed architecture for data overloading of the federates.  Conclusions about the affect of dataflow in the federation were found using Rapide.  The experiments found that the EnviroFed architecture with DDM produced more outgoing dataflow per federate but reduced the incoming dataflow per federate that the EnviroFed architecture without DDM, as would be expected.  Outgoing flow from the federate with DDM was thought to be a negligible issue because this was believed to be a burden on the network interface card (NIC) and not the federate’s simulation model itself.  Therefore, assuming adequate network bandwidth, the architecture with DDM reduces a federate’s burden in processing extraneous messages as can be witnessed by the reduction in overloading alerts.Figure 3:  Rapide poset snippetAs far as the general utility of Rapide and the Rapide development environment, Rapide provides some added user-friendly capabilities that make the utilization of an ADL attractive.  The following features were useful:Graphical editor.  The graphical editor provided a quick startup capability in creating the architecture and inputting the interface and architecture components.Animation capability.  The animation capability provided the ability to convey architecture simulations and issues in a user-friendly way.Behavior rules.  The behavior rules allowed the simulation execution of the architecture without defining the component modules.Constraints.  The constraints allow the definition of a reference architecture that can be compared to other architecture designs and tested for conformance.Poset browser.  The poset browser allowed the close examination of event causality and timing.Additionally, the utility of a reference architecture may be increased when accompanying a reference FOM.  A federation architect would be able to test not only whether his/her federation complies with the reference FOM but also could test for causality, i.e., whether the federates in the federation follow necessary sequences of events during the execution of the federation.ConclusionsADLs benefit software development by providing greater precision of representation than informal box-and-line diagrams.  This forces the architect to consider and specify his/her design for the system with more precision, thereby uncovering architectural problems earlier.  The likelihood of correctly designed connections (i.e., interfaces, protocols, and dataflows) between the components (i.e., modules, algorithms, and data structures) in an architecture is also increased [1].   ADLs allow more powerful analysis of designs.  ADLs that are sufficiently formal and rigorous in their syntax and semantics so as to express properties of interest of the represented architectures in unambiguous ways provide a basis for reliable reasoning, manual and automated, about the properties of software systems built to a represented architecture [1].  The goal is that  ADL-enabled reasoning and simulation will reveal properties inherent in the architecture earlier in the development cycle, when changes are easier and less costly, than would occur otherwise [1].The Rapide simulation allowed us to learn which federates in a federation might be overloaded when faced with expected federation data volume, and what effect HLA DDM might have on that flow.  A relatively simple architecture model, developed with a modest level of effort, produced a finding about the architecture that would have been quite valuable in a non-experimental context.  In a full-scale development effort such findings early in the development cycle could save very large amounts of time and money.    In a second experiment, not reported in this paper, the ADL Acme was used to model the run-time performance of the ModSAF architecture; the ADL was similarly useful in that application [14].Much of the modeling and simulation development community is currently using the informal software architecture methods mentioned in this report.  Would that community benefit from a more formal approach to software architecture, using software architecture design methods and ADLs?  From this study, we believe the answer is clearly yes.  We see these benefits to the simulation development community:Robustness.  Simulation architectures that are more reliable, stable and expandable than previous and current architectures will result from the employment of software architecture discipline, with or without the explicit use of ADLs.Composability.  The use of ADLs will support the community goal of composability, at least at the conceptual level, by making explicit the notions of simulation components, connectors, and their interfaces, at a level of detail more accessible than an API, and helping architects to see their simulation systems as compositions.Knowledge transfer.  Simulation architectures specified using ADLs can be studied as examples of good (or bad) design, and ADL descriptions for production simulations will serve as a good starting point for developers who need to become familiar with a system.Risk reduction.  Analysis of architectures using ADL-based reasoning can, as demonstrated in this study, reveal key aspects of simulation architectures, such as performance.  This should lead to identification of potential problems earlier in the development cycle.Though some benefits will accrue even from the use of any or multiple ADLs, we believe that the simulation community will derive maximum benefit from adoption of a standard community-wide ADL, due to the usual benefits of standardization.  Rapide’s simulation capabilities are powerful and flexible, but they follow from a language that is relatively more difficult to learn and use.  Also, the language’s development environment falls short of industrial-strength production software in both reliability and capability. Therefore, more study and research are needed to determine or develop an appropriate ADL for the simulation community.AcknowledgmentThis work was sponsored by the U. S. Army Simulation, Training, and Instrumentation Command, contract N61339-01-P-0293, and was supervised by Ms. Cindy Harrison, OneSAF Project Director.  That support is gratefully acknowledged.Authors’ biographiesFrederic (Rick) D. McKenzie is an Assistant Professor of Electrical and Computer Engineering at Old Dominion University.  He received a Ph.D. in Computer Engineering from the University of Central Florida in 1994.  Dr. McKenzie previously held a senior scientist position at Science Applications International Corporation.  He has had several years of research and development experience in the software and artificial intelligence fields.  Both his M.S. and Ph.D. work were in artificial intelligence.Mikel D. Petty is Chief Scientist of the Virginia Modeling, Analysis & Simulation Center at Old Dominion University.  He received a Ph.D. from the University of Central Florida (UCF) in 1997.  Dr. Petty has worked in modeling and simulation research and development since 1990 in the areas of simulation interoperability, computer generated forces, multi-resolution simulation, and applications of theory to simulation.  He has served on a National Research Council committee on modeling and simulation and is currently an Associate Editor of the journal SIMULATION:  Transactions of the Society for Modeling and Simulation International.Qingwen Xu is a Ph.D. student in Computer Science at Old Dominion University and a Research Assistant at the Virginia Modeling, Analysis and Simulation Center.  He received a M.S. degree in Computer Science from Wake Forest University in 1999 and a B.S. degree in Auditing from Wuhan Unversity in 1991.  His dissertation research involves self-organizing wireless sensor networks.References[1]	M. Shaw and D. Garlan, Software Architecture, Perspectives on an Emerging Discipline, Prentice Hall, Upper Saddle River NJ, 1996.[2]	J. Schneider and O. Nierstrasz, “Components, Scripts, and Glue”, in L. Barroca, J. Hall, and P. Hall (Editors), Software Architectures, Advances and Applications, Springer, London UK, 2000, pp. 13-25.[3]	D. Garlan and M. Shaw, “An introduction to software architecture”, in V. Ambriola and G. Tortora (Editors), Advances in Software Engineering and Knowledge Engineering, World Scientific Publishing, Singapore, 1993, pp. 1-39.[4]	A. D. Fuxman, “A Survey of Architecture Description Languages”, Technical Report CSRG-407, Department of Computer Science, University of Toronto, 1999.[5]	D. C. Luckham, L. M. Augustin, J. J. Kenney, J. Veera, D. Bryan, and W. Mann, “Specification and analysis of system architecture using Rapide”, IEEE Transactions on Software Engineering, Special Issue on Software Architecture, Vol. 21, No. 4, April 1995, pp. 336-355.[6]	J. Banks, J. S. Carson, and B. L. Nelson, Discrete-Event System Simulation, Second Edition, Prentice Hall, Upper Saddle River NJ, 1996.[7]	J. Banks (Editor), Handbook of Simulation, Principles, Methodology, Advances, Applications, and Practice, John Wiley & Sons, New York NY, 1998.[8]	D. C. Luckham, “Rapide:  A Language and Toolset for Simulation of Distributed Systems by Partial Orderings of Events”, DIMACS Workshop on Partial Order Methods In Verification, Princeton University, July 24-26 1996, pp. 329-358.[9]	EnviroFed Phase III Demonstration CD, Integrated Natural Environment, Defense Modeling and Simulation Office, November 8 2001.[10]	Rapide Design Team, Guide to the Rapide 1.0 Language Reference Manual (Draft), Computer Systems Lab, Stanford University, 1997.[11]	D. Katiyar, D. C. Luckham, and J. Mitchell, “A type system for prototyping languages”, Proceedings of the 21st ACM Symposium on Principles of Programming Languages, Portland OR, January 17-21 1994, pp. 138-150.[12]	F. V. Guimbretiere, D. C. Luckham, and F. C. Belz, “Rapide ADS HLA Simulation: A Simple Illustrative Demonstration”, Unpublished paper, April 1995.[13]	D. C. Luckham, F. V. Guimbretierre, H. Wang, and Y. Lu, “Applying Event-Based Modelling to the ADS High Level Architecture Development Process”, Unpublished paper, August 1995.[14]	M. D. Petty, F. D. McKenzie, and Q. Xu, “Using a Software Architecture Description Language to Model the Architecture and Run-Time Performance of a Federate”, Proceedings of the Sixth International IEEE Workshop on Distributed Simulation and Real Time Applications, Ft. Worth TX, October 11-13 2002.