Timing: Mechanisms for Ownership TransferMichael D. MyjakThe Virtual Workshop, & HLA Products, Inc P. O. Box 98 Titusville, FL  32781<mmyjak@virtualworkshop.com>Tom LakeInterGlossa Ltd.31A, Chain Street, Reading, UK RG12HX<Tom.Lake@glossa.co.uk>David J. RobertsBen WorthingtonUniversity of Reading, Whiteknights, Reading, RG6 2AY, UKcybdjr@cyber.reading.ac.ukar@ cyber.reading.ac.ukP.M.Sharkey@reading.ac.ukKeywordsDistributed Synthetic Environment, Latency, Concurrency Control, RTI, Real Time Interaction Abstract: The High Level Architecture (HLA) supports an Ownership Transfer service.  This service, according to the draft IEEE 1516 specification, only supports the transference of Object Attributes.  Yet there is more to the essential state data necessary in the organization and operation of a an object, than just its public attributes (i.e., HLA object state).   A key consideration in building these networked simulations is how to ensure that all of the participating hosts maintain a state-consistent view of the dynamic simulation environment (i.e., federation state -- which is not contained in any one object).  Dynamic shared state constitutes the changing information that must be maintained by multiple machines in a networked virtual environment.  Dynamic shared state includes, for example, information about what and who is currently participating, their relative locations, and their current behaviors. Thus, accurate dynamic shared state is fundamental to creating realistic environments among shared, multi-user environments. Maintaining both the quality and timeliness of the federation's dynamic shared state is one of the hardest challenges facing any HLA federation (or Run-Time Infrastructure (RTI)) developer.  Difficult tradeoffs must be taken between the available computational resources, networking resources and variances in latency on one hand and the desired realism of the shared Virtual Environment (VE) experience on the other hand.  After describing these fundamental tradeoffs, we discuss three basic approaches to maintaining dynamic shared state: shared repositories, frequent broadcast, and state prediction.  For the sake of illustration, we describe these approaches using the maintenance of position, orientation, and structure of entities in the Virtual Environment.  However, these techniques apply equally well to other shared state information such as the environment, dynamic terrain, or C4I interfaces. We will provide some examples of the timing involved in each of these basic approaches in order to enable the effective transfer of the ownership of an object instance, perhaps evolving the concept a bit, while adding some depth of knowledge for the reader.IntroductionA fundamental goal of a shared, synthetic virtual environment is to provide the user with the illusion that they are all seeing the same thing happening at the same time and in the same virtual place. [Singhal, 99]  On the surface, this appears simple enough.  After all, many of us have experienced single-player virtual games where the local environment is completely under the control of a single interactor.  Many of these (e.g., gaming systems) are chiefly concerned with position, location, and timing, which taken together are oftentimes critically important in advancing to "the next level."  However, where shared virtual environments are concerned, managing dynamic state information -- in a timely manner -- for multiple users can become an inordinately complex process.  A central theme (in computer science) in reducing implementational costs is to "divide and conquer."  [Dewdney, 98]Load-Balanced SimulationsManaging a shared virtual environment is often problematic for large-scale or long-running distributed simulation systems because maintaining shared dynamic state information is limited by both computational and network resource consumption.  Thus when resource consumption peaks exceed capacity (i.e., of individual simulation nodes, interconnecting networks, or distributed systems taken as a whole) such peaks can invalidate simulation results. Subsequently potential cost overruns occur, ranging from simulation exercise repetitions, to wholesale re-design and development of federates and federations.  So we ask, "Can't something be done to help mitigate these risks?"  Today's solution, based on the existing HLA metaphor, requires that each federate be constructed with sufficient dynamic range so as to be able to sustain peak performance levels at all times, even when those peak levels are never required throughout the course of any given scenario.  Put another way, a federation, like a chain, is as strong as its weakest link.  Thus while simulation exercise costs are reduced (due to lack of repetition), increased costs associated with each federate/platform are experienced.  So what can be done to further reduce the economic risk associated with adopting HLA? In a word: load-balancing.Why Dynamic Load BalancingDeveloping federations, federates, FOMs and SOMs can be downright expensive.  Still, these costs pale when compared to the actual costs associated with large, monolithic simulation platforms, or in reality, their prototype weapons platform(s).  Further, the idea of persistent federations, first postulated by [Dahmann, 98], has yet to be proven by industry.  Then as in now, there are "‚Ä¶ presently very few examples of persistent federations‚Ä¶" in the simulation community and "‚Ä¶ while the HLA FEDEP Model currently focuses on how federations are constructed from ‚Äúscratch‚Äù," the simulation community has "persisted" in taking a "wait and see" attitude toward wholesale adoption of HLA.  But why is this?  Isn't the "adoption" of HLA mandated? [Gansler, 98]  Many arguments have been expressed regarding this condition and while some of them may indeed be valid (i.e., lack of an open standard), others are not (i.e., there's a significant learning curve).  But one issue that stands out among the others in this battle for low-cost, reusable simulations is the desire to create low-cost, reusable federation(s) for human interaction and training.  This is precisely where dynamic load-balancing can help reduce costs and mitigate risk.  Whether the target goal is that of reduced platform costs, just-in-time training, the elimination of geographical boundaries to train teams effectively, or acquisition (to name just a few), all would benefit from a reduction in risk.In examining the HLA and it's adoption (or lack thereof) by the simulation community, we have steadfastly focused on its use as a driver for shared synthetic environments that allow users, called interactors, to interact (with synthetic objects) in a natural manner.  Synthetic objects, interacting within a federation, can be modeled today either as an HLA Object Instance, and maintained solely under the jurisdiction of a single (i.e., independent) federate, or as a distributed collection of HLA Object Attributes, owned by multiple federates during the course of a federation exercise.  However, where close and responsive interaction is required, the later solution is often preferable. [Roberts, 98]  The question we now raise is, are these two choices sufficient to load-balance a federation execution?Recently, the validity of HLA-Compliant Object Ownership Transfer Service was drawn into question by problems identified from within the Logistics Community. [Li, 98] [Myjak, 99]  As most of us know, logistics provides material support to and from the battle (among other things).  Logistics is also responsible for moving personnel and equipment from their point of origin(s) to their deployment destinations.  In short, logistics models prototype the object transportation process requests to be supported by HLA, and are perhaps one of the best candidates for demonstrating the need for HLA to support object instance migration.Object Instance Ownership - Limitations and Workarounds The challenge that logistic federates face is the need to simulate moving objects between federates during federation executions.  However, this level of interoperability is not supported by HLA!  This is unfortunate, for without the ability to re-host an object instance dynamically, dynamic load balancing cannot be accomplished within HLA. As currently proposed in the draft IEEE specifications, HLA's Ownership Transfer Service will support the transference of instance attributes only. [IEEE 1516.1]  This simplistic approach to ownership transfer means that the original object instance, its public and private state information are not transported during a federation execution. [White, 98] Further, ownership of object instances can only loosely be defined as the federate owning the privilege to delete object attribute (for a given object instance).  Consequently, HLA currently does not support the transfer of ownership (and implied rehosting) of object instances within the federation, as logistics federates would prefer.Some workarounds to this limitation have been explored, with varying degrees of success.  One of the more promising approaches involves using multiple object attributes (for any given object instance), essentially overloading the object within the federation.  In this workaround, different and otherwise mutually exclusive object attributes (for any given object instance) are used to represent similar features, but in support of different roles, and at different points in the scenario within the federation execution. For example, let us examine the simulated movement (i.e., transfer) of a tank from the point of origin to the point of use.  Once the determination for a new tank object has been made, and order is passed on to the logistics federate.  A tank of the appropriate class is instantiated on the logistics federate and loaded for transport within the scenario.  At the point delivery, the tank is transferred to the operations federate at the destination and moved into service.  Since the tank object instance cannot be transferred, the appropriate object attributes are transferred instead.  Similarly, the appropriate instance attributes for command or sensory federates can also be transferred. The effect of this approach is that the tank object instance(s) appear to be relocated from the logistics federate, used as a weapons platform by the operations federate, sensed by an opponents federate, and perhaps still commanded by a fourth federate.  However, in reality (and according to the current HLA draft specification) the Logistics federate cannot be expunged from the federation otherwise the tank object instances would also be expunged from the federation, leaving orphan attributes. [Li, 98]In this example, the attributes required by each of the operational federates (with each playing different roles) would most likely not be consistent.  The logistics federate might be interested in the objects Length, Height, Width, Weight, Geometric Footprint, and Hazard Restrictions attributes.  While the Speed, Range, and Firepower attributes may be more important to the commanding federate or operating this weapon platform.  The issue we are raising here is that (only the) federate which instantiated this object hosts (not owns) and sustains this object (and its private state variables). And while the privilege to delete attribute may be passed from one federate to another, the authoring federate cannot be removed from the federation without dire consequences to those objects which it instantiated. This approach has another disadvantage: overloading a given object with additional non-mutually exclusive attributes increases both federate(s) and RTI resources.  Where as if the object instance could be re-hosted in its entirety, excess resources would not be required. Thus because HLA supports the transfer of ownership of object attributes, attribute overloading is proving to be a poor remedy. [Li, 98]   While this may appear to be a subtle distinction, the prototypical needs of the logistics community and the capabilities provided by HLA are in direct conflict.  Clearly different attributes (associated with the same object) may be associated with the different roles that object instance is asked to play.  But when those attributes are created strictly as a workaround to the limitations of the supporting infrastructure, perhaps the functionality of that infrastructure should be examined again. As part of the on-going IEEE Draft 1516.1 discussions, one of us [Lake] has proposed that ownership exchanges be taggable with user-supplied tags.  This would have the benefit of allowing a tagged interaction to be sent between federates.  This additional information could then carry the otherwise hidden object state information to the new owner.Object Instance PersistenceThis brings us back to the idea of federate object persistence.  To continue our logistics federate example, the logistics federate (in our joint scenario) has the task of delivering a small platoon of tanks to the virtual battlefront. Thus the logistics federate instantiates the Tank Objects for the platoon, places them on flatcars in a simulated train, and ships them to the front lines.  Upon delivery, the logistics federate prefer to transfer ownership of the tank object instances to federates which might use them in an up-coming battle.  However, while the order might be to deliver these tanks, the HLA specification does not permit this action; the tank object instances cannot be transferred from the logistics federate.  Recall that HLA only transfers object attributes and not the entire object. In our example, the logistics federate must continue as it is responsible for all tank object instances that it instantiates -- even if all if its attributes (both public and private) have been relocated.  Thus the logistics federate cannot leave the exercise otherwise the tank object instances would become "unowned."  Consequently, for these objects to persist throughout the remainder of the federation execution, the logistics federate which instantiated them, must also persist, and cannot be deleted from the federation.  [Note:  There are currently no plans for a specification describing the HLA RTI as part of the IEEE 1516 set.  Consequently Applications Program Interface-based interaction descriptions such as this as described in the HLA RTI to Federate Interface Specification [IEEE 1516.1], would be at best, ambiguous, as only a specification regarding the precise implementation of an HLA RTI could resolve this particular interoperability issue.]With Two You Get Egg RollThe lack of an open source for HLA implementations has resulted in few attempting to write their own HLA RTI.  Consequently, existing HLA implementations (from DMSO) offer little choice in HLA Ownership Transfer services.  Only one implementation to date has attempted to show that true object instance ownership is possible under HLA. [Myjak, 99a]  However, this implementation extends the service described in the [1516.1] specification.Clearly, if only static object instance representations are necessary in a federation execution, then there is little need to dynamically move them.  But this is not the case.  Clearly, if object instances could be re-hosted dynamically within a federation execution, then the necessary basis for performance load balancing could be accomplished.  If the HLA's Ownership Transfer Service were to be expanded in this way, object persistence within a federation execution could also be supported.  The result of such an extension would be that we could both resolve the dilemma of the logistics federates and develop the means by which we can do effective load balancing, thus mitigating some of the risk associated with the adoption of HLA.Maintaining Dynamic Shared StateIn the previous section, we focused in on the issues regarding HLA Object Instances.  In this section, we shall focus on the overall state of an executing federation, and the implications that the former has on the latter.Multi-user virtual environments allow people to share a synthetic experience.  Virtual reality is by nature interactive and inhabitants should be able to interact with objects and peers.  A virtual environment may be considered as consisting of a number of objects, some of which may be affected, some may have behavior and some may represent other users.  Almost all objects may be interacted with in some sense.  For example, even a wall affects you when you walk into it.The ease and naturalness of interaction with a virtual object is dependent upon its responsiveness.  A user will become confused and agitated if they perceive an unnatural delay in the manipulation of an object.  (This is not necessarily so for purely constructive simulations.) In addition to processing delays, in instances where a remote federate or shared repository (barring some other advantage) owns an object, network latency can further reduce the responsiveness. To abrogate latency in a federation execution, object replication is often employed to reduce bandwidth consumption and increase responsiveness. Where more than one person tries to interact with a common object at the same time, the result they should ideally all see is the object affected in the same way. Inconsistencies occur when multiple federates are allowed to directly interact with local copies of a shared object. Consistency control reduces conflicts but at the expense of responsiveness.  We note that HLA has logical time interactions as well.  These can ensure that conflicts are sensibly resolved, but it appears that logically timed simulations are too expensive, that is, they induce excessive latencies for the Virtual Reality application.There is a view which says that since human beings have limited, though high bandwidth, there will one day come a time when it is possible to supply that bandwidth with low latency from a central repository, provided network bandwidths overtake processor effectiveness. In the sections below, we introduce three basic approaches to object management along with complementary ownership strategies.Shared RepositoriesThe simplest form of object management is the shared repository.  This is also the type of repository most of us are familiar with (i.e., client/server architectures). In this approach, all object behavior is managed centrally by a single shared repository (e.g., file system, database, web server, etc.).  Making the repository responsible for generating perceptual information (such as graphics and sound) can be bandwidth intensive (and is seldom done), especially over the Internet.  In the meantime, we use object replication where by each federate stores passive copies of the objects locally (i.e., cached copies) that shadow the master objects in the repository.  Federates use information pull to request the current state of the master objects from the repository before updating the local shadowed copies. Federates do not model object behavior directly but do interact indirectly by converting user input into requests to affect behavior.  These requests are then passed to the central repository, which applies rules of the model and simulation to calculate and implement the legal affect. For example a user might attempt to push a bat through a wall.  The repository will first check to see if the user has permission to interact with the bat and then calculate and apply the effect of a bat and wall collision.  If the user does not have permission to use the bat, the repository may yield a null result.Although the shared repository approach guarantees that conflicts in state information do not occur, it does have the following disadvantages:  User input will always be ahead of simulation time whereas perceived effect will always be lagging behind.  A federate does not know when a request for state information is useful.  A federate with a lower network delay to the repository will therefore have an unfair advantage in competition for control of a shared object.Further, presentation of the effect of a user's action is always delayed by at least twice the network latency (e.g., from source federate to the repository, and from the repository, back to the source federate).  Therefore state update requests are periodic; the maximum delay in perceiving effect from user input will be twice the maximum network latency plus the period of latency between requests.  Provided the delay between the repository and each user federate is the same, a user will experience the same delay in presentation of its own actions as in that of its peers.  This has some advantages for interaction but is also disconcerting: requesting state information wastes bandwidth and request messages and the resulting state information may be sent when the state information is unchanged.Frequent BroadcastFrequent broadcast allows direct interaction with owned objects, pushes updates when they are required and essentially "cuts out the middle man" by sending only changed updates directly between federates (and without the need for the corresponding "pull" request).  Each federate holds a replication of all objects of interest -- so far, so good.  However, before jumping off into ownership exchange, lets examine the problem associated with frequent broadcasts.  The problem is that when several interactors are contending for an object, there is a high probability that any given object is likely to be a remote object to some of them.  This is the same problem associated with the virtual repository: communication latencies for any given object can vary widely between federates (for some objects will be local, while others will be remote).  Now in a dynamically load-balanced environment, when the bulk of the interactions switch from one interactor to another (as in one federate to another), we also need to consider exchanging ownership of the object to improve performance (both locally and over the network).In this scenario, ownership determines the master copy.  In DIS, ownership was static, which implies that interaction with objects owned by a remote federate could only be done indirectly by sending a request to that owner. We have chosen to complement frequent broadcast with ownership exchange.  With this approach a federate must obtain ownership of an object instance, or in HLA an object attribute, before affecting it.  Once ownership of the attribute is exchanged, a federate can update the object attribute directly by allowing responsive user interaction.  The disadvantage with this approach is that requesting and exchanging ownership induces a delay that is at least twice the network latency, plus the latency involved in the ownership transfer process itself. The user will normally perceive this delay when he takes control of an object from a peer.  When a user affects an owned object, peers will see the effect delayed by single trip network latency, affected by the owning federate pushing the information to the receiving federates. This will however be increased to at least a factor of three when ownership must be transferred.State PredictionState prediction is an extension of frequent broadcast that attempts to overcome the effect of network latency by predicting future states.  However, while both Shared Repositories and Frequent Broadcast methods are consistent, State Prediction does not lend itself to be fully state-consistent without the addition of a state-consistency protocol.  A classic example of this approach is look-ahead and rollback. The basic point here is that state prediction cuts bandwidth for predictable evolution.  So the question is whether this feature could be extended to predict contention and a winner. That is, if two players are running for the ball, can we predict which will get it and either 1) predict the kick or 2) make an ownership exchange to make the predicted first kick local when it happens. The look-ahead and role-back approach implements a loose coupling between replications of the model, thus allowing federates to affect their replication according to local information, and rolling back the model if an update from a peer invalidates what has been changed. (In short, decoupling of local replicates with later restoration of consistency.) Role back can however be disconcerting to human-in-the-loop simulations. Instead we apply three complementary techniques: prediction based on parametric (dead-reckoned) behavior, pairing advance ownership exchange, and advance sending of events [Roberts, 1996] with deterministic locking [Roberts et. al. 1998]. Describing object behavior by using predictive contracts allows us to predict the time and nature of some future events. Using knowledge of network latencies we are able to send predicted events so that they arrive just before they are needed, thus eliminating the effect of network latency perceived by onlookers and minimizing the likelihood of false predictions. The need for role-back may be eliminated by making non-deterministic behavior, such as that controlled by a user, temporarily deterministic for the period of network latency. This reduces the confusion experienced by remote observers at the cost of limiting the frequency at which a user may affect an object.  But if the frequency (of round trip and processing delay) is well below the threshold of human perception, then this may be an acceptable penalty for acquiring deterministic behavior.  Similarly, the effect of ownership transfer may also be reduced or eliminated by predicting the need for ownership based on heuristics such as interest, intent, distance, velocity, capability and other parametric behavior. Consistency Throughput TradeoffIn shared virtual environments, there can be only one true owner of the data.  This can yield at least two different issues. First we see network delays, which theoretically have an ultimate latency near the speed of light, but are usually dominated by the various queues and buffers associated with the intervening routers and switches.  Secondly, there is the actual cost of maintaining consistency for a given frequency/discipline of update. In other words, there is a cost to maintaining state consistency in terms of the messages required to reach each machine, or perhaps such consistency may cost more in the form of (federate and/or RTI) computation.For example, maintaining a state-consistent federation could be achieved if all state information were maintained within a single central repository.  In HLA terms, a single federate would be responsible for posting all update attribute values service requests, and responding to reflect attribute values requests for data. Each federate (and thus interactor) would always see the same information, but perhaps at slightly different times (as in the Internet game Warbirds).The central repository operates much like the client-server metaphor.  The server, being the federate owning the central repository, is responsible for feeding state-consistent information to the client(s) federate(s). If such a federation supported human interactors, they would perceive the same information, although at slightly different times.  This is because internal RTI communication latencies would vary depending on the federate's logical proximity to the central repository.  Another subtle point is that while latencies may vary from federate to federate, to and from the central repository, communication latencies experienced by any given federate would tend to be consistent from one update to the next.  The same cannot be said for resource allocation.  While the central repository approach requires all updates to be made from a single, joined federate, the performance loading across such a federation would not be balanced across the federates.  Instead, computational and memory resources would be highly skewed toward the federate owning the repository. In short, a resource bottleneck is created at the cost of guaranteeing true state-consistency. Typically, such repositories scale rather poorly, usually on the order of O(N2).One way to annul the resource limitation of the central repository is to move to a shared or virtual repository (like ALSP or HLA). In this metaphor, the federation remains state consistent and the resource bottleneck (associated with the central repository) is now distributed across the federation. This in turn reduces the resource bottleneck of the central repository while increasing the communication latency by varying amounts.  Thus the cost associated with this approach is that distribution latencies vary for each attribute/federate pair, and as the performance and resource requirements of the attribute-owning federate grow. While subtle, this has another affect on the performance of the federation.  With the central repository, update latencies were varied across the federates, but were relatively consistent between sending and receiving federates.  When the data is distributed, some of it may also be locally owned.  In this instance, locally owned data will have zero (0) communication latency, as compared to a varied latency for every attribute not owned by the local federate.  This can be somewhat disconcerting to the overall outcome of the simulation scenario, as data that is locally owned will have different performance metrics when compared to data that requires update or reflect attribute values.  This can become problematic, particularly for federates that are both logically distant and operating at peak performance.  Human interactors may perceive attributes locally owned to operate within real-time parameters, while attributes not locally owned may appear sluggish, jerky and fixed (or worse). State consistency is maintained, but each interactor could conceivably perceive an entirely different simulation event.  Thus expected outcomes would vary from federation to federation and from exercise to exercise.  This is quite troublesome.An expansion of this method, which goes a long way toward relieving this problem is to frequently multicast the attribute information, such that the data can be stored locally.  By allowing each federate to use its locally cached copy (or shadow) of the data, pre-emptive communication techniques can be utilized, helping to negate some of the latency affects associated with attribute updates. Therefore, while improving upon the performance hit in communication latencies, and maintaining the distributed nature of the virtual repository, we're able to also improve end-to-end performance for human interactors.  However, we have given up on guaranteed state consistency throughout the federation by using locally cached data rather then acquiring the information from the authoritative source.  Furthermore, we are still left with the possibility of the slowest federate becoming the weakest link in the federation, for it only takes one federate to reach peak performance levels for the federation exercise to become invalidated.  This is perhaps the quintessential justification for supporting object instance-based load balancing in HLA. So in one paradigm, state consistency is maintained, but real-time performance suffered.  Conversely, when real-time performance measures were applied to correct the problem, state consistency can no longer be guaranteed. There appears to be a conflict between frequent update and state consistency in distributed systems.  This then is what is known as the Consistency-Throughput Tradeoff and all designers of shared virtual environments face it.This would imply a fundamental rule of HLA: that federations can generate either a dynamic world in which information changes frequently or they can generate a state-consistent world in which all hosts maintain identical information.  Thus it appears that the federation cannot support both dynamic behavior and absolute consistency at the same time as they appear to be inversely proportional to one another.Timing ExamplesWe will demonstrate the effect of the consistency-throughput tradeoffs through implementation of a simple two-player puck game.  This example has been chosen, as the effects of latencies are clearly visible. The game is constrained within a two dimensional playing field with walls along the side and a paddle at each end,  REF _Ref475867953 \h  \* MERGEFORMAT Figure 1. Players control movement of the paddle along one axis and attempt to hit the puck sending it towards the opponent.Logging the latency between user action and observed affect assesses the performance of each strategy. A comparison is made between direct and indirect interaction. The former being control of the paddle and the later.EMBED Word.Picture.8Figure  SEQ Figure \* ARABIC 1  The Classic Puck Game.Shared RepositoriesAll objects are held within the repository that manages the simulation.  Federates may request the current state of an object or request that state be changed.  In the ball game, paddles and the puck are owned by the shared repository that is responsible for affecting all changes to their state.  Each user can control their paddle with direction and stop buttons. A federate reads user input and sends the desired effect to the repository.  On receiving the request the repository will calculate the effect and update the paddle.  Federates must request the state of the paddle in order to observe the change.  The shared repository is responsible for determining object behavior including the effect of interactions between objects.  This will include collision detection and response to make the puck bounce of the paddles and walls.ResultsDue to the compressed schedule and extensive modifications necessary to implement the shared repository, results are not available as of the deadline for paper submission.  However, we expect to publish these results during the paper presentation at 7th Simulation Interoperability Workshop.Frequent UpdatesHere the model is replicated at each federate with object behavior communicated as parametric paths.  A new path is generated each time an object changes its velocity. The ownership of an object is transferred to the federate that is currently interacting with it.  In our ball game, paddle ownership will remain constant.  When a paddle comes in contact with the puck, the paddle's federate must obtain ownership of the puck in order to change its velocity. We compare the latency of perceived effect with that of obtaining ownership.ResultsResults have been obtained for the two-player puck game using Frequent Updates.  In this game as before, each player controls a paddle that may be used to hit a puck.  The puck may bounce off the paddles and off of two side walls (that limit the playing field).A federate was used to calculate collisions and new paths for all the objects that it owns.  In our ball game, each federate controls one paddle and calculates its movement path from user input and collision with the walls.  Ownership of the ball may be transferred between the two federates. The federate that owns the puck will calculate its path from collisions with its own paddle and the walls. A federate does not attempt to calculate collisions between the puck and the other federates paddle. Frequent Update DataBoth players (one person) are hosted on the same machine to reduce the effects of clock skew and clock synchronization on the results.  We introduce controllable network delay through a server on a separate machine, through which the federates (red and blue) communicate. In our first test the router is set to give an effective delay between federates of around forty milliseconds. When the user interacts with the red paddle, the red federate will update the red paddle and send a message to the blue federate which will update its copy of the red paddles movement.  Once a movement is received, object positions are synchronized until a new movement is generated.  Below,  REF _Ref475867806 \h  \* MERGEFORMAT Figure 2 shows us the delay in replicated objects reflecting the new moves of the original objects.EMBED Word.Picture.8Figure  SEQ Figure \* ARABIC 2  Movement Events using Frequent Updates.EMBED Word.Picture.8Figure  SEQ Figure \* ARABIC 3 Communicating movement with Frequent Updates.Communication of movement updates is the same for paddle and puck. A federate must however obtain ownership of the puck before generating a new puck movement.  In this example, a federate does not apply for ownership until it knows it needs it. That is to say that the federate request for ownership occurs when its paddle collides with the puck.As the puck is sent towards a paddle owned by the other paddle's federate, puck ownership exchange will always be necessary before a hit. Consequently, the hit event will be delayed locally by ownership transfer. The remote update will be further delayed by the passage of the update message.   REF _Ref475844703 \h  \* MERGEFORMAT Figure 3, shows the delays induced by ownership transfer, hitting of the puck, sending the update message and updating the remote copy.EMBED Word.Picture.8Figure  SEQ Figure \* ARABIC 4  Varying Network Delay with Frequent Updates.In the next test we show the effect of varying the network delay. The delay is increased by one millisecond each time a message is forwarded by the server.  REF _Ref475849164 \h  \* MERGEFORMAT Figure 4 shows that it becomes impossible to hit the ball when the ownership transfer delay exceeds 150 milliseconds. This limit is a function of the size and velocity of both the puck and paddle.State PredictionWith state prediction we attempt to overcome effects of network latency through calculating and sending events before they happen and by transferring ownership in advance of an interaction.  The need for role back is removed by locking the paddle into a new movement for the duration of the network delay.  Collision prediction is used to determine the time and place of the next interaction. Both ownership transfer and advance sending of the event are done just in time for the event to be received by the remote peer at the time of collision. This approach attempts to remove the effect of latency observed by both players when a ball is hit by a paddle.ResultsWe have really run out of time now, but still managed to evaluate one test example.  In this experiment, we used the state prediction method and coupled that with a 40 msec. network delay.  Ownership transfer occurred in advance of the paddle-on-puck hit event. The result, as expected, was that we achieved every hit attempted.  In fact the ownership exchange usually completed 4.6 seconds in advance of the ball, which takes just under 5 seconds to travel between paddles.State Prediction DataLocal processing and scheduling caused the only error in state synchronization noted. Recall that we have both players on one machine, with two Java virtual machines competing for the same resources, so this may be perceived by some as an atypical exercise.  EMBED Word.Picture.8Figure  SEQ Figure \* ARABIC 5 State Prediction Results.The errors are given below in  REF _Ref475850901 \h  \* MERGEFORMAT Figure 5.  Some of their value may be attributed to inaccuracy and of logging. If we keep reading the system time then the process grinds to a halt. We thus only read system time once per frame (which is running at about 40fps).ConclusionPut in HLA terms, a federate can only control the updates to the instance attributes that it owns.  For attributes that the local federate does not own, shared information (produced at another federate) must be reflected or mirrored to cooperating federates by transmitting that information through the RTI (e.g., over the network).  This mechanism creates the potential for increased latency at two locations, depending on the scenario and options selected by the federation manager.  First and quite likely the most common form of latency would be introduced through the RTI Object management service when a federate attempts to acquire the latest, best value (using Reflect Attribute Values) for an attribute. This latency may have varying affects on the federation as the logical transmission time is often a function of the physical distances between hosts.  The performance of the RTI may also have an impact, in that the RTI's performance may not be linear with respect to any given object attribute update and depends on the resources being consumed by each federate during the course of the federation execution. Further, the existing Ownership Management service, used to acquire ownership of a given attribute (using Attribute Ownership Acquisition) and thus making an object local, can also have a systemic impact on performance.The existing HLA Federate Interface Specification only identifies Object Attributes as the only mobile candidates within a federation execution.  By extending this operation to include the re-hosting of Object Instances, including their methods and essential state data, the interoperational basis for HLA can be extended.  Objects could persist within a federation execution long after the federates instantiating them have been removed from consideration.  Such a service would also provide the basis for load balancing the execution of a federation, thus reducing the costs of the simulation, and further reducing the risks of adopting HLA.  Unless the Internet changes significantly, long haul network latency will always have a tendency to interfere at the level of human perception.  Consequently, even without HLA we are usually faced with a trade off between responsiveness and consistency.  The shared repository is highly consistent but unresponsive.  Bibliography[1516]	SISO High Level Architecture Standards Development Group, ‚ÄúDraft Standard for Modeling and Simulation (M&S) High Level Architecture (HLA) - Framework and Rules,‚Äù Draft specification, currently being balloted by the Simulation Interoperability Standards Committee of the IEEE. April 1999.[1516.1]	SISO High Level Architecture Standards Development Group, ‚ÄúDraft Standard for Modeling and Simulation (M&S) High Level Architecture (HLA) - Federate Interface Specification,‚Äù Draft specification, currently being balloted by the Simulation Interoperability Standards Committee of the IEEE. April 1999.[1516.2]	SISO High Level Architecture Standards Development Group, ‚ÄúDraft Standard for Modeling and Simulation (M&S) High Level Architecture (HLA) - Object Model Template (OMT),‚Äù Draft specification, currently being balloted by the Simulation Interoperability Standards Committee of the IEEE. April 1999[Dahmann, 98]	Dahmann, Judith, and Robert Lutz, ‚ÄúPersistent Federations,‚Äù Proceedings of the 3rd Simulation Interoperability Standards Organization (SISO) Simulation Interoperability Workshop, 98s-SIW-059, Orlando Florida, March 1998[Dewdney, 98]	Dewdney, A. K., "The New Turing Omnibus,"  W. H. Freeman and Company, New York, ISBN 0-7167-8271-5, pp. 167-173.[Gansler, 98]	Gansler, J. S., "DoD Transition to the High Level Architecture (HLA) for Simulations," Memorandum from Under Secretary of Defense for Acquisition and Technology (USD(A&T), reaffirming Dr. Kaminski's policy letter of September 1996.[Lake, 98]	Lake, Tom W., ‚ÄúTime Management over Inter-Federation Bridges,‚Äù Proceedings of the 4th Simulation Interoperability Standards Organization (SISO) Simulation Interoperability Workshop, 98f-SIW-99, Orlando Florida, September 1998[Li, 98]	Zhian, Li, Ph.D., ‚ÄúThe Problem of Object Ownership Transfer in HLA-Compliant Logistics Simulations,‚Äù Proceedings of the 4th Simulation Interoperability Standards Organization (SISO) Simulation Interoperability Workshop, 98f-SIW-127, Orlando Florida, September 1998 [Myjak, 99]	Myjak, Michael D., Sharp, Sean T., with Tom Lake and Keith Briggs, ‚ÄúObject Transfer in HLA,‚Äù Proceedings of the 5th Simulation Interoperability Standards Organization (SISO) Simulation Interoperability Workshop, 99s-SIW-140, Orlando Florida, March, 1999[Myjak, 99a]	Myjak, Michael D., Sharp, Sean T., Shu, Wei Wennie, with Jeremy Riehl, Demarron Berkley, Phuoc Nguyen, Sean Camplin, and Mike Roche, ‚ÄúImplementing Object Transfer In the HLA,‚Äù Proceedings of the 5th Simulation Interoperability Standards Organization (SISO) Simulation Interoperability Workshop, 99s-SIW-157, Orlando Florida, March, 1999[Roberts, 96]	Roberts, D. J., "A Predictive, Real Time Architecture for Multi-user, Distributed Virtual Reality," Ph.D Thesis, Department of Cybernetics, University of Reading, 1996[Roberts, 98]	Roberts, David J., Lake, Tom W., with Andy Richardson, and Paul Sharkey, ‚ÄúOptimising Exchange of Attribute Ownership in the DMSO RTI,‚Äù Proceedings of the 3rd Simulation Interoperability Standards Organization (SISO) Simulation Interoperability Workshop, 98s-SIW-064, Orlando Florida, March 1998[Singhal, 99]	Singhal, Sandeep and Michael Zyda, Ph.D., "Networked Virtual Environments - Design and Implementation," ACM Press SIGGRAPH Series, Addison-Wesley, Reading MA., ISBN 0-201-32557-8, 1999.[White, 98]	White, Eric and Michael Myjak, "A Conceptual Model for Simulation Load Balancing," Proceedings of the 3rd Simulation Interoperability Standards Organization (SISO) Simulation Interoperability Workshop, 98S-SIW-100, Orlando Florida, March, 19988		About the AuthorsMichael D. Myjak is Vice President of Research and Development, co-founder and Chief Technical Officer of The Virtual Workshop, Inc., where his current role is as chief architect of Javelin and the Java RTI.  In 1982, Mr. Myjak received two Bachelor of Science Degrees from Clemson University, one in Computer Science and the other in Engineering Technology.  He obtained his Master of Science Degree in Computer Science - Systems from the University of North Texas in 1988 while employed with the Computer Science Laboratory, Corporate Research and Development labs at Texas Instruments.  Prior to founding The Virtual Workshop, Mr. Myjak was a Senior Research Scientist with the Institute for Simulation and Training, at the University of Central Florida.  Mr. Myjak has been an active participant in Modeling and Simulation standards activities for a number of years, and has completed a term of office as Chair of the Run Time Infrastructure and Communications Forum under the Simulation Interoperability Standards Organization (SISO).  He recently Chaired the Run Time Infrastructure Interoperability Study Group, and is the current Chair of SISO‚Äôs Standards Activity Committee (SAC).  Mr. Myjak also Chairs the Internet Engineering Task Force‚Äôs (IETF) Large Scale Multicast Application (LSMA) working group, and is active in the Web 3D consortium's Virtual Reality Transfer Protocol Working Group, and the Internet Research Task Force‚Äôs Reliable Multicast Research Group.Tom Lake is technical leader of InterGlossa, who exhibited a fully time-stamped RTI in spring of 1996. Tom is currently working on fully distributed support for causal and time-stamped message ordering for UK DERA. He is also interested in the ANDF portability technology and its use for architecture neutral program analysis and transformation.  His degrees are in Physics: BA from University of Oxford and PhD from University of Pennsylvania. He was founder chair of the British Computer Society‚Äôs Parallel Processing Specialist Group.David J. Roberts is a Lecturer in Computer Science at the University of Reading. Dave's research interests are communication architectures for Internet based multi-user virtual reality and agent systems as well as populated virtual workplaces. He specializes in overcoming problems of remoteness with an emphasis on interest, latency, scalability, consistency, causality and ownership. Current collaborative projects include networked games, mixed reality information spaces and synthetic populated control rooms. Prior to his lectureship Dave was a Principle Research Fellow and National Grid Scholar. He obtained a BSc in Computer Science at the University of Reading in 1992 and a PhD in Cybernetics in 1996 also at Reading. His PhD was in the field of overcoming the effect of network latencies in large synthetic environments through predictive time management.BEN WORTHINGTON is a cybernetics researcher at the University of Reading specializing in communication infrastructures for agent and VR systems. Ben obtained a BSc in Physics from the University of Birmingham in 1997 and a MSc in Information Systems Engineering from the University of Reading the following year. Ben's MSc focused on the encapsulation of network latency compensators in VRML. Since his MSc he has continued to work in the field of distributed systems with an emphasis on scalability and latency issues. This limitation is only in the specification as Myjak, et.al., demonstrated a prototype HLA Object Ownership Transfer service during the 5th Simulation Interoperability Workshop. [Myjak, 99a] The "owner" of an HLA object Instance is the federate owning the "privilege to delete" attribute (a required attribute for every object class).   Note: the host owning the deleted attribute may or may not be the same host sustaining the parent object instance.  This is equivalent to a "server push" rather than a "client--pull" operation. Note: as both federates and server are implemented in JAVA, results may be effected by garbage collection. Timed by watch.