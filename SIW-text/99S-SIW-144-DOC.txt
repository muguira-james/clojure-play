The FederateConnect ToolsuiteMary L. FrickeGlen L. HarrisSpectra Research, Inc.3085 Woodman Drive, Suite 200Dayton, OH 45420mlf@spectra-research.com, gharris@spectra-research.comKyle CrawfordMargaret HorstDavid RobertsGeorgia Tech Research InstituteInformation Technology and Telecommunications LaboratoryComputer Science and Information Technology Division347 Ferst DriveAtlanta, GA 30332-0832kyle.crawford@gtri.gatech.edu, margaret.horst@gtri.gatech.edu, dw.roberts@gtri.gatech.eduKeywords:  Federate, reengineering, framework, object model, FEDEP, middleware, Use CaseAbstract: This paper describes a High Level Architecture (HLA) tool suite and Use Cases for migrating legacy simulations to DoD HLA compliant federates.  The tool suite, called FederateConnect, is under development by Spectra Research, Inc. (S*R) and the Georgia Tech Research Institute (GTRI) for the U.S. Army Simulation Training and Instrumentation Command (STRICOM).  The development program is leveraging S*R developed reengineering software and a GTRI internal research and development project that developed middleware to support the migration of legacy simulations to HLA federations.  FederateConnect supports four HLA federate/federation cases: 1) connecting an existing legacy model to an existing HLA federation, 2) connecting a HLA compliant model to a different federation, 3) evolving HLA federates within an existing federation, and 4) connecting a suite of simulations which can be either legacy simulations or HLA compliant federates  to form a new federation. 1.	IntroductionThis paper describes how to apply a suite of tools to support the design and development step of the High Level Architecture (HLA) Federation Development and Execution Process (FEDEP).  The suite of tools, called FederateConnect, is under development by Spectra Research, Inc. (S*R) and the Georgia Tech Research Institute (GTRI) under sponsorship of the U.S. Army Simulation Training and Instrumentation Command (STRICOM).  The FederateConnect program is focused on providing tools that will enable Distributed Simulation Engineers (DSEs) to develop HLA federates or to evolve existing federates to increase their role in a federation or participate in other federations.1.1	FederateConnect Application CasesFederateConnect is being developed to support four cases for establishing or maintaining existing HLA Federations from the federate perspective as shown in Table 1.  This paper addresses how the FederateConnect tools support Case One.  We then establish how the tools can be used to provide federate program evolution to support Cases Two through Four.  Figure 1 illustrates the goal for Case One and identifies three Use Cases for applying FederateConnect to achieve the goal.  The three Use Cases are described in more detail in Section 4 of this paper.  The SIW presentation includes a sample scenario for the Use Cases including screen captures of the tools.CASEFederate(s)FEDERATION                  Case OneConnect an Existing Legacy SimulationTo an Existing Federation                  Case Two  Connect a HLA Compliant SimulationTo a Different Federation                  Case ThreeModify HLA Federate SimulationIn an Existing Federation                  Case FourConnect a Suite of SimulationsTo Form a New FederationTable  SEQ Table \* ARABIC 1 – FederateConnect Application CasesFigure  SEQ Figure \* ARABIC 1– Case One Goal and Use Case1.2	FederateConnect Data RepresentationsAs illustrated in Figure 2, FederateConnect consists of an object-oriented (OO) repository that stores reverse engineering; meta or OO framework; and federate source code representations.  FederateConnect is implemented in a repository-based architecture where all tools work from the representations stored in the OO Repository. Figure  SEQ Figure \* ARABIC 2 - FederateConnect Data Representations1.3	Paper OrganizationThis paper is organized into three main sections.  Based on abstract data representations, Section 2 addresses the theoretical and technical foundation for the tool implementation. Section 3 describes the FederateConnect system concept and each of the tools that are currently under development.   Section 4 describes the three Use Cases illustrating how the tools are used to modify a legacy model to create a HLA compliant federate as detailed in Case One.Theoretical and Technical Foundation The FederateConnect tool suite is based on a synthesis of theoretical and technical approaches used in domain analysis, reverse engineering, meta-repository design, and code generation.  This section provides an overview of the theoretical and technical foundation that is being used to implement the tools. 2.1  Domain AnalysisA domain is a problem area characterized by:  (1) the existence of comprehensive relationships among objects in a domain; (2) a community interested in solutions to the problem in the domain; (3) a recognition that software solutions are appropriate to the problems in the domain; and (4) a store of knowledge or collected wisdom to address problems in the domain. [1] A domain has a vocabulary, common assumptions, and a literature.  Using this definition, the HLA can be viewed as a domain for distributed simulation implementation.Domain analysis attempts to identify the objects, operators, and relationships that domain experts perceive to be important about the domain.  In order for a domain analysis to be useful for software development, reuse, or reverse engineering, the results of the analysis must be captured and expressed in a systematic fashion. 2.1.2  HLA DomainIn the HLA community, domain experts define federation object models as part of the FEDEP.  A portion of the HLA domain model can represented by a Federate Object Model (FOM), Simulation Object Model (SOM), or Base Object Model (BOM) [2]. The standard for exchanging an HLA-based Object Model (OM) is the Object Model Template Data Interchange Format (OMT DIF) file. FederateConnect introduces the concept of a Program Object Model (POM).  A POM is a set of primitive or compositional objects abstracted, via an object extractor, from a reverse engineering analysis of a simulation program. 2.2	Reverse Engineering ConstructsBoth legacy simulations and existing HLA simulations are computer programs. In order to understand the relationship between a federate’s SOM and a federation’s FOM program comprehension (understanding) is required.  Reverse engineering is a software engineering discipline that takes a program and constructs a high level representation that is subsequently useful for documentation, maintenance, or reuse.  Most current reverse engineering techniques analyze a program’s structure.  This structure is determined by lexical, syntactic, and semantic rules for correct and legal program constructs.  Representations of this structure include, for example, symbol tables, control flow graphs, invocation call graphs, data flow graphs, and system dependency graphs [3].   Experience has shown that knowledge of program structures is insufficient to achieve program comprehension [1].  A computer program interleaves many models representing different domains into a program. These domains may include multiple engineering domains, software data structure domains, and software computational domains.  FederateConnect uses reverse engineering techniques to build POMs of the simulation’s domain.  Different POMs can be generated using different analysis techniques.  For example, a type-based analysis may be performed on the program symbol table representation.  A hierarchical type-based POM that represents language-supported types can be generated using program scope information.  Alternatively, a more sophisticated analysis, based on a system dependency graph representation, can generate POMs for the simulation.  These POMs provide the foundation for the subsequent development of the federate’s SOM.  This more detailed analysis takes into account both control and data flow information pertaining to data in the program.In order to provide sufficient program comprehension to support HLA mapping requirements, a reengineering system needs to support an interactive annotation capability that relates the domain understanding to the program syntax.  FederateConnect incorportes an annotation capability that allow the user to annotate the POM with information discovered about the program that is relevant to mapping to an HLA object model.2.3	Meta-Repository DesignOntological or object oriented (OO) meta models are being used to specify the complex relationships between data.  Fortunately, the Object Management Group (OMG) currently supports an industry standard for specifying meta-representations for Object Models [4,5].  The FederateConnect Meta-Repository supports the persistent Meta Representation of object models or OO Framework specifications using the Object Datbase Management Group (ODMG) Object Database Standard 2.0.  Different object models, e.g. FOM, SOM, BOM, POM, or other OO Framework specifications, are parsed into a common OO meta model representation.  FederateConnect uses this meta model representation to provide advanced mapping, annotation, and transformation of object models.  2.4	Code Generation ConstructsA common way for implementers to address the issues of federate development is through the use of OO frameworks.  The use of an OO Framework simplifies the implementation of HLA federates and isolates the user from low-level RTI programming. As each HLA OO Framework has an associated set of assumptions and objectives, FederateConnect provides a methodology for storing meta models of OO Frameworks. FederateConnect generates HLA implementation code based on an OO Framework specification, a marked Abstract Syntax Tree (AST) and an annotated federate object model. 2.5	Application to FederateConnect System DesignFederateConnect applies a synthesis of application domain modeling knowledge, reverse engineering, and a domain model meta-representation system to provide a foundation for understanding the relationship between a HLA object model and a federate’s source code.  Equipped with reverse engineering representations and domain analysis tools, a FederateConnect user can interactively establish the required relationships between a given domain model and a simulation implementation.  Formal representations of these relationships also enable federates to be semi-automatically generated, reused, and evolved.  3.	FederateConnect System ConceptFederateConnect consists of nine toolsets that interact through a Meta Representation Repository (MetaRep).  The MetaRep is an object-oriented (OO) repository as illustrated in Figure 3.  This section serves to describe the MetRep and its usage with the FederateConnect tools. Figure  SEQ Figure \* ARABIC 3 – FederateConnect System Concept3.1	MetaRepMetaRep stores abstract representations of HLA Object Models (OMs), the HLA Interface Specification, and simulations that are being federated (the simulation).  All of the other FederateConnect tools connect to each other through MetaRep as shown in Figure 3. They perform transformations on the data representations described in Section 2.  The tools are grouped into three sets: reverse engineering tools on the left, domain analysis and mapping tools in the center, and code generation tools on the right.   3.2	Reverse Engineering ToolsThe Reverse Engineering tools are used to populate the MetaRep with a reverse engineering representation of the simulation’s source code and HLA object models. FederateConnect includes the following nine toolsets.SimAnalyzer imports the simulation into the MetaRep.  It parses the source code and stores it as an abstract syntax tree (AST) in an object oriented database.   Currently, it handles FORTRAN 77 and ANSI C programming languages.  The AST is analyzed to identify the input and output data item symbols and other parameters.  Several reengineering representations of the source code such as its control flow, subroutine call structure, and symbol table are constructed.  The SimAnalyzer also creates abstract object representations of the program and allocates the symbols to objects to build a POM.    The POM is subsequently related to elements of the FOM for a HLA federation. SimDowser provides user views into the reengineering representation.  It consists of a set of tools that are used to examine and annotate relevant program symbols that will be used in the POM and SOM.  These tools include: (i) an Input/Output Statement Browser; (ii) a Symbol Table Browser; (iii) a Call Browser; and (iv) a Control Flow Browser.  These tools are accessable from the OMResolver and allow the user to annotate program elements with observations. Grammar Monkey is used to import and store representations of HLA files in the MetaRep.  It parses the OMT-DIF file for a FOM or SOM and stores the data in MetaRep’s internal object representation.      3.3	Domain Analysis and Mapping ToolsThe Domain Analysis and Mapping tools are used to analyze and map the relationship between the legacy simulation’s program symbols and HLA object models.  These tools can invoke the various SimDowser tools to aid in the analysis and mapping process.  They are used to create a SOM for the simulation that maps to the FOM for the federation.   OMResolver is used to resolve differences in object models.  It is used to compare the POM (i.e., object model representation of the federate) with a HLA object model (SOM, FOM).  As all object models are stored in MetaRep as OO Frameworks, the objects and their members can be visually compared.  Hence, program symbols can be compared to HLA attributes and parameters.  It provides the user with a visual view and capability to navigate through the elements in an object model and compare them to one or more other elements in other object models such as a FOM to one or more POMs.  It is used initially to examine a FOM and determine, which objects and interactions are of interest for the creation of a SOM Candidate Object Model (COM).FederateMapper is used in conjunction with OMResolver and the SimDowser tools to conduct object to object or object to code mapping.  It provides a graphical view of two objects and their associated elements. Views of the POM symbols provided by the SimDowser tools can be used to aid in the mapping.  As the mappings are accomplished, the associations are established by dragging the mapped POM symbol onto the corresponding HLA object model (OM) element or complex data type. The symbols can also be annotated with meta data concerning the mapping such as noting perfect matches; mismatches in data type or units; or whether no corresponding element exists.  Any object or element of an object model including HLA OM elements can be annotated.  The annotations can also provide notes that a transformation needs to be included in the interface to resolve differences in data types, units, resolution, or other implementation factors.  The annotations are stored as associations with the symbols, which in turn are associated with specific program syntax statements or HLA OM elements. In addition, the FederateMapper supports the user with dialog boxes to insert meta data such as cardinality of attributes in the development of the SOM.FederateAssistant keeps track of the mapping progress for the user.  It will provide capabilities to query the status of the mapping such as what HLA objects or interactions and their associated elements have been mapped or have no corresponding symbol in the simulation’s program.  Once the mapping process is completed, the user can create a SOM for the simulation that maps to the FOM.  The capabilities of the FederateAssistant will be expanded as the needs for user assistance are identified during beta testing and application. 3.4	Federate Generation ToolsThe Federate Generation tools help the user build the interface code between the simulation and the RTI.   They automate the generation of most of the interface code between the simulation and the HLA RTI.  The Federate Connect tools will interface with the OMDT to validate the SOM and generate the Fed File.  RTIMarker is used to mark the simulation’s source code associated with the mapped symbols with the desired RTI service (e.g., publish or subscribe operations).  These marks are accomplished by scrolling through the mapping and annotations and completing the mark-up by dragging and dropping a symbol that represents the service.  The markup can be accomplished at the object level or the individual element level.Distributed Simulation Interface Framework (DSIF) [6] developed by GTRI generates a set of middleware classes specific to the SOM that support the communication of simulation data using the RTI.  The FederateConnect Build One beta version supports a substantial subset of the most frequently used RTI services.  Other services will be added as federates require those capabilities.  The annotations are also used by DSIF to identify where additional behavior code needs to be inserted in the generated C++ middleware classes to effect required transformations such as units and data types.FederateEvolver inserts the appropriate statements in the internal representation of the source code and generates a modified version of the program that contains calls to middleware classes generated by DSIF.  Unless other changes are needed to resolve differences in data (e.g., units, types, aggregation), this step is fully automated once the RTI mark-up has been completed.  The output code generated by the DSIF and FederateEvolver complete the conversion of the simulation into a HLA Federate that is compatible with the target federate.  At this point the federate is ready for testing. 4.	Use Case ExamplesIn this section, we present the three example Use Cases to illustrate how the FederateConnect tools can be applied to develop a HLA federate from a legacy simualtion.  The Use Cases are an adaptation of a goal oriented structuring methodology defined by Alistair Cockburn [7] and applied to HLA by Paul Gustavon and Larry Root of Synetics, Inc.   A more complete explanation of the methodology can be found in their Spring ‘99 SIW paper [8].  The following three sections describe the three Summary Use Cases identified earlier in Figure 1.4.1	Use Case 1: Conduct Interface AnalyisThe first challenge in converting a legacy simulation to a HLA federate is to gain an understanding of the interface requirements.  This could involve determining what objects and interactions in the FOM can be supported or if specific requirements can be met.  FederateConnect provides tools that can be used to quickly conduct an interface analysis as illustrated by Figure 4.  This is a Summary Use Case that incorporates four subordinate Object Use Cases. TitleUse Case 1: Conduct Interface AnalysisGoalDetermine simulation-to-federation interface requirementsLevelSummaryPreconditionHave access to relevant files from workstationSuccess ConditionDetermine what FOM objects and interactions can be supportedFailure ConditionAutomated analysis tools fail on syntaxActorsDistributed Simulation Engineer (DSE)FederateConnect toolsTriggerRequirement to understand interface detailsDescriptionStep       Subordinate Use CasePopulate the Program RepresentationImport the FOMCreate Candidate Object Model (COM)Evaluate Timing InterfaceExtensionsStep         Branching ActionVariationsStep         Branching ActionFigure  SEQ Figure \* ARABIC 4 – Interface Analysis Use CaseThe primary goal of this analysis is to use the FederateConnect tools to compare the FOM for the federation to the capabilities of the simulation and quickly create a COM that will be evolved into the SOM. The first and third subordinate use cases are discussed below.Figure 5 is the Use Case for populating the repository with the reengineering representation of the simulation.As can be seen from inspection of the Populate Program Representation, this is primarily an automated analysis that creates the reengineering representations used by other tools.  The POM is created by the automated analysis tools and stored as an abstract OO framework representation of the simulation’s symbols.  Different methods will be used to create POMs.  One method groups related inputs and outputs into a set of objects. Another method groups data types by program scope into a set of objects.  Once the POM has been created, the user can create a COM by comparing the POM objects and elements to the FOM objects and interactions stored in MetaRep.TitlePopulate Program RepresentationGoalBuild reengineering representation of simulation source codeLevelObjectPreconditionHave access to relevant files from workstation Success ConditionSuccessfully parse files and create meta-representations in repositoryFailure ConditionAutomated analysis tools fail on syntax of simulation source code or automated analysis failsActorsDistributed Simulation Engineer (DSE)FederateConnect toolsTriggerRequirement to understand simulation source code for a higher level Use CaseDescriptionStep        ActionDSE InvokesSimAnalyzerSelects files to be parsedSelects Automated AnalysesLaunches ParserSimAnalyzer -  Parses source code and builds AST in MetaRep-  Builds selected reengineering data in MetaRep-  Applies Object Extractor Algorithm3.    Object Extractor creates POM         representation4.    SimAnalyzer stores POM as an        OO Framework in MetaRepExtensionsStep         Branching ActionVariationsStep         Branching ActionFigure  SEQ Figure \* ARABIC 5 – Populate Program Representation Use CaseFigure 6 is the top-down domain analysis Use Case for creating a COM based on a visual comparison of the FOM objects and interactions to the COM objects and associated program symbols.   In this Use Case, the DSE invokes OMResolver and selects the FOM and POMs to be compared.  Note this process could be applied in the same manner to any HLA Object model such as a similar SOM or the BOMs described by Synetics [2].TitleCreate COM from FOM and POMGoalMap FOM to POMLevelObjectPreconditionHave established representation of program and FOM in MetaRep Success ConditionFOM objects and interactions mapped to POM ObjectsFailure ConditionUnable to find critical FOM attributes or parameters in POMActorsDistributed Simulation Engineer (DSE)FederateConnect toolsTriggerRepresentation of Simulation (POM) and FOM stored in MetaRep DescriptionStep       Action DSE Invokes OMResolverSelects FOM Rep in MetaRepSelects POMs  in MetaRepVisually compares and matches FOM/POM objects  Checks FOM object matchesFederateAssistant records ChecksDSE names subset as COM and invokes Generate COMOMResolver generates COM as a named framework in MetaRep ExtensionsStep         Branching ActionVariationsStep         Branching Action1a.    DSE Invokes OMResolver    -  Names COM Framework    -  Drags & Drops matches to   COM Framework    Figure  SEQ Figure \* ARABIC 6 – Create COM Use CaseThe DSE then uses OMResolver to compare the FOM objects and interactions to the POM and marks the matches, which are recorded by FederateAssistant.  Some automated methods are planned to construct default comparisons between the FOM elements and the POM elements.  The FederateMapper and SimDowser tools can also be invoked from OMResolver as required to conduct a more detailed comparison and to see exactly how any POM program symbol is used in the simulation’s source code.  The DSE checks all FOM objects and interactions in which the simulation can potentially interact and are needed to satisfy the federation requirement. Then, the DSE assigns a name for a COM framework and launches a task to create the COM, which consists of all checked FOM objects.  Meta data is also stored in the MetaRep for the POM objects that match the COM objects.TitleUse Case 2: Create SOMGoalMap COM elements  to POMLevelObjectPreconditionHave established representation of program and COM in MetaRep Success ConditionAll COM objects and interactions are mapped to POM symbolsFailure ConditionUnable to map critical attributes or parametersActorsDistributed Simulation Engineer (DSE)FederateConnect toolsTriggerHave created a COM either from HLA FOM, BOMs, or POM DescriptionStep       ActionDSE Invokes OMResolver- Selects COM & POMsOMResolver generates Tree view of both frameworksDSE Selects COM Object and automatic pattern matchingFederateAssistant generates list of matching POM objectsDSE Invokes Federate MapperMaps attributes or parameters from COM to POM symbols  Annotates DifferencesFederateAssistant records         associations in MetaRepDSE Repeats steps 3 to 6 until        all COM objects are  mapped,       names SOM and selects GenerateMetaRep generates SOM in        OMT-DIFExtensionsStep         Branching Action5a.    DSE is unable to locate corresponding symbol in POM5b.  Source Code Analysis Use CaseVariationsStep         Branching Action3a.    DSE Manually scrolls through POM to select  matching objectsFigure  SEQ Figure \* ARABIC 7 - Create SOM Use CaseA variation of this process is to name the COM framework in Step 1 and use drag-and-drop to drag the FOM objects and interactions to the framework, which is presented in a tree structure.  Similarly, a separate Use Case would involve building the COM bottom-up from the POM, which would require entry of the COM framework object, interaction, and complex data types followed by drag-and-drop of the POM objects and program symbols into the objects. 4.2 Use Case 2: Create the SOMFigure 7 shows the Use Case for creating the SOM from the COM.  This Use Case involves detailed mapping of a POM program symbol to each COM object attribute and interaction parameter including complex data type association using FederateMapper.  It also involves annotation of any COM element where no match can be identified.  Also, all program symbols that do not exactly match the COM (e.g., data type and unit mismatches) are annotated.  All annotations can be analyzed using SimDowser tools to examine the context of their use in the simulation’s source code.   The DSE uses the OMResolver to navigate to a COM object to be mapped and invokes the automatic pattern matching algorithm. This algorithm will use annotations from the Create COM Use Case, to bring up matching objects in the POM.  The FederateMapper is used to compare the elements of the objects being mapped.  When a match is identified, the POM program symbol is dragged to the COM view, which effects the mapping in MetaRep.  Note that this process requires that the simulation and the federation are at a corresponding level of detail and fidelity.  The association and any annotations entered by the DSE to note differences are automatically recorded in the MetaRep by FederateAssistant.   If an object cannot be mapped, it can be eliminated from the COM or notes can be entered to define the problem so that the simulation source code or perhaps the FOM can be changed to ensure a match.  In this case, the SimDowser tools can be used to conduct a detailed search through the source code to attempt to identify a match.  For example, the SimDowser tools will likely be used to identify interaction parameters and timing insertion points.Once all objects have been mapped, the DSE can name and generate the SOM, which is stored as an OO framework in the MetaRep.  An OMT-DIF form can be generated from MetaRep and imported into other HLA tools to generate the FED file.  4.3 Use Case 3: Generate the FederateFigure 8 is the Generate Federate Use Case to generate a modified version of the simulation’s source code and middleware necessary to generate a HLA compliant federate from the simulation.  This Use Case is initiated by invoking the RTI Marker to insert calls in the AST for the source code location where program symbols will be published to the federation and where the program symbols’ value will be updated via subscription from the federation.  TitleUse Case 3: Generate FederateGoalGenerate modified simulation source code and middleware for  federateLevelObjectPreconditionHave established mapping between Simulation and FOM in MetaRep Success ConditionModified source code and middleware generated and compiledFailure ConditionUnable to resolve insertion of source code changes, generate middleware from SOM or compile codeActorsDistributed Simulation Engineer (DSE)FederateConnect toolsTriggerHave created a SOMDescriptionStep       ActionDSE Invokes RTIMarkerSelects SOMRTIMarker generates a default view where RTI service calls can be inserted into source codeDSE uses RTIMarker to change any default service callsDSE  repeats steps 1 through 3 until all objects and interactions in the SOM  are handledInvokes Federate Evolver.FederateEvolverInserts function call statements in AST for RTI Generates modified source code for simulation Invokes DSIF for SOMDSIFImports SOMGenerates middleware classes for RTI callsDSE compiles federate  ExtensionsStep         Branching ActionVariationsStep         Branching Action6.a  DSE adds behavior code to DSIF created classes to convert data types, etc. as noted in the markupFigure  SEQ Figure \* ARABIC 8 - Generate Federate Use CaseAt this point in the design, it is envisioned that the annotations will be used to generate a default set of service calls, which are made to the middleware classes generated by DSIF.  The RTIMarker will then allow the user to step through each object or interaction in the SOM to either accept the default or modify it and to make other adjustments. The goal is to provide an HTML view of all the segments in the source code where the symbols that map to the HLA object or interaction are located. Once the service calls have been inserted in the AST representation of the source, the DSE invokes the FederateEvolver to generate a modified version of the source code. FederateEvolver inserts the calls at the proper place in the AST and generates a modified version of the source code that incorporates the calls to the middleware. It also invokes DSIF for the selected SOM, which automatically runs DSIF to create the middleware classes that will be called from the simulation.At this point the DSE reviews comments on differences that were annotated in the mapping process and adds behavior code to the DSIF classes as necessary.4.4 Extension to Other CasesThe FederateConnect tool suite also supports Cases Two, Three, and Four that were identified in Table 1.   For Case Two, FederateConnect tools are used to bring an existing HLA compliant model into a different federation. In this case the process uses the existing SOM for the Second Use Case rather than constructing a COM based on the FOM.  The FederateConnect OMResolver is used to compare the existing SOM to the new federations FOM to determine what additional classes or interactions are required.  The Federate Mapper is used to determine if they can be mapped to the existing simulation’s source code. The FederateConnect tool suite can also be used for Case Three to incorporate additional object or interaction classes to an existing federation.  In this case, the tools may also be used to analyze other federates in the federation to determine if they can support the additional object or interaction.  The FederateConnect tool suite can also be used to support creation of a new federation from either legacy simulations or existing federates.  In this case the tools would be used to help determine the FOM for the new federation as well as to construct a SOM and generate the federate.  5.0  FederateConnect Status FederateConnect is being developed under a Phase II Small Business Innovation Research program.  The goal is to complete a Build One version by 1 July 1999 and make it available for beta testing.  The beta test program is using the Air Force Armament Center Surface-to-Air Mission (SAM) federation as described in a Fall 1998 SIW paper [9] to test the FederateConnect tools.  The test program will apply the FederateConnect tools, per the Use Cases, to connect additional federates to the SAM federation.  Build Two will be completed by 1 May 2000.  The initial versions will be limited to supporting federation development in FORTRAN 77 and ANSI C; however, the development team hopes to find a sponsor to add C++ either during Build Two or as part of a Phase III project.  Other limitations of the initial operational capability will be determined through the beta test program.  Anyone interested in participating in a beta test of either Build One or Build Two should contact Glen L. Harris at Spectra Research, Inc.    SummaryFederateConnect is a repository-based tool suite that provides unique capabilities for migrating legacy simulations to HLA.  All of the tools work from abstract data representations maintained in the FederateConnect MetaRepresentation repository.  Reengineering representations are used to support analysis of the source code and mapping between HLA object models and the simulation.  POMs are constructed to provide an object representation of the simulation’s implementation to support the mapping process.  The DSIF generates middleware from the SOM to minimize the changes that will have to be made to the simulation source code to generate the federate.    7.0  References[1] Rugaber, Spencer. “Domain Analysis and Reverse Engineering”, College of Computing, Georgia Institute of Technology, Atlanta, Georgia. [2] Gustavson, Paul; Hancock, John P; and McAuliffe, Mark. “Base Object Models (BOMs), Reusable Components for Federation Development”, 1998 Fall SIW.[3] Rugaber, Spencer and Clayton, Richard. “The Representation Problem in Reverse Engineering”, College of Computing, Georgia Institute of Technology, Atlanta, Georgia. [4] Catell, R.G.G., et all. “The Object Database Standard: ODMG 2.0”, Morgan Kaufmann Publishers, Inc., 1997. [5] “Joint Meta Object Facility”, Revision 1.0, Object Management Group Common Facilities Task Force, 14 January 1999.[6] Roberts, D. W., Collins, T. R., Esslinger, D. I., Horst, M. M., Johnson, T. B., Marks, J. R., McLean, A. L. M. T., & Wallace, J. C. (1997). High Level Architecture Simulation Interface Phase One (Final Technical Report GTRI-TR-97-E8604-102F). Atlanta, GA: Georgia Institute of Technology.[7] Cockburn, A., “Basic Use Case Template”,  TR.96.03a, Human and Technology, October 26, 1998, http://members.aol.com/aacockburn/. [8] Gustavson, Paul; Root, Larry; and McAuliffe, Mark,“Object Model Use Cases: A Mechanism for Capturing Requirements and Supporting BOM Reuse”, 1999 Spring SIW.[9] Lucas, Jason L. & Kent, Robert A, “Development of a Surface-to-Air Missile T&E Federation”, 1998 Fall SIW.Author BiographiesKyle A. Crawford is a Research Scientist II at the Georgia Tech Research Institute.  He has over 15 years experience in software development and physical systems simulation.  He holds a BS Industrial Engineering, an MS Industrial Engineering, and an MS Mechanical Engineering.  Currently Kyle is completing a Ph.D. at Georgia Tech’s Industrial and Systems Engineering Center for Human-Machine Systems Research.Mary L. Fricke is the Principal Investigator and FederateConnect system architect.  She has over 15 years experience in the design and implementation of highly technical software systems.  She led the development of an Input/Output Reengineering and Program Crafting tool set that provides the basis for the FederateConnect source code analysis and meta representation capabilities.  She holds a B.S in Computer Science and B.S. in Chemistry from Wright State University and an M.A in Anthropology from SUNY at Binghamton.Glen L. Harris is the Director for Software Systems at Spectra Research, Inc.  He has over 25 years experience in modeling and simulation in the Air Force and the private sector.  In his Air Force career, he led the development of the Suppressor simulation and the establishment of the Joint Modeling and Simulation System (JMASS) program. He served as the chairman of the Methodology Integration Panel for the Methodology Subgroup of the Joint Technical Coordinating Group on Aircraft Survivability.  He holds a B.A. in Chemistry from the University of Wisconsin, LaCrosse and a M.S. in Systems Analysis from the University of Rochester, NY. Margaret M. Horst is a Senior Research Engineer in the Information Technology and Telecommunications Laboratory at GTRI.  She has over 20 years experience in radar propagation and backscatter simulation.  Currently she is working with the GTRI team developing the Federate Conformance Test system for DMSO to certify federates as HLA compliant.  She is Vice Chair of the Paper Review Panel for the Federation Development Process Forum (PROC) and is Vice-Chair of the PRP for the RD&E User Forum.David W. Roberts is a Research Scientist II at GTRI where he has been leading efforts to design, implement, and use tools to support the migration of legacy simulations to HLA. Prior to being at GTRI, he led systems integration efforts on the STOW-97 and War Breaker programs and has been involved in modeling and simulation since 1990. He is a past Chair of the Testing Forum and past Vice Chair of the Human Decision Making and Behavior Generation Forum of SISO. He received his B.S. from Cornell University in Operations Research and Industrial Engineering and his M.S. from the Johns Hopkins University in Computer Science. He is currently pursuing his Ph.D. in Human-Machine Systems Engineering.  Legacy simulations in this sense denote simulations that are not HLA compliant. A Symbol Table consists of all program data items and their types organized by scope. EMBED Visio.Drawing.4   EMBED Visio.Drawing.4  