Using STFs for CTDB ProductionKevin WertmanScience Applications International Corporation (SAIC)12901 Science Drive, Orlando, Florida 32826Ph: 407-207-2700, Fax: 407-277-5395 HYPERLINK "mailto:" jesse.campos@saic.com HYPERLINK "mailto:kevin.m.wertman@saic.com" kevin.m.wertman@saic.comJesse CamposScience Applications International Corporation (SAIC)12901 Science Drive, Orlando, Florida 32826Ph: 407-243-3700, Fax: 407-277-5395 HYPERLINK "mailto:jesse.campos@saic.com" jesse.j.campos@saic.comKeywords:Synthetic Natural Environment, Database Generation, SEDRIS, Compact Terrain Database, SEDRIS Transmittal Format, STF, CTDBABSTRACT: The Compact Terrain Database (CTDB) format is used for storing terrain data, developed for use with ModSAF (Modular Semi-Automated Forces) applications.  It is also widely used with variants of ModSAF such as JSAF (Joint SAF), OTBSAF (OneSAF Testbed SAF), and DISAF (Dismounted Infantry SAF).  These applications  have created a demand for CTDBs which has been met by different mechanisms within the modeling & simulation (M&S) community.	One such path for CTDB production is the STF to CTDB application.  This application is being developed by the SEDRIS project to take SEDRIS transmittals in a SEDRIS Transmittal Format (STF) file set and create a CTDB from that set.  This application has continued to evolve with increasing capability and users.This paper will discuss the state of the STF to CTDB application and how to effectively use it in supporting the M&S community. This paper will begin with a description of the mapping of SEDRIS data into the CTDB format and CTDB constructs.  This will include an introduction and a discussion of the STF to CTDB Transmittal Content Requirements Specification (TCRS).  The role of the STF to CTDB TCRS within the STF to CTDB application will be explained as well as how a user can effectively use such a specification to create SEDRIS transmittals.  This paper will then delineate the current capabilities, limitations, and performance of the STF to CTDB application.  The paper will then describe a real world usage of the application and the resulting CTDBs.  Future development and enhancement plans will also be addressed.IntroductionSEDRIS technologies provide a robust mechanism for the representation of environmental data across all domains and applications.  In order to provide these broad capabilities, five technology components have been developed.  The five technology components are as follows:A Data Representation Model (DRM) supports the full representation of any environmental data.The Spatial Reference Model (SRM) supports an extensive definition of Spatial Reference Frames (SRF). An Environmental Data Coding Specification (EDCS) that provides complete classification and attribution for environmental data.An Interface Specification, the SEDRIS API, which allows the user to develop applications to consume and produce environmental data.A binary file format, the SEDRIS Transmittal Format (STF), specifically designed for the efficient storage and access of SEDRIS data.These components are used to interchange environmental data and/or to produce environmental data applications.  As a result of the success in providing an internationally recognized mechanism to achieve these objectives, more and more environmental data sets are being provided to the community.  Applications that can benefit from environmental data provided in SEDRIS are the Semi Automated Forces (SAF) systems that use the CTDB format.  The Compact Terrain Database (CTDB) is a widely used format for the SAF community and the purpose of the STF to CTDB application is to effectively create CTDBs from SEDRIS transmittals provided in a STF file set.This paper will discuss the state of the STF to CTDB application and how to effectively use it in the M&S community. This paper will begin with a description of the mapping of SEDRIS data into the CTDB format and CTDB constructs.  This will include a discussion and presentation of the STF to CTDB Transmittal Content Requirements Specification (TCRS).  The role of the STF to CTDB TCRS within the STF to CTDB application will be explained as well as how a user can effectively use such a specification to create SEDRIS transmittals.  The paper will then continue by delineating the current capabilities, limitations, and performance metrics of the STF to CTDB application.  The paper will then provide real world usage of the application and results of CTDBs created using the application.  The future development and enhancement plans will conclude the paper.Mapping SEDRIS to CTDBNative Data ModelsIn order to understand the functionality provided by the STF to CTDB application, it is essential to understand the requirements of CTDB to support the SAF systems that use it as their run time formats.  Every application that represents the real world has a native data model.  That is to say that it defines the data constructs and the relationships between those data constructs.  For example, it is likely that an aircraft simulation will not require the type of a tree, just its location and perhaps height.  So in that date model there is a tree construct, which will have a location attribute and a height attribute.  On the other hand, SAF systems using CTDB require trees to have a trunk radius, foliage height, fullness, total height, and a location.  Both data models are perfectly valid since each deal with a domain specific use.The CTDB Data ModelThe following CTDB data objects exist that must be mapped from the SEDRIS DRM.  CTDB Volume Models - BuildingsCTDB Laid Linears -Rivers and RoadsCTDB Tree linesCTDB CanopiesCTDB Soil DefragsCTDB Terrain CTDB Power linesCTDB PipelinesCTDB RailroadsCTDB BridgesMulti Level TerrainMES Buildings, Caves, and Tunnels. Off roads LabelsMicro waterSteep SlopesPolitical BoundaryDitchCraterDragons TeethFighting PositionBermRubbleSnowFenceRock DropCamouflageHydro Surface and SubsurfaceConcertina WireMinefield FenceThe CTDB format is an optimized format used to store the above information.  As a result it calls for very specific information and data types.   See [1] for more information on what exactly the CTDB format consists of.  The DRM, on the other hand, intentionally provides the capability of representational polymorphism.  This is to say that it allows for multiple ways to represent the same environmental concept.  Through this capability a tree from any domain or application specific data model can be effectively mapped into the DRM.  Furthermore, when mapping from the DRM to a specific application data model, as is the case for STF to CTDB, the mapping is from many to one.  Thus, the above date elements are the final product that the STF to CTDB must derive to. At this point, the possible mappings from the DRM to CTDB will be discussed.DRM to CTDB MappingsThis document will not present an exhaustive analysis of all the mappings from the DRM to the CTDB constructs.  Instead a subset of the mappings will be discussed in order to highlight the important aspects of the overall mapping process.Mapping Into CTDB BuildingsFor SAF purposes, buildings are abstracted away to a higher degree than visualization applications.  These elements are referred to as volume models within the CTDB.  Volume models in CTDB are stored as simply a set of three-dimensional points that make up the roofline of the volume model.  Furthermore, there is a limitation of fifteen such locations per volume model.  SAFs in turn drop walls down from this roofline to present a complete volume model obstacle to the entities in the SAF.  This representation is a very simplified version for SAF systems and do not contain more advanced geometric representations.  For example, simple issues such as buildings with non-vertical walls will not map easily.  Is this a problem? Is CTDB a bad format because of these limitations?  The answer is: it depends.  It depends on your view of the world and your requirements for representing the world.  Regardless of what the answer may be, the fact still remains that the mapping will need to be made and it must be taken into account when taking data that might have been created for urban environment simulation into CTDB.In the DRM there are multiple organizations possible for representing buildings.  One way to represent a building is to provide a bag of polygons.  This would require a <Union of Primitive Geometry> with <Polygon> components.  This type of representation is suited for a visualization application.  A building could also be represented as a <Point Feature> with <Property Value> components for height, length, width, and orientation.  This could be very well suited for a SAF aircraft system.  Furthermore, a building could be represented as an <Areal Feature> with a <Property Value> component containing the height attribute.  Each one of these are perfectly valid representations in the DRM as a result of application specific requirements.  Furthermore, there are other representations as well, but only one of them is best suited to map into the CTDB representation.Mapping Into CTDB TreesTrees or tree lines are another environmental constructs within CTDB.  In CTDB tree lines are stored as a linear set of points. When the number of points is one, a single tree is being represented.  Furthermore, CTDB trees require a trunk radius, a foliage height, a fullness measure, and the total height of the tree.  These attributes are used to affect intervisibility and acts as an obstacle to vehicle movement.  Much like buildings, trees can have multiple representations within the DRM.  Multiple EDCS Classification Codes (ECCs) also can come into play.  For example for trees the following ECCs come into play: ECC_TREE, ECC_TREELINE, ECC_TREED_TRACT, and ECC_FOREST.  Thus, one representation would be to have a <Point Feature> with a <Classification Code> component of ECC_TREE.  Likewise the same <Point Feature> could be classified as ECC_FOREST and have a width attached to it using a <Property Value> object.  How does this representation map into CTDB trees? Does it map as a tree or another CTDB construct?  In this case the answer is that it really should map to the CTDB canopies.  Of a more interesting nature is a representation of a <Linear Feature>, which has been classified with ECC_TREE.  This could be an error in the data or it could be a valid representation.  A representation that has a <Linear Feature> with ECC_TREELINE is clear and unambiguous, but the latter representation although possible, brings into question the data.Effective Handling Multiple RepresentationsIn order to manage the many to one characteristics of DRM to native data model mappings, the concept of a TCRS has been applied.  A Transmittal Content Requirement Specification is a specification of the data requirements for an application or set of applications.  These requirements usually define what data and relationships are required in a transmittal to be compliant with the specification.  This specification ties the native data model of an application to the SEDRIS DRM.  In the case of STF to CTDB, the TCRS focuses on the basic primitive objects and what attribution those objects need to be fully realized in the CTDB creation process.  For instance, the TCRS definition for a CTDB road defines the following requirements:<Linear Feature> DRM objectClassified via <Classification Data> DRM objectAttributed with a road width via a <Property Value> DRM object using the EDCS attribution code EAC_WIDTH.So for any <Linear Feature> object that meets these simple requirements, the STF to CTDB compiler will create a CTDB Laid Linear road with the width specified in the <Property Value> DRM object.  This concept is then applied to each CTDB construct so that each will have a collection of requirements defined in the TCRS.  Ideally, the TCRS would contain the requirements that would have the cleanest mapping from the DRM to CTDB.  Since CTDB has a native organization, the cleanest TCRS requirements are the ones that match the organization in the CTDB.  In the examples previously provided, for buildings, the most direct mapping is an <Areal Feature> with a <Property Value> containing the height.  Likewise, for trees and tree lines, the best matches are to have a <Point Feature> with <Classification Data> of ECC_TREE and a <Linear Feature> with <Classification Data> ECC_TREELINE.  The goal of the STF to CTDB compiler is to provide an unambiguous and consistent mechanism to create CTDBs.  If an STF has its layout and information defined in accordance with this TCRS, then the consumption will be complete and the CTDB will be created correctly. The following section contains the STF to CTDB TCRS.STF to CTDB TCRSEach of the following figures clearly defines the necessary DRM class, EDCS classification and EDCS attribution that are necessary to be completely conformant to this TCRS.Tree lines and individual treesCanopiesRivers and RoadsBuildings and ObstaclesRailroads, Power lines, Pipeline Abstract FeaturesSoil Defragmentation AreasGridded Terrain DataPolygonal Terrain DataBridgesUsing TCRS for STF ProductionUsing this method removes the burden on the STF to CTDB compiler to be able to properly consume all possible STF datasets.  If a dataset has information that does not comply with the TCRS, then that information will not be transferred into the CTDB that is produced.  One of the main benefits of the STF to CTDB TCRS is that it gives a roadmap for producers of STF to go by in order to produce STFs suitable for the STF to CTDB compiler.  For a producer starting from scratch to define an STF production process for their project, this is invaluable, as it will save a lot of effort later reconfiguring or regenerating their STF process in order to take advantage of the STF to CTDB compiler to create CTDBs for the project.  It also allows for the development of a mechanism to validate that the produced STF passes the TCRS.State of the STF to CTDBConsumption IssuesIn creating the STF to CTDB compiler, issues have been encountered on the consumption of transmittals.  One issue has been faulty or incomplete input data.  Another issue is when the producer stores data in using a mechanism that the compiler is unable to support.  It is these cases that have prompted developers to pursue a TCRS mechanism.  For a survey of these type of issues refer to [5].  Although the TCRS provides a specification for the ideal transmittal, in the real world the transmittals are rarely created in this manner.  As a result, the current STF to CTDB application must handle with transmittals with inadequate content and non-optimal organization and representation.  In order to deal with these types of issues, the STF to CTDB provides the capabilities described in the next two sections.  Default ValuesThe data requirements for STF to CTDB consumption are fairly basic.  However, a lot of the time the STF being used for CTDB production was created for another project or process that didn’t have the same data content requirements.  In this case, a lot of data is missing from the STF.  The STF to CTDB compiler uses a configuration file called defaults.rdr which will be the basis for default values for when information cannot be obtained from the STF.   Each CTDB that requires additional information from <Property Value> objects will have an entry in this file.   For example, for tree lines the following entry exists:( treeline   ( height 10 )   ( foliage_height 4 )   ( diameter 2 )   ( opacity .60 ))So in this example, when a <Linear Features> that represent trees is encountered with no <Property Value> attribution for foliage_height, the value of 4 meters is used.  If the <Linear Feature> is made up of 2D locations, then the default height of 10 meters is used. Mapping ConfigurationThe STF to CTDB provides a features file that defines part of the mapping process from STF to CTDB.  In particular, it allows the user to specify which DRM Class and EDCS Classification combinations map to particular CTDB objects.   The format of the features file is based on the libreader file format, and has the following format:(  CTDB Concept 1   ( DRM Class 1 mapping to CTDB Concept 1       ( EDCS Classifications applicable to DRM Class 1 )    )    ( DRM Class 2 mapping to CTDB Concept 1       ( EDCS Classifications applicable to DRM Class 2 )    )    …    ( DRM Class N mapping to CTDB Concept 1        ( EDCS Codes for DRM Class N )) for example:( building     ( SE_DRM_CLS_GEOMETRY_MODEL_INSTANCE	        (BUILDING SHED )    )    ( SE_DRM_CLS_AREAL_FEATURE       ( AERODROME AERODROME_TERMINAL         AIRCRAFT_HANGAR  )    )   (  SE_DRM_CLS_POINT_FEATURE      ( BARRACK ECC_BARN  )    )  ) This entry refers to a CTDB building, specifying that this section contains mapping information specific to CTDB volume models.  The three different DRM classes listed can be used to create CTDB volume models, but only if the DRM class is found in combination with an EDCS Classifications that is listed in the set applicable to that DRM class.  This additional information has been added to the features file give the user more control over the STF consumption process.  In this example, the compiler will only compile <Geometry Model Instances> that have either the BUILDING or SHED classifications, and ignore all other <Geometry Model Instances> for volume model creation in CTDB.  However, any <Areal Features> that has the classification “AIRCRAFT_HANGER” will also be used to create CTDB volume models.  Instead of using the actual EDCS codes, labels are now used to help make features files easier to read and maintain.  Each portion of the features file is checked for validity.  An error is reported if an unknown EDCS Classification or DRM Class is used.Current CTDB Mapping CapabilitiesCurrently the following CTDB objects can be created:CTDB Terrain (Gridded and TINned )CTDB Soil Defrags CTDB Volume ModelsCTDB Laid Linears (Rivers and Roads)CTDB Tree linesCTDB CanopiesCTDB Bridges (Implicit and MES)CTDB Power linesCTDB PipelinesCTDB RailroadsThe CTDB constructs are created by executing a depth-first tree traversal of the STF data.  If there are multiple levels of detail in the STF data, the highest level of detail will be consumed, unless the user specifies otherwise.  The primitive DRM objects that are understood by the consumption engine are <Point Features>, <Areal Features>, <Linear Features>, <Geometry Model Instances>, <Property Grid Hook Points>, and <Polygon> objects.  It is only from these objects that relevant CTDB data can be extracted.  After encountering a primitive object of interest, the compiler will attempt to find the EDCS Classification for that object.  Based on the DRM class in combination with this EDCS Classification, the compiler can search for a mapping defined in the features file.    If a mapping is found then the mapped data will be extracted and compiled into the CTDB according to the algorithms defined for each CTDB type.   The following sections go into further detail based on CTDB type.CTDB TerrainCTDB Terrain is stored as gridded terrain in the elevation grid with microterrain in the patch features, or with no gridded terrain with Triangulated Irregular Networks (TIN) terrain in the patch features.  Both microterrain and TIN terrain are polygonal based terrain representations.  All terrain needs to have mobility information stored via a reference into the polygon attribute table (PAT).  For each post in the elevation grid, there is a corresponding soil grid that also indexes into the PAT.To extract this information, the STF to CTDB application can use <Property Grids> containing elevation and soil information and/or <Polygon> objects with <Property Values> specifying their soil and mobility information.CTDB Soil Defragmentation AreasThese are specified as boundaries of areas where all terrain within the boundary have the soil and mobility specified in the defrag object.  This information overrides soil and mobility information contained in individual grid posts and terrain polygons.  Soil defrags are extracted from <Areal Feature> objects in the STF, and the data describing the footprint of the <Areal Feature> is extracted and stored in the CTDB.CTDB Volume ModelsVolume models in CTDB are stored as simply a set of 3D vertices that make up the roofline of the Volume model.  SAFs in turn drop walls down from this roofline to present a complete volume model obstacle to the entities in the SAF.  For the CTDB compilation process, the only data needed is this set of roofline vertices.  The process that the STF to CTDB compiler uses to extract CTDB volume model information is simple for feature based DRM objects such as <Areal Features> and <Point Features> and more complex for <Geometry Model Instance> DRM objects. Using <Point Features> the compiler builds a box around the point specified by the <Point Feature> using height, length, width, and angle of orientation attribution stored in <Property Value> DRM objects specified by EDCS Attribute Dictionary concepts.  It then stores the roofline points of that box in the CTDB volume model.  For <Areal Feature> DRM objects, each vertex in the <Areal Feature> is mapped one-to-one to a roofline vertex in the CTDB volume.The process that creates CTDB volumes from <Geometry Model Instances> is based on the geometry of the model being instanced.  First, all polygons in the <Geometry Model> that are within 15 degrees of vertical are collected.   If the collected edges are able to be formed into a complete outline of the volume, then the top of each of those edges is used to construct the roofline of the CTDB volume model.    Due to the existence of complex models such as vehicles that don’t lend themselves to the wall finding algorithm described above, a new mapping to “obstacle” has been created to make simpler CTDB volume models from <Geometry Model Instances>.  When encountering a <Geometry Model Instance> that falls in the “obstacle” entry of the features file, the compiler will create a simple bounding box of the <Geometry Model> and store the roofline of that box as a CTDB Volume.  The resulting CTDB volume isn’t an exact representation of the original <Geometry Model> but it is close enough to serve as an obstacle to impede vehicles in a SAF environment.CTDB Roads and RiversCTDB Roads and Rivers are both forms of CTDB Laid Linears and use the same algorithm to extract data.  Both extract the vertices from <Linear Feature> DRM objects and collect the road width from <Property Value> DRM objects attached to the linear features.  Each laid linear has a soil type associated with it.  For roads, the soil type is equivalent to a road, and for rivers, it is equivalent to water.CTDB BridgesBridges can be created in a CTDB using multi-level microterrain, MES models, or implicitly storing the bridge.   The STF to CTDB compiler is currently only using the implicit or MES storage process.  The compiler uses <Linear Feature> DRM objects to create CTDB bridges, but in the case of implicit bridge storage, these <Linear Features> need to be mapped to CTDB Road constructs.  This is because the libctdb backend compiler will create implicit bridge nodes anywhere a CTDB Laid Linear Road crosses a CTDB Laid Linear river.  The SAFs detect these bridge nodes and create the necessary bridge routing data to allow tanks to cross rivers at these points.  When a road crosses over a terrain area that has been coded as deep water, then the terrain under the road takes the soil value of the road rather than the deep water, allowing tanks to cross as well.   This is currently the most stable bridge option available in the STF to CTDB compiler.  The MES model process uses the <Linear Feature> bridge in combination with width and height property values to construct a 3D MES Model representing a bridge deck, and instances it in the CTDB.  CTDB Roads and RiversCTDB Roads and Rivers are both forms of CTDB Laid Linears and use the same algorithm to extract data.  Both extract the vertices from <Linear Feature> DRM objects and collect the road width from <Property Value> DRM objects attached to the linear features.  Each laid linear has a soil type associated with it.  For roads the soil type is equivalent to a road and for rivers it is equivalent to water.Discuss roads and rivers before the bridges, actually discuss bridges at the end.CTDB Tree lines and CanopiesCTDB Tree lines are stored as a set of vertices, each representing a single tree in the tree line.  The Z value of each vertex represents the height of that tree.  Also stored for each tree line is information about the tree diameter, the trunk radius, opacity, and foliage height.  The compiler can use both <Point Feature> and <Linear Feature> DRM objects to compile CTDB tree lines.  For <Point Features> a tree line with a single vertex is created.  For a <Linear Feature>, each vertex in the <Linear Feature> is mapped to a vertex in the CTDB tree line.  <Property Values> are collected and examined for each of the extra information needed by the tree line. CTDB canopies are stored as a collection of polygons that make up the roof of the canopy and a set of tree lines that fall along the boundary of the canopy.  Additionally, an abstract feature representing the outline of the entire canopy is stored.  The compiler uses both <Polygon> and <Areal Features> to extract the information necessary to create a CTDB canopy.  The <Areal Features> are used for the tree lines and the abstract outline, while the <Polygons> are used to create the roof of the canopy.  Additionally, the <Areal Feature> is queried for additional <Property Values> that contain information that is used to determine whether the CTDB canopy is penetrable or impenetrable by moving entities in the SAF.CTDB BridgesBridges can be created in a CTDB using multi-level microterrain, MES models, or implicitly storing the bridge.   The STF to CTDB compiler is currently only using the implicit or MES storage process.  The compiler uses <Linear Feature> DRM objects to create CTDB bridges, but in the case of implicit bridge storage, these <Linear Features> need to be mapped to CTDB Road constructs.  This is because the STF to CTDB compiler, using functions provided in libCTDB compiler library, will create implicit bridge nodes anywhere a CTDB Laid Linear Road crosses a CTDB Laid Linear river.  The SAFs detect these bridge nodes and create the necessary bridge routing data to allow moving entities to cross rivers at these points.  When a road crosses over a terrain area that has been coded as deep water, then the terrain under the road takes the soil value of the road rather than the deep water, allowing moving entities to cross as well.   The MES model process uses the <Linear Feature> bridge in combination with width and height property values to construct a 3D MES Model representing a bridge deck, and instances it in the CTDB.  Other CTDB featuresOther CTDB features include railroads, pipelines, and powerlines.   All three of these features are derived from <Linear Feature> objects in STF and stored as a one-to-one vertex mapping to abstract data in the created CTDB.LimitationsThe current version of the STF to CTDB compiler does not support the creation of the following CTDB types:Multi Level TerrainMES Buildings, Caves, and Tunnels. Off roads LabelsMicro waterSteep SlopesPolitical BoundaryDitchCraterDragons TeethFighting PositionBermRubbleSnowFenceRock DropCamouflageHydro Surface and SubsurfaceConcertina WireMinefield FenceSome of these capabilities will take time to be implemented (such as MES) but the majority can be implemented, as the users demand them.PerformanceAll 3.1 transmittals were created directly from the 3.0 transmittal using the 3.0 to 3.1 STF converter provided by the SEDRIS Organization.  Performance statistics on input STF size, output CTDB size, and running time were collected on a Dell Workstation running dual 1.7 GHz Pentium 4 Xeon processors with 768 MB of physical memory.  The performance measures are provided in the ensuing tables. STF to CTDB using SEDRIS Version 3.0 ResultsDBExtents(km)STF Size (MB)Time(s)CTDB Size (MB)Bellevue10 x 109.025.2.5Philadelphia1 x 247.5210.92.7DTED Level 090. 5 x11030.223.05.9STF to CTDB using SEDRIS Version 3.1 ResultsDBExtents(km)STF Size (MB)Time(s)CTDB Size (MB)Bellevue10 x 103.818.9.6Philadelphia1 x 215.795.92.0DTED Level 0 90. 5 x11016.730.28.9Some notes about the statistics. The performance of the Philadelphia database increased partially because some of the geometry building model handling routines were upgraded.  In a similar vein, the DTED performance decreased slightly when the STF to CTDB compiler’s data table consumption code was redesigned.Real World Usage and ResultsHow can it be used?The STF to CTDB compiler has several use cases that make it a value tool.  In combination with a number of SEDRIS generation and verification tools such as SEE-IT, a complete CTDB can be created in a short amount of time.   One possible path is using the DTED to STF and VPF to STF tools with raw DTED and VMAP data from NIMA to create two SEDRIS transmittals.  With the STF to CTDB compiler, a single CTDB can be created from the two STFs.   This can be done in a single day, although there are usually some correlation issues between the VMAP and DTED data. Terrain generation tools such as TerraSim’s TerraTools produce STFs that the STF to CTDB can understand and create CTDBs from.  Another possible use is to augment existing CTDBs, by first using the CTDB to STF compiler and then using SEDRIS based tools to correct errors in the database or add additional features to it.   The corrected STF can then be fed into STF to CTDB to create a new CTDB.How has it been used?One of the first documented uses of the STF to CTDB compiler was for the VERTS project.  Using the STF to CTDB (then known as SEDRIS2CTDB tool) in combination with a number of other tools, the VERTS project was able to create urban databases.  Using a separate process,  MES structures were created and inserted into the created CTDBs.  More information can be found in [4].The STF to CTDB has been used for the rapid generation of CTDBs.   In 2001, CATI requested a 4 parcel CTDB from the P2 database.  The process involved taking a version 2.5 STF 20 GB P2 database,  extracting out the 4 parcels using SEDRIS based tools, and creating a CTDB from that section.  The final CTDB was delivered in 4 days to CATI.   Both the flexibility of SEDRIS and the capabilities of the STF to CTDB compiler made such a fast turnaround possible.Future DevelopmentThe STF to CTDB compiler goal is to create correct CTDB data structures from any STF that complies with the STF to CTDB TCRS, and to make that process as easy on the user as possible.   In order to facilitate these goals, the future development cycle will include the following:Comprehensive TestingTesting becomes crucial when an application is providing conversion capabilities.  How closely does the converted data correlate with the input STF?  One of the greatest needs for STF to CTDB development is the production of a testing process that can guarantee that the data going in are being reproduced accurately in the final CTDB product. Another realm of testing takes place before the STF to CTDB is even executed.  Tools such as the SEDRIS Syntax Checker and Rules Checker provide a way to validate that a given STF is a valid one.  In addition, a tool to test compliance with the STF to CTDB TCRS needs to be developed as well.Easier to useConfiguration of the STF to CTDB compiler is currently based on a set of text files and command line options.  To make the STF to CTDB easier to set up and use, a fully interactive GUI that allows the user to shape and watch the CTDB creation process as it occurs will be developed. This GUI will include the ability to interactively create the mappings that the features file does now.   It will also show progress state information to inform the user what is currently happening and about how much of the process is completed.ConclusionThis paper has discussed the STF to CTDB application and how to effectively use it in the M&S community. The mappings between the DRM and CTDB were discussed.  The STF to CTDB TCRS was discussed along with its role within the STF to CTDB application.  The current capabilities, limitations, and performance were then presented.  Real world usage of the application and results of CTDBs created using the application were provided along with future development efforts.  There still remains work to be done in the development of the tool and the specification of the transmittals for making the CTDBs, but the application is proving to be a consistent and practical mechanism to produce CTDBs.  As this capability matures in the next few months, this will be a valuable addition to the SAF community.References[1] J. Smith: “LibCTDB User Manual and Report”[2] A. Tosh, J. Campos: “SEDRIS’ing the CTDB Landscape”, Fall SIW 2002.[3] M. A. Pigora, D. Shen, J. Campos: “Innovating with SEDRIS Tools”, Fall SIW 2001[4] Robert L. Clover, (2000) “VERTS Synthetic Urban Environment Development Process – End to End”, Proceedings of I/ITSEC 2000.[5] J. Watkins, J. Campos: “Consuming SEDRIS Transmittals – A Pragmatic Approach”, Fall SIW 2001.Author BiographiesKEVIN WERTMAN is a Software Engineer with SAIC.  He has been working the SEDRIS project for 2 years.  Mr. Wertman graduated from the University of Central Florida with a B.S. in Computer Science.  JESSE CAMPOS is a Software Engineer with SAIC.  He has been working the SEDRIS project for almost five years.  His primary expertise is in software development as it applies to databases.  Mr. Campos graduated from the University of Central Florida with a B.S. in Electrical Engineering.  