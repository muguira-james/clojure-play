THE SEDRIS TRANSMITTAL FORMATJohn Carswell, Jesse Campos, and Rob CoxScience Applications International Corporation12479 Research Parkway, Suite 600Orlando, Florida 32826Keywords:  SEDRIS, STF, and Application Programmer Interface (API)ABSTRACTSEDRIS stands for Synthetic Environment Data Representation & Interchange Specification.  For background information on SEDRIS, visit the SEDRIS web site at  HYPERLINK http://www.sedris.org www.sedris.org.STF stands for SEDRIS Transmittal Format, the standard file format for SEDRIS transmittals.  The purpose of the STF is to provide a platform independent mechanism for interchanging SEDRIS transmittals.  This paper describes how to use STF, the design challenges and goals of the STF, the performance results of the STF, and the planned future developments and extensions to the STF.  Using the STF involves reading to and writing from the STF.  To read from the STF, use the SEDRIS Level 0 Read API.  This paper does not describe the SEDRIS Read API, but instead refers the interested reader to the appropriate documentation.  To write to the STF, there are two different approaches.  The simplest, most direct method is to use the SEDRIS Write API, often called the ‘push’ approach.  The other, more complicated approach is the ‘pull’ approach, which requires the use of a SEDRIS utility program and an implementation of the SEDRIS Level 0 Read API by the data producer.  The pros and cons of both approaches are discussed.IntroductionThis document describes the SEDRIS Transmittal Format (STF).  This includes the purpose of the STF (section 1), how to use the STF (section 2), the design challenges and goals of the STF (section 3), the performance results of the STF (section 4), the design of the STF software (section 5), and the design of the STF file format (Section 6).Where to go from here?If you are only interested in using the STF, Section 1 (Purpose) and Section 2 (How to Use) are required reading.  Section 3 (Design Goals) may be interesting as it includes information on how the STF might change in the future. Section 4 (Performance) may also be of interest as it compares STF with other file formats and provides some information about how STF can be expected to perform with certain types of data.If you are only interested in the layout of the STF file format, still read Section 1 (Purpose), but then feel free to skip to Section 6 (File Format).  You may also want to read Section 4 (Performance) to see how the STF file format performs compared to other formats used for similar purposes.Section 5 describes the design and implementation of the SEDRIS Level 0 Read API for the STF as well as the rest of the STF code.  Section 5 is intended for those who need to maintain this code, or those interested in learning how the reference implementation is designed.Those interested in developing software for the translation of other data formats into SEDRIS should read the SEDRIS documentation at the SEDRIS web site.PurposeThe purpose of the STF is to provide a platform independent interchange mechanism for SEDRIS transmittals.  In SEDRIS, a contractor/vendor provides a Read Application Program Interface (API) implementation that will map their internal native database format to the SEDRIS Data Model. The Read API implementation is used to do a runtime conversion from the contractor native database format to SEDRIS data.  This process is termed “in-memory conversion.”  This data is then available for SEDRIS-based applications, such as the model viewer, or conversion software to other native formats.Unfortunately, there is a problem with this method of data exchange.  The problem is that Read API implementations are platform dependent.  Thus, when one attempts to consume data from a different native database, a new conversion software module is required that is compatible with the new format.  This new module must also be compatible with the old module, because both are accessed by the SEDRIS API.  Since a purpose of SEDRIS is to provide an interchange mechanism among all vendors and eliminate as much extraneous software as possible, a single mechanism that is platform independent is required, thus the STF.1.1 What is the STF?The STF represents two distinct components, the STF file format and the STF code.  These components allow users to write to, and read from STF transmittals.  To read from the STF file format, use the SEDRIS Level 0 Read API.  SEDRIS documentation at the web site fully explains the details on how to read SEDRIS data using the Level 0 Read API.To write to the STF file format, there are two different approaches.  The simplest, most direct method is to use the SEDRIS Write API, which is documented in papers at the SEDRIS web site.  The other approach is to use the SEDRIS Traverse application. This latter approach uses a SEDRIS Level 0 Read API implementation for a source of data other than the STF.  See Section 2 How to Use in this document for more details on how to use the Traverse program to produce a STF transmittal.1.1.1 STF File FormatThe STF file format is a binary, non-proprietary, platform independent format.  It is capable of working on both little endian and big endian platforms.  The details of the format are described in Section 6 File Format of this document1.1.2 STF CodeCurrently, the STF code is an implementation of the SEDRIS Level 0 Read API.  A programmer can read SEDRIS transmittals from STF files by using this code.  A Write API has been added to the STF code.  All STF code is platform independent C++ code.  The STF code has been successfully compiled and tested on Sun, SGI, IBM (AIX), and Linux (gnu C/C++) platforms.  The design of the code is described in Section 5 of this document.1.2 The Role of STF Within SEDRIS?The STF file format is the standard file format for SEDRIS transmittals.  STF is not a library or repository of databases, just as SEDRIS is not a library or repository of databases.  To find a synthetic environment database, see the projects responsible for collecting and cataloging environmental databases, such as the Master Environmental Library (MEL) at  HYPERLINK http://www.????.???.?? www.mel.dmso.mil  Hopefully, in the near future, databases available at MEL will be available in the STF format as well as in their own ‘native’ format.A data producer can provide a SEDRIS transmittal using two different approaches.  The first approach, and possibly the simplest approach, is to provide the transmittal in the STF format.  Then the consumer can read the data on any platform using the standard STF implementation of the SEDRIS Level 0 Read API.  The second approach is to provide a special, possibly platform specific implementation of the SEDRIS Level 0 Read API.  This special Level 0 Read API obtains its data from some source other than STF files.  The user then has the choice of either reading directly from this particular API implementation or converting the transmittal into an STF transmittal.  See section 2 for a description of the conversion process and for a discussion of the drawbacks and benefits of the different approaches.2.0 Using the STFThe STF can be used to read and write SEDRIS transmittals.  The STF code contains underlying code common to both uses as well as code which is unique to reading and writing.2.1 Reading from the STF The STF has a SEDRIS Level 0 Read API implementation that is used to read a SEDRIS transmittal contained in a STF file set.  This implementation is to equivalent to any other native format SEDRIS Level 0 Read API implementation such as s1000.  When a SEDRIS application is linked to the STF read API implementation, it can open any STF transmittal and then perform searches using the API.  The STF transmittal is opened using the SE_OpenSE call.  The name of the transmittal passed to SE_OpenSE must be the name of the STF transmittal root file (i.e., <basename>.STF) including the path and ".STF" extension.  For example, the user wanted to read from bigDB.stf in the /usr/data directory, the user would use the following function call:SE_OpenSE("/usr/data/bigDB.stf", &synthEnv);The applications and the SEDRIS Level 0 Read API are not the subject of this document, but further information on these topics are covered in the SEDRIS Documentation at the web site.2.2 Writing to the STFProducers can provide their data by creating STF transmittals and thus allowing consumers to read the transmittal as described above.  There are two ways that producers can write data into STF files, the Write API and the Traverse SEDRIS application.2.2.1 Write APIThe most common method for STF creation will be through the use of a Write API.  As users decide to convert to SEDRIS transmittals, the Write API will be the easiest and most flexible manner to store the data.  The Write API is in the initial stages of development and not completely specified as of yet.  The Write API will allow the user to structure SEDRIS transmittals in the most efficient manner for their data.  In the absence of the Write API, the SEDRIS Traverse application was written to create transmittals.2.2.2 Traverse ApplicationThe Traverse application is the current medium by which SEDRIS transmittals are stored into the STF.  The Traverse application uses a vendor’s SEDRIS Read API implementation to read the data and perform a modified depth first traversal of the transmittal.  A user has the option of excluding object types by means of a filter file and turning off Geometry Model Instance to Point Feature associationsThe command line options for the Traverse program are as follows:Traverse t <inputtransmittal> f <filesetname> [exc <excludefile] [s]The <inputtransmittal> parameter is the name of the SEDRIS transmittal that will be traversed.  This name must be specified in accordance with the naming requirements of the vendor's API.  Consult the vendor's documentation or developers for these requirements.The <filesetname> is the name of the base part of the resulting file set, including the path, but excluding the ".STF" extension.  For example, if you want to create a file set with the name "bigDB" in a directory named "STF," which is one level up from the execution directory, the file should be specified as "../STF/bigDB".  The resulting file set will include the file <basename>.stf (the root file) plus additional files each named <basename>NNN.stf, where "NNN" is a three digit, zero filled, numeric string.  In the example above, the file set will include the files bigDB.stf, bigDB001.stf, bigDB002.stf... up to the number of files required to represent the transmittal.The optional "exc <excludefile>" parameter allows the user to specify a file that contains a list of object classes which should be excluded from the file set. The optional “-s” option allows the Traverse program to ignore Geometry Model Instance to Point Feature associations, in both directions.  This option allows a quicker traversal in the case the user does not want to process these associations because they are too numerous or irrelevant for their use.2.3 Converting Non-STF Transmittal to STFProducers will have a choice of either using the Write API STF implementation to create SEDRIS transmittals in STF or they can use a Read API implementation and the Traverse application.  Likewise, consumers have a similar option.  They may chose to work with a producers read implementation or they can use the STF transmittal of the producer’s data.  This is only an option if the producer has created a read implementation for their native format.  If the producer has used the Write API to create STF transmittals, then consumers will use the STF read implementation.Previously, producers had to create read implementations in order to produce SEDRIS transmittals.  Since this is the case, consumers can choose either the STF version or the in-memory conversion.  The problem with the in-memory conversion is that it is vendor specific and can be platform dependent.  The consumer must also deal with multiple vendors and different sources of software.  The STF, on the other hand, provides a single platform independent software for all vendors and all types of data.  The STF provides the simplest interchange of SEDRIS data.3.0 Design Goals and IssuesThe STF was designed in order to balance many different issues within the SEDRIS community and clearly meet others.  For example, one clear mandate was to make the code platform independent.  It was to run on platforms that were prevalent within the community.  As such, the platforms supported at 2.0 release were Irix, Solaris, Aix, and Linux.  Windows NT will soon be supported as well.  Another requirement was to capture everything in the SEDRIS data model, but not necessarily the same structures.  Compacting the data was allowed, as long as it was still lossless.  While making the STF lossless, compactness was also desired.  The space on disk was to be minimized which was a direct challenge to making the data lossless.  The reason being that the SEDRIS data model made native formats grow two to two and a half times the initial space on disk.  SEDRIS re-structured the original data and the STF had to store with the additional cost of the SEDRIS overhead.  There was also a goal of making the STF as efficient as possible, both in reading from and writing to.  The STF was also to be transparent to the user.  Thus the actual underlying code could be changed and modified without affecting the user.  An issue that has not been resolved but is a goal, is to use external file standards.  These standards would be used for images and grids.  Although, the STF will use them at some point, the ones that will be used have not been determined.  The standards that will be used will be determined from a consensus of the SEDRIS community.All of these issues were considered in developing a design for the STF.  The design approach was to create Object Oriented modular code.  The code would be designed into different layers or modules.  Objects would interact with each other to provide efficiency and portability.  The rational for this approach was that SEDRIS objects needed to be represented and the only way to do this was with STF objects.  The STF was divided into layers, because as later improvements were made, these layers could be updated and replaced with the newer improved code.   It was also important to have a design that allowed an object to easily reach any other object and to do it efficiently.  As a result the STF uses indexing extensively to sort through the data.  The STF file format was designed to the bit in order to pack as much data as possible onto the disk.  The final aspect of the design was the platform independence.  This meant that the code must perform on both little endian and big endian machines.  The problem is that the STF must deal with both possible situations.  For example the user could be running on a little endian machine, but looking at data that was created using a big endian machine.  The software must convert at run time and it must convert every time a piece of data larger than one byte is accessed.  Thus when designing, efficiency had to be balanced with the other issues.4.0 PerformanceThe STF software has been successfully built and run under the following hardware platforms and compilers:Linux,	gnu C/C++ 2.8 and binutilsIRIX 5.3,	MIPSpro 7.1.IRIX 6.2,	MIPSpro 7.2.AIX 4.2,	xlC 3.1.4.Solaris 2.6, 	SC 4.0 & 4.2 compilersAs mentioned before, the STF had to balance size and lossless data requirements with efficiency.  As a result runtime performance was considered only as a secondary objective.  The reason being that the STF provides an interchange mechanism for data and is such is a broad encompassing design with SEDRIS overhead.  A consumer would always take the SEDRIS data and convert it to their native format because it would be optimized for their needs. Therefore, the runtime performance of the Traverse program and the read API implementation should not be judged too harshly.  Nevertheless, improvements to the runtime performance and storage efficiency of the STF software and format are being identified and analyzed for further releases.  The STF was compared to native databases and their SEDRIS read implementation.  This analysis includes four s1000 databases and two GDF database.The four s1000 databases were Bellevue, AUSA, STOW, and Moba.  The GDF databases were the CCTT P1 I9 parcel and CCTT P1 AE.  The tar’d and gzipped original and STF sizes are given below (Table 1) for all databases except for CCTT P1 AE.Table 1.  Databases: Their original size and STF sizeDatabaseOriginal (kb)STF (kb)Bellevue9693,024Stow3,0572,704Ausa5,48913,056MOBA45,72943,008CCTT P1 I969,08832,736CCTT P1 AE3,828,5682,882,808The largest increase in size was the Bellevue which is greater than three times its initial size.  On the other extreme is the MOBA database, the largest of the s1000 databases tested, which was a one to one matching.  The P1 I9 STF was less than half the size of the original data and the P1 AE was three quarters of the original size.  The smaller databases show the overhead inherent in the STF.  The larger databases are relatively not affected by the STF overhead.  The differences in sizes can be attributed to the SEDRIS data model and its associated overhead.  For example, all databases must contain certain objects in SEDRIS and the smaller the databases, the greater the proportion of required objects.  The size is also greatly dependent on what types of objects are contained within the database.The next area of interest was the actual performance of SEDRIS applications for the native read implementation versus the STF version.  The simplest application is Depth which begins at the top of the transmittals and does a dept first traversal of the data.  It is a good measure of how long it takes to touch every SEDRIS object.  The run times for the various databases are given below in CPU minutes (Table 2).Table 2.  Database:  Their Depth runtime for the original and STF version.DatabaseOriginal STF Bellevue1:544:06Stow1:373:23Ausa5:1710:17MOBA87:3684:48CCTT P1 I913:4021:48For all but the MOBA data, the STF took approximately twice as long.  The performance of the STF is degraded by applications such as Checker which strenuously work with an object and touch every associated object.  The CPU run times in minutes is given below for the three smaller databases (Table 3).Table 3.  Database:  Their Checker runtime for the original and STF version.DatabaseOriginal STF Bellevue5:389:26Stow4:307:27Ausa12:1447:42As the number of objects increases the performance degrades.  The reason being that the more objects there are, the greater possible separation between objects and the harder the software will work to reach the objects.5.0 STF Software DesignThe STF software can be grouped into three layers. The top layer is the API Layer.  This layer implements the STF Read API, and in the future, the STF Write API. The second layer is the Transmittal Layer.  This software maintains the constructs that provide the logical structure of the STF file format.  The final layer is the STF System Layer.  This layer manages the sections of memory used to read or write to disk.  It maintains counts and calls the read and write commands.  5.1 STF API This layer of code deals with the actual instantiation of objects within the SEDRIS data model.  When instantiating an object the data must be read from disk and the objects fields must be filled in from the files.  The software thus has two sections.  The first section is the actual class definitions and contains these pairs of header and source files:ColorDataDataTablesGenericObjectImageLocationSynthEnvse_supportSE_Open and SE_Close, used to open and close SEDRIS transmittals, as well as other required API functions are contained in se_support.  Most of the over 300 SEDRIS classes are handled by the GenericObject file.  The rest of  the files are used to instantiate classes that need more than the basic information.  For example, SynthEnv defines the Synthetic Environment class, which is the top object in a transmittal and requires additional definitions to search for other objects.Associated with this code are additional files that deal with data tables and properly retrieving data.  The pairs of header and source files are listed now:SedrisDataTableDataSedrisElementDataSedrisElementDataBlockSedrisImageDataSedrisObjectSedrisTypesgenDataMap.cprimitiveDataMapprimitiveDataMap_staticsThe Sedris* group of files transform the STF file format data into SEDRIS data form.  The DataMap files are used to properly interpret the STF data and convert them SEDRIS object’s fields.  The DataMap is platform specific nd is stored in primitiveDataMap_statics.  This serves as a look up table for the STF to fill in the appropriate fields of a class.  Thus for example, the STF when given an Attribute Set Index object will lookup in the DataMap how many fields and their size.  In this example, it would read one field of size UINT16.5.2 STF Transmittal CodeThe main objective of the Transmittal Layer is to create the structures described in the STF Format below and populates them with valid data.  This is populating the STF file format structures as opposed to the API which populates SEDRIS structures.  In the case of writing, the data will come from either the STF Write API implementation or the Traverse application linked to a vendor read implementation.  When the STF read implementation is used the data will come from STF files stored on disk.  Regardless of the source, the Transmittal code brings the STF Format to life.The implementation of the Transmittal Layer uses the classes/objects that correspond to the STF Format.  Thus, there are STF Files, STF Blocks, STF Objects, and one STF Root File.  There are also helper classes that are used for the implementation and do not directly trace to the STF Format.  These helper classes are implemented to provide required functionality and are interspersed with the base classes.The Transmittal Layer software is contained in seven pairs of header and source files titled:FBOSTF_ObjectSTF_ReferenceTable STF_RawblockSTF_BlockSTF_FileSTF_RootFile5.2.1 FBOThe FBO is the object identifier.  There is one FBO for every object in the STF file set.  When storing data, the FBO is assigned to a SEDRIS object.  When retrieving data, the FBO is the File (number or index), the Block, and the Object, that the data comes from.5.2.2 STF ObjectSTF_Object corresponds to the Object Data in the STF Format.  An object is an instantiation of a SEDRIS object.  The object contains data values that contain the number of References (Object Reference Counts), the size of the attribute data, the type of the object, and the Flags of the object. 5.2.3 STF Reference TableThe Reference Table files deal with the problem, when storing data, of an object associating to another object that has not been stored on disk.  When this happens, it is termed an unresolved association.  For instance, the components of a newly created object will be unresolved associations.  Therefore, a group of objects and functions that deal with associations have been created.  These involve creating structures for unresolved references.  These functions keep lists of unresolved associations and when these objects are encountered resolves the associations.5.2.4 STF Raw BlockThe STF Raw Block corresponds to the various header components in the STF file format.  The raw block provides for a simple writing and reading mechanism and is used when the exact position of data is known.5.2.5 STF BlockThe STF Block is a more complex implementation of a Raw Block.  An STF Block corresponds to a Data Block in the STF Format.  Thus, an STF Block will have a header that is an STF Raw Block.  A Block contains all the data relevant to a Data Block such as block number, file number, number of objects, number of object types, etc.  The difference between a normal Block and a Raw Block is related to the fact that when the format of the data is not predetermined, a counter must be used.  This means that for object field data, which breaks up into different sizes, the software cannot read and write in prescribed locations.  The Block must know where it left off reading or writing.  The Block maintains a counting mechanism that keeps track of where in the Block it has written to or read from.5.2.6 STF FileThe STF File corresponds to the File in the STF Format.  An STF File contains a file header that is an STF Raw Block and all data relevant to the file.  This includes a path and file name, maximum block size, and a Block Table.  The Block Table stores the offsets to all the blocks contained within the file.5.2.7 STF Root FileThe STF Root File is the final piece of the Transmittal puzzle, and perhaps the most essential.  This class inherits from the STF File and adds the Master File Table (MFT).  The MFT contains the names of all of the transmittal files and allows those files to be opened.  Since the Root File has the MFT, it alone is capable of determining which Data Blocks to open.  For example, if one wanted to open an object with an FBO of (3,456,243), the file number (3) is the index into the Master File Table and thus the Root File would command File # 3 to open block # 456. 5.3 STF System LayerThe Transmittal software provides the STF structures, but when it is time to read or write the data, it requests the system software to do these tasks.  Thus, the implementation of reading or writing can be separated from the structures, because methods might differ depending on the system used.  The Transmittal software has pointers to data areas it is writing to on disk that are provided by the System Layer.  The System layer needs to manage the amount of memory allocated for data and read and write when it is appropriate.  For instance, a block that is open does not need to be written to disk every time a piece of data is written to it.  The System Layer code allows updates to a block and writes it only when necessary. The system software is contained within seven pairs of header and source files named:VbufferVfileFileManagerBufferManagerBufferHeapBufferMmapBuffer5.3.1Virtual Files and Virtual BuffersThe System Layer uses Virtual files (Vfiles) and Virtual buffers (Vbuffers) to manage resources.  The software creates a virtual file for each STF File and a virtual buffer for each STF Block.  The software sets a maximum amount of open Vfiles and open Vbuffers.  A Vfile contains an STF File name and file descriptor as well as a File ID.  The file descriptor is used to access the disk file and the file ID is used to uniquely identify a file.  A Vbuffer is assigned to each STF Block.  Thus, when a Block needs to read or write, it tells the Vbuffer to read or write.5.3.2 ManagersThe System Layer contains two managers, the File Manager and the Buffer Manager.  The File Manager keeps a list of the active and inactive Vfiles.  This manager activates the Vfile, which means that the Vfile has a valid file descriptor. The File Manager makes sure that the maximum amount of active files is not exceeded by closing the oldest file.  The limit is set at compile time.The Buffer Manager works much like the File Manager, except it uses Vbuffers instead of Vfiles.  This manager activates the Vbuffers which means that the memory is allocated and initialized and is ready to be read from or written to.  In order to activate a buffer, the Vfile must be active so the Buffer Manager works in conjunction with the File Manager.5.3.3 BuffersBuffers are the actual memory space used to keep data before it is written to disk or after it has been read from disk.  Vbuffers contain a pointer to a buffer.  When a Vbuffer is inactive, the pointer is NULL and cannot be written to or read from.  Activating a Vbuffer causes the Buffer Manager to assign a valid buffer to the Vbuffer.6.0 STF File FormatThe STF file format is a binary representation of SEDRIS objects.  The objects and their data are stored throughout files.  Thus the format is a description of the layout of the objects and how they are stored.  The basic unit of identification of the STF object is the File Block Object (FBO).  Every SEDRIS object can be uniquely identified by its FBO.  The FBO is an indexing mechanism for objects.  The file format is divided into Files which are subdivided into Blocks which contain objects.  This means that every object is contained in one block and in one file and can uniquely be identified by its FBO.  For instance, the first object will have an FBO of {1,1,1}, which means get the first Object of the first Block of the first File.6.1 STF FilesThe STF creates several STF Object Files and one STF Root File.  All files are composed of a File Header, Data Blocks, a Referenced File Table, and a Block Table.  The layout is given below in Figure 1:Figure 1.  STF file structure.The first data is the header which contains the data relevant to the file such as: version number, number of Blocks, the name of the Root File and the name of this file.  Data Blocks are stored after the header with a theoretical maximum of 4096, although the STF uses only 1024 at this point.  These Blocks vary in size and the format does not prescribe a minimum size for these blocks. After the blocks are written, the Referenced File Table is stored, the Blocks will be describer later.  The Referenced File Table is a list of all other files this file references.  The Block Table supports access to the blocks within the file.  Access to a Data Block is accomplished using the index into the Block Table.6.2 STF Root File The Root File is the first STF file written to and read from.  The Root File contains additional data members in its headers and a Master File Table (MFT).  The Root File header contains two additional data pieces, the offset to the MFT and the number of files in the transmittal.  The MFT is stored below the Block Table in the diagram above.  The MFT contains each STF Object File name and path from the Root File and a type mask that states what types of objects are contained within the file.  Referenced File Tables in other files only store the Index of the MFT, because the MFT provides the information needed to access the STF Files.6.3 STF Data BlocksSTF Data Blocks are the second category in the STF storage mechanism.  The layout of the Data Blocks is given below in Figure 2:Figure 2.  STF data block structure.STF Files contain 1024 data Blocks and each Block may contain up to 256 objects, depending on the maximum size specified by the file.  All Blocks within a file have the same maximum size, but not the same size or number of objects.  In order to minimize disk space, a block is only as large as it needs to be to contain an average of 256 objects.  Since the size of objects vary, the number of objects that fill a block will differ.  Thus, if objects are abnormally large, a block may not contain 256 objects.  Conversely, if blocks were made too large, most blocks would contain 256 objects but also contain large waster area that would bloat the STF files.  A Block contains a Header (number of objects and offsets), an Object Pointer Table (similar to the Block Table within the File), an Object Type Table (type of objects containd in data Block), an Object Pointer Index Table (location of types of objects), and data Objects.  Data Objects are stored at the end because they vary in size.6.4 STF ObjectsThis is the final data storage construct.  The layout is given below in Figure 3:Figure 3.  STF data storage structure.SEDRIS Objects can associate with other objects through three different types of associations, Plain, Aggregate, and Component, with each association having a link class.  An aggregate association means that this object is a child of or derived from another object.  A component association means that this object is the parent of another object.  All three associations can have link objects, which describes the relationship between objects.  The Object header stores a flags indicating this object’s associated objects, the type of the Object, and an offset to the Reference Table.  The count of each type of association is stored in the Object Reference Counts.  The Object Reference Counts are variable.  If an object does not have the bit set in the Flags then it will not have a count.  After the Object Reference Counts are stored, the Object Field Data is stored.  The field data varies by object type and is defined by the SEDRIS data mode.  The final component of the Object data is the Reference Table.  This table consists of entries of objects that reference this object and as such this table stored the identification of these objects.  The STF format encodes the FBO into a 32-bit data value.The entire layout is given to give the reader the total perspective (Figure 4).  The exact layout, bit by bit is provided in the SEDRIS documentation at the web site.Figure 4.  STF Layout7.0 SummaryThis paper has presented the STF.  The purpose of the STF and its relationship with SEDRIS was discussed.  The methods of using the STF were described.  Specifically, how to use the STF to convert other native databases to SEDRIS format.  The design rational and challenges were presented along with the tradeoffs of the goals and requirements for the STF.  Some analysis was also included as to how well the STF performed in regards to disk space and performance.  The software structure was outlined and the software was described down to the file level.  The final section of the paper gave an overview of the STF file format.  This paper could not cover all of the details of the STF, but was intended as an introduction to STF.  For a more comprehensive treatment of this subject please refer to the SEDRIS Documentation at the web site.7.0 ABOUT THE AUTHORSMr. John Carswell is a Scientist with SAIC with over eight years experience in computer image generation applications, synthetic environment representations and database generation systems.  His primary expertise is in specification of system configurations and derived performance requirements based on visual requirements.  He has demonstrated specific expertise in visual database performance, construction strategies, and interoperability designs.  Mr. Carswell graduated from Stetson University, Deland, Florida in 1989 with a B.A. degree in Computer Science.  He can be reached at 12479 Research Parkway, Suite 600, Orlando, FL 32826, 407-207-2758, FAX 407-381-8436, john.carswell@cpmx.saic.com.Mr. Jesse Campos is a Software Engineer with SAIC.  He has been working the SEDRIS project for almost two years.  His primary expertise is in software development as it applies to databases.  Mr. Campos graduated from the University of Central Florida with a B.S. in Electrical Engineering.  He can be reached at 12479 Research Parkway, Suite 600, Orlando, FL 32826, 407-207-2796, FAX 407-381-8436,  Jesse.J.Campos@cpmx.saic.com.Dr. Rob Cox is a Senior Scientist with SAIC.  Dr. Cox will serve as project director and principal investigator for SEDRIS.  His Ph.D. is in Meteorology from Texas A&M University. Dr. Cox has served in a diverse set of assignments including Korea, Nebraska, and Washington DC.  Through the years he has supported many experiments and wargames including ULCHI FOCUS LENS and wargames at the Warrior Preparation Center in Germany.  Dr. Cox has authored or co-authored over 2-dozen articles and papers in scientific conferences and journals.  He can be reached at 12479 Research Parkway, Suite 600, Orlando, Florida 32826, 407-207-3609, FAX 407-207-381-8436, coxr@saic.com.