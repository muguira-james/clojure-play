Lessons Learned Creating an HLA Interface for a DIS Legacy SystemRobert A. CaseThe Boeing Company6030 S. Kent St., Bldg 560Mesa, AZ 85212-6061480-988-9773x425 HYPERLINK "mailto:robert.case@williams.af.mil" robert.case@williams.af.milLance CallL3-Com6030 S. Kent St., Bldg 560Mesa, AZ 85212-6061480-988-9773x438, 480-988-9773x477, 480-988-9773x423, 480-988-9773x479 HYPERLINK "mailto:lance.call@williams.af.mil" lance.call@williams.af.milCaptain Jeremy HendrixAir Force Research Laboratory, Human Effectiveness Division - AFRL/HEA6030 S. Kent St., Bldg 558Mesa, AZ 85212-6061480-988-9773x227 HYPERLINK "mailto:jeremy.hendrix@williams.af.mil" jeremy.hendrix@williams.af.milKeywords:HLA, FOM Design, Code Generator, Real-time, Legacy System, RTI-1.3NG, DMT, vxWorks, NTABSTRACT:  Decisions affect the design, development, and ultimately the time and cost of any project.  Seemingly insignificant decisions can adversely affect not only schedule but product efficiency too.  The AFRL/HEA participated in a Defense Modeling and Simulation Office led proof of concept effort to integrate commercial and multi-force federates in a small but realistic Distributed Mission Training scenario.  The federates included multiple real-time, high fidelity, man-in-the-loop simulators, computer generated forces, radio communications systems, data loggers, record and playback utilities, and simulation control stations.  The effort included the design and generation of a Federation Object Model (FOM) and the development of associated High Level Architecture (HLA) interfaces for each of the participating federates.  This paper focuses on the design decisions made during various stages of development and the ensuing affects on the HLA interface code for the legacy systems at AFRL/HEA.  Covered topics include problems and solutions encountered due to decisions in up-front overall design, FOM design, and tool selection.  Additionally, insights will be provided relative to integration with the Runtime Infrastructure Next Generation (RTI-NG) 1.3.PurposeThis paper’s goal is to help other development efforts save time, effort, and money.  In the concluding forum of the Spring 2000 Simulation Interoperability Workshop, a gentleman voiced a plea for more papers on the conversion process from the Distributed Interactive Simulation (DIS) format to the High Level Architecture (HLA).  This paper provides insights relative to that conversion process.  The Air Force Research Laboratory Warfighter Training Research Division (AFRL/HEA) has gained much experience through a multi-group cooperative effort led by the Defense Modeling and Simulation Office (DMSO).  The name of the project is Tasmanian Devil, usually referred to as “TAZ”. The TAZ effort included the design of a Federation Object Model (FOM) to support a small but realistic Distributed Mission Training (DMT) scenario and the generation of HLA interfaces to support existing and developing federates in the use of the TAZ FOM.  AFRL/HEA upgraded their Network Interface Unit (NIU) to include support for the TAZ FOM interface.  The lessons presented within this paper regard the effects on the HLA interface code and executable relative to decisions made in up-front interface design, FOM design, and Ttool selection. This paper will be helpful to those designing HLA compliant interfaces as well as guide those endeavoring to develop a FOM.Up-front Design of the NIUMany decisions are made at the outset of a research effort based on the experiences of participants and the best information available. , experiences of participants, and yes, on a whim. This section outlines a few of the up-front design decisions, along with the ensuing results, that may have application to other efforts.  These decisions include porting C code to C++, building a single interface for all needs, filtering data, remote control of the simulators, and RTI selection.Porting Existing C Code to C++C++ was chosen as the development language as it already had a natural ability to interface to the HLA Run Time InterfaceInfrastructure (RTI). The, DMSO sponsored, RTI comes with a federate ambassador C++ class, “NullFederateAmbassador”.  This class has stub functions for each of the callback functions the RTI supports.  Using C++, it is a simple process to inherit all of this functionality and simply override or adapt the specific functions to be used within the NIU.  However, the natural fit of C++ did not come without a price.Global Access to Everything versus Everything in its PlaceNot only are there differences between the C and C++ languages, there is also a very distinct difference in the manner of programming or the mindset of the programmer.  For example, C++ concepts attempt to secure and hide data so that it is less likely to become corrupted.  The C programming concepts allow for data to be globally accessible.  The biggest challenge in porting the previous NIU C code to C++ was to deal with this concept of having all data globally accessible and outside functions working on all data structures from anywhere in the code.Within the C code, the translation of state information took place across multiple functions at various stages of the NIU process.  Some translations took place at the network side of the NIU while the information was in the DIS format.  Other conversions were made at the host side of the interface in a common data format (CDF) used at the lab.  Attempts to confine translation and dead reckoning algorithms to objects in the CDF were met with several timing issues and partial translations.Eventually, with some compromising, data was hidden within applicable classes and functions were relocated to become object methods.  The resulting set of code is object-oriented and allows for support of multiple types of network interfaces.One Size Fits AllIn an effort to reduce development, testing and maintenance time/costs, a decision was made to generate a single interface, named Multi-Format Capable Network Interface Unit (MFCNIU), to support in-house developed, DMT related, federates.  Figure 1 depicts a simplified block diagram for the initial system the interface will be integrated into.  The MFCNIU will support:A variety of FOM specifications including the TAZ FOM and the Real-time Platform Reference (RPR) FOMThe DIS 2.04 format specificationVarious operating systems to include: 1) Windriver vxWorks, 2) Microsoft Windows NT, 3) SUN Micro-systems SOLARIS, and 4) Silicon Graphics IRIXVarious federates to include: 1) real-time, man-in-the-loop F16F-16 simulators, 2) real-time threat generators, 3) data loggers, 4) simulation record/playback stations, 5) simulation control stations, and 6) stealths EMBED Word.Picture.8  Figure  SEQ Figure \* ARABIC 1 - Simplified System Block DiagramFigure  SEQ Figure \* ARABIC 2 - MFCNIU Block DiagramThe MFCNIU has a requirement to support the CDF already in use in the legacy interfaces for the F16F-16 simulators and the ATES threat generators.  Consequently, the MFCNIU was designed to store and work with data in this common data format. As can be seen in Figure 2, all translations from the network data format to the CDF take place at the network port of the interface code.  Not only will this work with the legacy systems as is, this will also ease development of all host products, as developers need only worry about one type of data format, the CDF.  (A second host interface, a threaded Dynamic Link Library (DLL), was added to provide alternative support for Windows NT applications.)The MFCNIU currently sportssupports interfaces for the TAZ FOM, DIS 2.04, and a CDF interface.  It works with Windows NT and vxWorks.  The MFCNIU supports the F16F-16 simulators, the ATES threat generators, and the newly developed Director’s Control Station (DCS) application.  The DCS application contains data logging, record and playback, and simulation control capabilities.  The intent of a single interface to minimize development, test, and maintenance costs has been greatly realized.  The purpose of this section is to expose some of the tradeoffs incurred in order to obtain a single interface.Data TranslationsAs with interpretation of human languages, information is sometimes lost in the translation.  It may be as simple as words that are similar but not an exact translation, or it may be that there is no equivalent expression available in the other language.  The CDF at the AFRL is similar to the DIS standards in many respects, yet it uses the geodetic (Lat/Lon) rather than the geocentric (XYZ) coordinate system; some precision is lost in the translation between the two systems.  Within the TAZ FOM structures, there are portions of data for which there is no equivalent information available within the CDF.  In these instances, default values, which may be inaccurate or misleading, are passed along in both directions.Recorder/PlaybackThe recorder/playback system, attached to the backend of the MFCNIU, is very good for the debrief system used at the AFRL; however, it is a poor choice for use as a network analyzer.  Data recorded with this system will always have the same format no matter what the network interface definition may have been.  Any recorded file can then be played back to the net without concern of what the network data format is.  This is similar in design concept to the Synthetic Environment Data Representation and Interchange Specification (SEDRIS).One shortfall for this method is that it falls prey to data translation woes.  As stated in Section 2.2.1, precision is lost in translation. The recorded data went through the translation process once and likely has precision loss in it.  When played back, that data is then put through a second translation process, which potentially increases the data corruption due to precision loss.  Though this is a concern, its affects are not nearly so dramatic as data loss due to information not being available.Only data supported by the CDF can be recorded and played back.  For example, the TAZ FOM defines a 64-bit field the data for which is generated and used by the radio federate.  This field links a data stream to a given transmitter.  The CDF has no corresponding field into which this data could be translated, passed on, and saved, therefore, it is lost. If the recorded file were to be played back to the radio federate, the radio federate would be missing a key piece of information to function properly.Windows NT DLLThe DLL version of the code includes 3 additional files to accommodate an NIU operating in its own thread with a set of C++ API function calls.  The function calls pass pointers to events and states.  This design allowed for the host application to access the state information in the containers in the center of the NIU.  The benefits of this were to eliminate the time consuming process of allocating and copying memory and to allow the host application the ability to access the data at any time.  The downfall of this was to allow an outside source, the host application, to modify the internal data of the NIU and to access the data at any time.  The lesson learned was to return to safe interface practices, take the necessary computer processing time and provide a set of valid but temporary data to the interface with appropriate controls to manage data validity.Coding and MaintainabilityThe MFCNIU code was written using only standard ANSI C++ calls.  This was done to allow a single set of code to be ported to each of the target operating systems.  Though there is only a single set of code to develop and maintain, it is a more complex set of code.Many useful features and benefits built into a development system aimed at a particular operating system could not be used, as they were not common to all operating systems.  A few global functions were developed to perform simple operations such as copying a string.  Substitute functionality needed to be developed, as favorite classes were particular to a development system and not universally available.The MFCNIU contains two types of host interfaces and 4four types of network interfaces.  Necessary control had to be implemented to allow for remote selection of interface types.  In fact, the MFCNIU comes up in the DIS interface mode.  Through various control methods, the NIU can be commanded to transition to HLA mode and join a particular federation or resign from the current federation and return to the DIS interface mode.  This added flexibility and complexity allows for easy system configuration and is in difference to several smaller, less complex, executables, one for each combination of interfaces.Error messages must be compatible with all operating systems and operating environments.  The display environments range from remote VT100 terminals connected to a board in the VME chassis to fully functional Windows development and debugger stations.  One version writes messages to terminals while another version can only write to the debugger window.  A complex system of error messages was subsequently developed.Variations in the operating conditions from platform to platform affect the operation of the MFCNIU.  Currently, he entire HLA system is still under development.  We are designing an interface based on a loosely defined interface specification (a changing FOM), we’re using an evolving unproven communications technology (the RTI) which itself is under development), and we are attempting to debug our code.  The vxWorks version of the RTI is a latecomer to the RTI set and operates differently internally.  CoincidentallyConsequently, it has a few bugs that are not availablepresent in the RTI released for other operating systems.  This difference has accounted for many hours of debug and test, questioning why the same set of MFCNIU code worked on one system but not on the other.  However, if a different set of MFCNIU code were used on each system, it would have made the situation even more difficult.  The more unproven hardware/software there is in a system, the more challenging the debugging process will be.Data FilteringReal-time hosts such as the F16F-16 simulators are limited in the number of entities they can process each frame and still maintain a 60Hz frame rate.  Likewise, image generators have limitations on the number of models they can display in a given period of time.  Therefore, filters were put in place within the NIU to limit the number of entities passed to the host applications.Filtering HLA Object MemoryInternal filtering should not affect the HLA memory.  The HLA interface actually contains object storage too.  It is this HLA storage data that gets checked for which attributes have changed to determine what data is passed to the network.  And fFor incoming datacoming in, since only partial updates come in, and the rest of the NIU expects complete records of data, a full set of the last received values is always available for translation.  The potential problem for filtering is to delete objects out of the HLA storage.In the MFCNIU, when the RTI sends a callback saying that it has discovered a new object, the MFCNIU immediately requestsasks the RTI to request a full set of attributes for the newly discovered object.  Those attributes are subsequently added to the HLA storage for that object.  If the object were to be subsequently deleted using an internal filter, the non-changing data would be lost.  This is because the RTI still knows about the object and will, therefore, not callback with a discoverObject callback.  The MFCNIU would never request the full set of attributes, and there would only be partial data available via the object attribute updates.In reality, the MFCNIU will simply complain that it was unable to locate a corresponding object in its memory and would drop the data.  This could be used as the trigger to request a new set of attributes and the object could be added again.  However that would not be practical, as it would continue this filter-add cycle until the object was removed from the net or the object was no longer filtered.  What this implies then is that a full set of objects must be kept in the HLA storage memory, with no internal filtering.  Data Distribution Management (DDM) was not part of the TAZ effort.  However, conceptually, DDM should reduce this HLA object storage requirement to only objects that meet the DDM parameters set by the federate.Time-out FiltersAn important filter specified in the DIS interface is based on time-outs.  If the NIU does not receive an update for a given entity within a specified time period, the entity is removed from the NIU internal memory.  This filter is not dictated within the HLA specifications.  This is left as an agreement between federates within the federation.  In the TAZ federation, the objects update rate ranges from multiple times per second to once per simulation.  Consequently, the time-out values were set to 99999 seconds.  The problem here is that entities are now left indefinitely in the NIU internal memory filling up very valuable slots.The current MFCNIU design will have to be thought over again.  Without an update, no entities are removed from the NIU internal memory.  Consequently, missiles that fly out and never destruct are left in memory. Federates that hang up and are subsequently removed from the federation leave objects in the NIU memory.  The result is a federate with a reduced capability to process new entity objects as some memory slots are filled with invalid objects.  Additionally, the NIU continues to dead reckon the invalid objects and provide those updates to the host federate.Remote ControlChanges were made to the original design of the MFCNIU to accommodate a remote control concept to lengthen the lifespan of the director and the simulator components.  Largely due to the current unstable environment of a large HLA federation, the federation would sometimes find itself in a restart mode. As federates failed, the RTI would stop servicing working federates and concentrate its efforts on the one that wasn’t responding.  This usually led to a restart of the federation.  This would happen anytime from startup to finish.  Sometimes the RTI itself would hang up.  At each restart, the vipers F-16 simulators need to be reset.  A hardware reset to the viper’sF-16’s VME chassis affects every computer, monitor, gauge, and motor in the simulator.  Occasionally, one of the components failed to start up correctly thereby causing additional simulator resets  and federation restarts.  With multiple simulators, new and developing interfaces, and a test and research environment, resets to the viper simulators were becoming a rather frequent occurrence.  A stable and consistent interface was necessary for startup and shutdown to save wear and tear on the system.Originally, the MFCNIU was designed to startup with the type of network interface (DIS, TAZ, or CDF) that was specified in a defaults file.  This approach was cumbersome at best.  Each time the interface was to change, every defaults file had to be modified.  Aand the viperF-16 simulators had to be reset.  Modifications were made to start the simulators in a DIS interface mode.  From this mode, the status of the simulators could be monitored from a remote location.  Then when the RTI executive was up and all federates appeared to be functioning properly, the viperssimulators could be commanded remotely to join the federation.  Provisions were also made to provide a command to resign them vipers from the federation and return to DIS mode.With this approach, the simulators can always communicate with the director’s station.  The federation and associated files can be specified from a single location.  The status of the simulators can be determined prior to attempting to join the federation, and possibly bringing the federation down.  The simulator can be commanded back to a stable interface until the federation is ready to startup again.  This approach was a change from the original design and was well worth the effort.  to make the change.FOM Design IssuesFOM design can wasteconsume precious time.  This is not in reference to the time spent designing the FOM, but, rather, the time spent implementing the FOM specifications in actual code.  The design of the FOM affects the time to code, time to test, time to debug, time to maintain, and time to execute.  The Phase 1 TAZ FOM specified thirty-three interaction classes.  There was much debate over the design of some of these interactions and stress over the implied code implementation.  The code implementation wreaked havoc with the design of the MFCNIU.  Less than half of the interactions were actually implemented during the first six months of development time.  However, in Phase 2, design control of site-specific interactions was turned over to the individual sites.  The core set of interactions dropped to twenty-three and the AFRL/HEA site-specific interactions jumped to forty-two.  Code for all but 5five interactions was completed in less than two months.  Implementation of the other 5five interactions had been put on hold.FOM design must consider the difficulty of code implementation. The information necessary to be passed within a given FOM specification may be passed in a variety of ways.  It is virtually limited only by the mind of the FOM developer.  However, the actual code implementation for the FOM specification may be less than optimal and require more time and effort to produce and maintain. This section will discuss some of the ways the design of the FOM affected the NIU code development.Makeup of the TAZ FOMThe TAZ FOM is flexible and modifiable at near runtime to support the particular needs of some federates.  The TAZ FOM is comprised of a core set of objects and interactions termed the Core TAZ FOM.  Additional interactions are added for each federate group on an as needed basis.  These additions could be considered the individual federate’s FOM.  For instance, the TAZ FOM used at the AFRL/HEA is comprised of the following:Core TAZ FOM,Joint Semi-Automated Forces (JSAF) JSAF FOM,Data Collection Tool (DCT) FOM, andAFRLHEA FOM.Within the freeware Object Model Development Tool (OMDT) application, a manual copy and paste operation is used to merge the FOM components together.  (With the exception of the DCT FOM, which is an automated process.)  The order in which pieces of a FOM are merged is important.  Enumerations are first, followed by the complex data types, then the objects and/or interactions.  If one copies objects and interactions first, data loss will occur for the as yet undefined enumerations and data structures.Having merged the FOM components together, the new Fed file is provided to each federate to install as appropriate.  Only federates associated with their FOM need to know the enclosed data structures.  No other federate will likely subscribe to the objects and interactions contained therein.  (Again, with the exception of the DCT which can subscribe to all enclosed interactions and objects.)  This provides a level of versatility and reuse.There are a couple downfalls to this approach.  Configuration management for a large federation would be cumbersome trying to maintain all FOM additions from each federate.  Then, after merging all federate components, the DCT tool must apply its changes.  Then the FED file can be distributed to each federate.  A larger problem occurs if additional tools use the same concept as the DCT tool and need to be last to update the FED file.Object IdentificationIn the TAZ federation, the object identification scheme was required to support various types of objects and identification methods.    Three different schemes were used during Phase I and Phase II of the TAZ project.  The three schemes used were 1) the RTIHandle, 2) the registered object name, and 3) the Entity Id.  The first two systems had shortfalls with regards to supporting the legacy system.  The main issue was the lack of Entity Id information within the TAZ FOM specification.  Because this key information was missing from the specification, various workarounds were generated to supplement the FOM.Identification via RTI HandleThe Phase 1 TAZ FOM identified objects by passing the RTIHandle.  Problems began immediately with this approach.  The F16F-16 simulators only react to interactions addressed to their individual DIS Entity Id.  One very important interaction processed by the F16F-16 is the setting of its initial conditions.  When the NIU registered the F16F-16 with the RTI, it produced a table entry cross-referencing the Entity Id with the RTIHandle.  However, no other federate, including the Control Station, is capable of making that same cross-reference for that federate.  Therefore, no federate was able to tell who the other federates were.  In particular, the control station could not determine which RTIHandle to use to address a set of initial conditions to.  So key names were entered in the marking field to allow the Control Station to create a cross-reference table for sending initial conditions.  In this situation, the intent of an object attribute, “marking field”, was compromised in order to pass Id information.  Worse yet, the simulator software and Control Station software were no longer separate from the network but were modified to work with a particular interface type.The RTIHandle, being randomly generated, has other problems being used as the method for federate identification.  When analyzing or playing back recorded data, the RTIHandle does not provide information as to which federate it represents.  It becomes a challenge to determine which federate shot and which federate was shot.  It is nearly impossible to playback to a simulator, as the translation table now resides in the playback system and not the simulator.  Also, registered RTIHandles during playback will, in all likelihood, not match the RTIHandles that exist in the interactions such as fire, detonate, and initial conditions.  The random nature of the RTIHandle makes it a poor candidate for federate identification.  Consequently, the Phase 2 TAZ FOM switched to identifying federates using the predefined, registered object name.Identification via Registered Object NameUsing the registered object name to pass federate identification was better than the RTIHandle.  However, this approach still carries with it inherent problems, both conceptual and practical.  These problems encompass both conceptual and actual problems.  Though workarounds can be found for the actual problems, they are CPU intensive and inconsistent.Uncontrolled ContentConceptually, it seems fundamentally wrong to attempt to convey information outside the FOM specification.  The RTIHandle and the registered object name are both outside the FOM specification.  There is nothing in the FOM that dictates either the information or its format that may be included within the object name.  The AFRL/HEA successfully passed the much-needed entity Id information between its own federates using the registered object name.  However, no other federate used the same naming conventions.  Therefore, the MFCNIU code contained a path for string names that matched the AFRL/HEA convention and one for string names that did not.  Here we see code becoming more complicated and slower in execution due to the lack of specification, because the transport method resides in a field with no defined data format.Encoded Entity IdCreating an object name simply by using the entity Id structure information will cause an object registration failure with the RTI as soon as an entity Id is reused.  The emitter, transmitter, and receiver objects all carry the entity Id of the host rather than a unique one for themselves.  One solution is to add a fourth id value to the string.  This value must have a unique offset for each type of subsystem, for example, to set transmitter 1 apart from emitter 1.  Next, a fifth value is added to set one beam apart from another from the same emitter.  The information can be passed in this manner provided there is an agreement to the string format and the data offsets.Additional and Slower CodeAn additional cross-reference table, between the Entity Id, the object name, and the RTIHandle, must be generated and maintained.  Now, there are three cross-reference tables to create and maintain during execution; one each to allow object lookup by Entity Id, object name, and RTIHandle.  The RTIHandle lookup cannot be removed, as some callbacks, notably removeObjectInstance, do not guarantee the object name to be valid in the argument list.  The generation, maintenance, and use of lookup tables can be expensive in terms of processing time.  Now we have added the additional processing burden of a third table to create and maintain.  However, switching to another scheme will not reduce this overhead unless the other scheme is able to make use of one of the two existing lookup methods.Race ConditionsA race condition exists between objects and interactions, which may cause interactions to have invalid federate identification.  For example, the F16F-16 simulator creates a missile object the same frame it also creates the MissileFire interaction.  If the NIU processed the interactions prior to processing the objects, the munitions Id contained in the interaction could not be translated, as the object would not have been registered yet.  The sending federate can make sure this situation does not occur by processing objects prior to interactions. However, due to network collisions during data transmission and possibly different processing queues within the RTI, the order in which the interactions are processed is not guaranteed which leaves the receiving federates vulnerable to this race condition.  If the receiving federate receives a callback from the RTI to process the interaction prior to the object, the resulting munitions entity Id will be invalid.Unregistered ObjectsRegistered object names, as well as RTIHandles, only provide reference to objects that are registered.  No method is provided whereby components within a federate could be addressed.  For example, neither the NIU nor the Visual Interface Unit (VIU) of the federate can be addressed to modify its operational parameters from a remote station.  Beyond that, federates may not be addressed as some are not registered objects.  For instance, a control station is not an object defined within the FOM.  Therefore, the control station cannot be a registered object and doesn’t have a registered object name.  A control station sends interactions with identification for the originator (the control station) and the receiver (the simulator).  Since a federate will not receive an update or discover object with reference to the control station, no table entry will be created in its cross-reference table.  Yet, some name must be generated and placed in both the cross-reference table and the interaction.  On the receiving end, the unregistered string name must cause the creation of a unique entity Id with which the federate can then address a response to.  This condition can be extended to loggers, threat generators and servers of various types that may need to respond to a variety of action requests but have no registered string name to be addressed by.  Federates of this type will need to create table entries using their registered federate name.  Then, other federates can implement MOM functionality to obtain a list of registered federates.  Further, provisions must be made to allow for special string names that convey the idea of global addressing.  Thus, allowing the control station to send out a federation-wide, site-wide, or federate-specific start interaction or the like.InconsistencyThe use of the object string name lacks consistency, which is inefficient.  String names represent objects that are registered, represent federates that are not able to be registered, represent sub-components of federates, represent subsets of federates within the federation, represent the entire federation, are not confined to a given format, and may or may not contain necessary information.  Each condition requires a different method, or set of methods, to process.  They require a cross-referencing scheme to obtain the entity Id.  In the end, using the object string name as the method of federate identification causes more complex code and inefficiency in execution time.Identification via Entity Id StructureInclusion of the Entity Id within the interactions proved to be the best solution for the legacy system.  The AFRL/HEA-specific addition to the FOM contained 42 interactions.  Each of these interactions contained the Entity Id of both the receiver and the sender.  This scheme allows for addressing of sub-components such as the NIU.  It provides for identifying unregistered objects or federates.  It eliminates problems with the race condition. It was easy to implement and fast to execute.  This scheme never required any table lookups and, in stark contrast to the lookup tables, there was not a single problem encountered.Additional timesaving would be realized if the Entity Id scheme were to be expanded to the core TAZ FOM objects and interactions.  Each update to a subsystem object would eliminate the table lookup for its host’s Entity Id.  For example, an update for an emitter would not require a table lookup to find out the Entity Id of the Host object.  Each interaction, which includes the Id of at least two objects, would eliminate the need for both table lookups.  The one notable exception would be in the warfare interactions that include three object Ids.  Within this particular set of interactions, specific object information, the munitions’ orientation, was added.  A table lookup on the sending side is required to obtain this information from the munition object and supply it with the interaction.  Still, for a single warfare interaction, the table lookups reduced from 6 to 1 for both sending and receiving.  Additionally, this one lookup can use the existing Entity Id method so no additional code is generated to support it.  A common identification scheme, such as the Entity Id, that is repeatable and provides a priori knowledge of a federate’s Id will save time in development, test, maintenance, and execution.Consistency in DesignLack of consistency in a FOM specification will cause additions to code development, test, maintenance, and execution times. For instance, a given federate may host multiple emitters, transmitters, and receivers.  To address a given emitter, the emitter object within the TAZ FOM contains fields for the host object Id and the emitter Id number.  This addresses the specific emitter within the host.  The translation of the emitter Id is quick and easy as it is a natural fit for the DIS structures.  On the other hand, to address a given receiver or transmitter within the TAZ FOM, there is only a host object Id.  The missing radio Id is provided via the naming convention used by the radio federate.  Parsing the object’s string name provides the missing information link.  Providing radio federates don’t change or as long as their object naming conventions stay the same, all of the information can be obtained.  HBut nowever, now multiple methods are used to accomplish essentially the same type of task.Another example of inconsistency may be found in the interactions.  Request/response interactions typically provide a request Id parameter; this way the initiating federate can correlate the request Id in the received response interaction to the Id contained in the request it sent out.  The core TAZ FOM contains three sets of request/response types of interactions:Health Request – Health Report,Ping Request – Ping Report, andPing – Ping Ack.Of these, only the Health Report responds with the Request Id.  The federates sending the Ping Request and Ping interactions will need to develop another way keep track of responses to requests.And lastly, a review of section 3.2 provides a good example of inconsistency in the treatment of federate identification.  Though the identification method is the same, a string name, the processing of it is different with the type of object, the type of federate, and with interactions as opposed to objects.  This idea of consistency provides for a huge timesaving.  Only a single method needs to be developed, tested, maintained, and executed.Inefficiency by designAnother area of concern is inefficiency by design.  For example, the process of searching for an object in a list, table, or container is costly in terms of CPU time.  Keeping this activity at a bare minimum is a must for real-time performance and/or large-scale simulations.  We noted two areas where, by design, an update for a single object required the lookup of additional objects to complete.The first example is the update for a beam object.  When an update for a beam arrives, the beam object must be looked up in order to obtain the unchanging host emitter Id.  The host emitter must then be looked up to obtain the emitter’s host Id and the emitter number.  Then the host Id must be looked up in the cross-reference table to obtain the corresponding entity Id.  A more efficient and object-oriented method would provide all information in the object necessary for it to take care of itself.  In this instance, adding the host Id and the emitter number to the beam would prevent the additional lookup of the emitter object.  The cost would be to send that information once to each requesting federate, usually done at federation startup.  The information should be readily available at the sending federate.The second example deals with an interaction.  The design team felt it might be useful in the future to have information about the munitions object available in the WeaponsFire interaction.  The munitions’ orientation parameter was added to the interaction.  Once again, a race condition is introduced.  The munitions object must be created and processed prior to the interaction being processed and sent.  The munitions object can then be looked up and the specified data can be transferred. The combining of object data within an interaction provided the inefficiency for this situation.  Additional code had to be generated to allow interaction translation libraries access to object information.A third example deals with attempting to incorporate HLA concepts no matter what.  The particular HLA concept referred to requires all information defined in the FOM, passed as attributes and parameters, to be bounded or enumerated within the FOM.  This requires a specific field for each data type sent.  The F16F-16 simulator has a list of approximately 150 different parameters that can be set or queried against.  Several parameters, such as wing station and stores, are sent multiple times.  The order in which data is received is important so that stores can be applied to the correct wing station.  The implementation of this would require a huge interaction, several parameters grouped together into structures, and all parameters being set as an array.  The end result is a large, complex interaction which only satisfies the present needs of the F16F-16 simulator.  Every simulator type that works with the DIS Data, DataQuery, and SetData protocol data units (PDUs) would likely require their own interaction, as the parameter sets would not match.  Additionally, each time a simulator was modified to include a new parameter, the FOM would have to be modified.Some related concerns with this approach deal with data that are unknown to the interface developer.  For instance, AFRL/HEA desired to pass proprietary information it obtains from one black box to another black box.  The format and the content were unknown.  It was impossible to meet the conditions that the HLA concept required.  Beyond that, some groups may not desire to show all their information due to it being classified, encrypted, proprietary, or simply not ready for public consumption.In general, this HLA concept is goodbeneficial.  It provides for a well-defined interface specification.  Tools such as the Data Collection Tool (DCT) are able to use that information to provide user-readable values in reports.  For example, a report might contain the value of “USA” for the country field rather than the number 225.  RConceptually and pealistically, however, it is a good concept but not for every conditionnot always practical or even possible to implement..  Sometimes, attempting to force a square peg in a round hole borders on the ridiculous.Data StructureConsideration must be given to the actual data structure within the FOM design.  The arrangement and order of parameters and attributes along with the declaration of data types plays an important part in the overall execution of the federation.Grouping AttributesEach attribute sent has overhead associated with it.  Each attribute is sent with an Id and size.  It is individually processed at both the sending and the receiving sides.  Therefore, there are benefits to grouping variables together into structures.  In this way, some network bandwidth is preserved, though this seems minimal.  More importantly, though, processing time to update and reflect attributes is significantly reduced.  A single time through the switch statement and a quick call using memcpy and several attributes have been updated.  Of course, putting all the attributes into a single structure would tend to increase bandwidth as all fields contained within the structure would have to be sent every time.  Somewhere in-between is a happy medium.Uncommon Data TypesNot all operating systems support the same data types.  This might wreak havoc for some systems attempting to comply with a FOM specification.  For instance, the vxWorks operating system does not support a 64-bit integer.  Fortunately, an equivalent structure of 2 32-bit integers can be used in its place but that could become tricky if the variable is used in mathematical equations.EnumerationsAnother data structure, or rather a data type, to be careful with is the enumerator.  In C/C++, an enum is defined as an int.  An int is defined differently depending upon the operating system.  For the most part, an int is defined as a 32-bit signed integer.  However, there are some operating systems, which define it as a 16-bit signed integer.  If the sending federate uses a 32-bit enumeration and the receiving federate expects a 16-bit enumeration, memory errors may ensue.  Additionally, sometimes enumeration names in the FOM specification contain a one or two digit suffix indicating the bit-size of the enumeration.  To implement those correctly, one would need to use bytes, shorts, and longs with #define statements for “textual values” rather than the single sized enum.ArraysWhen a variable length array is contained within a structure, the order or placement of the structure’s fields becomes important. If the variable defining the number of items contained in the array was placed after the array, in the structure order, one would be unable to know how to extract any data from the structure that comes after the array, including the array itself.  Good practice would put the array at the end of the structure with the item count variable just prior to it.Data alignmentSome systems require the data to be aligned in memory on boundaries for the size of the data.  For instance, a 64-bit floating-point number would have to be positioned in memory on an address that is evenly divisible by 8 bytes.  So if a structure, as defined in the FOM, were to contain say a 32-bit integer followed by a 64-bit floating-point number, the system would crash if the code attempted to access the float directly.  Rather the code must first copy the 8 bytes to an aligned address before it can be used as a float.  There are two options for this example; first the structure could be re-arranged to put the 64-bit variable first followed by the 32-bit variable, or second, a 32-bit “padding” variable could be added to the structure prior to the 64-bit variable.  Both situations would put the 64-bit variable and the 32-bit variable at memory address boundaries that are evenly divisible by the size of the variable.  Defining structures that force the code to first copy pieces of the structure to other variables prior to accessing them as their true data types is harder to read, harder to maintain, and less efficient.Tool Selection IssuesThe availability and selection of development tools can speed the development process many fold.  A proper set of tools provides the ability to generate code in minutes as opposed to weeks; they provide opportunities to test and validate the product; they may save money by not tying up valuable and expensive resources; they may provide much better debugging environments; and they may shorten the development time while extending the life of the simulator.Automated code generatorsOne of the first items on the “To Do” list when starting the conversion process should be to select an automated code generator.  The AFRL/HEA opted to use the Original Sim product until it was determined that it would not support the vxWorks operating system.  At this point the developer quickly determined that a code generator would eliminate a great deal of redundant, tedious, and somewhat boring work.  A prototype code generator, HIGEN, was developed.  HIGEN generated code for the object and interaction classes as well as an improved RTI ambassador class.  Further, it generated header files containing structures, definitions, and enumerations.  The code generator saved a great deal of time and effort in developing and maintaining the interface and it did this many times.With the project’s unique opportunity to develop the TAZ FOM, came the challenge of keeping the HLA interface in sync with a rather fluid FOM specification.  For each FOM update during Phase 1, the code generator was used to create a new set of files rather than attempting to edit the old ones.  This helped to ensure that all changes made to the FOM were captured and implemented in code.  Even small changes to the FOM specification could cause a ripple of changes across several sections of code.  Each change to the TAZ FOM, large or small, required only minutes to completely implement corresponding code changes.  The manual editing process left room for too many errors.  On the other hand, the code generator had to be maintained to provide for all the unique situations that arose and were not planned for.  These changes were due to modifications to the TAZ FOM and an increasing understanding of the RTI operations.  At first, these changes were being made daily with new files being generated for the next day’s efforts.  Over time, updates to the code generator became less frequent and minimal.  Eventually, maintenance of the code generator was completely dropped while refinements to the classes it had produced continued.  Yet, though the code generator was out of date, when major changes to the TAZ FOM took place early in Phase 2, the code generator was revived to generate the class files for both the core TAZ FOM and the new AFRLHEA FOM.  Manual editing ensued to provide the additional refinements.A proposal was made to develop a new code generator that would include both the FOM and the Simulation Object Model (SOM).  This improved generator would provide a library of translation functions.  The translation functions would include access to stored object attributes.  There would be a user-friendly GUI set up to aid in the process of mapping SOM attributes and parameters to FOM attributes and parameters.  Mapping information would be stored in a readable fashion to be used later to detect changes to the FOM or SOM specifications and resulting inadequacies in the current translation set.  The generated code would be operating system independent.  These are the main features that we felt would be useful in a code generator.  Of course, the market will be searched prior to development to see if there is a likely candidate available.  The biggest fear is the modifications that will need to be made to the NIU to fit a particular vender’s code methodology.  This is the reason for the recommendation to select a code generator first; then the rest of the interface can be developed around it.Test Federates a MustThe importance of test federates cannot be overstated.  Why the test federate and not the actual federate?  Several reasons come to mind.  Simulator time, simulator cost, and debug capability are the major ones.  Simulator time at the lab is at a premium.  Without test federates, no testing can be performed while the simulators are in use.  When testing and debugging code, particularly in the early stages, one expects errors and bugs to be found.  These unplanned for “features” may be somewhat harmful to the simulator.  It may be that the simulator equipment is put through an extensive number of hardware resets and power downs.  This abusive lifestyle will shorten the life of simulator components, increase maintenance costs, and leave the simulator less reliable.  Eventually, the simulator must be used for testing, but keeping this to a minimum will save time and money.Verifying Data at the InterfaceSince the data format on the “wire” is not publicly available, the next best monitoring location for network analysis takes place right after the RTI.  The “Test Federate”, put out by the DMSO-sponsored RTI developers is a quick and easy tool that was used to view the parameters and attributes being sent in selectable objects and interactions.  Though the version of the tool we had was cumbersome to use, it did help validate some interfaces and show federate developers where they were not compliant.  This was a useful tool; making it user friendly, showing data in various formats (not just hexadecimal), and validating its operation could easily make it into a VERY useful tool.Another useful tool for this effort is the DCT.  The DCT is a DMSO sponsored, freeware data logger.  The data is stored in a Microsoft Access database in tables mimicking the objects and interactions in the FOM specification.  This tool provides all information passed via the FOM specification.  This makes for great debug and analysis capability.  The tool requires a bit of setup time for a given FOM but is well worth the effort.RTI Integration IssuesCompatible RTIsAt the time the TAZ project began, there was only one RTI available that would work with the vxWorks operating system, the DMSO sponsored RTI 1.3 NG version 1.  Since that time, MÄK Technologies has also produced a vxWorks compatible RTI. Discussions with other developing RTI vendors have pointed to a lack of interest in porting their RTI product to the vxWorks operating system.  This may be shortsighted on their part.  For example, the AFRL/HEA F16F-16 simulator cockpits are based on the vxWorks operating system.  Any group that wants to include their federate in the same federation as the AFRL/HEA will need to use a compatible RTI.  The number of compatible RTIs is very limited at this point.  Now, though the AFRL/HEA may not be the goal for other federates to interface with, there are some major Air Force programs that are using vxWorks that may be very desirable to interface with.  RTI developers may want to take note.RTI UpgradesAs a federation, we have continued to upgrade to the latest RTI 1.3NG release and are currently working with version 3.  The only problems we have had in upgrading to the latest releases were in configuration management.  We used the default path names provided in the setup programs.  This required us to change environment path name variables and include and library path names within project files.  Having missed making the change in the primary set of project files that were subsequently copied over the test versions, we spent the better part of a day trying to figure out why the simulators could no longer join the federation.  The compile and link worked fine, it just happened to be with version 2 rather than version 3.RTI PollingThe RTI executive process continually attempts to communicate with each of the local RTI components using a polling process.  When one of the federates’ local RTI component fails to respond, the RTI executive process then concentrates on polling the failed federate and fails to provide sufficient support to the federates that are still working.  The reason for the communication failure being irrelevant, the entire federation is affected due to the failure of a single federate, and may cause the entire federation to fail.Debugging one’s system while connected to the RTI is a tricky situation.  When the code hits a break point and stops, the local RTI component no longer receives calls to its “tick” function.  Without calling “tick”, the local RTI does not respond to the RTI executive polling.  The affect of this is felt federation wide.VxWorks Version of the RTIThe HLA version of the NIU requires more memory, and has more code making compile and download time increase significantly. (See Table 1)DIS NIUHLA NIUExecutable Size1.2 MB64.3 MBTime to Make/Compile a single line change11 sec280 secTime to Download onto the PPC board2 sec73 secTotal System Memory allocated7.9 MB57.1 MBTable 1 – DIS vs HLA Executable comparisonsConclusionA little upfront planning, a useful set of tools, and a well thought out FOM specification can go a long way to making the conversion process a success.  The lack of any one of these areas may well cost time, money, and execution efficiency.  Several examples have been provided of lessons learned in this process.  By all means this is not an exhaustive list.  And though not all the presented examples may apply, consideration of each may provide insight or inspiration to the reader relative to areas of their concern.settings in the RTI.RID file.  We are still working with the RTI developers to remedy this situation.Author BiographiesROBERT CASE is a Senior Software Engineer for the Boeing Company assigned to the Air Force Research Laboratory’s Warfighter Training Research Division (AFRL/HEA) in Mesa, AZ.  He is the designer and developer for the MFCNIU.LANCE R. CALL is a Senior Software Engineer at the Air Force Research Laboratory (AFRL). He graduated with a Bachelor of Science degree in Electronics Engineering Technology from Brigham Young University in 1988. At AFRL he has been responsible for improving threat systems and integrating simulators with DIS & HLA. CAPT JEREMY HENDRIX is an U.S. Air Force communications officer assigned to the Air Force Research Laboratory’s Warfighter Training Research Division (AFRL/HEA) in Mesa, AZ.  He is the HLA transition team leader for AFRL/HEA.  Capt. Hendrix holds a B.S. in Aviation Computer Science from Embry-Riddle Aeronautical University in Daytona Beach, FL.PAGE  PAGE  1 EMBED Visio.Drawing.4  