Simulation-Based Design of Advanced Avionics Displays – a Two-Edged Sword (O3E-SIW-005)Mark SnyderPete DanielRich WendlandtQuantum3D, Inc7055 W. Bell Rd, Ste 6Glendale, AZ, 85308623-486-9939 HYPERLINK "mailto:msnyder@quantum3d.com" msnyder@quantum3d.com,  HYPERLINK "mailto:pdaniel@quantum3d.com" pdaniel@quantum3d.com,  HYPERLINK "mailto:rwendlandt@quantum3d.com" rwendlandt@quantum3d.comKeywords:Prototyping, Avionics, OpenGL, Simulation Based DesignABSTRACT:  Simulation and prototype-based design has often been applied to create advanced avionics systems, but the gulf between prototype and integrated, reliable, supportable embedded systems with associated training systems is often misunderstood, resulting in spiraling development costs and unrealistic schedules. Some common approaches include creating distributed simulations of avionics systems that link multiple models at various levels of fidelity.  These prototypes can include 'rehosted' code from the end platform, which can improve their fidelity.   In this paper the authors' will describe their experiences with distributed avionics simulations, and will also identify some reasons why current approaches can fall short. Also we will address what steps can be taken at the process level and what tool technology can be applied to ensure a greater chance of successful transition from prototype to product.1. INTRODUCTION Small-scale simulation is often used as a tool for generating specifications and requirements for complex human machine interfaces, or HMIs, such as the flight deck of a modern aircraft.  Simulation provides obvious benefits, including the ability to see and operate a user-centric system within a synthetic or even virtual environment.  Problems in system design, especially those related to operational usefulness, can be ironed out with up-front simulation. In the case of avionics displays, the HMIs are typically intended for deployment in an embedded environment, often with significant restraints on computing power and resources, and also software design due to safety criticality.  This situation can create a tension between the demands for rapid, prototype-based development of embedded HMIs and successful, supportable, certifiable embedded implementations of the designs.  Even when attempts are made to ‘rehost’ actual avionics code to simulation systems, problems can occur.  This paper discusses some of these pitfalls, and suggests approaches for successful use of simulation-based HMI design in embedded applications.  This paper discusses experiences in using a simulation based design (SBD) process while developing an advanced avionics system.2. BACKGROUNDSmall-scale distributed real-time simulation is a technique for creating and linking together a collection of models or simulations that are intended to mimic the design and behavior of an actual system.  This technique typically involves simulating a set of cooperating processes intended to mimic the behavior and processing of a real system, such as an avionics flight deck composed of multiple computers, controllers, and displays.  Typically used for design, HMI development, and system prototyping, these simulations can provide valuable help in developing a complex system.  Advantages can include:The ability to create cooperating models that mimic actual components of a system, such as processes or Line Replaceable Units (LRUs) in an avionics suite.The ability to define and simulate interfaces between components.The ability to treat models of varying fidelity abstractly.The ability to reuse or rehost actual software or hardware from the real system,2.1 Data InterfacesSmall-scale simulation, rather than relying on standard protocols such as Distributed Interactive Simulation (DIS) or High Level Architecture (HLA), typically uses data formats closely tied to the data interfaces of the system being simulated.  Some typical approaches include:Reflective Memory – whereby all processes share their data through a hardware-synchronized memory.Ethernet synchronization – whereby processes exchange data through networked messages with simulated data in them through broadcast or point-to-point Ethernet.Bus-based synchronization – whereby real bus interfaces, such as ARINC429, Honeywell’s ASCB, Mil-1553, etc are used to exchange simulated data.Shared memory – whereby processes on a single machine share data through a shared data area.All of these forms of synchronization share the goal of distributing simulated data between the processors and/or processes of a distributed system.   The methods differ, though, in their fidelity of representing the actual data distribution mechanisms they try to simulate.  When designing a small-scale distributed simulation, this is a key design decision.There are tradeoffs associated with the method chosen to represent and accomplish data interfaces, especially for a system intended as a prototype for an actual product deployment.  Typically, the tradeoff boils down to a single dynamic – the easier and more abstract the data interface simulation, the harder the transition to the real data interface protocols during productization.  For instance, a real ARINC 429 data input from a sensor, such as an IRS or Air Data Computer, contains data delimited by words and sent in 2’s complement format.  Specialized software is required to unpack and scale the data into a form usable by, for instance, a graphics display program using floating point—this is typically done by specialized hardware (I/O cards).  But, to simulate every hardware output as close to the embedded system as possible introduces overhead and sometimes unnecessary steps into the process.  The key is to simulate the data to the level of fidelity required to reuse the software in the target system.  This point has been well illustrated in our experience with these systems.2.2 Software StandardsA second important area to consider for using this type of simulation is the software.  This is especially true for any software intended to be reused in the actual system, and even more so for software destined for an embedded, potentially certified system such as avionics.  Some key areas to consider:Coding Language – what is the language required for the end system?  Is it destined for a safety-critical embedded OS?Tools – if tools are used, for instance to generate code, do they support the embedded constraints?  Do they have a path to deploy their output in an embedded environment?User Interface – if the software has a user interface, how will this software be deployed to the end system?  Does it rely on commercial operating system constructs like Windows or X that will not be available in the embedded environment?Perhaps the most important considerations in the software arena concern the differences between embedded and non-embedded software development.2.3 Embedded Software or Not?Many engineers begin their programming career working with UNIX, Microsoft Windows, Linux or some another commercially available operating system.  These operating systems lend themselves well to a wide range of applications programming paradigms.  They run on high-speed processors, allocate considerable amounts of memory to each process, and typically have some form of virtual memory scheme granting almost limitless resource usage.  These operating systems are updated yearly, if not more often, by their creators or by the Open Source community, providing optimizations for the latest technologies and programming paradigms—they provide an environment of flexibility.By comparison, the embedded applications programming environment is one of rigidity:  a specific operating system supporting a specific set of functionality.  The engineer may be working with a product that is decades old—and, most likely, the operating system is as old.  The engineer does not have access to limitless resources:  system resources are strictly assigned to processes which are monitored by the kernel and terminated if their resource consumption exceeds their allocation.  The engineer must weigh the advantages and disadvantages of any programming paradigm when designing an application in this environment.Some programming practices that are desirable when writing software for commercial operating systems are undesirable in embedded systems software.  The following details some techniques that should be avoided and the reasons.Recursion - a recursive function is one that calls itself.  Recursion is commonly used for traversing hierarchical data structures.  Recursion can cause excessive stack overhead and usage, which can have unforeseen effects in a resource constrained embedded environment.C++ Construction Dependencies – global C++ class objects are constructed in an unpredictable order, causing problems that are difficult to track, test, and certify for safe operations.  This can also cause issues when accessing static class variables in a constructor. Dynamic memory allocation - allocating memory from the heap using new or malloc is a practice that is taken for granted on commercial operating systems and is almost always avoided on embedded systems.  There must be straightforward ways to determine the total resource requirement for a process.  Many safety-critical operating systems do not provide a heap for this reason.  Memory management schemes that provide similar capabilities can be implemented, but must be used with care.Large class-based systems - These are the norm for a new generation of programmers, but the object oriented paradigm is not well-suited to many embedded environments.  Using instances of class objects for commonly used data constructs is very helpful for encapsulation and protection, as well as, for the niceties of construction time initialization.  However, large class systems including inheritance and virtual functions are typically inefficient, difficult to maintain, and difficult to debug.  More of the stack is required for each function call, more processor time is taken to call functions due to virtual function pointer table access, and construction time problems as described in the paragraph above are ever present.  Overuse of Threads – embedded systems often require hard real-time scheduling of their processor time.  A design heavily dependent on threads, locks (semaphore, mutex), and other synchronization may be extremely difficult to adapt to this type of operating environment.2.4 Advanced RequirementsThe above list of constraints would imply that simplicity is the key to making a prototype small-scale simulation that has easily-reused components.  The main issue facing system designers today, especially in avionics, is that complexity, especially software complexity, has increased exponentially, which makes a simple design more difficult to achieve.  Some areas where complexity is increasing in avionics are:HMI complexity.  User interaction with HMIs is becoming increasingly complex.  One key trend in avionics is the replacement of dedicated ‘hard’ controllers, such as radio tuning units, with ‘soft’ controls on graphics displaysData complexity.  Data is no longer just readouts of sensor inputs.  Fused map/sensor displays, synthetic vision, and ‘smart’ systems displays are increasingly common.Graphics Complexity.  Today’s avionics displays use increasingly complex graphics systems to present data.  For instance, they may include heavy dependency on OpenGL-based 2D or 3D graphics for synthetic vision, moving map, or other complex displays.Along with increased complexity comes the need for more up-front prototyping, often with the stated (or unstated) goal of transitioning the prototype to product.  This makes the task of designing a successful simulation based prototyping scheme very challenging.  The complexity of a modern OpenGL based flight deck is one reason why even more discipline is required in the use of simulation-based development.  Since a graphics language like OpenGL is readily available on desktop systems, it becomes all-too-easy to ‘whip up’ prototype displays that look effective and compelling.  It can be difficult for customers, management, and others to understand the gulf between the prototype and the fielded system.  This has been shown in our experience working on advanced avionics display applications.3. EXPERIENCEThe authors were involved in several simulation-based developments of avionics systems in the last few years.  In our case, the flight decks being developed were for the commercial aviation industry.  OpenGL and hardware accelerated embedded graphics systems were new technologies being implemented into the avionics systems, and PC-based prototypes were used to validate the design of flight deck’s distributed HMI.3.1 Simulation System Description The simulation system was a UDP based distributed simulation intended to simulate a flight deck and the components of an avionics system necessary to validate the display and control system, or HMI.  It was implemented using standard PCs with commercial graphics cards and a combination of commercial and avionics hardware. The simulation system included a mix of rehosted or simulated avionics software components at varying levels of fidelity.  For instance, the Flight Management System (FMS) code in the simulation system was almost entirely rehosted from actual avionics, while the Air Data (IRS, ADC, Radios, etc) was entirely simulated, even through commercial packages like Microsoft Flight Simulator in some cases.  In general, the fidelity of a component was tied to its importance in the HMI simulation.  For instance, the FMS was a key area for HMI development, so a high fidelity FMS was important.  But hand-flight of the aircraft was not critical to the simulation system’s goals, so this area was not as important.  Representative aircraft models were used rather than specific ones.  A typical simulation system layout is shown below.The avionics data bus simulation we implemented in the system was an Ethernet driven distributed shared memory scheme.  It was intended to make data available in synchronized shared memory buffers to each process in the simulation, on any computer in the simulation.  This scheme is shown below:3.2 Simulation System Results The system was used for simulation-based design of flight decks, as well as, for human factors testing, customer demonstrations, engineering test and support, and desktop simulation purposes.  It was also used in several flight test activities to validate display designs in flight. The system was a success in many ways.  It helped to win business, and provided much early-visibility into HMI design and performance.  It provided the ability to work with the customer to clearly define system requirements early in the design cycle.  It was an excellent prototyping environment for these purposes.  The system  was also used as the springboard to bring many new technologies to the new generation OpenGL based flight decks.  These included moving maps, synthetic vision displays, and new methods of pilot interaction with the display system. However, prototyping is not the same as full-fledged simulation-based design.  In many ways, the difference between a prototyping environment and a disciplined, planned simulation-based design effort were not well understood by those involved.  We encountered several drawbacks while using the system in the SBD role.  We have several lessons learned from our SBD experience:Lesson 1 – Ensure Data Bus FidelityOne key area we underestimated in our simulation-based development was the importance of data bus fidelity.  Our simulation design over-simplified the way that data was passed around the system, resulting in the development of much code that had to be rewritten for the embedded system.  Our system design treated data transport between system components as a part of the simulation framework, rather than as a part of the system being simulated.  Data was passed around the system transparently in the background, when in the real system, the production and consumption of data was a key part of overall system timing and software operation.  As a result of this oversimplified data bus simulation, it became difficult to perform system timing tests.  It became too easy to share data between processes by taking advantage of the simulation’s easy-to-use but unrealistic data communications scheme.  In the end, the embedded developers had to redo far too much logic, IO, and communications code that could easily have been reused from the distributed simulation system.A better approach would be to create a complete simulation of at least the software layer of any data transmission scheme being used in the embedded environment.  This simulation layer should be characterized in terms of throughput and compatibility with the real data transmission layer.  The goal is to allow software processes to make the same calls and get the same results whether they are obtaining data from a simulated source or an actual source, and thereby ensure their compatibility with the end system.  This technique is commonly used by developers of simulation and training systems, such as full-flight simulator manufacturers, to achieve the ability to insert real LRUs into simulated systems.  Lesson 2 – Design to the End SystemAnother major area the simulation design and engineering team underestimated was the importance of embedded constraints when attempting to reuse software from a simulation-based design and prototyping environment in an embedded system.  Many of the software development errors listed above, such as bloated object-oriented design, lack of concern for resource limitations, and even overuse of hard-to-embed graphical display techniques were made.   For instance, an object-oriented scheme for graphical user interface management was implemented, which was heavily reliant on dynamic memory allocation, multiple inheritance, and other ‘heavy’ software practices. The result of this was that much of the software developed using SBD had to be redone, and in several cases completely redesigned.  This affected not only the project schedules, but even the operation of the HMIs the prototype was intended to define.  When real constraints were introduced, system throughput characteristics changed, and the HMIs operated differently – sometimes better, but more often worse.  A better approach to making software that could be re-hosted to the embedded system would be to use embedded processors and operating systems much earlier in the SBD lifecycle.  The engineering environment should be set up so that, wherever possible, target processors running target OS systems can be used as nodes in the SBD environment.  Again, this goal is supported by using a high-fidelity data distribution scheme rather that a lower fidelity one.Lesson 3 – Let Everyone Team UpPerhaps the biggest drawback in our experience was the division between the simulation/prototyping team and the embedded engineering team.  The team tasked with employing SBD to define the HMI was not responsible for any part of the embedded engineering effort – although the expectation was their software would be reused.  As discussed above, this proved to be harder to achieve than originally planned.Another major drawback to this separate teams approach is the morale problems it can create.  In simple terms, people want to work on the cool new stuff.   On the other hand, the people actually doing the advanced simulation work did not adequately consider the impact of their activities on the embedded development team.  A more integrated process was needed.Lastly, the SBD environment was underutilized because of this division of effort.  Although the simulation system would have made an excellent testing environment for the end software, it was seldom used in this role.  Similarly, the engineers whose job it was to create requirements specifications did not use the environment either.To make this process work better, SBD should have been introduced across a broader spectrum of engineering activities. The intended result of the SBD effort was not identified or quantified.  The creation of usable software was a general goal, but there was not a good plan for reaching it.  There were intended uses of the simulation system environment for training, requirements definition, and even test of embedded code, but the process was not in place and it was not done.  The potential uses and benefits of SBD should have been made clearer, and management-level buyoff should have been solicited for its use.  All stakeholders in the SBD process should be represented in the design and use of an SBD environment intended for engineering development.Lesson 4 – Define Your Tools and ProcessAlthough the team had many good tools to aid in the development of software for the simulation and embedded system, their use was not enforced for all of the prototyping and simulation effort.  There was no standard software design, and in many cases, display developers were left to create their displays in whatever manner they wanted – by using hand-coded graphics, object-oriented frameworks, or whatever they chose.  Well enforced tool usage can mitigate many of the factors which make SBD difficult to apply to complex engineering environments like avionics, but in our case this was not done.   What was lacking was a clear process, technical approach, and direction for SBD use.When defining an SBD process designed for application to an embedded environment, the goals of the effort should be clearly spelled out to ensure everyone works together.  Then, a clear technical direction should be established.  This direction should define tools, reuse strategies, fidelity requirements, rehost candidates, and even rehost strategies for software intended for embedded environments.  Only then should engineers start cranking out the cool prototypes, and the process and technical guidelines should be followed each step of the way.4. ConclusionJust a couple of key decisions would have meant a much larger impact for the SBD activities we undertook with the simulation system.  In particular, treating the data bus as a part of the simulation, rather than as a part of the simulation support system, would have made a large difference.  Additionally, making the embedded engineering team a part of the SBD effort and applying embedded constraints to the SBD software development would have made a big difference.  Finally, SBD should have been sold and introduced across a broader spectrum of the organization.However, there was significant success in the use of SBD.  Complex HMIs were prototyped and shown to be operationally workable on a flight deck.  Software was developed that was reused to some degree.  SBD showed the way to what could be done with modern advanced graphics on the flight deck, so overall its use must be considered valuable and a success in this case.Our experience has shown that simply applying simulation-based design to the problem of creating an advanced embedded HMI is not enough to ensure success, especially in transitioning designs and software to embedded avionics systems.  More rigor is required in tools, software design, prototype implementation, and simulation system design to ensure a successful transition of the design to an end system.  Much of this is related to the demands of creating an embedded, certified system.	 Increasingly, software development practices on modern desktop computing platforms create problems when applied to prototype environments intended for redeployment to embedded systems.  Systems with limited resources and processor throughput are quickly taxed by many modern programming practices.  For a commercial operating system, these conditions are almost never present.  For an embedded platform, these conditions are almost sure to be present—even if they are not present initially.  An initial design tuned for maximum performance is best when working in the embedded space.The process of SBD must be thoroughly understood for it to be successfully employed.  The roles of the people involved, and the goals and outputs of the simulation effort must be clearly identified.  In today’s business environment, there is little time available to be spent designing and redesigning systems.  Simulation components developed up front as prototypes must be able to be put to good use in the end product.  For this to happen, a strong, process-oriented, and technically sound approach must be used.  Much attention must be paid to the amount of code, the style of code, the system interfaces, and the selection of tools to avoid creating an unrealistic prototype that cannot be successfully implemented in a cost effective and timely manner.5. References[1] Snyder, Mark I. A Data Based Paradigm for Dynamic Graphical Human Machine Interfaces, IITSEC Proceedings, 2002[2] Bennet, Paul A. Applications of Display Prototyping and Rehosting Tools to the Development of Simulator, Flight Training Device, and Cockpit Displays, American Institute of Aeronautics and Astronautics, 1997[3] SBS Avionics Technologies.  An Interpretation of MIL-Std-1553 Version 2.0, May, 1998[4] CG2, Inc. Fulcrum – Cross Platform Data Capture, Distribution, Analysis, and Display , Version 1.2 Author BiographiesMARK SNYDER is a senior staff engineer withQuantum3d, Inc, where his responsibilities include research, design, and development of tools and software for the embedded graphics and simulation markets.  Prior to joining Quantum3d, he was employed with Honeywell International as a flight-deck engineer researching advanced avionics display applications.  Prior to that, Mr. Snyder spent 9 years in the Air Force, including an assignment as a research engineer at AFRL in New Mexico, where he was involved in distributed simulation and visualization research.  He holds a BS from Arizona State University and an MS from the Air Force Institute of Technology School of Engineering at Wright Patterson AFB, OH, and is named as inventor on several US and International patents in the avionics glass cockpit display arena.PETE DANIEL is a senior engineer with Quantum3d, Inc, developing software for embedded graphical displays.  Prior to joining Quantum3D, he was employed with Honeywell International as a flight-deck engineer working on several DO178B certified avionics applications and Honeywell’s distributed avionics simulation test bed.  He holds a BS from Embry Riddle Aeronautical University.RICH WENDLANDT is a software engineer with Quantum3d, Inc, developing software for embedded graphics and simulation systems..  Prior to joining Quantum3D, he was employed with Honeywell International building embedded displays and simulation systems for glass flight deck systems.  He has over 10 years developing software in the avionics industry.