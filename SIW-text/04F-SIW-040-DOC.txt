An Approach To Addressing Computer Generated Actor Knowledge Base SecurityMartin R. Stytz, Ph.D.Sheila B. Banks, Ph.D.Calculated InsightWashington, DCOrlando, FL HYPERLINK mailto:mstytz@worldnet.att.net mstytz@att.net,  HYPERLINK "mailto:mstytz@computer.org" mstytz@computer.org  HYPERLINK "mailto:sbanks@calculated-insight.com" sbanks@calculated-insight.com  Keywords:cyber warfare opposing force, information warfare opposing force, eXtensible Markup Language, secure knowledge bases, secure computer-generated forces, computer-generated computer security red teamsAbstractA serious impediment to implementing robust, realistic computer-generated actors (CGAs) is the time and dollar cost of knowledge base development.  There are a number of reasons for this difficulty; the chief challenge being the fact that currently each knowledge base is mostly handcrafted for a type of CGA with very little or no re-use.  The specific research reported in this paper is part of our research effort aimed at reducing the cost of knowledge base reuse, we are currently pursuing this goal by the development of a format for knowledge bases that can be used to represent a knowledge base in a reasoning system independent manner. As part of the larger project, we developed an approach to reusing knowledge base representations that is based on the eXtensible Markup Language (XML). In this paper, we consider the security issues raised by reuse and how these issues can be addressed within the XML context.As foundational work, we developed a reusable knowledge base representation format based upon XML that accomodate types CGA reasoning systems. Given that we intend to reuse large portions of each knowledge base, and would want to do so automatically, the issue of providing a secure environment for knowledge base reuse arises.  Since CGA systems are increasing in fidelity, the information they use for reasoning is becoming more accurate and contains information, such as tactics and experiential knowledge, that may need to be protected.  Therefore, a security system must be developed and put in place so that the knowledge base for each CGA, as well as the constituent parts of the knowledge base, can be protected from snooping, piracy, or misuse.  Because the intermediate format is based on XML, we embed the security designations, protection description, and other security-related information and designations within the XML-based knowledge base.  By embedding the security information in different parts of the knowledge base, we can restrict access to different parts or to the entire knowledge base automatically by controlling the access to the security-related information that they need to access the knowledge base or any portion of it.  In this approach, some technical issues arose.  These issues were generalized requirements, a design methodology for determining how to mark and identify parts of the knowledge base that should be restricted in the same manner, and how to insure that when a user/CGA accesses a part of the CGA knowledge base that they have the proper certificates and access authority for the access they desire.In this paper, we discuss an approach to solving the problem of documenting and designing computer-generated actor (CGA) knowledge.  In the paper, we review related work and provide a brief introduction to security for CGA knowledge bases as well as software protection in general.  We then discuss the requirements for the CGA knowledge base security system and then describe the resulting knowledge base security.  The paper concludes with a short summary and suggestions for future work.1.	IntroductionThe US military is in the midst of a change in its philosophy, approach, and technologies used for warfare.  Thee change in warfare is toward small formations, small but extremely accurate weapons, and high speed movement all augmented by rapid, automated transfer (push) of information between and among all military components.  This new form of warfare, in which a premium is placed upon timely, accurate information, is called network centric warfare (NCW).  For NCW to be achieved and be effective there are a number of issues that must be addressed and solved in the real-world and in the simulation world.  In the NCW battlespace of the future, warfighters will become very dependent upon the unprecedented level of detailed information available concerning the situation within a battlespace.  This reliance upon information, and the systems that gather and transport it, will induce foes to attempt to disrupt the information flows to gain an advantage over friendly operations.  The interplay between the efforts of friendly efforts to maintain their information operations and the efforts of enemy forces to disrupt them will inevitably result in conflict in cyber space.  As a result, given the importance of information flows to future combat operations, we believe that computer-generated actors (CGAs) can and should be used in the cyberbattlespace to enhance military readiness by simulating attacks upon friendly information resources.  Therefore, in this paper, we will concentrate on the development of cyberspace opposing forces and the development of knowledge bases for use by cyber warfare opposing forces.Cyberwarfare is the broadly defined term used to describe any type of hostile activity taken against computer systems, computer networks, and computerized databases with the objective of degrading or disabling the targeted system(s).  Cyberwarfare attacks make these systems unusable, degrade performance, may lead commanders to make poor decisions due to faulty data, reveal valuable secrets, and may leave behind code that could provide continuing back-door access or be activated on a predetermined event to take obstructive action.  The vulnerability of Department of Defense and commercial systems will continue to increase due to the ever increasing interconnection of systems and connection to the Internet.  As a result of these increased vulnerabilities and of the growing realization of the strategic and tactical advantage that can be gained by attacking or degrading systems, the Department of Defense and commercial sectors are striving to develop a variety of defensive cyberwarfare technologies.  The required cyberdefense technologies must provide defense against attack; enable attack assessment; provide rapid, autonomic response to attack; insure continued operation in the presence of attacks and degradation; and increase network resilience to attack.  Simulation, especially distributed simulation, is a key component in the development of cyberdefense capabilities because distributed simulation can provide an economical, standardized, scientific environment within which to develop and evaluate cyberwarfare defensive technologies.The impetus for our research is drawn from the recent technological advances in the fields of computer-generated forces1,5,6,7, information assurance, and software protection technologies.  The state of these technologies indicate that a much more realistic information warfare, or cyberwarfare, battlespace can be simulated. While the technology is in hand to begin the development of simulated cyber warfare environments, this new combat arena, the cyberbattlespace, has many unique characteristics that call for new training and rehearsal technologies to prepare warfighters to manage them and to operate within a combat environment that is unprecedented in its characteristics and in the demands placed upon humans within it.  Some of these new characteristics are the extreme speed with which events occur, the capability for rapid change of attack vectors and tactics, the difficulty humans face when developing situation awareness and mental models of the cyberbattlespace, the difficulty encountered in achieving a level of prediction for cyberbattlespace activity, and the extreme susceptibility of the combatants and civilians to intended and unintended effects of the results of operations within the cyberspace battlespace.  These capabilities and needs in sum point to the need for CGAs to simulate opposing force cyber warriors. We call this this type of CGA a Cyber Warfare Opposing Force (CW OPFOR).  The opposing force cyber warriors will be an autonomous information warfare (IW) red team capable of conducting cyber warfare exploits against friendly forces and testing their cyber warfare readiness.Before a useful CW OPFOR can be fielded, a broad-ranging research and development effort is needed.  Some of the research needs that we have identified to date are research targeted at advancing cyberbattle understanding, advancing human behavior modeling, advancing intent inferencing, and advancing information display, data mining, and hybrid reasoning. In this paper, we discuss an approach to enable the solution to the problem of development of computer-generated actor (CGA) knowledge bases for use by cyber warfare opposing force.  In order to document the architecture and design of the knowledge base so that the documentation as well as the knowledge base are extensible, flexible, and support a wide variety of activities we exploited the eXtensible Markup Language (XML), which we will discuss in Section Three.The remainder of this paper is organized as follows.  The next section contains our description of our knowledge base development approach.  Section Three contains a discussion of the CW OPFOR knowledge base representation and documentation approach using XML and the associated implementation issues.  The concluding section contains our conclusions and suggestion for further work.2.	BackgroundA cyberwarfare distributed simulation environment such as we advocate can offer a broad range of services and capabilities such as evaluation of cyber science/information assurance environments and hosting experimentation to develop and evaluate cyber science theories.  A cyberwarfare simulation environment can be used to train personnel and to develop and evaluate the strategies and tactics for responding to cyberwarfare attacks.  A cyberwarfare simulation environment can be used to develop and evaluate the analytical tools, decision support tools, and intelligent agents that assist humans in responding to cyber attacks.  A cyberwarfare simulation environment can also be used to develop and evaluate tools used for cyber command and control and to train personnel in their use.  The cyberwarfare distributed simulation environment can also be used to evaluate implemented systems in order to determine their vulnerabilities and strengths and to devise information assurance strategies.  Finally, a cyberwarfare distributed simulation environment can also be used to simulate automated attacks, practice response coordination, and develop strategies and tactics.Distributed simulation can play a significant role in developing defensive systems against large-scale cyberattacks.  Improved large-scale systems are needed because the attacks against computer networks, computer systems, and computerized databases are increasing in their sophistication and breadth; therefore, there is a need for simulating large-scale networks and computing capabilities so that defenses for these new environments can be developed and tested.  The CW OPFOR could accomplish these tasks.  Also, distributed simulation can provide the foundation for the development, testing, and evaluation of defensive layering technologies.  A layered defense strategy consists of a balance of avoidance, detection, and response techniques designed to improve security.  Currently, defensive system layering is typically confined to a single computer.  Distributed simulation coupled with the CW OPFOR can provide the conditions needed to accurately emulate the computational and networking milieu and uncertainties of the real world and thereby improve a layered defense capability.  Distributed simulation can also aid in the development of a cyberdefense development environment by capturing and portraying the key characteristics of the real-world environment, the CW OPFOR would capitalize upon this capability.  Few tools currently exist that support the design and assessment of cyberdefense technologies in systems and very few of these tools have a science-based foundation.  A formalized, broad-based approach to developing system-level cyberdefenses requires an environment for the designers and evaluators that aids them in their task and guides them through a design and evaluation methodology.Given that the previously described capabilities are required, we now turn to a discussion of the environment in which they will operate.  The articulation of the requirements for cyberwarfare simulation requires a framework for analysis.  To provide this framework, we suggest using the phases of a cyberwarfare engagement:  1) determination if an attack is underway, 2) characterization of the attack, 3) counteract and neutralization of the attack, and 4) counterattack.  Within the framework, each phase assists in understanding the defensive capabilities that are needed.  Within each phase, proper simulation of an attack and evaluation of defensive tools and techniques requires that the response of the complete system be portrayed, from disk drive to wide-area network.  Bandwidth consumption, CPU cycles consumed, data corruption, attacking software movement through the net at all levels, attacker activity, effectiveness of various defenses, adequacy of warning, damage to the affected system, and the human response (confidence, frustration, uncertainty, hesitation, etc.) must all be modeled.As a rprelude to determining how to represent the knowledge needed by the CW OPFOR, we identified the requirements for the knowledge base and for its organizational structure.  The requirements that we identified were determined during the course of a literature survey and from the concurrent examination of the types of attacks and the knowledge needed to execute each one.  The first and key requirement is that the knowledge base must be extensible in all regards.  This extensibility includes being able to add new types of attacks as they are defined, major variations on types of attacks as they are identified, and adding rules for executing specific types of attacks as they are discovered.  Secondly, the knowledge base format must also be flexible.  Any type of expertise, reasoning system, or other factor that can play a role in executing a specific attack must be able to be captured within the knowledge base in a manner that is clear, concise, economical, and maintainable.  The third requirement is that the knowledge base representation should permit a simple, straightforward mapping between the CERT and bugtraq security fault reporting system formats and the knowledge base representation.In the construction of the knowledge base DTDs, we assume without loss of generality or substance, that any authentication required to be performed between the database and database user were performed before access is granted.  However, because of the sensitivity and need for trust that must be placed in the knowledge base, one of the prime considerations for the knowledge base DTD is securing the data from tampering and piracy.  Therefore, as part of the design process we considered methods for securing the data contained in the documents.  As a result, the DTDs contain embedded elements that allow the knowledge base user to verify the authenticity and accuracy of each document formatted using the DTD.  We placed the authentication information into the DTDs in order to insure that the final requirement for the knowledge base would be satisfied, this requirement is addressed using digital signatures.  The method we use to authenticate the information is the use of digital signatures.  Before discussing the DTD formats, we turn to a discussion of XML digital signatures and their associated issues.One of the requirements for the knowledge base is to insure that the knowledge base is secure, which in general requires the use of some form of encryption and a digital signature.  While this may seem to be a straightforward requirement, it is actually more complex than might first appear due to the fact that different amounts of white space, tab characters, end of line characters, and other inconsequential portions of a document that serve to help to improve its visual appearance also lead to differences in digital signatures and encrypted text for documents that contain the same actionable information.  To insure that digital signatures and encrypted text are identical and correct across computing platforms, the documents must be properly canonicalized and thereby address the need to support different computing platforms in order to yield correct and consistent signatures and encrypted/decrypted text irregardless of the CPU or operating system used. Because of the variability in document format the documents must be made to be identical; XML canonicalization deals with this issue, as discussed in the IEEE Request for Comment (RFC) document RFC3741RFC3741.In general, the canonicalization process operates by taking the input document, reading it into a canonicalization parser, which in turn performs canonical transformation operations and then outputs the final canonical form of the document.  The original document remains unaltered, so the actual knowledge base is uncorrupted.  The canonicalization process simply generates a content identical output document that is in a standard canonical form.  The canonical form can then be encrypted or signed and the canonical form is guaranteed to yield a repeatable encrypted or signed output on every computing platform. The document output canonical transformations make sure that special characters in CDATA sections are handled as character references, attribute values are normalized, white space in content is retained but eliminated between top level elements and instructions, and default attributes are added to all elements.  More complicated canonicalization rules are specified in the standard and we refer the reader to the standard for an explanation of the rules applied to canonicalize complex items.  Relative URI and URLs can also create canonicalization problems, so we recommend using fully specified paths at all times, as discussed in two other RFCsRFC2141, RFC2396.  There are a number of approaches to canonicalization (while there is a standard for operation and capabilities there is no standard implementation), the choice of technique should be based upon a security analysis and an in-depth analysis of the requirements for canonicalization for the knowledge base, which would consider issues such as performance, ease of interoperability, robustness, and extensibility.As discussed in other RFCs, SigningRFC3653 and/or encrypting a “canonical” formRFC3741 of an XML document solves the problem of insuring that identical documents are used as the basis for computing an encrypted text or digital signature, since the canonical form is guaranteed to be identical on all platforms. As a result, an untampered/unaltered document is guaranteed to yield the same signature, encrypted form, or plaintext on all computing platforms.  However, simply choosing to canonicalize all the XML documents does not completely solve the problem since canonicalization is not a simple straightforward process.  If the canconicalization process chosen is too simple, the signature is brittle and simple change can ruin the form.  On the other hand, a complex canonicalization leaves the data insecure since significant changes can be made to the text and a valid signature or encryption might still be computed.  Canonicalization is difficult because, in general, there are a number of complex issues that must be addressed.  For example, the question of how to handle white space in the XML document leads to three different situations where whitespace may appear and many different ways in which this issue can be resolved.  Because of the complexities involved in canonicalization for the XML knowledge base, we decided to use the standard canonicalization approach specified in the latest edition of the XML standardRFC3653.  Therefore, for knowledge base and DTD security purposes, whether it is for computations involving encryption or for digital signatures, the encryption and signature are computed on the canonical form of the document. In XML, a digital signature is embedded in a document using XML data structures called SignedInfo, Signature Element, and the Reference Elements (we discuss their use later in this section).  In the DTD the structure is specified using a format that is very similar in form to the basic <ELEMENT> structure.  The signature element, of course, conforms to the XML syntax, which allows XML tools to manipulate and display the signature element(s).  This convention allows signatures to be computed for complete documents, parts of documents, and/or reference items within the document.  To create an XML digital signature, the only requirement is that the signed object conform to XML syntax; therefore, any binary or text document can be signed.  For the purposes of the knowledge base, we believe that using an embedded signature is the best approach.  An embedded signature approach allows for later use of multiple signatures within a document, which allows different users to verify different parts of the document using different types of signature computation algorithms.  We should note that our approach to knowledge base security provides a mechanism for verifying the security of the information in the knowledge base (content security) and permits use of other protection techniques, such as encryption of entire documents, to provide access security.As discussed in the standard, signature generation has two steps.  The first step is the generation of the Reference elements that are placed in SignedInfo.  The second step is construction of the SignedInfo element, signing, and then creating the Signature Element.  Signature verification is also accomplished in two steps.  The first step is verification of the Signature element.  In the second step, the Reference elements in SignedInfo are verified.  The strength of the signature depends upon the signature and digest algorithms that are used, the strength of the key generation algorithm, key size, key security, and protection of cryptographic processing at least; there may be other factors as well that may be uncovered during a security analysis.  Having completed a brief review of XML digital signatures and of their need to be used in the knowledge base, we now turn to the DTDs we developed.3.	Using the   XML for CW OPFOR Knowledge Base DocumentationWe employed an iterative process to design and define the knowledge base.  As a result of the analysis performed to determine the best way to organize knowledge base information, we determined that the knowledge base should be organized based on types of software attacks.  The analysis also indicated that major threat cases should be encapsulated within each type of software attack and that major threat cases can be isolated and identified based upon the permutations of target application, host operating system, host CPU, and type of network used for a specific variation of the type of attack.  One class of major threat case is defined for each target application, host operating system, host CPU, and type of network.  Variations on each major threat case, which are called minor threat cases, are captured and defined within each major threat case and are identified/defined based upon the software application’s defenses, required attack capabilities, reasoning system that the attacker should use, and other environmental characteristics that determine the capabilities needed to accomplish the major threat case.  The minor threat cases are composed of sets of variations of sequences of exploit activity actions, the actions are specified in the specific knowledge format used to support the reasoning system that should be used for each minor threat case variation.  Each sequence of exploit actions consists of knowledge and the sequence for its use that, together, must be used to achieve the goals of the minor threat case and its encapsulating major threat case and type of attack.  By using an iterative process we could identify and refine descriptions and characteristics of attacks and their components and it aided us in developing means for expressing the knowledge required to execute each attack as well as the knowledge required to execute their major and minor threat case variations.  The iterative analysis also aided us in identification of the specific activity sequences for the major and minor threat cases that comprise each type of attack.  The resultant knowledge base structure is depicted in Figure 1.  Figure 2 contains a representation for a single attack and its contained minor threat cases defined for the knowledge base.3.	CW OPFOR Knowledge Base Representation and Initial Implementation IssuesAfter consideration and analysis, we decided to use XML as the vehicle for instantiating the knowledge base representation described in the preceding section.  The eXtensible Markup Language (XML)2,3,4 is a meta-language that supports the customized definition of the components of the language (syntax, data types, vocabulary, and operators) needed to support the interchange of data for a particular application environment.  Each application-specific definition is contained within a Document Type Definition (DTD).  The DTD describes a vocabulary and syntax for the data to be transmitted.  XML provides a basis for the development of data transmission formats that are transmitter and recipient independent and that are completely self-describing and self-contained.  In our opinion, XML permits a deeper level of specification by providing data definitions and formats that are flexible, independent, and comprehensive.Figure 1:  Use Case and Threat Case Decomposition for the CW OPFOR Knowledge DomainFigure 2: Knowledge Base Representation for a Specific Type of Attack for a Specific Major Threat Case and Its Minor Threat Case Variants.The DTDs that were defined for the knowledge base mirror the knowledge base organization presented in Figure 2.  Each DTD specifies the contents of each required document for the attack knowledge base. An example XML-based rule-based knowledge base format for a DTD is contained in Figure 3.  This sample serves as the root node for the knowledge for each major threat case within an attack type.  The root node contains prototypes for the information structure and attack action sequences for the major threat case within the attack type and pointers to the minor threat case variants for each major threat case.  As is clear from the DTD, there can be any number of prototype representations for a major threat case. Each prototype specifies the general structure of the knowledge used to execute the major threat case attack exploit.  The prototype is designed to be flexible enough to accommodate minor variations for the exploit within a minor threat case.  These prototypes are also structured so that they can be maintained and extended.  Note that there is one root node in the knowledge base for each different major threat case within a type of attack; where a major threat case is defined by a combination of type of software, type of operating system, type of CPU, and type of network that the attack targets.  For each prototype in the major threat case root node, there is a “pointer” to a list of minor threat cases.  The minor threat cases are the variations on the major threat case that are instantiated in a common, similar manner.The DTDs that we have specified are general enough to accommodate broad types of knowledge representation such as frames, rules, Bayesian networks, and fuzzy logic, but further research is required to determine which type of reasoning system that best supports each attack and its variants.    Our approach to implementation is to populate the knowledge base with rules as the first step.  Based upon the results of our literature review, it is apparent that many exploits can be captured and represented within a rule-based structure without sacrificing flexibility or robustness and that a prototype CW OPFOR using only rules in its knowledge base would be sufficient primarily to demonstrate the value and validity of the concept without incurring undue expense or technical risk.  Because most exploits can be captured within a simple knowledge base strucure, a key benefit of the CW OPFOR and the source of the majority of the cost saving that would result from its use is that the prototype CW OPFOR will have sufficient utility to execute the majority of the simple exploits, which will allow human red teams to concentrate on testing an application’s defenses with more complicated exploits.  This approach provides both an initial cost saving coupled with a shorter period for implementation of the prototype and helps to improve the security testing of the software systems.  The success of the CW OPFOR prototype will allow more extensive testing of an application’s defenses for the same cost than is possible today.  Once the prototype CW OPFOR is implemented in its initial instantiation, the stage is set for expanding the knowledge base to encompass more complicated exploits, knowledge representations, and analysis of defensive responses to threats.The outline for the signature component of the embedded digital signature is presented in Figure 3.  The digital signature format that we propose has three major components (DTD Elements), SignedInfo, SignatureValue, and KeyInfo.  The SignedInfo component (Element) contains three subparts, CanonicalizationMethod, SignatureMethod, and Reference.  The sub-elements serve to embed within the signature information that describes the methodology and algorithms used to compute the digital signature for the document.  The CanonicalizationMethod entry defines the canonicalization method used to canonicalize the document. The SignatureMethod entry defines the algorithm used to compute the signature.  As discussed in the RFC, the Reference entry specifies the data being signed, preprocessing algorithms used to prepare the data for canonicalization and computation of the digest, and the algorithms used to compute the document digest, and the document digest value.  If, in the document no value is supplied for the URI then the referred document is assumed to be the document in which the signature is embedded.The SignatureValue Element contains the signature computed for the document using the methodology and algorithms specified in the SignedInfo Element.  The value in this element is computed using the canonicalized document derived using the SignedInfo specification and the appropriate signing key and is encoded in base-64.  The KeyInfo Element contains additional information that helps the verifier to locate the appropriate verification key for the signature.  The KeyInfo entry always appears as the child of SignedInfo, EncryptedData, and Encrypted Key elements and provides information to the recipient of a document about the keying material used to compute a digital signature or to encrypt the document.  The KeyInfo element has one or more child elements that serve to specify various aspects of the keying material and all child elements of a given KeyInfo element must all refer to the same key.  As defined, each document has one or more digital signatures; if only one is used then the signature defaults to the entire data payload for the document.  If there is more than one signature used in the document, then one signature must be used to sign the data payload, others can be used to sign subsets of the payload and can also be used to digitally sign other digital signatures.  The number of digital signatures to employ and the sub-items or digital signatures to be signed should be determined during the course of a security analysis for a specific use of the knowledge base.Signature	 	SignedInfo, SignatureValue, KeyInfo	SignedInfo		CanonicalizationMethod, SignatureMethod, Reference		CanonicalizationMethod		SignatureMethod				Reference		Transforms, DigestMethod, DigestValue			Transforms			DigestMethod			DigestValue	SignatureValue	KeyInfo		KeyName, KeyValue, More …		KeyName		KeyValue		More…End SignatureFigure 3:  Outline for the Signature Portion of the Knowledge Base DTDs.Figure 4 contains the DTD specification for a major threat case.  Each minor threat case attack activity sequence node in the knowledge base specifies the attack activities for a particular variant of a minor threat case as specified in one of the prototypes in the major threat case root node.  A subset of the XML tags that we defined is presented in Figure 5.4.	Conclusions and future workThe major objective for this research project was to determine how to represent attack knowledge and major and minor threat case knowledge within a knowledge base.  Therefore, the first step that we took toward addressing this objective was the development of requirements for the knowledge base and for its organizational structure.  As we determined, the knowledge base must be extensible and able to accommodate insertion of the following: 1) new types of attacks as they are uncovered, 2) major and minor variations on types of attacks as they are identified, and 3) new activity sequences for specific types of attacks as they are discovered.  Secondly, the knowledge base format must be flexible.  Any type of expertise, reasoning system, or other factor that can play a role in executing a specific type of attack or its variations must be able to be captured within the knowledge base in a manner that is usable, clear, concise, economical, and maintainable.  The third requirement is that the knowledge base representation must permit a simple, straightforward mapping between the CERT and bugtraq security fault reporting system formats and the CW OPFOR knowledge base representation.  The knowledge base format we developed addresses all of these requirements and has been evaluated to be sure that it does so.To aid us in our analysis, we relied upon the Unified Modeling Language (UML) and the eXtensible Markup Language (XML) to document attacks, attacks variations, and to develop the knowledge base format in XML.  We employed an iterative process for both the identification and characterization of attacks and of major and minor threat cases.  The knowledge base, then, is organized as a network of attacks.  Within each attack, there is a network of major threat cases.  Within each major threat case, there is a list of minor threat cases, with the knowledge for each minor threat case organized hierarchically.In this paper, we addressed the problem of secure documentation of CGA knowledge bases for a CW OPFOR by exploiting XML and its digital signing capability.  XML provides the means for establishing the interoperable knowledge base formats for the knowledge required by the CW OPFOR to execute each type of attack.  At this point in the development of the knowledge base for the CW OPFOR, a standardized set of XML documentation for CW OPFOR knowledge bases is needed and would be beneficial given the size of the required knowledge base and the need to improve our capability to employ CGAs as realistic CW OPFORs.  While the XML documentation standardization effort will by no means be a trivial undertaking, our experience indicates that the cost is more than outweighed by the benefits.  One further area that we will address in additional research is the development of an ontology for the CW OPFOR domain.Our research indicates that two knowledge base follow-on efforts are necessary in addition to the population of the knowledge base.  One of the follow-on knowledge base efforts needs to be directed at capturing and organizing meta-knowledge concerning application security, computer security, and software structuring.  In brief, meta-knowledge serves to provide the knowledge necessary for command and control of the system and would be founded upon the ontology development effort.  The other knowledge base effort should be targeted at developing a broad database schema for the knowledge base.  In this effort, we have defined what data should be available in an individual data item in the knowledge base, but it is clear that the complete knowledge base will be very large and must also be expandable.  The size of the knowledge base indicates that decisions about the overall structure of the knowledge base (whether it should be hierarchical, network, or relational) must be made and then a schema for organizing the knowledge must be developed.ReferencesBanks, S.B. and Stytz, M.R.   (2003) “Progress And Prospects For The Development Of Computer Generated Actors For Military Simulation Part 2 – Reasoning System Architectures And Human Behavior Modeling,” Presence: Teleoperators and Virtual Environments, vol 12, no. 4, August, pp. 422-436.Copenkus, A. & Hoodbhoy, F. (1999) Applied XML:  A Toolkit for Programmers. John Wiley & Sons: New York, NY.Harold, E.R. (1999) XML: Extensible Markup Language. IDG Books Worldwide: Foster City, CA.St. Laurent, S.; St. Laurent, S.; & St. Laurent, S. (1999)  XML:  A Primer. 2nd edition.  IDG Books Worldwide: Foster City, CA.Stytz, M.R. and Banks, S.B.  (2001) “Using The Extensible Markup Language To Document The Authority And Source Pedigree For Computer-Generated Actor Knowledgebases,” Proceedings of the 2001 European Simulation Interoperability Workshop, London, England, UK, 25 – 27 June,  pp. 587-598.Stytz, M.R. and Banks, S.B.  (2003) “Progress And Prospects For The Development Of Computer Generated Actors For Military Simulation Part 3 - The Road Ahead,” Presence: Teleoperators and Virtual Environments, vol 12, no. 3, December, pp. 629-643.Stytz, M.R. and Banks, S.B.  (2003) “Progress And Prospects For The Development Of Computer Generated Actors For Military Simulation Part 1 – Introduction And Background,” Presence: Teleoperators and Virtual Environments, vol 12, no. 3, June, pp. 311-325.Figure 4: Attack Type Major Threat Case Specific Document Type Definition (DTD).<?XML version=”1.0” encoding=”UTF-8”?><!DOCTYPE KNOWLEDGEBASE SYSTEM [<!—START MAJOR THREAT CASE DOCUMENT PAYLOAD  --><!ELEMENT KNOWLEDGEBASE (attack_case_name?, attack_case_ID+, objective+, strategy+, target_application_type, target_operating_system_type, target_network_type, target_CPU_type, expertise+, exploited_vulnerabilities+, CERT_advisory_number+, bugtraq_identifier+, communications+. cooperation_and_coordination+, human_behavior_model, number_of_prototype_rules, Prototype_Rule+, number_of_minor_threat_attack_sequences, minor_threat_attack_sequence+, external_knowledgebase* , version, change_date, Signature+)><!ELEMENT	attack_case_name	(#PCDATA)><!ELEMENT	attack_case_ID	(#PCDATA)><!ELEMENT	objective 	(#PCDATA)><!ELEMENT	strategy	(#PCDATA)><!ELEMENT	target_application_type 	(#PCDATA)><!ELEMENT	target_operating_system_type	(#PCDATA)><!ELEMENT	target_network_type	(#PCDATA)><!ELEMENT	target_CPU_type	(#PCDATA)><!ELEMENT	expertise 	(#PCDATA)><!ELEMENT	exploited_vulnerabilities 	(#PCDATA)><!ELEMENT	CERT_advisory_number	(#PCDATA)><!ATTLIST	CERT_advisory_number	xlink:form	CDATA	#FIXED	“simple”	href	CDATA	#REQUIRED  ><!ELEMENT	bugtraq_identifier 		(#PCDATA)><!ATTLIST	bugtraq_identifier	xlink:form	CDATA	#FIXED	“simple”	href	CDATA	#REQUIRED  ><!ELEMENT	communications	(#PCDATA)><!ELEMENT	cooperation_and_coordination	(#PCDATA)><!ELEMENT	human_behavior_model	(#PCDATA)><!ATTLIST	human_behavior_model	xlink:form	CDATA	#FIXED	“simple”	href	CDATA	#REQUIRED  ><-- Prototype Rule Formats that are Used to Execute Attacks Within This Major Threat Case --><!ELEMENT	number_of_prototype_rules 	(#PCDATA)><!ELEMENT	Prototype_Rule 	(rule_number, type_of_rule+, content)><!ELEMENT	rule_number	(#PCDATA)><!ELEMENT	type_of_rule	((frame, frame_slot*) | rule_based | fuzzy_logic | case | neural_net | bayesian)><!ELEMENT	frame	(#PCDATA)><!ELEMENT	frame_slot	(#PCDATA)><!ELEMENT	rule_based	(#PCDATA)><!ELEMENT	fuzzy_logic	(#PCDATA)><!ELEMENT	case	(#PCDATA)><!ELEMENT	neural_net	(#PCDATA)><!ELEMENT	bayesian	(#PCDATA)><!ELEMENT	content	(formula*, variable_text*, constant_text*, variable_int*, variable_float*, constant_int*, constant_float*, fuzzy_set_name*, fuzzy_set_parameters*, fuzzy_set_hedges*, radar_status*, radio_status*, if*, then*, else*, variable_name*, case_value*, hierarchy* )><!ELEMENT	formula	(#PCDATA)><!ELEMENT	variable_text	(#PCDATA)><!ELEMENT	constant_text	(#PCDATA)><!ELEMENT	variable_int	(#PCDATA)><!ELEMENT	variable_float	(#PCDATA)><!ELEMENT	constant_int	(#PCDATA)><!ELEMENT	constant_float	(#PCDATA)><!ELEMENT	fuzzy_set_name	(#PCDATA)><!ELEMENT	fuzzy_set_parameters	(#PCDATA)><!ELEMENT	fuzzy_set_hedges	(#PCDATA)><!ELEMENT	radar_status	(#PCDATA)><!ELEMENT	radio_status	(#PCDATA)><!ELEMENT	if	(#PCDATA)><!ELEMENT	then	(#PCDATA)><!ELEMENT	else	(#PCDATA)><!ELEMENT	variable_name	(#PCDATA)><!ELEMENT	case_value	(#PCDATA)><!ELEMENT	hierarchy	(#PCDATA)><-- End Prototype Rule Formats --><-- Pointers to Minor Threat Cases That are Used to Execute Attacks Within This Major Threat Case --><!ELEMENT	number_of_minor_threat_attack_sequences 	(#PCDATA)><!ELEMENT	minor_threat_attack_sequence 	(rule_number, decision_making_system, programming_language, minor_threat_case_success_criteria+, sequence_length, sequence+)<!ELEMENT	rule_number 	(#PCDATA)><!ELEMENT	decision_making_system 	(#PCDATA)><!ELEMENT	programming_language	(#PCDATA)><-- criteria for success for a particular minor threat case, consists of a list and pointer to external references --><!ELEMENT	minor_threat_case_success_criteria	(#PCDATA)><!ATTLIST	minor_threat_case_success_criteria	xlink:form	CDATA	#FIXED	“simple”	href	CDATA	#REQUIRED  ><!ELEMENT	sequence_length 	(#PCDATA)><!ELEMENT	sequence	(#PCDATA)><!ATTLIST	sequence	xlink:form	CDATA	#FIXED	“simple”	href	CDATA	#REQUIRED  ><-- End Pointers to Minor Threat Cases --><!ELEMENT	external_knowledgebase	(#PCDATA)><!ATTLIST	external_knowledgebase	xlink:form	CDATA	#FIXED	“simple”	href	CDATA	#REQUIRED<!ELEMENT	version	(#PCDATA)><!ELEMENT	change_date	 	(#PCDATA)><!—END DOCUMENT PAYLOAD  --><! -- START SIGNATURE FOR DOCUMENT  --><!ELEMENT	Signature	 	SignedInfo, SignatureValue, KeyInfo?)><!ATTLIST	Signature	xmls	CDATA	#FIXED		 	 “http://www.w3.org/2000/09/xmldsig#’”	Id	ID	#Implied  ><!ELEMENT	SignedInfo		CanonicalizationMethod, SignatureMethod, Reference+)><!ATTLIST	SignedInfo	Id	ID	#Implied  ><!ELEMENT	CanonicalizationMethod	(#PCDATA)><!ATTLIST	CanonicalizationMethod	Algorithm	CDATA	#REQUIRED><!ELEMENT	SignatureMethod		 (#PCDATA)><!ATTLIST	SignatureMethod	Algorithm	CDATA	#REQUIRED><!ELEMENT	Reference		Transforms?, DigestMethod, DigestValue)><!ATTLIST	Reference	Id	ID	#Implied  >	URI	CDATA	#Implied  >	Type	CDATA	#Implied  ><!ELEMENT	Transforms		(#PCDATA)><!ELEMENT	DigestMethod		(#PCDATA)><!ATTLIST	DigestMethod	Algorithm	CDATA	#REQUIRED><!ELEMENT	DigestValue		(#PCDATA)><!ELEMENT	SignatureValue		(#PCDATA)><!ATTLIST	SignatureValue	Id	ID	#Implied  ><!ELEMENT	KeyInfo		(#PCDATA | KeyName | KeyValue | RetrievalMethod | X509Data | PGPData | SPKIData | MgtData)><! – KeyName and KeyValue must be supplied, the other elements are optional.  The key selected should be based upon a security analysis of the implementation, so element definitions for this and the other elements are not supplied since they will be security environment specific.  It is anticipated that only one key and one key value will be used for each document. ><!ATTLIST	KeyInfo	Id	ID	#Implied  ><!-- END SIGNATURE FOR DOCUMENT -->>         ]>Figure 5:  Select XML Tags and Their MeaningsTagMeaningattack_case_nameSpecification of the name of the attacksource_authorityLocation of factual basis or rationale for the knowledge base of for individual rules in a knowledge baseNumber_of_prototype_knowledge_representation_conventionsNumber of prototype entries contained within the foundation knowledge base for a specific type of attack.number_of_entriesNumber of entries contained within the knowledge base/document that specify the knowledge and attack sequence used to execute a specific minor threat case exploit.Prototype_ convention_numberThe particular prototype that provides a generalized description of a specific type of knowledge and sequence of activities used to execute a given minor threat case within a major threat case.  Every specific major threat case for an attack type can have one or more prototypes (one for each minor threat case).  Each minor threat case variant is represented by a prototype.EntryThe entry for each sequence specifies the knowledge used to execute a specific minor threat case exploit within each major threat case variant of type of attack for an attack type.objectiveThe purpose of the exploitstrategyStrategy for executing the exploitdecision_making_systemThe decision-making system(s) (frames, rule-based, fuzzy logic, bayesian nets, etc.) Supported by the rules in this document.  More than one decision making system can be supported by a set of rules.CERT_advisory_numberIf the attack implements an attack reported in the CERT advisory database (www.cert.org/advisories), the identifier is recorded here.  Multiple entries are comma delimited. If none are used/identified, enter Null.Bugtraq_identifierIf the attack implements an attack reported in the bugtrac archive (www.securityfocus.com/archive/1) then the bugtraq identifier is recorded.  Multiple entries are comma delimited. If none are used/identified, enter Null.target_software_typeThe software that can be attacked by the vulnerability; can be anything from a class/type of software to specific names of application programstarget_operating_system_ typeThe operating system that is assumed to be in place that hosts the targeted software against which the exploit will be executed.target_network_typeThe network across which the exploit will be executed.sequence_lengthNumber of external documents specifying specific instances of a type of attack.  This entry specifies the number of variations on a type of attack that are captured in the knowledge base.sequenceHyperlink to external document that specifies the sequence in which exploit actions are to occur, decision points, and alternatives at decision points. CERT and bugtraq are attack and vulnerability databases that are available via the web at  HYPERLINK "http://www.cert.org" http://www.cert.org and  HYPERLINK "http://www.securityfocus.com" http://www.securityfocus.com respectively. RFCs can be found on the web at  HYPERLINK "http://www.ietf.org/rfc.html" http://www.ietf.org/rfc.html  CERT and bugtraq are attack and vulnerability databases that are available via the web at  HYPERLINK "http://www.cert.org" http://www.cert.org and  HYPERLINK "http://www.securityfocus.com" http://www.securityfocus.com respectively.		PAGE  		PAGE  		PAGE  