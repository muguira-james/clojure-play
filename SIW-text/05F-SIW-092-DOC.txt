An Experiment in Command and Control System SimulationDr. Furman Haddix, Ph.D.Texas State University- San Marcosfh10@txstate.eduMr. Jack SheehanDefense Modeling and Simulation OfficeJack.Sheehan@dmso.milKeywords:command and control simulation, command and control systems, executable mission content, simulation toolsABSTRACT: 	The Military Missions and Means Framework is, among other views, an integrated procedure to inform the military decision making process. An important aspect of this is descriptions which constitute executable mission content. MATLAB© is a tool which has many uses, including engineering level simulation, for which it is used by several of the Department of Defense Intelligence Centers. There are many separate capabilities within the suite of MATLAB-compatible capabilities, including Stateflow©, which provides a finite state machine modeling capability which can be used to drive engineering level simulations in MATLAB and Simulink©, a related product. The question to be answered by this experiment was if the MATLAB/Simulink/Stateflow suite of tools could be used to simulate command and control systems, and at the same time, capture executable mission content. AFATDS (Advanced Field Artillery Tactical Data System) was used as a source of potential executable mission content in the command and control area. This paper reports the results of simulating a subset of AFATDS fire missions, utilizing OPFACS (Operational Facilities) from the Forward Observer through DIVARTY (Divisional Artillery). The simulation utilizes Stateflow in creating logic to drive OPFAC behavior and maintain OPFAC status, and Simulink as the playing field for inter-OPFAC communication. Included in the paper is a discussion of the strengths and weaknesses of this approach.1. IntroductionThe Military Missions and Means Framework is, among other views, an integrated procedure to inform the military decision making process. Its multi-level decomposition allows separation of concerns regarding the missions and means, extension of the well-regarded Vulnerability/Lethality Taxonomy [1] to command and control, and separation or combination of issues regarding opposing forces, clearly demarcates planning and decision-making concerns vis-à-vis execution and evaluation concerns, and provides a capability for unambiguous communication of concerns between warfighters, engineers, and controllers. [2] An important component of the Military Missions and Means Framework is descriptions which constitute executable mission content. This provides value added in many areas, including mission-centric, capability-based assessment, enabling transformations in many areas of military endeavor. [3]The Advanced Field Artillery Tactical Data System (AFATDS) is a multi-service (Army and Marine Corps), digitized and totally integrated fire support system. It processes fire mission and other related information to coordinate and optimize the use of all fire support assets, including mortars, field artillery, cannon, missile, air support and naval gunfire. AFATDS provides up-to-date battlefield information, target analysis and unit status, while coordinating target damage assessment and sensor operations. MATLAB© is a tool mainly used for engineering level simulation, by several of the Department of Defense Intelligence Centers. It includes Stateflow©, which provides finite state machine modeling capability and Simulink©, which allows simulation of combinational and sequential circuits.The question to be answered by this experiment is if MATLAB/ Simulink/ Stateflow suite of tools could be used as a source of potential executable mission content in the command and control area. This paper reports the results of simulating a subset of AFATDS fire missions, utilizing OPFACS (Operational Facilities) from the Forward Observer through DIVARTY (Divisional Artillery). The simulation utilizes Stateflow in creating logic to drive OPFAC behavior and maintain OPFAC status, and Simulink as the playing field for inter-OPFAC communication. The AFATDS command and control system was selected for experimentation, because of modest familiarity on the part of the principal investigator. The MATLAB suite was selected because of its common usage by Department of Defense (DoD) agencies, e.g., the intelligence centers. Thus, even if the MATLAB suite was merely practicable, rather than optimal for command and control simulation, it might still be utilized because of the availability of software licenses, and trained personnel, among potential users.2. The MATLAB tool suiteThe MATLAB tool suite is both a high-level language and a general purpose technical computing and development environment. It provides core mathematics and advanced graphical tools for data analysis, visualization, algorithm design, and rapid application prototyping. It provides other tools beyond the three utilized in this experiment, namely MATLAB, Simulink, and Stateflow.MATLAB is a virtual machine with command line interface; that provides high level language and general purpose computing environment; an environment based on dynamic data structures, including matrices and vectors. It provides graphic and mathematical functions. The use of dynamically defined data structures supports rapid prototyping. [4]Simulink is a set of interconnectable functional and graphic blocks; supporting the creation of engineering level models that can be used to analyze real-world dynamic systems. [5] The predefined blocks in Simulink can be quickly and graphically assembled to model real-world systems within the MATLAB environment. In this experiment, most of the blocks utilized were user-defined, created with Stateflow.Stateflow is a tool for developing state transition driven blocks; and provides a graphical simulation environment for control and protocol logic. It allows user creation of finite state machine-based Simulink elements. It can access MATLAB data structures. A Stateflow chart is a Simulink block. [6]Additional MATLAB capabilities not used in this experiment, include application-specific MATLAB functions and Simulink blocks. In addition, code generators for high-level languages exist, so that the models created can be run within MATLAB, or as stand-along applications.In this experiment, several approaches were considered. A subset of these approaches were modeled. There were difficulties in implementing all of the approaches considered. Use of a monolithic Stateflow model was discarded because component reuse was difficult. Significant use of the Function Call interface was discarded because this approach did not facilitate distributed control and concurrent operations. It was further contemplated that at some point, subject matter experts without technical backgrounds might assemble plug and play modules from model libraries. The use of relatively fine-grained Stateflow charts/Simulink blocks would facilitate this. The approach used was to create each OPFAC as a separate Stateflow chart/Simulink block. (The same artifact appears as a chart in Stateflow and as a block in Simulink). Thus, command and control logic for an OPFAC, e.g., a Forward Observer, could be graphically specified in Stateflow. Then, the OPFACs could be explicitly connected to one another using the inter-block communication capabilities of Simulink. Stimulation was provided by a Time-ordered event list generator (TOEL), which was also implemented as a Stateflow chart. The act of sensing a target is simulated by sensors receiving a message from the TOEL. The TOEL object also performs a start simulation functions, sending wakeup messages to the major OPFACS. Other than these stimulating messages, the other messages of the simulation correspond to messages that would actually be transmitted in an AFATDS environment. As a proof of concept experiment, this effort was directed toward attempting to determine if there were barriers to simulating command and control systems, such as AFATDS, rather than creating a full-up simulation. Thus, only a subset of OPFACS, fire missions, messages, and fields within messages were simulated.3. Using StateflowThe principal elements of Stateflow are charts, events, states, junctions, transitions, simple data, and MATLAB (ml) data.A chart is a Stateflow model corresponding to a Simulink box. It is a Stateflow state space having states, transitions and other Stateflow elements, such as graphic functions, as components.An event is a trigger of actions; it has elements of a data element and of a message. The occurrence of an event causes the status of the states in the Stateflow diagram to be evaluated. The broadcast of an event can trigger a transition to occur or can trigger an action to be executed. In Figure1, the transition from StateA1 to StateA2 is labeled with the event transitionA1_A2 that triggers the transition to occur. A transition out of a higher level, or superstate, also implies transitions out of any active substates of the superstate. A state describes a mode of an event-driven system. There may be multiple states within a Stateflow chart. There may be multiple substates within a (super)state. Thus, multi-level hierarchical structures may be created. Stateflow provides two types of states: parallel (AND) and exclusive (OR) states. In Figure1, StateA1 is a child in the hierarchy to StateA. If a substate is active, its superstates and chart are also active.A transition is a graphical object that links one object to another. One end of a transition is attached to a source object and the other end to a destination object. A transition label describes the circumstances under which the system moves from one state to another. A transition label has two types of guards and two types of actions. The order and format of the four elements, each of which is optional, follows:     event [condition] {condition_action}		/transition_actionWhen a specified event occurs, the transition is potentially triggered. Events may be generated by actions on transition or actions within states. A condition is a Boolean expression, which must be true in order for the transition to occur. An action is either a condition_action or a transition_action. It can be a mathematical expression, library function or user-defined function. A condition_action is executed if the condition and/or event are true. A transition_action is executed only if the transition is taken. For example, transitions can be cascaded using junctions. Even if the current transition guards are true, a subsequent transition’s guard may prevent the sequence of transitions from being taken, and force a return to the previous state. When there are multiple transitions available from a state or junction, there can be at most one unlabeled transition and it is taken only if none of the labeled transitions is true. Whether a transition is taken from a state depends on the label of the transition, the conditions of the source state, and the labels of any transitions joined in series by junctions.Junctions allow connection of one or more incoming transitions to one or more outgoing transitions. A self-loop transition, in which the source state and the sink state are the same, allows the implementation of a loop. In Figure1, the connective junction is used as a decision point for two transition segments that terminate at State A1c or at State A1d, depending on whether the condition is true or false.Data objects are used to store numerical values for reference in a Stateflow diagram. Data objects are not represented directly in Figure1, although they can be used within both conditions and actions. INCLUDEPICTURE "http://www.mathworks.com/access/helpdesk/help/toolbox/stateflow/concepts4a.gif" \* MERGEFORMATINET Figure 1: Elements of Stateflow4. AFATDS Simulation A subset of AFATDS operations was simulated. The operations simulated have to do with fire missions. A fire mission can be thought of as having several phases, including initiation, allocation of resources, execution of fires, and termination. Initiation may have several sources; the model used in this experiment is that a target or need for fire support has been sensed either by a simple sensor or a command structure. Allocation of resources has to do with the need being communicated through the system until an appropriate asset allocation can be made or until the mission is denied. Execution of fires has to do with establishing communications between the sensor and the firing unit and the iterative process of target treatment. Termination involves informing all interested parties that treatment of the target has been completed. Resource allocation involves communicating the target information to from a few to ten or more OPFACs, e.g., the handoff of target information from a forward observer up the chain of command to a BDE FSE and then back down to a FA BTRY. Execution of fires primarily involves the firing unit and the sensor, plus any OPFACs required to establish the communication links, e.g., a FIST may be required to forward information from a FO to a FA BTRY. Termination involves informing all parties that the target has been treated, e.g., those not involved directly in mission execution, such as the BN FSE, BDE FSE, and FA BN. [7]5. Simulation Concept of Fire Mission Generally a fire mission is associated with a single target. Allocation of Fire Support Assets is done by an iterative procedure that finds the appropriate asset; otherwise the fire request is rejected. Sensors identify the target, e.g., FO receives a target event message from TOEL. The sensor sends an initial message to a fire support unit, e,g,, FIST. Each fire support OPFAC will deny the mission, allocate appropriate firing unit assets that it controls, or forward the message to a superior unit. This process continues until a fire support unit either denies the message or allocates a firing unit, e.g., BDE FSE allocates mission to FA BN. Fire direction units then assign the mission to subordinate units, e.g., FA BTRY, until it reaches a firing unit, e.g., DS FA PLT.Upon receiving the initial fire order message, the firing unit identifies itself to the sensor, and follows with shot and rounds complete messages, as appropriate, which are forwarded by the shortest available path back to the sensor, e.g., FO. Finally, the sensor ends the mission by sending an end of mission message, which, if appropriate might be routed to multiple OPFACs, including FIST, DS FA BTRY, DS FA PLT, DS FA BN, BDE FSE, and BN FSE.The simulation executes missions using the following message types:Fire Request – used to request fire support; Fire Order – used to allocate firing unit resources to a fire mission;Message To Observer – informs sensor of firing unit servicing its request;Shot – informs sensor that rounds for its target are in the air;Subsequent Adjustment – provides fire adjustment from sensor to firing unit;Fire For Effect – informs firing unit that last adjusting round was close enough;Rounds Complete – informs sensor that no more rounds are intended for the target; andEnd of Mission – sensor informs all other interested parties that treatment of target is complete. A fire mission within the simulation is considered to have five states: Not Initiated State (0), Initiation Phase (1), Execution Phase (2), Termination Phase (3), and Completed State (4). Communications of the initiation phase, execution phase and termination phase are illustrated in Figures 2, 3 and 4 respectively. From the AFATDS perspective, states 1, 2, and 3 would represent an active mission, while states 0 and 4 wound not necessarily have any standing. SHAPE  \* MERGEFORMAT  SHAPE  \* MERGEFORMAT The principal function of the initiation phase is allocation of the assets which will be used to fire the mission. The execution phase activities are concerned with target location, and determination of success of target treatment. The termination phase activities inform all interested parties that the mission has been (successfully) completed. SHAPE  \* MERGEFORMAT 6. Implementation IssuesAFATDS is a message-passing system. Since none of Matlab, Simulink or Stateflow have message passing capability, a different approach has to be used. Simulink data buses can share a set of data elements. This fact is made use of in our approach to simulate a message passing system. Simulink/Stateflow events can be used to indicate message type and time of passing. Event data would indicate which fire mission is involved. The remainder of the fire mission data can be maintained in a Matlab array (matrix), which is effectively global.OPFACS are modeled using Stateflow. Stateflow is used to model the states of the OPFAC, which are effectively the concatenation of the states of its missions. A set of Stateflow states would therefore represent mission states. Multi-threaded OPFACS can use parallel state sets (the number of parallel sets limits number of concurrent missions executable). The states of an individual OPFAC are included in a Stateflow chart. Each Stateflow chart forms a component of the Simulink. Charts are associated with specific event and data links.Stimulation is provided by a Time-ordered event list generator (TOEL) which is also implemented as a Stateflow chart. Rather than viewing a target, sensors would receive a message from the TOEL. Other than these stimulating messages, the other messages of the simulation correspond to messages that would actually be transmitted in an AFATDS environment. 7. Executing the SimulationAs the simulation uses components of MATLAB, Simulink and Stateflow, these portions of the simulation are discussed separately.An overview of the simulation can be obtained from the Simulink representation, a portion of which is shown in Figure 5.Figure 5 shows the Simulink blocks of the Reinforcing FA Battalion and its six platoons. In the simulation, the batteries of the reinforcing battalion are inactive; thus, fire orders are sent directly to the platoons. In Figure 5, the seven rounded corner rectangles are Simulink blocks corresponding to AFATDS OPFACs. The large one to the right is DS FA BN. The six smaller ones to the left of center are the FA PLTs. The various connecting lines represent buses or links between OPFACS. The small squares are Simulink memories which provide one cycle delays for messages. In some cases these are necessary to avoid perceived cycles; in other cases, they are used to preserve sequencing and integrity at the receiving OPFAC. The long black rectangles are bus creators, combining multiple links and/or buses into a single bus. These have two functions, one is that all events must enter a Simulink block on a single bus; the other is simply combining events and data elements to simplify the graphic representation. Three types of messages are sent from the battalion to the platoons: a wakeup message, an order to fire, and an end of mission. The wakeup message is only sent at simulation start-up. As these platoons are only used to handle massed fires, the order to fire and end of mission messages are adequate. The direct support platoons have significantly more complex needs. In addition to these artifacts, Simulink provides a wide variety of other block types. Some of the elements used in this simulation were scope type graphics which can be used to plot transmitted data in real time, numeric displays also used for real-time data display, random number generators, and constant input generators.Figure 6 is the Stateflow chart for a forward observer. The dotted rounded corner boxes indicate parallel states. The upper states correspond to fire mission buffers, so that the forward observer has the logic available to handle two fire missions simultaneously. The lower state is used to allocate a buffer to a sensed event and keep track of which buffers are in use. The solid rounded corner boxes within the parallel states represent sequential states. In the upper two parallel states, these represent the stages of execution for a mission, including a loop back for target location adjustment. In the lower parallel state, the sequential states represent idle, buffer a busy, buffer b busy, and both buffers busy.Figure 5. A Simulink Representation of a Reinforcing Field Artillery Battalion and its Component PlatoonsFigure 6. A Stateflow Representation of a Forward Observer.The forward observer can be very simple as it handles few message types and only communicates with the fire support team. Conversely, the fire support team is substantially more complex, as it must communicate with multiple forward observers, multiple batteries, and its superior fire support element (BN FSE).The Mission Table, illustrated in Table 1, provides selected results for the simulation. The columns in the Mission Table are described in the following paragraphs.Mission Types supported by the simulation are normal fire requests (1) and massed fire requests (2). Northing is the north/south component of a grid location. Easting is the east/west component of a grid location. Target Type in the simulation refers to the type of treatment required: Mortar (1), Howitzer (2), or Close Air Support (3).	Sensor Type refers to the type of sensor identifying the target: Forward Observer (1), Firefinder (2), Divisional Artillery (3), or Intelligence/Electronics Warfare (4). Firefinder is counter battery radar, e.g., Q-36. Divisional Artillery is the source of certain preplanned fires.	Target Size refers to the firing capacity required, in terms of 1-6 platoons. Altitude simply refers to the altitude of the target. Sensor Unit refers to the actual sensor unit: Forward Observers (1-8), Q-36 (9), DIVARTY (10), or IEW (11). Firing Unit refers to the unit responsible for firing the mission: Direct Support Field Artillery Platoons (1-6), Mortar Platoon (7), Reinforcing Field Artillery Battalion (8), or Air Force (9).	Mission Status refers to the current status of the mission: Artifact of the Time-Ordered Event List (0), Resource Allocation Phase (1), Execution Phase (2), End of Mission Phase (3), or Completed (4). The Mission Table illustrated in Table 1 is in the middle of an execution. Had it been taken after exercise completion, all entries would have had status 4, and all sensor units, and/or firing units, would have been entered into the table.Table 1. Mission TableMission TypeNorthingEastingTarget TypeSensor TypeTarget SizeAltitudeSensor UnitFiring UnitMission Status1525821137142826723651084147792124134153212113453156782112562192752111823237432360108416648111527217342211931218933211963214329211870121298243 7000134523216000128662115000As would be expected, most of the missions which are active are in the mission execution phase. Note that the mission status 1 mission hasn’t had a firing unit assigned yet. That is done in real time, and depends on which firing units are available and which has not fired a mission recently. Sensor units are also assigned to missions at run-time by the TOEL on a round-robin basis.MATLAB has extensive data matrix manipulation and graphic representation capabilities, which can be used for after action analysis. For example, target locations could be superimposed on a three-dimensional terrain representation, with firing units represented by different colors. MATLAB also supports panning of three-dimensional representations. 8. Lessons LearnedThe natural way to communicate between finite state machines within a simulation is using messages. The lack of a true messaging capability is a deficiency for Simulink/Stateflow, and is particularly onerous in the simulation of a real distributed system such as AFATDS. Instead, of messages, in Simulink/Stateflow, one must use a combination of events as triggers to examine the data which is continuously shared. The difficulty then becomes providing unique combinations of events and data. It is preferable not to have separate data variables for every event because of the promulgation of state variables and redundant logic thereby, yet necessary in many cases to avoid ambiguity in interpretation of variable values. An example of this phenomenon is the receipt of two “shot” messages by a FIST on the same time step. The solution used was to make source and destination specific events, where necessary to avoid ambiguity, e.g., SHOT_BTRY_A_FIST_B meaning a “shot” message sent by BTRY A to FIST B.Delays must be used in two ways: It has to be used for implicit synchronization between two messages sent in the same direction at about the same time, e.g., a “shot” and “rounds complete”. They are also used so that Simulink doesn’t interpret interactive charts as cycles. (If chart A sends a message to chart B and chart B sends a response to chart A, Simulink believes it is a cycle. It allows this if one or both charts delay sending their messages. Buses may be used to bundle events and data (constituting implicit messages) from sources to destinations. However, the order of events on the input bus must be the same as expected in the chart. The Stateflow Data Explorer may be used to check and/or modify the bus order of signals to the implicit order within the Stateflow chart.In a hierarchical state environment bottom-level state transitions will only execute on occurrence of an event. In the absence of a stimulating event, Simulink may never check a chart for “true” transitions. Each chart must be “awakened” or it may not properly handle its first event.9. ConclusionsMATLAB/Simulink/Stateflow can be used for Command and Control simulations. To do this, the models within a simulation must be specified at the finite state machine level, developers must be aware of the idiosyncrasies of the suite, use a modular approach to determining system states, and consider use of a library to hold reusable models.MATLAB/Simulink/Stateflow has many nice features, including “drag and drop” component addition from user-defined and predefined libraries; reuse of modules, states, and transitions; animation of “logic flows”; real-time monitoring tools; after exercise analysis tools; real-time modification and re-execution; and run-time declared data arrays. A feature that was not used is the capability of creating stand-alone executables.The original proposition of this experiment was, “Can MATLAB/Simulink/Stateflow be used to create executable mission content within the context of the Military Missions and Means Framework?” Our conclusion is that it is practicable, and may be the preferred solution for users who have already obtained experience with the MATLAB tool suite, and have already invested in it. This would be particularly true, for users who wished to integrate command and control simulations with engineering-level simulations, created using the MATLAB tool suite. For those who don’t have a reason for specifically using the MATLAB tool suite, it may be worthwhile to do some “comparison shopping,” due to some of the constraints and limitations discussed in Section 8 above.Bibliography:.Paul H. Deitz and Michael W. Starks, “The Generation, Use, and Misuse of ‘PKs’ in Vulnerability/Lethality Analyses,” Proceedings of the 8th Annual TARDEC Symposium, 25-27 March 1997, Monterey, CA; also US Army Research Laboratory Technical Report ARL-TR-1640, March 1998; also The Journal of Military Operations Research, Vol. 4, No. 1, 1999, pp. 19-33.. “The Military Missions and Means Framework”, Jack H. Sheehan, Paul H. Deitz, Britt E. Bray, Bruce A. Harris, Alexander B. H. Wong, Interservice/ Industry Training, Simulation and Education Conference, 2003.. “The Use of MMF to Organize, Train, and Equip the Force”, Ronald Smits, John Kearley, Interservice/Industry Training, Simulation and Education Conference, 2004..Stateflow and Stateflow Coder User’s Guide, Version 5, The Math Works, Inc., 2002..Using Simulink, Version 5, The Math Works, Inc., 2002..Using MATLAB, Version 6, The Math Works, Inc., 2002..AFATDS (Advanced Field Artillery Tactical Data System) Concept Evaluation Plan, 1988.FA BNFA BNBDE FSEBN FSEFISTFO  IFA BTRY I IBCSX I I IFigure 4. Fire Mission Termination Phase FA BTRYFA BNBDE FSEBN FSEFISTFO  I I IBCSX I I IFigure 2. Fire Mission Initiation Phase BDE FSEBN FSEFISTFO  I I IFA BTRYBCSX I I IFigure 3. Fire Mission Execution Phase 