Challenges and Solutions for Large-Scale HLA FederationsLen GranowetterBen WatrousMÄK Technologies10 Fawcett StreetCambridge, MA 02138617 876-8085 x121 HYPERLINK "mailto:lengrano@mak.com" lengrano@mak.com, HYPERLINK "mailto:bwatrous@mak.com"bwatrous@mak.com HYPERLINK "http://www.mak.com" http://www.mak.comKeywords:HLA, RTI, ScalabilityABSTRACT: Today's distributed simulations are quickly becoming larger and more complex.  HLA exercises are now likely to include a variety of federates from different organizations, and are likely to involve multiple sites connected over a Wide Area Network (WAN).  In this paper, we describe some of the challenges involved in developing large-scale HLA exercises, and some solutions for overcoming these challenges.  Some of these challenges must be solved at the level of the Run-Time Infrastructure (RTI), because it is the RTI that deals directly with the underlying network.  In order to work in a large-scale federation, an RTI must minimize the amount of network traffic that is sent from site to site over the WAN.  We will describe some of the design decisions that we made in developing the MÄK RTI's distributed TCP and UDP Forwarders - RTI components that take advantage of subscription and DDM region information in order to do sender-side filtering whenever possible.  For example, in developing these components, we had to choose between two approaches: either the Forwarders needed access to the subscription database so that they could figure out which federates required each update, or we could pass destination information from the Local RTI Component to the Forwarders. We will also discuss the "federation-of-federations" or "hierarchical federation" system architecture that has become popular for some large exercises.  In this approach, a large exercise is divided up into segments - each its own federation with its own RTI and FOM.  A bridge-federate or "Portal" is used to selectively exchange data among the sub-federations, based on what is required to meet the goals of the exercise.  As part of the discussion, we will describe the design of MÄK’s Portal application, called VR-Exchange.IntroductionDuring the early history of the High-Level Architecture (HLA), a federation typically took place entirely on a single Local Area Network (LAN).  Occasionally a few federates from remote LANs joined in across a Wide Area Network (WAN), but those federates were often peripheral – not critical to the goals of the federation.  Run-time Infrastructure (RTI) developers often focused first on the needs of these LAN-based federations, and employed techniques that are not appropriate for Wide Area Networks: using UDP multicast addresses to segment traffic based on Data Distribution Management (DDM) information; creating TCP connections directly among all pairs of federates; or bouncing reliable traffic through a single TCP Forwarder, which often lived in a central rtiexec.In recent years, large-scale WAN-based exercises have become much more commonplace.  Many federations include a variety of critical federates spread across the country, or across the world.  RTI implementations have had to evolve over time to meet the requirements of these WAN-based federations.  In the next section we will describe some of the design decisions we faced as we worked to optimize the MÄK RTI for scalable operation over wide-area networks.  The following section will describe a different approach to large-scale WAN-based federations – a “system of systems” approach that tries to segment the exercise into sub-federations that are joined by a Portal or Bridge.  Finally, we will provide some suggestions for how to decide whether a single large federation, or a federation of federations is right for a specific exercise.Optimizing an RTI for Wide-Area NetworksWhen designing an RTI for operation over a WAN, the main consideration is reducing the amount of network traffic that needs to travel from one site to another across the WAN.  This is because the amount of network bandwidth available over a WAN link is often significantly less than the bandwidth available within a LAN.  At the same time, the most obvious bandwidth reduction tool – multicast – is not available over WAN links.An RTI developer faces similar issues in routing traffic, whether dealing with UDP or TCP.  For the purposes of this discussion, we will focus on how we handle TCP in the MÄK RTI, but our approach to UDP is very similar. REF _Ref106594292  \* MERGEFORMAT Figure 1a and b depict the two approaches to handling reliable transport that have been most commonly chosen by RTI developers for use on a LAN.a)			   b)Figure  SEQ Figure \* ARABIC 1: a) In a Fully Connected Network, each Federate's LRC has a TCP connection to every other federate's LRC.  b) With central TCP Forwarding, each federate's LRC has a single connection to a central TCP Forwarder.In the first approach, each federate’s LRC has a TCP connection to each other federate’s LRC (creating a fully-connected network of federates).  When a federate wants to send a message to multiple recipients, it must send a separate copy directly to each destination. In the second approach, each federate’s LRC has only a single TCP connection – to a central TCP Forwarder (or TCP Exploder).  When a federate wants to send a message, it sends a single copy to the TCP Forwarder, which resends a copy of the message on to each destination.Both of these approaches are problematic in a WAN-based environment.  In the case of the fully connected network, the problem is that multiple copies of each message are sent over a WAN link whenever there are two or more recipients on a single remote site.  Clearly, this is not an efficient use of WAN bandwidth.The central Forwarder approach is also inefficient whenever the Forwarder is not on the same LAN as a recipient.  This is because all packets need to first travel from the sender’s LAN to the TCP Forwarder’s LAN, before being sent on to the recipient’s LAN.  In the worst case, a packet traveling from federate A to federate B must actually traverse a WAN link to get to the Forwarder, and then travel back across that same WAN link to get to federate B, even though federates A and B are on the same site!  Clearly, this is also not an efficient use of WAN bandwidth (or a good way of minimizing latency between federates).The solution is to use a different approach to reliable transport over Wide-Area Networks: multiple, distributed TCP Forwarders.  This approach allows the RTI to minimize the amount of network traffic that needs to travel from one site to another across the WAN by doing two things: First it ensures that you never send more than one copy of the same message across the same WAN link.  Second, it ensures that you do not send data at all to recipients that do not need it. Figure 2 shows the design we chose for the MÄK RTI.   The most common configuration involves setting up a fully-connected network of TCP Forwarders (one per LAN) so that there is a single TCP connection traversing each WAN link.  Each Forwarder is responsible for forwarding network traffic to and from the federates on its local LAN.  Each federate has a single connection to its local TCP Forwarder, which it finds either through multicast discovery, or through RID file configuration (the RID file may include the IP address of the TCP Forwarder's machine). EMBED Word.Picture.8  Figure  SEQ Figure \* ARABIC 2: A network of TCP Forwarders (one per site) is used to efficiently send traffic over the WAN.The idea is that when a federate wants to send a message, it sends a single copy to its local TCP Forwarder.  That Forwarder sends a copy to each local federate that needs a copy of the message.  It also sends a copy to each remote TCP Forwarder that services any federates that need the message.  The remote Forwarder, in turn, sends a copy of the message on to each interested federate on its LAN. So how is this idea implemented?  How does each TCP Forwarder know which local federates are interested in each message, and which remote TCP Forwarders service remote federates that are interested?  How do the Forwarders know which TCP connections are associated with which federates?  And how do the various TCP Forwarders find each other?  Identifying interested federatesFor the first question, we considered two possible designs.  One choice was to allow the TCP Forwarders to access the “database” of subscription and publication information.  Remember that the TCP Forwarder is part of the RTI, and therefore could have been written to have knowledge of all of the RTI’s internal bookkeeping messages.  In this design, a Forwarder listens for and processes subscription, publication, or region association messages.  As it sees each message, it updates its database, so that at any given time, it “knows” who needs what.  Now, when a Forwarder gets a message from a local federate, it can compute which local federates, and which remote TCP Forwarders require that message.  It then provides sender-side filtering by sending a copy only to those who need it.The second implementation choice was to keep all knowledge of the publication and subscription database confined to the Local RTI Components (i.e. out of the TCP Forwarder.)  In this approach, it is the sending federate’s LRC that computes which remote federates require a copy of each message.  The LRC passes that information (i.e. a list of destinations) to the TCP Forwarder along with each message.  The TCP Forwarder looks at the destination list, and sends the message only to local federates who are on the destination list, and to remote TCP Forwarders who service remote federates who are on the destination list.  When a Forwarder sends a packet over a WAN link to another Forwarder, the destination list goes with it, so that the receiving Forwarder can send the packet on to just those federates that are interested.For the MÄK RTI, we chose the latter implementation for several reasons.  First, each LRC already maintains the database of publication, subscription, and region association information.  It needs this for a variety of reasons, including advisory generation, assignment of different messages to different multicast addresses for best-effort DDM within a LAN, and performing the ultimate kind of sender-side filtering when no one is interested (not sending the message at all).  By avoiding duplicating the database in the Forwarders, we were able to keep the Forwarders simple.  By allowing the Forwarders to avoid decoding and interpreting RTI bookkeeping messages (including DDM region changes), we allow it more time to do its primary job – receiving and re-sending packets as fast as possible.  Second, we avoid race conditions – the possibility that different Forwarders might disagree on whether some remote federate is subscribed to something, because one Forwarder has received a subscription message, and another has not received it yet.Passing a destination list along with each packet does add a little bit of overhead, but that is kept to a minimum by using a bit field.  The nth bit of the bit field is set to 1 if the federate with FederateHandle n is a desired destination.  In this way, the RTI adds only 8 bytes to each packet for federations of up to 64 federates.  Even for federations that have 1000 federates, only 128-bytes are needed to describe destination lists.  That is a small price to pay in order to save 999 whole copies of every packet that you would have to send without distributed TCP Forwarders!Mapping FederateHandles to connectionsSo now we have a TCP Forwarder that knows that a message needs to reach, for example, federates #1, 3, 7 and 9.  How does it know which TCP connections to send the message over?  Obviously, the TCP Forwarder has to maintain a map between FederateHandles and TCP connections.  For local federates, this is easy.  Since each local federate has its own TCP connection to its local Forwarder, when the Forwarder sees a “join” message coming over a particular TCP connection with a particular FederateHandle, it knows that the federate with that Handle must be at the other end of that connection.  What’s interesting is that the same approach works for remote federates that are behind remote TCP Forwarders.  When a Forwarder sees a join message, it notes which TCP connection that join message came from.  Whether that is a connection to a single local federate, or to a remote Forwarder (behind which sit many remote federates), the conclusion is the same: when I want to reach that federate, this is the connection I must send to.Setting up the network of ForwardersThe last question is: How do all of the Forwarders find each other in the first place.  Again, there are several possible approaches.  The one we chose was the simplest: Forwarders are configured with a small file that lists the IP addresses of all of the remote Forwarders.  In the future we may also support a more flexible but more complex approach, where each Forwarder is configured only with the address of a “master” Forwarder, which dictates to each Forwarder the addresses of the others.Sender-side filtering in actionFigure 3 shows an example of sender-side filtering in action.  The federation has four different sites connected over WAN links.  Federate 1 on Site A is sending a Detonation interaction.  Federate 2, also on Site A, is subscribed to Detonation interactions.  On Site B, Federates 3 and 4 are both subscribed.  On Site C, Federate 5 is subscribed, but Federate 6 is not.  On Site D, neither federate 7 nor 8 are subscribed.  Federate 1’s LRC computes that the destination list for this message consists of Federates 2, 3, 4, and 5.  It sends this destination list along with the interaction to the TCP Forwarder on site A.  That TCP Forwarder sends one copy of the interaction directly to Federate 2, one copy to the TCP Forwarder on site B, and one copy to the TCP Forwarder on site C, because sites B and C both have interested federates.  The Forwarder on Site B sends copies of the message to Federates 3 and 4, and the Forwarder on Site C sends a copy to Federate 5. EMBED Word.Picture.8  Figure  SEQ Figure \* ARABIC 3: Distributed TCP Forwarders ensure that no more than one copy of a message traverses each WAN link, and that copies are never sent to federates who do not need them.In this example, it is important to note the following:1) The interaction was never sent over the WAN link to LAN D, because none of the federates on that LAN needed it.2) Only one copy of the interaction was sent across the WAN link to Site B, even though there are two federates on that site that will receive it.3) The remote Forwarder on site C sent a copy of the message to Federate 5, but not to Federate 6, who didn’t need it.So we have sent the absolute minimum possible number of copies of the packet over WAN links.Incidentally, a side benefit of the TCP Forwarder approach is that it facilitates the use of HLA on networks where LANs are protected by firewalls that perform address translation.  Because the TCP Forwarder is the first place on the LAN that all packets need to go, only a single rule must be added to the router to insure that all packets get to their desired destination.The Federation of Federations ApproachThe previous section discussed how an RTI can be optimized to handle a federation that is spread across many sites on a WAN.  That is the solution that is needed when an exercise designer wants to think of his exercise as a single, large HLA federation.  However, another system architecture is possible: the Federation of Federations approach (also called the “hierarchical federation” approach).In the Federation of Federations Approach, system architects divide their exercise into two or more separate HLA federations – each with its own Run-time Infrastructure, and each with its own FOM.  Often, each of these separate federations is running on its own LAN, at its own site.  The individual sub-federations are then “bridged” together to meet the overall goals of the program.   REF _Ref106615820  \* MERGEFORMAT Figure 4 shows how this approach works:One of the federates on each site’s federation is a “bridge federate”, often called a Portal.  Each Portal also acts as a federate in a “central” federation that usually consists only of Portals (no other federates).  The central federation is often referred to as a “federation of federations”. EMBED Word.Picture.8  Figure  SEQ Figure \* ARABIC 4: A Federation of Federations - a Portal bridges each LAN's federation to a central federation made up entirely of Portals.  The portals exchange data among the sites through the central federation’s RTI.Each Portal’s job is to take the data that it receives from its site’s federation, and publish it onto the central federation, and vice versa.  In effect, a Portal acts as an RTI-to-RTI bridge and a FOM-FOM bridge, enabling the exchange of data among federations that are using different RTI implementations and different FOMs.  A Portal can also be written to have filtering capability, so that it filters out objects and interactions that the other sites do not need.Variations of the Federation of Federations system architecture have been used or proposed on a variety of programs, including US Air Force Distributed Mission Operations and the Joint National Training Capability (LVC Bridge).  At MÄK, we have recently built a COTS Portal product called VR-Exchange.There are a few challenges in building a Portal that can do RTI-RTI bridging.  One key challenge is the fact that it is generally not possible to link two different RTI implementations into the same executable.  This is because different RTI implementations all implement the same API; if you attempt to link two different RTIs into the same application, symbol name collisions will result.In designing VR-Exchange, we chose the architecture depicted in  REF _Ref106618344  \* MERGEFORMAT Figure 5.  It consists of a central Data Exchange, implemented as a set of message queues in a block of shared memory; and a set of Brokers for a variety of networking protocols and architectures.  Each Broker pulls data from its local federation, and sends it through the shared-memory Data Exchange for other Brokers to grab.  It also pulls data from the shared memory Data Exchange, and publishes it to its local federation. EMBED Word.Picture.8  Figure  SEQ Figure \* ARABIC 5: The design of an interoperability Portal - Brokers convert between specific protocols, RTIs, and FOMs, and a central protocol-independent Data Exchange in shared memory.As the figure shows, the architecture supports the addition of Brokers for a variety of different protocols, and is able to support a number of Brokers at once.  But for the purposes of a Federation of HLA Federations, each instance of VR-Exchange is configured with two HLA Brokers, one for the local federation, and one for the central federation.  The two Brokers can be configured with different RTI implementations and different FOMs.  Because each Broker is actually a separate executable, we are able to avoid symbol collisions: no single executable needs to link with more than one RTI.It is worth mentioning that this kind of Portal design also supports a simpler system architecture, where federation designers want to directly bridge two or more federations without going through a “central” federation.  In this case, one Broker joins each federation, and the shared memory Data Exchange replaces the central federation as the place where data is exchanged among the individual federations.It is also worth mentioning that a Portal can also be used to bridge different federations that are using the same RTI implementation.  Even though everyone agrees on an RTI, there still might be reasons to divide an exercise into multiple, interacting federations (different FOMs, different goals, etc). Choosing Between the Two Approaches We have now seen how a large-scale WAN-based exercise can be successfully implemented as a single federation using an RTI that has been optimized for WAN use.  We have also seen how the Federation of Federations approach can be used to divide a large-scale exercise into several sub-federations connected by Portals over a central federation.  So how does one choose between the two approaches?In general, we believe that this is more of an organizational/programmatic decision than a technical one.  In a previous paper[1], we argued that a bridge solution often does not live up to expectations, because it does not emulate the situation where all federates are participating in the same federation.  But we also wrote:“We believe that RTI-to-RTI bridges are useful for situations like hierarchical federations, where a distinct separation between the federations on each side of the bridge is desired.  (Perhaps the different federations are using different FOMs, or different levels of security.)”Our view on the subject remains largely unchanged.  But what has changed since then is that there are now more exercise designers that do desire a distinct separation between sub-federations on different sites.  For one thing, it often makes large-scale exercises easier to manage.  Sub-federations on each site are free to choose their own FOM and RTI implementation, and can be independently developed, tested and verified.  The integration effort to bring the sub-federations together becomes more manageable.You still need to develop the FOM and choose the RTI for the central federation, and you still need to make sure that the Portal you are using can support the desired FOMs and RTIs (in the case of VR-Exchange, this usually means building FOM-Mappers for your FOMs of choice, and configuring the tool so that it can find the desired RTIs).  But at least you do not need to go back and modify the FOMs at each sub-federations, you do not need to force all sub-federations (which might be managed by different organizations) to agree on an RTI version, and you don’t need to re-validate each sub-federation on a modified FOM and new RTI.The bottom line is that if you feel that these improvements to the process of setting up an exercise outweigh the technical advantages of putting together a single large-scale federation on top of a common RTI (see [1]), then the Federation of Federations approach is the right choice.References[1] Granowetter, L.: "RTI Interoperability Issues – Wire Standards, API Standards, and Bridges", Paper 03S-SIW-063, Proceedings of the 2003 Spring Simulation Interoperability Workshop, Orlando, FL, March 2003.Author BiographyLEN GRANOWETTER is the Director of Product Development at MÄK Technologies, responsible for MÄK’s COTS product development group.  He was the chief architect of the MÄK High-Performance RTI during its initial development.  He has been involved with MÄK’s distributed simulation products for over 12 years, including as MÄK’s Lead Products Engineer for several years during the HLA transition.  Mr. Granowetter holds a Bachelor of Science degree in Computer Science and Engineering from the Massachusetts Institute of Technology.BEN WATROUS has been a key member of the MÄK RTI development team for over 2½ years.  As the lead developer for RTIspy, he has created extensions to the RTI’s plug-in capabilities and graphical user interface.  In addition, he has been responsible for optimizing the RTI for use over Wide Area Networks, including design and implementation of the TCP Forwarder approach.  Mr. Watrous holds a Bachelor of Science and Master of Engineering in Electrical Engineering from Cornell University, and has over seven years of experience developing distributed computing applications. CDBEFACDFully Connected NetworkCentral TCP ForwardingForwarderBEFA