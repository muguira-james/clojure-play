BRINGING HLA COMPLIANCY TO LEGACY MODELSTobin A. HillMichael J. DavisENEWS Program, Code 57074555 Overlook Ave.Naval Research LaboratoryWashington DC 20735-5339hill@enews.nrl.navy.mildavis@enews.nrl.navy.milKeywords:JSTARS, HLA, STOW, legacy modelsABSTRACT: This paper describes an approach to providing a connection to the High Level Architecture’s (HLA) Run-Time Infrastructure (RTI) for legacy models.  The technique involves a two-process design using shared memory and interprocess communication (IPC) messages to link the two processes.  This approach is applied to an existing model of the Joint Surveillance Target Attack Radar System (Joint STARS) sensor.  The performance of the resulting application in the Advanced Concept Technology Demonstration (ACTD) of the Synthetic Theater of War ‘97 (STOW 97) is reviewed.  A discussion of an alternate, multi-threaded architecture concludes this paper.1. IntroductionMost legacy models/simulations were designed to run as a stand-alone application and are more than likely ill prepared for handling network communication in order to operate in a distributed simulation framework.  To be compliant with a specific network protocol, such as DIS, the application must contain the code for connecting and communicating through the network.  Each network type requires its own set of specific code.  This code includes the specific mechanisms for establishing the connection, sending and receiving data, and passing messages.  The data must be converted within the application to meet the format of the network protocol.  As new network protocols come along such as the HLA RTI, the application’s existing set of network-handling classes and functions must be replicated with alterations specific to the new protocol, which causes quite an impact on the application’s design. What this document proposes is an alternative approach to the all-encompassing single process, or “wrapper-type”, architecture.  The main idea of our approach uses two processors: one process handles the network input and output, leaving the other process for the legacy model.  The two processes are linked via shared memory and IPC messages.  We have applied this architecture to the Joint STARS sensor federate associated with the STOW ACTD federation.2. RADSIM - The Legacy ModelOur candidate for a STOW Federate was an existing simulation called RADSIM.  The Radar Simulation (RADSIM) is a high-fidelity physics-based model that was readily adapted to realistically model the wide-area surveillance (WAS) function of the moving target indicator (MTI) mode of the Joint STARS radar and the environment it senses.  Joint STARS was designed to detect, track and guide accurate attacks against enemy ground movers, i.e. convoys of tanks and trucks, large scale troop movements, etc.  Through a data link, it provides Army commanders with a picture of enemy ground activity that arrives in regular updates (nominally, every 40-60 seconds).  More details on the radar model can be found in [1].To participate in STOW, RADSIM was required to receive the E-8 flight path orbit and  a list of ground entities that are located within the ground range coverage area (GRCA) and produce an MTI detection list.  The entities would be provided by other simulations linked to the STOW HLA RTI (which is based on DMSO’s v1.0 specification [2]), and the resulting MTI detection list would be sent to a simulated ground station - Motorola’s Common Ground Station (CGS) software - that could only receive DIS packets [3].Previously, RADSIM had some DIS interoperability, which meant its architecture was somewhat geared toward network communications.  But we wanted a way to hook it up to the HLA RTI without making major alterations to the legacy code.  Optimally, the specifics of the HLA could be kept in a network module; the model would only need to know about data that concerned it.  It could receive  that data through some API.  But how?3. The approachThe design described in this section attempts to protect the application from the havoc that ensues when a new feature, such as a new network protocol, is added.But first, some thought must be given to the role that the application will play in the HLA federation.  Defining its role involves the following steps:1.	Decide which RTI classes the application will publish and/or which classes it will subscribe to.2.	Out of that set of classes, decide which attributes are needed.3.	For each class, determine which routing space(s) to use and which attribute(s) define the object’s location in that routing space.  Also, define the bounding area (i.e. minimum and maximum extents) of that space. [Note: This must match what other federate applications in the federation are using; otherwise, they cannot communicate.]4.	For each HLA class, provide a conversion of the attributes to the application’s coordinate system or units.5.	Determine which RTI Ambassador services will be called by the application.6.	Plan a response for each Federate Ambassador service.Let’s look at how these steps apply to RADSIM when preparing to join the STOW Federation.:Out of the 12 object classes in the STOW RID, the RADSIM federate will only subscribe to the entity_state object class, shown in Figure 1.None of the interaction classes are used by RADSIM.  And, because the output of the RADSIM federate will be DIS signal PDUs, no classes will be published.2. The attributes of entity_state used by the RADSIM federate are the position, velocity and primary_guise (DIS enumeration).  The rest are ignored.3. The STOW Federation has different routing spaces for ground entities (ground_space) verses air and sea entities (air_sea_space).  Also, each entity space has an associated dead-reckoning space (*_dr_space), which contains more frequent updates of the velocity, location and orientation attributes.  The RADSIM federate will create subscription regions in ground_space and air_sea_space.  The position of the entities in each space is based on the entity’s location attribute.  The bounding area of each space is the STOW exercise area: (25 N 46 E) X (32 N , 51 E). 4. RADSIM’s target list format requires the position to be specified in WGS-84 geocentric coordinates, which is the same format as the location attribute of the entity_state class.  The velocity vector is in the same coordinate system.  So, no attribute conversion is needed.5. The following  RTI Ambassador service calls will be made by the RADSIM federate:joinFederationExecution - have the RADSIM federate join the HLA federation.createSubscriptionRegion - create a GRCA-sized region in ground_space and an orbital region in air_sea_space (to capture the E-8C) subscribeObjectClassAttribute - subscribe to the entity_state object classunsubscribeObjectClassAttribute - when finished, unsubscribe to the entity_state object classdeleteRegion - delete the GRCA and orbital regionsresignFederationExecution - have the RADSIM federate resign from the federation[Note: the RTI implementation used by the STOW Federation did not include the time or ownership management services which are present in DMSO’s RTI v1.3]6. The following Federate Ambassador services will be provided by the RADSIM federate:discoverObject - a new entity was discovered; add it to a remote entity listreflectAttributeValues - receive updates on the entity attributes; find the entity in the remote entity list and update its attributeschangeThresholds - modify the thresholds for the specified subscription regionIn short, the role of the RADSIM federate is a listener.  The mechanisms for listening have been outlined; now we need to outfit the RADSIM application with these mechanisms.The new application design transplants most of the networking code into a separate network process, which was named the RTI-RADSIM Interface Program (RRIP). The RRIP process is launched independently from the RADSIM application and connects to both the HLA RTI and the DIS protocol.  Data is placed in shared memory, and its access is controlled through semaphores and IPC messages.  Figure 2 gives an overview of the new design.3.1  Shared memory contentsThe shared memory contains sections for a read buffer, a write buffer, and semaphores.  The read buffer holds data received from the network: a list of ground entities that fall within the GRCA, and the current position and orientation of the E-8C.  This buffer  is read by RADSIM and written to by the RRIP process.  The write buffer holds data that is sent out to the network: the MTI detection list.   It is written to by RADSIM and read by RRIP.  The semaphores regulate access to each buffer, as discussed in the next section.It is important that the application has some internal storage area for incoming network data.  [Typically, legacy models access an internal list whose contents are updated from either data files or internal behavior functions.] Access to the shared memory buffers should be kept to a minimum in order to avoid read-write contingencies and delays.  By copying the contents of the read buffer to an internal storage area, the application minimizes its shared memory access time.  For example, RADSIM maintains an internal target list. At the beginning of the scan, RADSIM copies the latest entity list from the read buffer into its target list.  For the remainder of the scan, RADSIM refers to the internal target list instead of the read buffer, thereby freeing up access to the read buffer by the RRIP process.  In a similar fashion, RADSIM forms an internal detection list (an MTI report) at the end of the scan, which is then copied into the write buffer.  RRIP transfers the write buffer contents into DIS packets, which are immediately sent out.Both buffers contain data in a form specific to the application; for example, the position is in the WGS-84 geocentric coordinate system, in units of meters.  The network process is responsible for converting the data to the format needed by the network protocol.  The CGS software mentioned earlier accepts MTI reports in the NATO EX Interface format (see [4]), which packs information into a series of DIS Signal PDUs. [See “Appendix A: Stuffing the Signal PDU” on page 7 for more information.]  Whenever RADSIM would produce an MTI report, RRIP would fill the Signal PDUs and send them to CGS via the DIS connection.3.2  IPC Messages And SemaphoresDuring initialization of the two processes, IPC messages are exchanged to allow synchronous operation.  Initially, RRIP and RADSIM wait for acknowledgment that both processes have started.  Then RRIP sends the GRCA and E-8C orbital information to RADSIM, which acknowledges their receipt.  Next, RADSIM idles until RRIP discovers an E-8C entity on the HLA RTI; RRIP signals RADSIM that the sensor exists, and RADSIM transitions to an operational state.  The initialization phase has ended, and the operational phase begins.During the operational phase, the two processes alternate roles as reader and writer of the shared memory buffers, using the semaphores to dictate what roles are assumed.  There are two groups of three semaphores, each group corresponding to a shared memory buffer.  The three semaphores are actually single bits which indicate a request by the reader, a lock while writing, and a lock while reading.  RADSIM requests the target list by setting the target-request bit.  This signals RRIP to set the target-write bit, unset the target-request bit and write the target list into the buffer.  Upon finishing, RRIP unsets the target-write bit.  RADSIM then sets the target-read bit, reads the list, and unsets the bit.  A similar exchange occurs with the detection list bits, except that RADSIM has the writer role, and RRIP is the reader.  The detection list is not formed until after the target list is read, and the next target list is not requested until after the detection list has been read.The termination phase is entered when the user interrupts the RRIP process.  Signal handlers detect the interrupt, and RRIP sends a finish message to RADSIM.  When RADSIM receives the message, it detaches from shared memory and terminates.  Because RADSIM is unable to signal its termination, RRIP waits for an arbitrary length of time before deallocating the shared memory.[For more information on the message exchange, see “Appendix B: RRIP-RADSIM Interactions” on page 10.]4. Critical Review of DesignThis section discusses the advantages of the dual-process design over the “wrapper-type” design as well as the disadvantages and caveats.4.1  AdvantagesThe bulk of network code has been transferred to the network process.  Thus, the code for the network process can be written by someone not associated with the application, and the application author need not be familiar with the networking codeAdding a new network type to the network process only requires the application to be aware of initialization parameters and any data beyond the standard entity/emission data.The network process can handle reading from and writing out to multiple network types.  The only effect this has on the application process is that it must specify which network protocols to use for each data.The network process can handle any conflicts between networks, i.e. a common port number, without referring to the application process.This is an optimal design for two-processor machines such as the SGI Octane.The development of the network process and the model application can be done simultaneously.4.2  Disadvantages/CaveatsLatency time of shared memory access is added onto network access time.  However, shared memory access is on the order of microseconds, while network access is in milliseconds.Entity/emission data, which has two copies in the “wrapper-type” approach (one in the application, one in the specific network manager) now has another copy in shared memory.  The network process would have code specific to the application: conversion to & from the application’s coordinates and units.  So, its reuse in other applications would be limited.  However, the network process is in a form better suited for transplanting than the code within a “wrapper-type” architecture. The application still needs some protocol-specific code: for initialization, extra data sent or received other than the base entity/emission form, messages.  But the mechanics for each network have been moved to the companion process, leaving behind just the application shared memory manager and some structures.Applications with some networking capability have a head start on their adjustment to this architecture.  But applications without any networking or model use (i.e. legacy code) may need more work.  RADSIM already had code in place to communicate via the DIS protocol; its conversion was relatively painless.5. STOW performance The performance of the Joint STARS federate was put to the test during the STOW ACTD.   The STOW environment consisted of hundreds of individual simulation components, each contributing multiple entities to the HLA network: about 4000 entities at the peak [5].  In addition to the entity traffic, other forms of data kept the network busy: communications, emissions, dynamic terrain, and environmental conditions.But most of the data was excluded before it reached the model. Thanks to hardware (namely, the MCED and  QCBMR [5]), most of the traffic was filtered out before reaching the host computer.  The RTI’s data distribution management services allowed our software to indicate to the router which data types should be sent our way - namely, the entity state information.  And, the entity data could be filtered out by geographical regions: only entities that are located inside the GRCA and orbital area would reach our computer.  At most, half of the entities in the exercise fell within the GRCA.  A part of those entities were ground, and only some of those were moving.  This final list is what was passed by RRIP to RADSIM.The model was prepared for a much heavier load than what STOW was able to offer.  Prior to STOW, we tested with 2000 computer generated entities, all moving, all inside the GRCA.  RADSIM was always able to come back with a detection list before the 40 second scan time had finished.  But during the peak activity periods of the STOW demonstration, only 8% (or 160 entities) of all the entities actually qualified as targets for RADSIM.  Needless to say, RADSIM was able to handle the relatively small workload.  In future demonstrations, we hope to have a situation that involves more moving ground targets that fall within the GRCA.[A full description of our setup can be found in “Appendix C: STOW Configuration” on page 12.]6. Future work: Lightweight Threads ApproachThe two process, shared memory approach works well for the configuration with a single legacy model executing on a host communicating with a single network process.  This approach becomes cumbersome when a simulation requires other components, such as another legacy model executing on the same host or a network entity / detection data logging process.  Figure 3 shows an example of such an architecture.Lightweight threads work in much the same way as the multiple processes described previously, the operating system’s process scheduler will distribute the execution of the threads to  the available processors.  Lightweight threads have one key difference however, since they belong to a single process and share the memory address space for that process, the shared memory is simply “built-in” the application process.  Any data structure in any thread can be seen by all other threads that belong to the process.This “built-in” shared memory does not relieve the programmer from the burden of protecting shared data structures from simultaneous access from multiple threads.  In fact, since all data can be seen by all threads, extra care must be taken to protect any data when multiple threads may access that data, and at least on thread may potentially change that data.  The mechanisms for this thread-safety are similar to those described in section 4.2, but since the threads belong to a single process, the overhead of interprocess communication is avoided.6.1  Lightweight Thread DesignWe chose POSIX lightweight threads for the implementation of our prototype architecture design.  POSIX threads are the implementation of IEEE standard 1003.1c-1995, "System Application Program Interface-Amendment 2: Threads Extension” [6].  They have a standard interface, portable between operating system vendors and have a very small creation overhead of a few microseconds, compared to a UNIX process which can have a much larger start-up time.  POSIX threads share memory address space, file table and I/O streams with all threads in the process [7].The shared data structure is simply a thread-safe implementation of a linked list type data structure.  We used a list structure from the ANSI standard C++ Standard Template Library (STL) because it is widely available and it supports thread-safe read access.  Support for thread-safe write access to the list was added through the use of POSIX mutexes and condition variables.  Each shared list is limited to a single writer thread but multiple simultaneous reader threads.  A thread-safe allocator that uses a different memory pool for each thread is used for best performance, especially on multiprocessor systems.  It can, however, cause resource fragmentation, because memory deallocated in one thread is not available for use by other threads The single writer  limitation is mainly to ensure that list elements allocated by a thread can only be deallocated by that same thread.An application can have several shared lists, each of which could have a different writer thread.  For the example of Figure 3, there would be four such list structures.  There would be a list of HLA network entities written by the HLA network thread and read by both of the legacy model threads and by the logger thread.  There would be a list of DIS network entities written by the DIS network thread and read by both of the legacy model threads and by the logger thread. There would also be a detection list written by each of legacy model threads and read by the logger threads and possibly by each of the network threads for output to the network.A prototype application using this design architecture is in development, and it shows early success using as many as three concurrent threads.  The prototype application consists of a network thread using both HLA and DIS, a logger thread logging entities received from the network and a display and GUI thread that displays the network entities as they are received.  This architecture shows promise for development of a new multi-threaded, shared memory API for communication between diverse simulation processes on a multiprocessing host system.7. References[1] - McGraw, Hill, Ganz and Hansen, “Joint STARS In STOW,” 98S-SIW-122.[2] - “High Level Architecture Interface Specification, Version 1.1,” Department of Defense, 12 February 1997.[3] - “Standard for Distributed Interactive Simulation -- Application Protocols, Version 2.0, Fourth Draft (Revised),” Institute for Simulation and Training, 16 March 1994.[4] - “Interface Control Document for Milestone I of the NC3A AGS Capability Testbed, Edition 1.08 (Draft),” NATO C3 Agency, 4 February 1997.[5] - Calvin, Chiang, McGarry, Rak, Van Hook, and Salisbury, “Design, Implementation, and Performance of the STOW RTI Prototype (RTI-s),” SIW 097-019.[6] - IEEE standard 1003.1c-1995, "System Application Program Interface-Amendment 2: Threads Extension”, IEEE, 1995.[7] - “Topics in IRIX Programming”, Document (007-2478-004), Silicon Graphics, Inc., 1996.Author BiographiesTobin A. Hill received his BS in Mathematics from Kalamazoo College in 1991 and his MS in Computer Science from University of Maryland in 1997.  He has been working as a computer scientist for the Tactical Electronic Warfare Division of the Naval Research Laboratory since 1991, and is responsible for conducting advanced research in areas of distributed simulation, interactive visualization and programming methodologies.Michael J. Davis is an electronics engineer working for the Tactical Electronic Warfare Division of the Naval Research Laboratory (Washington D.C.).  He received his B.S. in electronics / computer engineering from Marquette University in 1988 and a M.S. from Johns Hopkins University in 1995.  Mr. Davis has been working in the field of electronic warfare simulation and visualization since 1988.Appendix A: Stuffing the Signal PDUThis section describes how the MTI detection reports were placed into a signal PDU.Some assumptions were made about the communication to Motorola’s CGS software:Communication will be only one way: RRIP to CGS.DIS v2.0.4 (IEEE 1278.1 - 1994) will be used.Entities sent to CGS (via entity state PDUs) will be only in the GRCA, except for the E-8.The frequency of entity state PDUs sent to CGS will be around 10 seconds/update.The detection list will be stored in the signal PDU, in the form of the EX interface header and MTI target blocks specified in [4].Signal PDUs will be sent to CGS once the detected target list has been formed, i.e. once per scan of JSTARS.The E-8’s time stamp stored in the EX interface will be the time that the target info was sent to RADSIM.  The E-8’s position, velocity and heading will be as of that time.The time stamp for the MTI data will be the same as the E-8’s time stamp above.Since the maximum number of MTI target blocks allowed in the EX interface is 45, multiple signal PDUs per scan may be sent.The fields of each signal PDU were set to indicate that it carried an EX Interface, according to [4].  The signal PDU field values are shown in Figure 4. The Data field of the Signal PDU contains the EX Data Frame structure and up to N <= 45 instances of the MTI Target Block.  The contents of the EX Data frame are listed in Figure 5, and the MTI Target Block data structure for target #i (out of N occurrences) is shown in Figure 6.Appendix B: RRIP-RADSIM InteractionsIn Figure 7, the enumeration of IPC messages exchanged by RRIP and RADSIM is shown; each message is annotated with a description and direction of  flow.The next three figures describe the sequence of IPC messages exchanged and the semaphore usage during the initialization (Figure 8), operational (Figure 9) and termination (Figure 10) phases of both processes.Appendix C: STOW ConfigurationWe brought two SGI Octanes, each outfitted with 2 processors.  On one Octane, we had installed the RRIP and RADSIM software.  The other Octane contained STOWView and a Java Telnet applet.STOWView is a visualization program that can link to both the HLA RTI and DIS.  It displays the STOW exercise as two-dimensional icons on a map background (DTED, ADRG), and it has three dimensional capability as well.  STOWView offered graphical user interface controls to the Joint STARS model, allowing the user to set the initial parameters graphically.  Before launching the model processes,  the user first must specify the GRCA by drawing out an area with the mouse.  Then the user specifies the E-8C’s orbital area in the same manner.  Finally, the user selects the E-8C entity by clicking on its 2-D icon representation.  Then STOWView launches the Telnet Java Applet. The Telnet Applet consists of two terminal shells; above each shell are control buttons.  The left terminal shell runs the RRIP process, and the right one runs RADSIM.  The buttons above each shell configure the executable’s directory path and command line arguments.  Default arguments for RRIP were set by the STOWView process.STOWView also has a logging capability.  The logger captures all RTI entity state information and DIS Signal PDUs (which contain the MTI reports) and writes them to a sequence of data files.  The maximum length of each file can be configured by the user.  Later, these files can be read by STOWView into memory.  We have recorded logs of the entire 48-hour operation. Percentage was obtained from logs of the STOW demonstration’s peak periods, which occurred between 1200-2100 GMT on 10/30/97; it represents the fraction of all  ground-based entities that fell within the GRCA and had non-zero velocity. EMBED Word.Picture.8  (class entity_state   (attribute force 2 1)   (attribute primary_guise 2 1)   (attribute alternate_guise 2 1)   (attribute velocity 2 1)   (attribute velocity_ 4 1)   (attribute location 2 1)   (attribute location_ 4 1)   (attribute orientation 2 1)   (attribute orientation_ 4 1)   (attribute appearance 2 1)   (attribute dead_reckoning 2 1)   (attribute veh_marking 2 1)   (attribute top_unit 2 1)   (attribute capabilities 2 1)   (attribute articulated_struct 2 1)  )FIGURE 1. The STOW HLA entity_state object class. EMBED Word.Picture.8  PDU Header    Protocol Version:	4    Exercise ID:	1    PDU Type:	26 [Signal PDU]    Protocol Family:	4 [Radio Comm]    Time Stamp:	(variable)    Length:	(Entire length, in bytes)    Padding:	0Entity ID    Site:	1    Application:	1    Entity:	(Entity ID of the E-8)Radio ID:	1Encoding Scheme:	0x8000TDL Type:	1Sample Rate:	0Data Length:	(Length of the EX data frame, in bits)Samples:	0Data:	(contains the EX data frame)FIGURE 4. Fields for the Signal PDU.Message Type:	1 [MTI]Radar Mode:	1 [GRCA]Scan Flags:	(Depends on order in sequence)Resolutions    Range Resolution:	(TBD by RADSIM)    X-Range Res:	(TBD by RADSIM)Label:	0 [8 blanks]Sequence Number:	(Total # of MTI blocks)Target Count:	N (# of MTI blocks in this PDU, N <= 45)Scan Area (Rectangular format)    Point1:	(SW corner of GRCA in ARP offset)    Point2:	(SE corner of GRCA in ARP offset)    Point3:	(NE corner of GRCA in ARP offset)Scan Number:	(current scan # maintained by RRIP)Service Request #:	0xFFFF [No info]Platform Time Stamp:	(See assumptions)Data Time Stamp:	(See assumptions)Platform ID    Platform Type:	1 [JSTARS]    Plat Track #:	0 [Not available]Platform Position:	(See assumptions)Platform Velocity:	(See assumptions)Platform Heading:	(See assumptions)Topocentric Origin	(Center of GRCA)    Latitude, Longitude:	varies (in radians)    Altitude:	0Protocol Version #:	108 [Edition 1.08]Spare:	0FIGURE 5. The EX Data Frame.Target Location:	(converted to ARP offset from RADSIM GCC)Target Radial Velocity:	(meters/sec)Radar Cross Section:	(meters ^ 2)Classification:	0, 1, or 2Radial Vel. Quality:	0 or 42Count:	iTruth Tag    Count:	1 [Assume only one entity per target]    Application:	1 [From above]    Entity:	(entity ID)FIGURE 6. The MTI Target Block data structure for target #i.enum EMessageType {MT_NULL = 0,MT_PROG_START,	/* Start RADSIM [RRIP -> RADSIM] */MT_PROG_ACK,	/* Acknowledge start [RADSIM -> RRIP] */MT_GRCA,	/* Send current GRCA info [RRIP -> RADSIM] */MT_GRCA_ACK,	/* Acknowledge GRCA info [RADSIM -> RRIP] */MT_FLIGHT_PATH,	/* Send sensor flight path [RRIP -> RADSIM] /MT_FLIGHT_PATH_ACK,	/* Acknowledge flight path [RADSIM -> RRIP] /MT_SENSOR_STATE,	/* Sensor on/off [RRIP -> RADSIM] /MT_SENSOR_ACK,	/* Acknowledge sensor state [RADSIM -> RRIP]/MT_FILTER_VEL,	/* Filter 0-vel. targets [RADSIM -> RRIP] */MT_FINISH	/* Detach from shared memory*/	/* & exit [RRIP -> RADSIM] */};FIGURE 7. Enumeration of IPC messages.RRIP	RADSIM[Independently set up shared memory and IPC messages]	Wait for MT_PROG_STARTSend MT_PROG_START,Wait for MT_PROG_ACK	Receive MT_PROG_START,	Send MT_PROG_ACK,	Wait for MT_GRCAReceive MT_PROG_ACK,Send MT_GRCA,Wait for MT_GRCA_ACK	Receive MT_GRCA,	Send MT_GRCA_ACK,	Wait for MT_FLIGHT_PATHReceive MT_GRCA_ACK,Send MT_FLIGHT_PATH,Wait for MT_FLIGHT_PATH_ACK	Receive MT_FLIGHT_PATH,	Send MT_FLIGHT_PATH_ACK,Receive MT_FLIGHT_PATH_ACK,Wait for MT_FILTER_VEL	Send MT_FILTER_VEL,	Wait for MT_SENSOR_STATEReceive MT_FILTER_VEL,Initialize RTI network,Wait for sensor on (from RTI)...Send MT_SENSOR_STATE,Wait for MT_SENSOR_ACK	Receive MT_SENSOR_STATE,	Send MT_SENSOR_ACKReceive MT_SENSOR_ACKFIGURE 8. Message sequence for the initialization phase.RRIP	RADSIMSend MT_FINISH,Wait 40 seconds	Receive MT_FINISH,	Detach from shared memory	Terminate executionDeallocate shared memory, Terminate executionFIGURE 10. Message sequence for the termination phase.RRIP	RADSIM	Checks for MT_FINISH	Set target_requestSet target_writeUnset target_requestWrite target listUnset target_write	Set target_read	Read target list	Unset target_readSet detect_request	Set detect_write	Unset detect_request	Write detect list	Unset detect_writeSet detect_readRead detect listUnset detect_readFIGURE 9. Message sequence for the operational phase.