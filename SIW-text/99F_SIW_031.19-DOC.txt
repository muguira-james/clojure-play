Supporting the Flexible Federate Christopher L. MartinezSterling SoftwareJNTFRDC ‚Äì CSF 270730 Irwin AvenueSchriever AFB, CO 80912-7300719-567-8546martinec@jntf.osd.mil, Keywords:HLA, FOM, Wargame 2000.ABSTRACT: At the Joint National Test Facility, the Technology Insertion Studies and Analysis project implemented a prototype federation to reduce risk for Wargame 2000, a new command and control simulation. We found it difficult to flexibly specify and modify data interfaces among federates.  An additional problem in our prototype development was federate visualization - we found it very difficult to show the workings of the federation.  We recently worked with Wargame 2000 on a High Level Architecture gateway and were able to successfully resolve these two issues.  Building on the lessons learned from our proto- federations, we extended our development tools by developing two innovative modules that use Thin Layer Data Interfacing. FedConnector is a generic framework that allowed rapid federate development.  FedConsole is a federate viewer and control console. The two provide the developer access to federate data and federation components for runtime viewing and modification.  FedConnector allowed data primitives and structures to be defined without recoding the simulation. Zero or more mappings were defined in the data and provided bi-directional data conversion. Applications are developed using these mappings with and without a Run Time Infrastructure connection and the development team has the choice between automatic FedConnector services or access the native RTI API. Through multiple mappings FedConnector supports interoperability between the federate and federation creating a flexible federate.  FedConnector coupled with FedConsole facilitates federate/federation test and evaluation using a common benchmark. The two were used in the development of the War Game 2000 gateway as deliverable software modules. This project substantially decreased technical risk to modeling and simulation projects at the Joint National Test Facility that are required to be compliant with the High Level Architecture mandate.1. IntroductionAnyone who has been around the simulation community in the past few years has also been exposed to High Level Architecture (HLA). It has become apparent that HLA has brought new challenges that are currently being approached and solved in many ways. More specifically there is the challenge of Federation Object Model (FOM) dependence: when there are any changes to the FOM there will normally be a direct effect on the simulations Simulation Object Model (SOM) which typically leads to recoding. This paper describes the evolution of an HLA tool called FedConnector that has provided FOM independence for Wargame 2000 (WG2K) and Missile Defense Space Tool (MDST).  2. Approach						FedConnector started out as a small library designed to minimize the federate overhead involved in creating, joining and resigning from an HLA federation.   The library succeeded in doing just that and made it easy for a federate to start/join/resign. The next logical step was to extend these services to some smart data types.  A smart-data base class was developed and different data types could be created base on this data type. This idea became the basis for some of our early federates. The design suffered from one major draw back: any changes in the FOM means changes to data names and types in the federate code. About this time, WG2K had developed requirements for a configurable HLA Gateway. Since our work had a head start interfacing with the RTI API provided by the Defense Modeling and Simulation Offices, it was chosen as a starting point. The object data for the Gateway is configured via a parameter file with HLA data via the SOM. The challenge was to devise a system that would allow changes to be made to either side. Our smart-data types were limited primarily because they made specific assumptions about data.  We needed an architecture that started with primitive data types and allowed complex structures to be built from the primitives.  This approach presented it‚Äôs own challenges, it had to support nested structures and be fast.  There was still one major obstacle to be addressed: a means of bridging differences in data names and types. These and other problems were solved through the development of a Thin Layer Data Interface (TLDI).      Thin Layer Data Interface Figure 3.1 Thin Layer Data Interface The bulk of the TLDI is pictured in Figure 3.1. It is shown configured by definition and mapping files. Local and remote hosts operate sharing data that is defined by the data definition. The local host has the option of using the native format or one or more alternate-mapping interfaces. In the case of multiple mappings the TLDI notifies the local host of remote data creation/updates by calling the first update function registered. The TLDI makes no assumptions about data and emphasizes speed and flexibility. The TLDI supports user:Data DefinitionData MappingData ConversionData InstantiationData DeletionData Publication/SubscriptionLocal/Remote Host Interfaces Local/Remote New/Updating/DeletionData Constructor/Destructor Data Definition Associated User dataData WarehousingData UtilitiesDefinition ParserData Definition - Data primitives are defined using a name and a size. This scheme makes it possible to create a primitive data type with any name and size. Structures are defined based on data primitives as well as other structures. Structures can be nested to any level. These data definitions came to be known as ‚Äúnative data‚Äù.Data Mapping - Data mapping is accomplished by creating an alternate interface into the native data provided by the data definition. Multiple maps can be defined creating a many-to-one map-to-definition relationship. A map element can be associated directly with a native data element or it can reference an element of a nested structure. Data Conversion - Data conversion is applied in a number ways. Normally it is defined in a map bridging a map element to a native element. Occasionally it will be assigned to a data primitive, as is the case with any sort of data pointer.  There is a number built-in conversion functions that support most user requirements.Data Instantiation - Based on the definition and map information the TLDI can instantiate data objects and provides all of the accessor and mutator functions. Data Deletion  - Data deletion is also handled based on the data definition.  Since all data objects are created dynamically, garbage collection is very straightforward.Data Publication/Subscription ‚Äì Data can be published and subscribed by type, map or element.Local/Remote Host Interfaces - The TLDI provides a local interface that is used by the application and a remote interface that can be used by a gateway, or as you will see, an HLA interface. Both local and remote handles are maintained for both definition and instantiated data. Local/Remote New/Updating/Deletion - Callbacks can be registered at the structure and element level for object creation, updates and deletion.  This is the way the local application can be notified of the creation, change and deletion of a remote object.Data Constructor/Destructor - Data constructors and destructor functions can be registered at the structure and element level to support specific initialization and clean up operations.Data Definition Associated User data - There are two user definable integers and two void pointers that can be associated with any structure/map or structure/map element. Data Warehousing - The onboard data warehouse maintains references to data where it is stored based on data type. Retrieval is based on the local or remote handle. Data Utilities - The TLDI has utilities to support:DocumentationConfiguration ExplanationDefinition AmbiguityDefinition Parser - Figure 3.2 shows the definition/mapping file format accepted by the TLDI built-in parser.  The parser can be directed by the application to load a configuration file or it can be configured by setting the CDATA_DEF environmental variable. The TLDI parser supports the following functionality (numbers are keyed to Figure 3.2):Application ParametersParser Processing Log FileFedConsole ActivationData Primitive DefinitionsConversion Function AssignmentsData DefinitionsMap Definitions Publish and Subscribe User Data Assignment (integer)Utility ExecutionFigure 3.2 TLDI Configuration File3.1 Using the TLDIThe are two C++ classes associated with the TLDI CDTypes and CData. CDTypes maintains all definition and configuration, while CData represents all instance data.  A CDTypes class is instantiated and the developer loads configuration data either from a definition file using the built in parser, from the application, or a combination of the two.  Update and delete functions are registered and the TLDI is ready for use by the local host.  Data is instantiated by the CDTypes class in the form of CData objects. Accessor and mutator functions are available for all elements as well as several copy and assignment functions/operators.The CDTypes object is now ready to be passed to a remote host for connection and configuration.  4.  FedConnectorThe target for the TLDI remote host was an HLA interface. This meant reusing the original small library and adapting it for use as a remote host. This library became the basis for FedConnector. FedConnector, reads the federation .fed file and combines the configuration information of the TLDI with the FOM reporting any errors found. All new/update/delete functions are registered with the TLDI to automate the processing of all-local objects and interactions. FedConnector then joins the federation and processes all publishing and subscription requirements. Figure4.1 Federate Using FedConnectorFigure 4.1 shows a typical FedConnector based federate. Definition and map information are parsed by the TLDI. FedConnector parses and correlates FOM information.FedConnector uses a single C++ class that contains the complete functionality of a remote HLA host as shown in Figure 4.1.  Figure 4.2 FedConnector as a Remote Host5. FedConsoleA problem encountered during federate development was the lack of visibility. Out of this necessity came FedConsole. FedConsole is a Java application that provides a federation view from the federate perspective as shown in Figure 4.2. The main screen is shown in Figure 5.1. There is a section for object, federation and interaction information. A current status section and a notes section provide the state of the federation and RTI. The developer takes advantage of the Start/Stop/Halt/Reset buttons and well as 6 different sync/event buttons for federate control. Time management controls are available providing the 4 modes of time management. The developer passes application information to the info, notes and status areas.An object/interaction viewer is started from the main console. This displays objects/interactions listings, instance listings and object/interaction instance data.  Figure 5.1 FedConsole Main ScreenFedConsole attaches to FedConnector from anywhere on the network. Because it is written in Java, it can run on virtually any host. 6. Putting it all TogetherThe driving force behind the development of FedConnector and FedConsole was the HLA Gateway project for Wargame 2000 as shown in Figure 6.1. The federate can adapt to changes to the .par or .fed file with simple modifications to the definitions and maps.Figure 6.1 the TLDI with Local Host WG2K6.1 An ExampleA simple federate was constructed using the definition file shown in Figure 3.2 and the source listing shown in Figure 6.2 and 6.3. This federate consisted of one HLA object and one interaction and can federate with another instance of itself while being controlled by FedConsole.  The missile object used in this example is a mapping of the MunitionsEntity HLA object. The FedConsole ‚ÄúStart‚Äù, ‚ÄúStop‚Äù and  ‚ÄúHalt‚Äù buttons start, stop and halt the main loop. Pressing the Event1 button sent a message and an Event2 creates a missile. All message and missile values are randomly generated. When a missile or message is received it is printed out by the registered update callback function. This code example shown contains a complete test federate. Figure 6.2 Example Source Listing 1The important points from listing 1:Lines 5-6 contain the two include files required in the federate source. Lines 11-15 provide the callback functions that can be tied to FedConsole buttons.Lines17-28 contains the callback function for a message interaction. All we do here is use the built-in accessor functions to print out the message data.Lines 30-42 contain the new/update callback function for a missile. Again, using the accessor function the missile data is printed out.Lines 44-49 contain the delete callback for a missile object.Figure 6.2 Example Source Listing 2The important points from listing 2:Line 7 declares the TLDI CDTypes instance. Line 8 loads the definition file. An environmental variable can be used to automate this process supporting multiple configurations.Lines 9-11 register the update and delete functions.Lines 12-13 query the TLDI for the Message and Missile handles.Line 14 declares the FedConnector instance passing the address of the TLDI.  The constructor for FedConnector opens the .fed file and correlates it to the TLDI definitions and maps then joins the federation.Lines 15-19 registers the control functions from listing one with FedConnector for use with FedConsole.Line 20 sends a string to the FedConsole notes sections.Lines 21-50 show the federate main loop.Line 22 Ticks the RTI.Lines 23-49 provide a run loop that is controlled by the FedConsole ‚ÄúStart‚Äù and ‚ÄúStop‚Äù buttons.Lines 24-35 send a Message interaction when the ‚ÄúEvent1‚Äù button is pressed on FedConsole.Lines 25-28 create the random message data.Line 29 creates the Message interaction CData instance.Line 30-32 loads the random message data into the Message interaction.Line 33 updates the Message reflecting the new values.Lines 36-47 create Missile Object when the ‚ÄúEvent2‚Äù is pressed on FedConsole.Lines 37-39 create the random Missile data.Line 40 creates the Missile CData Object.Lines 41-44 load the random missile data. Line 45 updates the Missile object reflecting the new values to the RTI.Line 51 deletes the FedConnector instance calling the destructor for the fedConnector object. This will resign the Federate from the federation and cleanup all data.This test federate example touches on some of the main features of FedConnector and FedConsole.  This example allows a federate to connect to a federation,  publish and subscribe to one interaction and one mapped object. Control of the example is managed via FedConsole.7. ConclusionFedConnector and FedConsole will continue to evolve in support of WG2K and MDST. This evolution will remain generic and general purpose to support rapid HLA federate development.8. References[1]	Mitch Peckham: ‚ÄúHigh Level Architecture Gateway for Wargame 2000‚Äù, Simulation Interoperability Workshop 99F_SIW_140.	Author BiographyCHRISTOPHER L. MARTINEZ is a Senior Software Engineer at the Joint National Test Facility, Schriever AFB, CO.  He is a member of the Technology Insertion Studies and Analysis (TISA) group where he has been supporting the War Game 2000 HLA efforts.  CDataTypesCData Configuration FilesDefsMapsInterfaceThin Layer DataMapping/TranslationDataData DefinitionApplicationLocalApplicationSimulationHLA/RTIFedConnector.fed TLDI .def .map  EMBED Visio.Drawing.4  Remote EMBED Visio.Drawing.4  001 //**************************************************002 // TestFed  Example       -        Listing one         003 //**************************************************004005 #include ‚ÄúCDTypes.H‚Äù                                    // TLDI006 #include ‚ÄúFedConnector.H‚Äù                             // FedConnector007008 int run      = 0, quit      = 0;      // globals for FedConsole Control009 int event1 = 0, event2 = 0;       //  run/quit/events 010                                                                         011 int startFed     (char *s, int cmd, int chan) {run = 1;} //  FedConsole 012 int stopFed     (char *s, int cmd, int chan) {run = 0;}   //  Callback013 int resetFed    (char *s, int cmd, int chan) {quit = 1;}   //  Functions014 int event1Fed (char *s, int cmd, int chan) {event1++;}  //  for Federate015 int event2Fed (char *s, int cmd, int chan) {event2++}    //  Control016017 int receiveMessage(int type, CData* d, int cnt) {// Message Update 018   int type, size;                                                          // local Varibles019   CByte *dataPtr;020   d->get(‚Äútype‚Äù, &type);                                          // Message.type accessor 021   d->get(‚Äúsize‚Äù, &size);                                           // Message.size accessor022   d->get(‚Äúdata‚Äù, (CByte *) &dataPtr);                     // Message.data accessor 023   cout << ‚Äú*** Message Data Dump ******** ‚Äú<< endl;   // Print out the 024   cout << ‚ÄúType:‚Äù << type << ‚Äú Size: ‚Äú << size<< endl;      //  Message data025   CData::bufferDump(dataPtr, size);  // Dump Utility   026   cout << ‚Äú*****************************‚Äù << endl;027   return(CData::DeleteInteraction);  // Delete interaction instance028 }029030 int receiveMissile(int type, CData* d, int cnt) {   // Missile Update Function031   float id;                              // local varibles032   double mX, mY, mZ;033   d->get(‚ÄúmissileId‚Äù, &id);   // Obtain Missile ID034   d->get(‚ÄúmX‚Äù, &mX);         // Obtain X035   d->get(‚ÄúmY‚Äù, &mY);         // Obtain Y036   d->get(‚ÄúmZ‚Äù, &mZ);          // Obtain Z037   cout << ‚Äú*** Missile Data Dump ******** ‚Äú<< endl;  // Print out the 038   cout << ‚ÄúID:‚Äù << id << ‚Äú X: ‚Äú << mX << ‚Äú Y: ‚Äú           // Missile Data039           << mY    <<  ‚Äú mZ:‚Äù        << mZ <<    endl;040   cout << ‚Äú*****************************‚Äù << endl;041   return(CData::InsertObject);                           // Insert Object042 }                                           043044 int deleteMissile(int type, CData *d, int count) { // Missile Delete function045  int id;                                                                 046  d->get(‚ÄúmissileId‚Äù, &id);                                       // Obtain the id047  cout << ‚ÄúMissile ‚Äú << id << ‚Äú Deleted‚Äù << endl;   // Print it out 048  return(CData::OK);                                                              // return049 }050051//**************************************************052// ***************  End of Listing One  ******************053//**************************************************001 //**************************************************002 // TestFed  Example        -   Listing two                 003 //**************************************************004005 int main(void) {006  int lEvent1 = 0, lEvent2=0;                                     // Local event values007  CDTypes dts(‚ÄúTestFed‚Äù);                                       //  CDTypes Object (TLDI)008  dts.load(‚ÄúTestFed.Def‚Äù);                                       // Load Def‚Äôs & Maps009  dts.setUpdate(‚ÄúMissile‚Äù, receiveMissile);              // Register Missile Update 010  dts.setDelete(‚ÄúMissile‚Äù,  deleteMissile);               // Register Missile Delete011  dts.setUpdate(‚ÄúMessage‚Äù, receiveMessage);       // Register Message Update012  int missile   = dts.find(‚ÄúMissile‚Äù);                       // Obtain Missile Handle013  int message = dts.find(‚ÄúMessage‚Äù);                   // Obtain Message Handle 014  FedConnector *f = new FedConnector(‚ÄúTestFed‚Äù, &dts);    //  New FedConnector015   f->setStartCB(startFed);                           // Register  the FedConsole Start Callback016   f->setStopCB(stopFed);                          // Register  the FedConsole Stop Callback017   f->setResetCB(haltFed);                        // Register  the FedConsole Halt  Callback018   f->setEvent1CB(Event1Fed);               // Register  the FedConsole Event 1 Callback019   f->setEvent2CB(Event2Fed);              // Register  the FedConsole Event 2 Callback020   f->notes(‚ÄúTest Federate Starting‚Äù);    // Write string to FedConsole notes area021   while(!halt) {                                                             //  Run till halted022     f->tickRTI(0.2, 0.5);                                              // Tick the RTI023     if(run) {                                                                // If the federate is Running024       if(event1>lEvent1) {                                          // Create/Send Message025          int type = rand()%128;                                  // Load type with random value  026          int size = rand()%256;                                  //  Load size with random value027          CByte *cPtr = new CByte[size];                  // Create a random size data buffer028          For(int iSize=0;iSize<size;iSize++) cPtr[iSize]=rand()255;  // Load buffer029          CData  * mes = dts(message);                   // Create a message instance030          mes->set(‚Äútype‚Äù, type);                            // Set Message.type031          mes->set(‚Äúsize‚Äù, size);                            // Set Message.size032          mes->set(‚Äúdata‚Äù, cPtr,size);                   // Set Message.data033          mes->update();                                    // Update message  interaction034          lEvent1 = event1;                               // advance local event 1 to FedConsole035        }                                                         // End of Event 1 ‚Äì Create/Send Message 036        if(event2>lEvent2) {                          // Create/Send Missile037           double x = rand()%360;                 // Load x with random value038           double y = rand()%360;                // Load y with random value039           double z = rand()%360;               // Load z with random value040           Cdata *mis = dts(missile);           // Create the missle object 041           mis->set(‚Äúid‚Äù, rand()%256);       // Set Missile.id with random value042           mis->set(‚ÄúmX‚Äù, x);                                 // Set Missile.mX043           mis->set(‚ÄúmY‚Äù, y); );                             // Set Missile.mY044           mis->set(‚ÄúmZ‚Äù, z); );                            // Set Missile.mZ045           mis->update();                                    // Update Missile Interaction046           lEvent2=event2;                                // Advance local event 2 to FedConsole 047        }                                                         // End of Event 2 ‚Äì Create/Send Missile048        usleep(1000);                                     // Small Delay049     }                                                          //    run050  }                                                            //   !halt051   delete f;                                               // Resign and Data Warehouse cleanup   052  return(0);                                            // main053}054//**************************************************055//*************  End of listing  two ********************056//**************************************************//**************************************************// TestFed Definition File                      <FedConnecter>//**************************************************// Application ParametersFederationName   TestFederationFederateName      TestFedFedFileName        TestFed// Open a file for outputing runoutput: testFed.txt// Turn FedConsole OnFedConsole On// Data Primitive Definitions  int 	4  float	4  double 	8  dataPtr       	8       buf2ptr// Assign Conversion Funcitons  int 	float	itof	ftoi  int	double	itod	dtoi  float	double	ftod	dtofStruct     // Data Definitions   position      int x    int y    int z  MunitionsEntiy    int 	id    position 	pos    int 	stateMessage     int type    int size    bytePtr data MapStruct	// Map Definitions       Missile MunitionsEntity    float 	missileId   	id    double 	mX   	pos.x     double 	mY   	pos.y     double 	mZ  	pos.z    double 	health 	state    //Publish & SubscribePublish 	MissileSubscribe 	MissilePublish           	MessageSubscribe 	Message// User Definition data AssignmentsFunction 	USER1 	Missile.id 	8192Function 	USER2 	Missile.id 	128Function 	USER1 	Missile.mX  	20Function 	USER1 	Missile.mY  	55Function 	USER1 	Missile.mZ  	89// Run UtilitiesFunction   buildDefs               // Build all Function   dumpCStruct         // Output Defs in C formatFunction   dumpFuncs            // Output Conv. Func. ListFunction   dumpMaps             // Dump all Def MapsFunction   dumpConvAssign  // Output Conv. Func. AssignmentsFunction   checkNames          // Check for errors in defs//**************************************************// End of testFed Definition File         <FedConnector>//**************************************************23956710841