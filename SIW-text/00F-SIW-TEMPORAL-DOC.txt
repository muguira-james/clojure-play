A TEMPORAL VERIFICATION FRAMEWORK FOR DEVS/HLA MODELSCuneyd Firat,  Mehmet Fatih HocaogluInformation Technologies Research InstituteTubitak Marmara Research Center41470 Gebze, Kocaeli, TURKIYE(262) 641 23 00Currently Reseach Scholar in AI&Simulation Research Group in ECE of University of ArizonaBernard P. ZeiglerAI&Simulation Research Group in ECE of University of Arizona1230 E. Speedway Blvd,Tucson, AZ 85721-0104(520) 621-6184{ HYPERLINK "mailto:firat, hocaoglu, zeigler}@ece.arizona.edu" firat, hocaoglu, zeigler}@ece.arizona.eduKeywords:DEVS/HLA, FEDEP, Temporal Reasoning, Verification ABSTRACT: Operational verification of a simulation model deals with determining how well the behavior exhibited by an implemented model conforms to its specification in a conceptual model of real system. Although it has not been used widely for this purpose, temporal logic appears to be a suitable technique to capture key temporal requirements of discrete event systems.  Temporal logic meshes well with the event based nature of discrete event systems and can be derived directly from natural language statements.  It can express such temporal modal forms as “always” and “eventually” applied to state-descriptive predicates (e.g., eventually a target will be attacked after a threat is perceived, provided a suitable weapon becomes available in time). Recall that one of the main motivations of HLA is the verification of federations based on given requirements and that this requires some form of operational verification of federations.  Models expressed in the Discrete Event System Specification (DEVS) formalism effectively express the operational perspectives of real systems and they are able to represent both the structural and behavioral features of HLA federations.  Therefore the DEVS formalism offers an attractive framework for capturing federation requirements and testing them against federation implementations for behavioral correctness. This paper proposes a new approach to operational (behavioral) verification of  HLA federations which combines the expressive power of DEVS with the ability of temporal logic to capture important temporal requirements for federations as stated in a conceptual model specification.  We employ DEVS/HLA to develop HLA federations and a new set of tools to map temporal logic formulas into executable run-time test harnesses for such federations. An example of a theater missile defense example from HLA domain will be given to demonstrate the proposed approach. Temporal logic can also be used in concert with other logics such as the Z specification language to provide enhanced capabilities for verification and validation of HLA federations. These initial results suggest the possibility of combining DEVS and a suite of logical formalisms as a verification framework for the HLA FEDEP process.IntroductionVerification is the process of determining that a system implementation accurately represents the developer’s conceptual description. As system complexity grows, the need to uncover system faults becomes evermore acute. For example, the failure of Ariane 5 rocket resulted from a tricky combination of relatively simple mistakes that could have been avoided, had programs been fully specified, documented, tested and verified [1]. The aim of verification efforts in M&S domain is to examine the appropriateness and compliance of a simulation model to its objectives from structural and dynamic perspectives. Operational verification of a simulation model deals with determining how well the behavior exhibited by an implemented model conforms to its specification in a conceptual model of real system. Although it has not been used widely for this purpose, temporal logic appears to be a suitable technique to capture key temporal requirements of discrete event systems [2]. It is a well-established and well-explored formalism [3], which has its own syntax, semantics that properly captures the propositions made over temporal properties of systems. Temporal logic meshes well with the event-based nature of discrete event systems and can be derived directly from natural language statements. In discrete event systems, events are the main concerns that trigger the state changes and occurrences of new events and therefore we say that ‘an event has some implications for future’. This is nothing but a proposition for the future states of the system implied by the occurrence of the event. Therefore event-based propositions of a discrete event system can be well expressed with temporal propositions of temporal logic. The collection of temporal logic proposition for the target system constitutes an operational conceptual model that should be satisfied by the system’s operation. Temporal logic can express such temporal modal forms as “always” and “eventually” applied to state-descriptive predicates (e.g., eventually a target will be attacked after a threat is perceived, provided a suitable weapon becomes available in time).Recall that one of the main motivations of HLA is the verification of federations based on given requirements and that this requires some form of operational verification of federations.  As Discrete Event System Specification (DEVS) atomic model represents a component’s dynamic behavior and has a well-defined mathematical structure [4], models expressed in this formalism effectively express the operational perspectives of real systems and they are able to represent both structural and behavioral features of HLA federations.  Therefore the DEVS formalism offers an attractive framework for capturing federation requirements and testing them against federation implementations for behavioral correctness. This paper proposes a new approach to operational (behavioral) verification of  HLA federations which combines the expressive power of DEVS with the ability of temporal logic to capture important temporal requirements for federations as stated in a conceptual model specification.  We employ DEVS/HLA to develop HLA federations and a new set of tools to map temporal logic formulas into executable run-time test harnesses for such federations. An example of a theater missile defense example from HLA domain will be given to demonstrate the proposed approach. Temporal logic can also be used in concert with other logics such as the Z specification language to provide enhanced capabilities for verification and validation of HLA federations. These initial results suggest the possibility of combining DEVS and a suite of logical formalisms as a verification framework for the HLA FEDEP process.Operational Models and Behavioral Verification in HLAThe customary way of verification and validation of a simulation system has been performed by after-development testing. However, conventional systems and software engineering wisdom suggest that substantial benefits will result from the application of V&V throughout development [5]. HLA is one of the most recent distributed simulation development and execution framework that appreciates the importance of V&V and practices it at every step from planning and requirements phase to after execution evaluation. A distributed simulation compliant to HLA is developed following the steps set forth in HLA-FEDEP process. FEDEP is an ordered iterative waterfall software development process [4] such that federation is designed based on conceptual model of the federation. Then federation is developed creating Federation Object Model (FOM), which is a representation of structural features of the federation. FOM captures information about data flow by having routing space and interface specification information. However, the FOM has no facility to represent federation’s key behavioral capabilities. The specifics of what might comprise a federate’s behavior are not specified by HLA rules and OMT.  As a consequence, it is difficult to make judgements about the appropriateness of a model for an application without the understanding of inner workings [6]. Although there are some means to annotate and hence verify interactions and attribute updates of federates [7], this insight is confined to examine the interactions on the interfaces of federates rather than having a global view on federate and federation. Therefore a formalism that also include dynamic aspects of federations will foster more robust V&V.A solution to this problem is afforded by the DEVS formalism with its capability to represent the dynamic behavior of models and well-defined mathematical structure. It has been shown to support modular, hierarchical, distributed modeling for the class of discrete event systems [4]. DEVS simulation models capture a system’s dynamic behavior, how it organizes itself over time in response to imposed conditions and stimuli. Such modeling is required in order to be able to predict how a system will react to external inputs and proposed structural changes. This approach supports capturing a system’s structure in terms of atomic (federate) and /or coupled (federation) models. This gives the opportunity to look the whole federation like a single federate from structure point of view and promotes operational as well as structural verification and validation. Recently it has also been shown that models based on ordinary differential equations can be represented as discrete-event models with accuracy/performance trade-off [2].  The DEVS/HLA environment was developed to support HLA-compliant simulations. Since, the formalism both describes static and dynamic features of federation by identifying state variables, states, input/output couplings and internal/external state transitions, the verification can easily be performed embracing all aspects, especially on operational performance of the federation. The operational verification can be performed whenever the federation is designed and developed provided that its federates and their capabilities given in DEVS formalism. One approach is to base early verification on untimed execution of the federation to generate possible behaviors [2].  An untimed DEVS execution engine must be available for the purpose. An alternative is to perform verification at the time of federation execution and check the correctness of the behavior generated with respect to reference operational assertions. The phases in which each of these verification tests are applicable are shown in Figure 1  (a modification of the diagram I [8]).Figure 1. . Points at which operational verification can be applied in the federation development processThe verification scheme is based on this information supplied by the conceptual model and FOM.  The conceptual model identifies the functional elements of the simulation, their possible states, their inter-relationships, and their critical behavior/performance characteristics [9]. On the other hand, the FOM gives the structure that is supposed to exhibit the anticipated behavior. Therefore, behavioral assertions to be verified are constructed based on parts of federation conceptual model providing operational aspects and corresponding static object structures of the FOM.  Assertions specify  the behavior that is expected from each federate and from the federation overall. Both untimed or timed execution of the federation must satisfy these assertions for it to be verified as operationally correct. Application of verification  early in the FEDEP and as many points as possible as the federation matures can save development cost from detection of problems at the earliest possible time. Moreover, continued “regression” testing acts to assure that code that was verified at early stages continues to correctly operate as additions and modifications are made to other parts of the system. Before proceeding we provide some background that will be needed for the main discussion.BackgroundLanguages in Untimed Models of Discrete Event SystemsIn the state evaluation of a Discrete Event Systems (DES), the first concern is with the sequence of states visited. Thus, in untimed execution, the time when the system enters a particular state or how long the system remains at that state are not the focus of  concern. The input to the DES is described in terms of an event sequence {e1, e2, … }. Such a sequence specifies the order in which various events occur over time, but it does not provide the time instants associated with the occurrence of these events. Such a model is referred untimed DES model [10]. The analysis of untimed model focuses on the logical behavior of DES. The study regarding the logical behaviors of DES is based on languages and automata. A finite nonvoid set of arbitrary symbols is called a finite alphabet and is denoted by V. The finite strings of letters are called words [11]. Any DES has an underlying event set E associated with it. The set E that is an alphabet for the DES contains events. Event sequences are thought of as words. An automaton can be thought as a device that generates a language by manipulating the alphabet (events) according to a specified set of rules. The main purpose in generating a language is to make the system spoken using the language.  A language may be thought of as a formal way to describe the behavior of a DES. It attempts to specify all admissible sequences of events the DES is capable of processing.The basic operation to describe a language on strings is known as concatenation. In particular, let u and v be strings, the concatenation, written as uv. The new string uv is simply the string consisting of all events in u immediately followed by all events in v. Three types of operation can be defined on languages. Given an alphabet E, let A and B be two languages. Then,ConcatenationAB={w: w=uv, u(A, v(B}Kleene closureA*= EMBED Equation.3  An where A0={(} and An=AAn-1 for all n ( 1All common set operations: A ( B and A ( B denote the union and intersection of A and B, respectively. Ac denotes the complement of A with respect to E*, the set of all possible strings over alphabet E.  For convention, union operation is represented with “+”rather than “(”. It also refers logical “OR” operation. Union and concatenation of u and v represented as (u+v) and uv, respectively. Concatenation indicates a sequence of events occurrences in DES. In an execution, string uv means that the events of u occurs before the events of v. These representations refer to Regular Expressions which can be defined as if r and s are regular expressions, then rs, (r+s), r*, and s* are regular expressions. Regular expressions provide a compact finite representation for potentially complex languages with an infinite number of words. Any language that can be denoted by a regular expression is a regular language.As mentioned above, an automaton is a device, which is capable of generating language according to well-defined rules. This device is intended to observe strings of events formed according to some alphabet E. Such a device (finite-state automaton) is also endowed with a state set and initial state represented as X and x0, respectively. A subset of X, denoted by F, is chosen to include some final states. As an addition to all, it obeys some rules called state transition function to be able to make transition from one state to another. State transition function gets a state x and an event e as inputs and produces a new state as output. In this sense, a finite-state automaton is a five-tuple		(E, X, f, x0, F) where E is a finite alphabetX is a finite state setf is a state transition function, f: X x E ( Xx0 is an initial state x0 ( XF is a set of final states, F ( EThe term “finite state” automaton express the fact that the state space is constrained to be finite.In this study, the language to be generated by the automaton is based on temporal assertions. Grammar rules of language are also based on temporal decomposition rules.  Temporal LogicTemporal Logic (TL) extends ordinary predicate logic by introducing a set of special temporal operators that provide a natural, succinct, and abstract description of precedence, invariance, and frequent recurrence of events in time. In this sense, TL is a part of modal logic. A modal is an expression (like `always' or `eventually') that is used to qualify the truth of a judgment. Modal logic is, strictly speaking, the study of the deductive behavior of the expressions `it always … that' and `it eventually …'. Narrowly construed, modal logic studies reasoning that involves the use of the expressions “always” and “eventually” [12].It is assumed that an underlying assertion language L which is a first-order language over interpreted symbols for expressing functions and relations over some concrete domains such as integers, arrays, and lists of integers. We refer to a formula in the assertion language L as a state formula, or simply as an assertion [13]. For an assertion p and a state s that interprets all variables appearing in p, we write s ╞ pTo denote that s satisfies p, which can also be described by saying that p hold on s, or that s is a p-state.  TL provides operators for reasoning about program computation. A computation is a sequence of states that can arise during program execution. Informally, the first state in a computation represent the present, starting at the beginning of the program, so a future state in one computation can be the present state in another [14].Elements of TL:  The elements of TL are modals, syntax, semantics and formations. Modals that are used in TL can be grouped under two categories. The categories based on time and the first one is Future Temporal Operators such as ( (always), ( (eventually),U (until), W (waiting-for), ( (next), and the other is Past Temporal Operators such as ( (so-far), ( (once), S (since), B (back-to), ( (previously). The non-temporal boolean connectives are used to construct a formula such as  ( (negation), and ((), or (() quantifiers (( and (). Syntax refers to representation of the temporal statements. It has a list of primitive symbols (atomic predicates, usual logical operators, modal operators) and formation rules.Semantics are defined informally as a state is the value of the program counter(s) and the values of the program variables. Formally, a state is defined to be a truth-valued function on the set of atomic predicates.    The propositions that consist of temporal statement(s) are called formulas of traditional temporal logic [3]. There exist a number of formation rules, which define precisely how syntactically correct formulas are built. Starting point is a set of atomic propositions, i.e. “Threat generator generates threats”. Definition 1. Let ( be a set of atomic propositions. Then the following sentences are formulas of traditional temporal logic:For all p( (: p is a formula.Let ( be a formula, then (( is a formula.Let (1, (2 be formulas, then ((1((2), ((1((2), ((1((2), ((1((2) are formulas.Let ( be a formula, then ( (, ( ( are formulas.A model of a traditional temporal logic is a (possibly infinite) sequence (= {s0, s1 … sn} of states, where each state is defined by a set of true atomic propositions. A temporal formula constructed by formations defines a relation between states of the model and a proposition to be satisfied. Satisfaction relation between a model, one of its states, and a formula which holds if and only if the formula is true in that situation is defined to be able to give a meaning to a formula. The satisfaction constraints for n-th state of ( are as follows; (, n ╞ p		iff p ( sn(, n ╞ ( (		iff not (, n ╞ ((, n ╞ (1 ( (1	iff (, n ╞ (1 and (, n ╞ (2(, n ╞ ( (		iff  (, m ╞ ( for all m ( n(, n ╞ ( (		iff  (, m ╞ ( some all m ( nGiving a meaning is strictly related with satisfaction relation. We say that a formula ( is satisfied in a model ( (written ( ╞ () iff ( is true for some state of (. ( is valid (written ╞ () iff ( is true for all states of all models (.  In the model shown in Figure 4, Threat Generator creates a threat in any type. If QueueT gets a threat created by Generator, QueueT.lenght state variable increases its value by one. This is an atomic proposition.  !threat_type && Queuet_LENGTH=n =>QueueT_LENGTH=n+1For convenience, let’s write the proposition, p => qIt is obvious that left-hand side of the proposition implements right-hand side of the proposition. It gives such a meaning “if initially p then eventually q” to add modal eventually right-hand sight. In this case, the model ( satisfies p if p is true in sj. It satisfies (q, if for some position k ( j q holds as sk.   p =>( (q)Adding always operator in front of the previous formula states that this property holds for all position k ( j. ((p =>( q)The verbal statement of formula is “Every p-position coincides with or is followed by a q-position”. In our example, whenever a threat comes to queueT, QueueT increases its length value by one at a point that is after the point threat comes and this process continues. It is quite obvious, temporal statements have natural languages counterpart and they are derived from them. This property makes them close to definition of the model. The temporal statement above is derived from the natural language statement  “Threat Generators always generates threats and QueueT increases its length eventually”.  A modality is defined as any unbroken sequence of zero or more modal operators. The degree of modality is the number of operators in the sequence. If there are no modal operators in a formula (degree zero), then that formula refers only to the first state in computation: the present. The modality of degree one and two we have showed are always, eventually, next and infinitely often, eventually always, respectively. The example given above has two modalities because of always eventually. The specification of a system in TL is usually divided into safety conditions, liveness conditions, and fairness conditions [15]. The safety conditions are those, which must not occur in operation of the system. The system cannot be in two states in the same time. This is achieved changing states variables values taking values from an infinite and discrete value set. The liveness conditions specify what the system must do. The fairness conditions describe how non-deterministic specifications are to be resolved. This means to define that the system will follow what kind of action sequence in case the events are got at the same time. Reasoning in TL:To make inference from a temporal formula, it is necessary to decompose formula to simpler logical operators. This process is called Decomposition and it gives us production rules producing strings using decomposition rules. In a temporal formula, each premise is counterpart of the alphabet. The process generates a Regular Grammar of a Temporal Logic Formula. Regular Grammar is an ordered fourtuple (VN, VT, P, S) where VN and VT are finite alphabets with VN ( VT = (. VN, VT, S and P are temporal formulas set, non-temporal formulas set, start symbol (i.e.given TL formula) and all applied decomposition rules set, respectively. Decomposition rules are as follows.P1: ( ( ( ( ( (P2: ( ( ( ( + ( ( (( ()  P3: (1 ( (2 ( (2 + (1 ((1  ( (2)P4: ( ( ( ( + ( (( ()P5: ( ( ( ( ( ( (( ( ()P6: ( ((1 ( (2) ( ( (1 (2 + ( (2 (( ((1 ( (2))P7: (1 ( (2 ( ( (1 + (1 (2The decomposition process to build a grammar for a TL formula is as follows:Set given TL formula to the start symbol S.Apply a decomposition rule to the TL formula. Add the applied decomposition rule to the production rule set if it is used for the first time.If a new nontemporal formula is in the decomposition result, add it to the terminal set VT.If a new temporal formula is in the decomposition result, add it to the terminal set VN.If a new temporal formula does not appear, then terminate.The decomposition algorithm is as follows [2];Set the TL formula to the start symbol S (S is a member of state set of the model- S ( (, s ╞ p), Apply a decomposition rule to the TL formula. Add the applied decomposition rule to the production rule set if it is used for the first time.If a new nontemporal formula is in the decomposition result, add it to the terminal set VT.If a new temporal formula is in the decomposition result, add it to the terminal set VN and go to step 2.If a new temporal formula does not appear, then terminate.A grammar for TL formula is constructed applying decomposition process. After this point, finite automaton M of the TL grammar G is defined as follows;	M:=<(, (, (, q0, F>   		(: finite states set,		(: finite input symbol set,(: transition function, q0: initial state, F: final state set, F ( Q. With following constraints:	(: VN ( {f}, where f is newly defined final state,	(: set of VT of TL grammar,	(: ( x ( ( (	q0: start symbol S of TL grammar.The start symbol S of G becomes the initial state q0 of M. If the production rule is A(aB the transition function becomes ((A, a)=B. If the production rule is A(a the transition function becomes ((A, a)=f. After this step, model is verified by language acceptance checking. In the language acceptance checking, whether the operational specification satisfies the assertional specification is determined. If a language set defined by TL formulas contains a language set generated from the untimed DEVS model, the language acceptance checker concludes that the developed model satisfies the desired properties. The language acceptance checker examines the containment between the language of the DEVS model and the language of the TL grammar. This is done memorizing the global state transitions for an overall DEVS model to check whether the transition is closed  [2]. The language acceptance checking process is as follows;Start with the initial state of the DEVS model and of the finite automaton.Find the set of all possible next states from the DEVS model. Then, select a state from the set that satisfies the transition condition of the finite automaton. If there exists a satisfied transition condition, then transit to the next state. If none of the generated next states satisfies any transition conditions in the finite automaton, then this current global state is a deadlock state. In this situation, both DEVS model and finite automaton backtrack to the previous state.Repeat the generation of the global states of the DEVS model and the finite automaton until the generated global state trajectories are closed.  Operational Verification of DEVS/HLA Federations  We now explore the applicability of operational verification of federations using Temporal Logic and its feasibility in DEVS/HLA paradigm. Temporal Logic  is used to make assertions about required behavior which are then translated into a form of language acceptance checking that can examine federate interactions during run time. This framework is shown in Figure 2.Figure 2. Temporal Logic Based Operational Verification FrameworkThe framework includes generation of assertions based on both conceptual model and object model of federation. Then the  assertions are automatically transformed into a language grammar that can generate the correct behavioral sequences implied by the temporal assertions. Rather than being employed as a generator, the grammar is used as a language acceptor to verify the federation behavior. In other words, the acceptor observes the message exchange among federates. Views these as a language generated by the execution of federation, it tests the event sequences for membership in the language generated by the grammar. The architecture indicated by this framework for verification during execution is shown in Figure 3.Figure 3 . Temporal Logic Based Operational Verification Architecture on Execution for DEVS/HLA FederationsThe framework is exemplified by Theatre Missile Defense example, which is a generic DEVS federation based on the “Decide course of action” part of conceptual ‘Theatre Missile Defence (TMD)” model in [16] with some changes and additions. TMD Federation consists of four DEVS federates which are Generator, Prioritizer, Assign Weapon System and Threat Federates. The DEVS coupled model of the federation is shown in Figure 4. The detailed execution of TMD federation is as follows:The Generator produces threat by generating threat_type output.Whenever a threat is generated the length of the queue_T of prioritizer federate is increased by one.When the query of prioritizer federate is not busy it takes all the threats generated and assigns each of them a priority value interrogating the imaginary knowledgebase. Then the prioritized threats are sent to queue_P of assign weapon federate.When the assign weapon system is not busy it pulls the highest priority threat and makes a query from weapon knowledgebase to assign the most effective weapon to the threat and then gets the readiness information of the weapon from weapon status resources. If the weapon is ready, then the action output is generated that destroys the threat, otherwise, a follow-up output is generated to reinterrogate the readiness status of the weapon.Whenever a threat is pulled from prioritized threats queue, it is also assigned to the threat federate as the current threat. When the threat federate receives an in-range signal from sensor resources, it launches its weapon and outputs fire which will destroy the assign weapon system if it itself is not destroyed in time.For the purpose of demonstration of the verification framework, The DEVS specification of Assign Weapon Federate and Threat Federate is given in Appendix 1.The first step of temporal assertion based verification is to identify the expected behaviors of the systems as temporal assertions. Some of federation-wise temporal formulas that are created using the operational information that is supposed to be given in the conceptual model of TMD federation, and data with related variables from DEVS specifications, which are also supposed to be given in the FOM. They are given below;Temporal assertions are clustered under two groups. These groups illustrate that different level of granularity  for temporal assertions can be employed. The first group is a kind of fine grained assertions including internal dynamics of TMD Federates whereas the second group is TMD Federation assertions that is coarse grid one, and they show global manner of federation. The first group assertions are as follows;Action 1.1: The Federation continuously generates threats on intervals based on probability distributions((Generator_STATUS=ACTIVE =>(!threat_type)Action 1.2: Whenever generator generates a threat it is buffered in a list((!threat_type && Queuet_LENGTH=n =>((Queuet_LENGTH=n+1))Action 1.2’: Whenever a threat is generated and a list requested from buffer at the same time this threat will also be send to query (Coincidence)  ((!threat_type && !done_signal && Queuet_LENGTH=n =>((Queuet_LENGTH=n+1 => (Queuet_LENGTH=0))Action 1.3: Whenever there is a threat to be prioritized query will prioritize it.(( Queuet_LENGTH=n && Query_STATUS=STAND_BY =>((Query_STATUS=QUERY && Queuet_LENGTH=0))Action 1.4: Whenever n threats are prioritized they will be ordered in a queue.((Query_STATUS=QUERY && Queuet_LENGTH=k =>((QueueP_LENGTH= k+n && Query_STATUS=STAND_BY))Action 1.4’: Whenever threats are prioritized and a threat is requested from the queue the threats will be ordered in the queue and a threat is then send for weapon assignment (Coincidence).((!threatp_list && done_signal && Queuet_LENGTH=k =>((Queuet_LENGTH= k+1 => QueryP.length=k)))Action 1.5: Whenever there is a threat to be assigned weapon, weapon assignment system will process it (this will assign the threat to Threat federate as well).((Queuep_LENGTH=n && Aws_STATUS=PASSIVE =>((Aws_STATUS=ACTIVE && Queuep_LENGTH=n-1 && Threat.status=ALIVE && IDENTITY=Thrat_type)Action 1.6: When there is a suitable weapon for the threat, but it is not ready to lunch a follow up request will be issued.(( (Aws_STATUS=ACTIVE =>((!follow_up && Aws_STATUS=ACTIVE))Action 1.7: When there is a ready weapon for the threat, the system will issue an action request (This will make the Threat dead).(( (Aws_STATUS=ACTIVE =>((!action && Aws_STATUS=PASSIVE && Threat_status=DEAD))Action 1.8: Whenever the threat receives an in range signal from sensory resources it sets its range to in_range((In_range => ((RANGE=In_Range))Action 1.9: Whenever the launch is requested a weapon is fired (launch turns to off)((Launch=ON => ( (!fire && Launch=OFF && Aws_Status= DEAD))The second group assertions are as follows;Action 2.1: Priotizer makes query as generator produces threats.((Generator_status=ACTIVE => ((Query_status=QUERY))Action 2.2: When priotizer queries eventually Assign Weapon System will be active. ((Query_status=QUERY => ((aws_status=ACTIVE && Query_status=STAND_BY))The next step is to exemplify the temporal verification by an example case from temporal formulas. Temporal formula of Action 2.2 is decomposed and related grammar and corresponding finite automaton is generated, which will then be used to verify the operation of TMD federation from Action 2.2 point of view.Action 2.2: When priotizer queries eventually Assign Weapon System will be active. ((Query_status=QUERY => ((aws_status=ACTIVE && Query_status=STAND_BY))Let’s say that A: Query_status=QUERYB: aws_status=ACTIVE && Query_status=STAND_BYThen the formula becomes ;	((A=>(B)decomposition of the formula to produce the state automaton for the Action 2.2 is as the following;1. ( ( (A => (B)S=(2. Apply decomposition formula (: (1((2 = ((1 + (1(2(= (A + A((B)VT ( ((A, A( (Terminal expressions i.e. events)VN ( ((B ( (Non-Terminal expressions i.e. there is still something to happen)P( (S=>(A, S=>A((B) (3. Apply the decomposition rule (( => ( + ((((() to the non-terminal expression (B(B => B + (B((B)VT (  VT  ( ((B, B(P( P  ( ((B =>B, (B =>(B((B) (Since there is no new non-terminal expression other than (B, the decomposition process ends. The Grammar for Action 2.2 is completed;		G=<VN, VT, P, S>Now the state automaton for this decomposition is realized as in the following;Finite Automaton  M of  the TL Grammar G is;	M:=< Q, (, (, q0, F >These are defined for Action 2.2 as:	Q: VN ( (f(= (S, (B, f( where f ( F	(: VT = ((A, A, B, (B(	q0: q0 = S ( Q	F:  F= (f(	(: transition functions;Yet if the temporal formula is always (() valid then this behavior should be generated in every execution of the model. Therefore, final state is treated as initial state [2]. This movement is called (-movement which is an automatic (non-event) movement. Hence, transition functions are derived from P of Action 2.2 as;P= (S=>(A, S=>A((B), (B =>B, (B =>(B((B) (			Then((S,A)= f = S((S,A)= (B = S1 (((B,B)= f = S(((B, (B)= (B =S1The state transition diagram for the grammar of Action 2.2 is;Figure 5. State Transition DiagramThe verification is performed based on the algorithm given in the previous section. For this purpose the untimed operation of TMD federation that generates all possible states of TMD federation is shown in the finite state automaton in Figure 6. For the sake of simplicity, the automaton is represented by the corresponding state changes in a combinatorial state, which consists of Generator_Status, Query_Status, Assign_Weapon_System_Status, Threat_Status and Threat_Launch states of the federation. In this automaton, A stands for the Active states of Generator_Status, Assign_Weapon_System_Status and Threat_Status state variables of federation, S stands for Stand-By state of Query_Status, Q stands for Query state of Query_Status, P stands for Passive state of Assign_Weapon_System_Status, On and Off shows the state of Threat_ Launch. S0 and S1 represents the states of the Action 2.2 automaton. Figure 6. Finite Automaton for Verified ModelAs implied in the verification algorithm given in the previous section, the state transitions are verified if the next state of the federation satisfies the transition condition of Action 2.2 finite automaton at its current state. For example, the transition from state 3, at which the Action 2.2 automaton is its S1 state, to state 1 is a correct and verified operation since the next state that is Assign_Weapon_System ‘output’ is action, Assign_Weapon_System_Status is ‘Passive’ and Threat_Launch is ‘Off’. This is nothing but the transition condition for the Action 2.2 automaton from state S1 to State S0 (Figure 6). Hence the language generated by TMD federation is verified and accepted. The verification is complete when the same process is applied for the whole operation (state transitions), in other words, the language of TMD federation taking all the temporal assertions based grammars into account. Discussion and ConclusionTemporal assertions are directly related the real world, they can be generated from natural language statements since it is based on logic. These assertions impose safety and liveness conditions when they are generated based on the correct behaviors of systems. So, temporal assertions based verification bridges the gap between the operation of federations and what is expected from the simulation. This framework offers a well-defined process for operational verification in developing verified, validated and accredited HLA Federations. The approach enables us to focus on whole federation behavior as well as separate federate behaviors. This allows simulation developers to verify that they have behaviorally correct federations that arecomposed of dynamically verified federates. The realization of this framework in the HLA domain requires an architecture as given in the paper. The two main parts of the architecture are observer and language acceptor. When these two modules are plugged in a federation execution, the behavior of federation is verified at execution time. A proof-of-concept prototype is under development using the DEVSJAVA, and Prolog  and DEVS/HLA environments.     REFERENCES[1]URL:  HYPERLINK "http://yeroos.qant.ucl.ac.be/dummies/ariane.html" http://yeroos.qant.ucl.ac.be/dummies/ariane.html[2] Zeigler, B. P., Praehofer, H., Kim, T. G., “Theory of Modeling Simulation: Integrating Discrete Event and Continuous Dynamic Systems”, Academic Press, San Diego, CA, (2000)[3] Gotzhein, R., “Temporal Logic and Applications-a Tutorial”, Computer Networks and ISDN Systems 24, North Holland, (1992)[4] Serjoughian, H. S., Zeigler, B.P. “DEVS and HLA: Complimentary Paradigms for Modeling and Simulation”, SCS  Transaction (To be published in 2000)[5] Hone, G.N., Moulding, M.R., “Application Domain Modelling to Support the Verification and Validation of Synthetic Environments”, Spring Simulation Interoperability Workshop, Orlando, FL, (1998)[6] Morales, M.C., Moulding, M.R., “Improving the Verification of Synthetic Environments: Advanced Checking of HLA Specifications Across a Federation”, Spring Simulation Interoperability Workshop, Orlando, FL, (2000)[7] Moulding, M.R., Rosenbaum, D., “The Federation Verification Tool”, Fall Simulation Interoperability Workshop, Orlando, FL, (1998)[8] URL: HYPERLINK "http://hla.dmso.mil/misc/documents/federation/fedep/fedep-v1-2.pdf" http://hla.dmso.mil/misc/documents/federation/fedep/fedep-v1-2.pdf[9] Pace, D. K., “Impact of Simulation Description on Conceptual Validation”, Spring Simulation Interoperability Workshop, Orlando, FL, (1999)[10] Cassandrass, C. G., “Discrete Event Systems: Modeling and Performance Analysis”, Richard D. Irwin, Inc. and Aksen Associates, Inc., (1993).[11] Revesz, G. E., “Introduction to Formal Languages”, Dover Publications, Inc., New York, (1983).[12] Garson, J. W., “Modal Logic”, Stsnford Encylopedia of Philosophy,  HYPERLINK "http://plato.stanford.edu/contents.html#l" http://plato.stanford.edu/contents.html#l, pp. 1, (2000). [13] Manna, Z., Pnueli, A., “Temporal Verification of Reactive Systems”, Springer-Verlag, New York, (1995).[14] Hailpern, B. T., “Verifying Concurrent Processes Using Temporal Logic”, Springer-Verlag, Berlin, (1982).[15] Good, W. G., “Temporal Logic Case Study”, Technical Report, CMU/SEI-89-TR-24, ESD-89-TR-32, (1989).[16] Lewis, R. O., Coe, G.Q., “A Comparison Between the CMMS and the Conceptual Model of the Federation”, Fall Simulation Interoperability Workshop, Orlando, FL, (1997)APPENDIX 1The DEVS specification of Assign Weapon Federate and Threat Federate are given as follows:atomic model ASSIGN_WEAPON_SYSTEMinports	: threatp_in;fire;outports	:action;follow_up;done_signal;no_weapon;state variables:	status	:(ACTIVE, PASSIVE, DEAD(;	fq_status: (QUERY, STAND_BY(;	winfo_status: (WEAPON_TYPE (;	wsq_status: (QUERY, STAND_BY(;	ws_data	: (READY, NOT_READY(;initial condition:	status		= PASSIVE;	fq_status	= STAND_BY;	winfo_status	= EMPTY;	wsq_status	= STAND_BY;	ws_data	= NOT_READY;internal transition:(fq_status=QUERY)=>(fq_status=STAND_BY);(fq_status=QUERY)=>((winfo_status=WEAPON_TYPE)  || (winfo_status=EMPTY));(winfo_status=WEAPON_TYPE)=>(wsq_status=QUERY);(winfo_status=EMPTY)=>(status=PASSIVE);(wsq_status=QUERY)=>(wsq_status=STAND_BY);(wsq_status=QUERY)=>((ws_data=READY) || (ws_data=NOT_READY));(wsq_status=QUERY)=> (status=PASSIVE);external transition: (status=PASSIVE)*threatp_in=>(status=ACTIVE);(status=ACTIVE)*fire=>(status=DEAD);output function:(ws_data=READY)=>action && done_signal;(ws_data=NOT_READY)=>follow_up && done_signal;end ASSIGN_WEAPON_SYSTEMatomic model  THREATinports	: threatp_out;in_range;action;outports	:fire;state variables:	status	: (ALIVE, DEAD(;	identity	: (THREAT_TYPE, NONE(;range	:(IN_RANGE, OFF_RANGE(;	launch		: (ON, OFF(;initial conditions:	status		= DEAD;	identity	= NONE;	range		= OFF_RANGE;	launch		= OFF;internal transitions:(range=IN_RANGE)=>(launch=ON) && (range: OFF_RANGE);(launch=ON)=>(launch=OFF);external transition: (status=DEAD)*threatp_out=>(status=ALIVE);(status=ALIVE)*in_range=>(range=IN_RANGE);(status=ALIVE)*action=>(status=DEAD) && (identity=NONE);(identity=NONE)*threatp_out=>(identity=THREAT_TYPE);output function:(launch=ON)=>fire; end THREAT;The Prioritizer and Assign Weapon federates are coupled DEVS model coupling whose specifications are as in the following:Coupling PriotizerEIC={(( Priotizer, threat_in),(QueueT, threat_in))}EOC={((Query, ThreatP_list),(Priotizer, threatp_list))}IC={((QueueT, threat_list), (Query, threat_list)), ((Query, done_signal), (QueueT, done_signal))}Coupling AWSEIC={((AWS, threatp_list), (QueueP, threatp_list)),	((AWS, fire), (Assign_Weapon_system, fire))}EOC={(( Assign_Weapon_system, action), (AWS, action)),	((QueueP, threat_out), (AWS, threat_out))}IC={((QueueP, threat_out), (Assign_Weapon_system, threatp_in)),	((Assign_Weapon_system, done_signal), (QueueP, done_signal))}Author BiographiesCUNEYD FIRAT is a researcher in Information Technologies Research Institute of TUBITAK-Marmara Research Center and Ph.D. student in Institute of Sciences and Technology in University of Sakarya, Turkiye. His research interests include software development processes, conceptual modeling especially as applied in HLA conceptual analysis, DEVS modeling and simulation methodology, verification and validation of simulation models and AI applications in simulation domain. He is currently visiting scholar in AI & Simulation Research Group in Electrical & Computer Engineering Department of University of Arizona, Tucson.MEHMET F. HOCAOGLU is a senior researcher in Information Technologies Research Institute of TUBITAK-Marmara Research Center. His Ph.D.  was about qualitative simulation. His research interests include software development processes, qualitative simulation, logic programming, DEVS modeling and simulation methodology, verification and validation of simulation models and AI applications in simulation domain. He also studied on simulations of production systems (JIT, job-shop, harvesting). He is currently visiting scholar in AI & Simulation Research Group in Electrical & Computer Engineering Department of University of Arizona, Tucson.BERNARD P. ZEIGLER is Proffesor of Electrical and Computer Engineering at the university of Arizona, Tucson. He has written several foundational books on modelling and simulation theory and methodology. He is currently leading several projects sponsored by DARPA and NSF. He is a Fellow of the IEEE. PAGE  11Figure 4. The DEVS scheme of TMD federationASSIGN WEAPON SYSTEMGeneratorthreatp_listSTATUSAWSfireactionWS_DATAWSQ_STATUSWINFO_STATUSFQ_STATUSSTATUSfollow_updone_signalthreatp_inthreatp_outAWS_STATUSLENGTHQUEUE_Pactionthreatp_outfireIn_rangeLAUNCHRANGEIDENTITYSTATUSTHREATthreat_listthreat_listdone_signalthreatp_listPriotizerSTATUSQUERYQUERY_STATUSLENGTHQUEUE_Tthreat_typethreat_in EMBED PBrush  Verification resultsTemporal Logic Based Language Acceptor...	.	.Observer FederateDEVS FederateDEVS FederateHLA-RTIVerification ResultFederation ExecutionLanguageLanguage CheckerDecompositionLanguage GrammarFederation Object ModelConceptual Model of FederationAlphabet and Temporal AssertionsOperational Verification on time of executionOperational Verification based on untimed execution EMBED Word.Document.8 \s 