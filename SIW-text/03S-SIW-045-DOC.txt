The Advantages of the TENA 2002 Meta-ModelEdward T. PowellTENA ArchitectScience Applications International Corporation5400 Shawnee Road, Suite 110, Alexandria VA 22312703-587-8036 HYPERLINK "mailto:edward.powell@saic.com" edward.powell@saic.comKurt LessmannTerry BurksRob LurieTENA Object Model Team500 Wynn Drive, Suite 314, Huntsville AL 35816256-722-7200[klessmann, tburks]@amtec-corp.com, rlurie@hiwaay.netGeorge J. RumfordFoundation Initiative 2010 Technical Project ManagerCentral Test and Evaluation Investment Program4850 Mark Center Drive, Suite 1000, Alexandria VA 22311 703-681-4000 x138 HYPERLINK "mailto:george.rumford@osd.mil" george.rumford@osd.milKeywords:Interoperability, Reuse, Architecture, Ranges, Test and Evaluation, TENA, FOM Design, Object ModelsABSTRACT: The Test and Training Enabling Architecture (TENA) 2002, a product of the Foundation Initiative 2010 project, is defined to bring interoperability and reuse to the nation's test and training ranges.  A major part of TENA 2002 is the TENA Middleware, which is used for high-performance, low-latency, real-time communications between applications.  The content of the communication is the “Logical Range Object Model (LROM),” a set of object definitions that are agreed to by all applications that participate in a logical range.  While the LROM may seem similar to the HLA's Federation Object Model (FOM), the nature of objects in each are strikingly different.  Objects in an HLA FOM are based on the HLA Object Model Template (OMT), while objects in the TENA LROM are based on the TENA Meta-Model.  The TENA Meta-Model defines the different types of objects that TENA supports and the features they may have.  TENA supports a wide variety of object modeling features that the HLA does not: composition, local and remote object methods, interfaces, vectors, local classes, distributed object references, and fundamental types.  This paper discusses the TENA Meta-Model in detail, provides a description of the subset that has been implemented in the current TENA Middleware prototype (IKE 2 Release 3), and contrasts the TENA Meta-Model with the HLA OMT.IntroductionThis paper describes the meta-model defined in Test and Training Enabling Architecture (TENA) 2002, designed to bring affordable interoperability to America's test and training ranges and their customers.  TENA is designed to support the implementation of the Joint Vision 2020 by promoting integrated testing and simulation-based acquisition through the use of the concept of a “Logical Range.”  A logical range integrates existing testing, training, simulation, and high-performance computing technologies, distributed across many facilities, and ties them together using the elements of a common architecture.TENA is a product of the Foundation Initiative 2010 (FI 2010) project, sponsored by the Central Test and Evaluation Investment Program.  The FI 2010 project performed numerous studies on other architectures, including the High-level Architecture for Modeling and Simulation (HLA).  TENA builds upon the advances made by each of these architectures. [1] [2] [3] [4]The basis for a successful logical range is its Logical Range Object Model (LROM), which encodes all information exchanged in a logical range, and the TENA Middleware, which transports this information.  The rules that guide the creation of the objects that make up the LROM comprise the TENA Meta-Model.  This paper describes and compares the TENA Meta-Model and the HLA Object Model Template (OMT), and describes the significant advantages of the TENA Meta-Model.What is a Meta-Model and How Do You Represent It?A meta-model is a description of the features available for use in formulating an object model.  This is true whether you are defining an HLA FOM or a TENA LROM.  Each architecture has its own meta-model that describes the features that FOM objects or TENA LROM objects may have.  The meta-model concept is not unique to TENA or the HLA—all computer languages are governed by a meta-model, and these are all different from one another.  The TENA Meta-Model is the architectural construct that specifies both the rules for defining an LROM and the requirements for the middleware.In formulating the TENA meta-model, the TENA architects studied the meta-models of the C++ programming language, the Java programming language, the CORBA Interface Definition Language (IDL), and the HLA OMT.  The TENA meta-model was defined based on the information description requirements of the test and training range communities, taking into account all lessons learned from the studies of previously-defined meta-models.The primary high-level requirements for the TENA meta-model were:It must support distributed computing,It must be rich enough in features to support the object modeling needs of the entire test and training range community,It must provide a semantic unification of information amenable to the creation of a simple, yet powerful, standard TENA Object Model for the entire test and training range community,It must be as easy to use and understand as possible given the above requirements.These requirements led to the invention of the Stateful Distributed Object concept, combining the best features of CORBA and the HLA in one easy-to-use package.It is believed that the TENA meta-model presented below can describe all of the information encoded on ranges today and in the future.  However, if as part of the TENA prototyping process it is determined that additions or changes to the TENA meta-model are needed, these will be made in as unobtrusive a fashion as possible.The rules of any computer language are usually expressed in Backus-Naur Form (BNF), a text-based representation of the structure of the language.  While useful and very precise, such a representation is almost impossible for the casual reader to understand.  Thus for the purpose of this paper (and the TENA 2002 architecture), the TENA meta-model is illustrated pictorially using a representation based on the Universal Modeling Language (UML).  This representation is illustrated in  REF _Ref30347152 \h Figure 1, below.Figure  SEQ Figure \* ARABIC 1 – Pseudo-UML used to depict meta-modelsIn this figure, the reader can see that the standard UML notation for “contains” is modified to mean “may contain.”  Similarly, the inheritance notation is modified so that it can represent the concept “may inherit from.”  Both the “contains” and “inherits” notation can be annotated with a multiplicity to indicate whether an item can contain multiple other items or multiply inherit.An Overview of the HLA Meta-ModelBefore describing the TENA Meta-Model, it is useful to describe the HLA OMT (meta-model) in equivalent terms.   REF _Ref30348267 \h Figure 2 shows the HLA Meta-Model in pictorial form using the pseudo-UML described in the previous section. The HLA OMT is composed of three basic concepts, the “object” which can loosely contain one or more “attributes,” and the “interaction” which may contain one or more “parameters.”  There is no semantic difference between an attribute and a parameter (other than that objects can only contain attributes and interactions can only contain parameters), thus they are shown as a single item in the figure above.  An object is said to “loosely” contain attributes because such containment is not maintained across process boundaries—different applications can “own” attributes belonging to a single HLA object.Each attribute/parameter contains a single name-value pair, a concept not exactly in the HLA meta-model, but defined in the implementation language (C++ [as shown in the figure] or Java).  The name-value pair contains a block of memory, which of course could contain any type of information; however, the actual type of this information is not available to the RTI, which treats it as the diagram represents—as a single chunk of undifferentiated memory.Figure  SEQ Figure \* ARABIC 2 – The HLA Meta-ModelBoth objects and interactions can inherit from other object and interactions, respectively, but cannot contain other objects or interactions.As can be seen from the figure, the HLA meta-model is very limited.  TENA has attempted to provide a much richer and more extensive set of features for object modelers to use when creating their LROMs.  We describe these TENA features in the next two sections.Services of The TENA Meta-ModelThere are three main categories of service that the TENA Object Model must support.  These services provide the underlying functionality for the different types of range information that need to be encoded and standardized.  These three services can be summarized as a) objects with definite lifetimes during the logical range (Stateful Distributed Objects), b) transient objects (Messages), and c) streaming information (Data Streams).  The TENA Meta-Model supports the constructs necessary to describe all of the information that can be transferred using these three services.  In this section we describe these services in detail, while the more formal description of the meta-model can be found in the next section.Stateful Distributed Objects are objects that have a non-zero lifetime during a range event, and have a state that evolves during the event.  They have remotely-invocable interfaces and a publication state that is disseminated to client applications.An SDO is a combination of two powerful concepts: a distributed object paradigm (like the one used in CORBA), and a distributed publish and subscribe paradigm.  “Distributed object-oriented systems and publish-subscribe systems both provide users with powerful programming abstractions.  Yet each provides something the other lacks.  A conventional distributed object-oriented system offers no direct support to the user for disseminating data from a single source to multiple destinations.  A conventional publish-subscribe system does not provide the abstraction of objects with a set of methods in their interface.  Combining this pair of powerful programming paradigms yields a new paradigm providing the strengths of each, and at the same time freeing the programmer from the common chore of explicitly storing the data that arrives as part of the publish-subscribe system.…  An SDO is an object that provides a location-transparent interface to its methods as well as the notion of publication state.  The publication state of an SDO is data that is disseminated from the creator of an instance of an SDO to all parties that have indicated their interest in that SDO's data through a subscription.  Interested subscribers receive references [proxies] to SDOs.  With an SDO reference a subscriber can invoke methods on its interface, as can be done with a CORBA reference to a distributed object. In addition, an SDO reference provides the programmer the ability read the publication state of the SDO as if it were local data, as can be done in many distributed shared memory systems.” [5]An SDO exists only in a single application, in a single process space.  This application is called the “server” or “owner” of this particular SDO.  There is only one owner application of any particular SDO instance at any one time.  The SDO instance itself is called the “servant.”  References to this servant that have a local cache of the servant's publication state (called “proxies”) may exist in any application in the logical range, including the server application.  This concept is illustrated in  REF _Ref30499968 \h Figure 3, below.Composition is the most important aspect of the TENA meta-model—users may construct SDOs that contain other SDOs.  This feature is critical to the creation of a standard set of reusable TENA object definitions.  Since the TENA meta-model allows composition, TENA object model developers can focus their efforts on standardizing small, reusable, “building block” objects, rather than having to define the entire object model all at once. The remotely-invocable methods on an object are intended for one-to-one communication, in which an object or application wants to communicate something to a specific single object.  Publication state, on the other hand, is intended for one-to-many communication, where one object's publication state is disseminated to many recipients.Figure  SEQ Figure \* ARABIC 3 – SDO Servants and ProxiesMessages are single transient “bundles” of information that are published by applications and consumed by sub-scribing applications. Messages represent single instantaneous objects that may be transmitted between publishers and subscribers.  Messages are defined in the TENA Meta-Model as local classes (also called valuetypes, see below), and like SDOs support single inheritance for implementation, multiple inheritance for interfaces, and composition.  Messages are intended for one-application-to-many-applications communication.  For single-application-to-single-application communication, a concept called the Application Management Object is used (see [4]).  Messages are currently being prototyped.Data Streams represent repetitive, isochronous streams of information, such as audio, video, or telemetry.  Data streams are used for both one-application-to-many-application and one-application-to-one-application communication.  They are implemented in the Meta-Model as a special StreamBuffer attribute in an SDO's publication state.  The SDO's other publication state attributes contain all of the meta-data associated with the data stream, while the StreamBuffer attribute represents the endpoint for publishing and receiving the actual data stream information.  The stream itself consists of a sequence of “frames.”  There may be many types of frames associated with a single stream.  Each frame is encoded as one or more local classes or vectors. The intent of a separate data stream service is to provide a very high performance, quality-of-service-managed mechanism for exchanging streaming information.  This feature is currently being prototyped..Elements of the TENA Meta-ModelThe TENA Meta-Model is shown in  REF _Ref30504590 \h  \* MERGEFORMAT Figure 4 below, which presents a UML-like diagram that describes all of the elements of the meta-model, along with their relationships. The reader is encouraged to view  REF _Ref30504590 \h  \* MERGEFORMAT Figure 4 as merely an illustration of the meta-model concepts.  Each of the concepts in the figure has a corresponding keyword in the TENA Definition Language (TDL).  Each of these concepts will now be discussed in detail.(SDO) Class - A class is a Stateful Distributed Object servant.   REF _Ref30504590 \h  \* MERGEFORMAT Figure 4 illustrates a class's features:A class may inherit from zero or one other class (no multiple inheritance),A class may contain other classes (composition), as many as the user needs,A class may contain a vector that contains an arbitrary number of similarly-typed other classes, A class may implement interfaces, as many as the user needs,A class may contain a number of operations (method signatures),A class may be referred to by a reference,A class may contain a StreamBuffer, a special attribute that acts as the endpoint for the dissemination of data streams,A class contains one special local class, called the “Publication State,”  which is disseminated to all subscribers of this class and is cached locally in the subscribers' proxies.StreamBuffer - A StreamBuffer is a special attribute of an SDO class that provides an endpoint for disseminating a data stream.  The information in the data stream itself is divided up into frames, each of which is encoded as either a vector or a local class.Interface - An interface is a series of one or more operations (method signatures) intended to represent a type.  An interface may extend (inherit from) multiple other interfaces.  It may be implemented either by an SDO class or by a local class.  When an interface is implemented by a local class, it is called a “local interface,” and the inheritance is called “local inheritance” since the methods are executed wherever the local class is located, either on the server as part of a servant, or on the client as part of a proxy or message body.Operation - An operation is a method signature, containing a return type and a series of parameters. Return types and parameters can be enumerations, fundamental types, references, vectors, or local classes.  Operations may throw exceptions indicating that an error or unexpected circumstance has occurred.  Operations may be contained in a class, an interface, or a local class.  In this latter case, operations contained in local classes are called “local methods,” since they execute locally.Exception - An exception may be thrown by an operation to indicate an error or unexpected condition.  An exception can contain enumerations, fundamental types, or references to SDOs.Enumeration - An enumeration represents a user-defined type that can take one of several pre-defined values.  Enumerations can be contained in exceptions, local classes, or vectors.  Enumerations can be used as parameters and return values of operations.Fundamental Type - A fundamental type is a type that represents an indivisible piece of information.  Fundamental types can be contained in exceptions, local classes, and vectors.  Fundamental types can be used as parameters and return values of operations.  The TENA meta-model supports the following fundamental types:short - a signed 16-bit integer,unsigned short - an unsigned 16-bit integer,long - a signed 32-bit integer,unsigned long - an unsigned 32-bit integer,long long - a signed 64-bit integer,unsigned long long - an unsigned 64-bit integer,float - a 32-bit floating-point value,double - a 64-bit floating-point value,octet - an untyped, uninterpreted eight-bit value,char – 8 bits interpreted as an ASCII character,string - a sequence of characters, treated as a fundamental type,boolean - an eight-bit value that represents one of only two values: TRUE or FALSE.Reference - A reference represents a distributed “pointer” to an SDO class.  Using a reference to an SDO, a user can navigate directly to that SDO.  When a user uses (dereferences) a reference, he gets a proxy to the SDO, including the current version of the SDO's publication state.  References can be contained in local classes, vectors, and exceptions.  They can be used as parameters and return values of operations.  An individual reference refers to a particular type of SDO.Vector - A vector is a sequence of elements, all of the same type.  A vector consisting of other vectors is a valid construct, so vectors support composition to any level desired by the logical range developer.  A vector can be a sequence of similarly-typed local classes, fundamental types, enumerations, or references.  A vector of a series of similarly-typed SDO classes can be contained in another class.  Vectors can be used as parameters and return values of operations.  Vectors can be contained in local classes.  Vectors can be used as frames for data streams.  Since local classes may also contain vectors, it is possible for the logical range object model developers to create quite complex attributes; for example, a vector of a particular local class that contains a vector of vectors of another local class that contains fundamental types, enumerations, references, and another vector of a fundamental type, etc.Local Class (also called a “Valuetype”) - a local class defines an object that exists only locally in a given process space, and can be transmitted “by value” from one process to another.  The most important local class is the one that implicitly comprises the publication state of an SDO class.  Local classes may also be used as message bodies and as frames for data streams.  Local classes have the following properties:A local class may contain other local classes,A local class may contain enumerations,A local class may contain any number and type of fundamental types,A local class may contain references to SDO classes,A local class may contain vectors of other elements,A local class may be contained in a vector,A local class may inherit from at most one other local class (single inheritance for implementation),A local class may implement any number of interfaces; this is called “local inheritance,”A local class may have any number of operations; these operations are also called “local methods,”A local class may be used as a parameter and return value for an operation,A local class is used as the publication state for an SDO class.Aspects of the TENA Meta-Model Currently Available in The TENA MiddlewareNot all of the features described in  REF _Ref30504590 \h  \* MERGEFORMAT Figure 4 have been prototyped yet in the TENA Middleware.  The features currently available in IKE 2 Release 3 are illustrated in  REF _Ref30506396 \h Figure 5 below.The most important elements present in  REF _Ref30506396 \h Figure 5 are the SDO, struct, and vector concepts.  “Structs” are used temporarily in place of the more sophisticated local classes. Vectors of fundamental types and arbitrary structs are allowed, so quite complicated object models are possible.  All of the objects defined as part of the LROM are marshaled and de-marshaled by efficient, type-safe, compiled code, no matter how small or complex they are.  Thus the user is not presented with a choice between either high performance on the one hand and standardizability on the other, but can achieve both at the same time.Conclusions about the HLA and TENA Meta-ModelsThe HLA meta-model has two major limitations.  First, because the attribute name-value pairs are interpreted, users are forced to choose between defining fine-grained objects with lower performance, or defining large un-marshaled structures, with higher performance but limited potential for interoperability across platforms or standardizability across programs or domains.  Second, the HLA meta-model does not support composition—the ability to contain objects of one type in definitions of objects of another type.  This deficiency prevents the standardization of small, frequently reused “building block” objects that can be contained in many other objects, and severely constrains object model developers from creating, standardizing, and easily evolving reusable object definitions.The TENA Meta-Model, by contrast, not only allows users to define extremely fine-grained objects with no performance penalty, but empowers users to create classes, structures, and vectors that can be easily reused from one logical range to the next without having to fully and formally define the entire standard TENA Object Model.  The TENA Meta-Model provides the basis for the gradual, iterative development of a standard TENA Object Model through tests performed at real ranges.In addition, when fully implemented, the TENA Meta-Model supports object modeling constructs that cannot even be imagined using the HLA, such as direct support for data stream definitions that can be standardized across multiple user domains, seamless coordinate conversion capability built right into the object model via local methods, or support for both local and remote interfaces.The definition of the TENA Meta-Model is not set in stone.  Based on feedback from TENA users, new features may be added in the future to meet new information modeling needs.  TENA remains flexible enough to change and adapt based on the needs of the range community as a whole, while still providing substantial and increasingly powerful standards that ensure a new level of high-performance interoperability to the test and training range community and the entire US Department of Defense.Bibliography[1] George J. Rumford, Minh Vuong, Stephen T. Bachinsky, Dr. Edward T. Powell, “Foundation Initiative 2010: The Foundation for Test and Training Interoperability,” 01S-SIW-056, March 2001.[2] George J. Rumford, Minh Vuong, Stephen T. Bachinsky, Dr. Edward T. Powell, “Foundation Initiative 2010: The Design of the Second TENA Middleware Prototype,” 01F-SIW-110, September 2001.[3] Kurt Lessmann, Jason Lucas, Dr. Edward T. Powell, “Foundation Initiative 2010: Update on the Development and Testing of the Test and Training Enabling Architecture (TENA),” 02S-SIW-052, March 2002.[4] Edward T. Powell, Kurt Lessmann, Jason Lucas, and George J. Rumford, “The Test and Training Enabling Architecture (TENA) 2002 Overview,” 02F-SIW-074, 9/02.[5] Noseworthy, JR, “IKE 2—Implementing the Stateful Distributed Object Paradigm,” Proc. of 5th IEEE International Symposium on Object-Oriented Real-Time Distributed Computing (ISORC 2002), May 2002, pp 45-53.Author BiographiesDR. EDWARD T. POWELL is a senior scientist and program manager with Science Applications International Corporation.  His interests include large-scale system architectures and designs, and the integration of simulations with C4I systems and live test and training facilities. He has served as a lead system architect for many simulation programs including JPSD, STOW, and JSIMS, and is now the TENA Architect and Program Manager for the TENA 2nd Middleware Prototype (IKE 2) Development Team.KURT LESSMANN is the FI 2010 Object Model Development Team Lead.  His background includes the development and utilization of weapon system simulations to support various Army acquisition programs.  He has overseen several High Level Architecture-based distributed testing efforts that specialize in integrating simulations and Hardware-in-the-Loop facilities to support developmental testing programs.  He is currently the Chair for the SISO Simulation Interoperability Workshop Test and Evaluation Planning and Review Panel.GEORGE RUMFORD is the Technical Project Manager for FI 2010.  With degrees in Electrical Engineering and Computer Engineering from the University of Missouri, he has worked on numerous multi-range and synthetic test and training events at the U.S. Army White Sands Missile Range (WSMR).  George is a member of the DoD Architecture Management Group (AMG) for the High Level Architecture (HLA) and is currently serving as the Deputy CTEIP Program Manager for the Director, Operational Test and Evaluation (DOT&E).Figure  SEQ Figure \* ARABIC 5 - Parts of the TENA Meta-Model currently operational in the TENA Middleware (IKE 2 Release 3).Figure  SEQ Figure \* ARABIC 4 - The TENA Meta-Model, its features illustrated in a UML-like notation.  Stateful Distributed Objects are instances of what is shown on the diagram as a “Class,” shaded yellow.  Messages are defined as “local classes.”  The information content of Data Streams is defined either as a series of vectors or local classes, while the endpoints of Data Streams are defined as a special SDO attribute, the StreamBuffer.Local Class