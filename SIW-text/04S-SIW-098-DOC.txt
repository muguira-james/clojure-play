The Distributed Simulation Management Services Layer in SPEEDESDr. Jeffrey S. Steinman, Chief ScientistRAM Laboratories10525 Vista Sorrento Parkway, Suite 220San Diego, CA  92121(858) 677-9207steinman@ramlabs.comKeywords:Standard Simulation Architecture, DSMS, SPEEDES, CCSE, WarpIV, SSA, HLA, DIS, PDES, HPC-RTI, Distributed Simulation, Interoperability, Reuse, Entities, Components, Federation Objects, Interest Management, DDMABSTRACT: This paper provides an overview of the SPEEDES design and implementation of the Distributed Simulation Management Services (DSMS) layer defined within the Standard Simulation Architecture (SSA). The DSMS layer mirrors HLA services in logical time between entities and their components executing either sequentially on single-CPU machines or in parallel on multiprocessor machines operating in a distributed network environment. The DSMS layer is currently implemented in SPEEDES in support of several large DoD simulation projects such as the Joint Simulation System (JSIMS) and the Joint Modeling And Simulation System (JMASS).IntroductionThe High-Level Architecture (HLA) [1, 2, 3, 4] provides services through its Run-Time Infrastructure (RTI) to facilitate interoperability between Federates. In a similar manner, the Distributed Simulation Management Services (DSMS) layer mirrors HLA services in the Synchronous Parallel Environment for Emulation and Discrete-Event Simulation (SPEEDES) [5, 6, 7, 8, 9] framework to facilitate interoperability between entities and their internal components potentially executing in a parallel and distributed environment within the Standard Simulation Architecture (SSA) [10].Within the DSMS layer, entities interoperate through two basic mechanisms. First, Federation Objects (FOs) allow entities to publish exportable attributes to subscribing entities. This is how entities in a parallel and/or distributed simulation execution obtain knowledge about each other. Second, entities interact with one another through an HLA-compatible interaction mechanism. This is how an entity invokes actions on other entities. Interest management is provided for both FOs and interactions to reduce the amount of traffic flowing between entities.Automated interoperability with HLA is accomplished through two mechanisms. First, an HLA Gateway [11, 12, 13, 14] acting as a special entity passes two-way information between the DSMS layer and the RTI. This is accomplished while also coordinating the advancement of logical and/or real time. Second, a High-Performance Computing Run Time Infrastructure (HPC-RTI) [15] provides direct HLA interfaces between legacy Federates and models implemented in the SSA.The Standard Simulation ArchitectureThe Standard Simulation Architecture provides a layered architecture with standardized interfaces in each of its layers (see  REF _Ref411500179 \h Table 1) The goal of the Standard Simulation Architecture is to facilitate interoperability, flexibility, and high-performance computing on parallel and distributed hardware systems.Table  SEQ Table \* ARABIC 1: The Standard Simulation Architecture.The low-level System Services, Threads, Network Communications, Internal High-Speed Communications and External Distributed Communications layers provide a full-spectrum of system utilities and inter-process communication services in a standard portable manner.The Rollback Framework, Event Management Services, and Time Management layers provide the basic infrastructure that is necessary to support discrete-event and real-time simulations executing on single or multiple CPU machines.The Utilities, Rollback Utilities, Standard Modeling Framework, Distributed Simulation Management Services, and External Modeling Framework layers provide the basic set of constructs and tools required for software developers to efficiently build simulation models and to directly connect them to external systems such as graphical user interfaces and hardware devices.The Component Repository and the Entity Repository provide a library of models that were designed for reuse across multiple simulation domains.The CASE tool layer allows commercial vendors to generate code through specialized compilers and/or graphical programming environments to simplify the development of new models. The CASE tool layer may also provide graphical tools to simplify scenario generation and object compositions with mixed levels of resolution. The CASE Tool layer may also provide backward compatibility services to map legacy simulations to the standard simulation Architecture.The SOM/FOM Translation Services, HPC-RTI Interface, and HLA Gateway layers support interoperability between Standard Simulation Architecture Federates, legacy HLA Federates, and HLA Federations. The FO and interaction data translation services allow a Federate to define its own specialized SOM while promoting interoperability with other Federates. The HLA Gateway may provide multi-level security services between networked Federates.The complete architecture provides high-speed software reuse and interoperability between entities and components that are modeled in Direct Federates and Abstract Federates. It further provides interoperability with legacy Federates and HLA Federations through the HPC-RTI Interface and HLA Gateway layers. Non-HLA external systems may directly interoperate with the overall system through the External Modeling Framework.Functionality Provided by the DSMS LayerThe DSMS layer in the Standard Simulation Architecture mirrors HLA services between entities and promotes interoperability between Federates, entities, and components within an entity. The services provided by the DSMS layer include:Publication and Subscription ServicesManagement of Federation ObjectsPolymorphic Notifications for FO eventsInteractions with Polymorphic HandlersTime Managed Interest Management FilteringOwnership Management and Attribute EnhancementDynamic Attributes with Predictive ContractsComponents with Polymorphic MethodsEvolution of Federation ObjectsThe first implementation of the DSMS layer in SPEEDES began in 1996 as HLA began to find acceptance among the DoD simulation community. An Object Proxy system allowed entities to publish a proxy and to subscribe to proxies published by other entities [16]. Special attributes were implemented as C++ objects that could be mapped into the entity’s proxy. Through the use of operator overloading, these attributes could be used as regular data types with the added benefit of automating the bundling and distribution of attributes when they were modified.The Object Proxy mechanism provided a powerful infrastructure for distributing exportable attributes, but it suffered from several critical limitations.Only one proxy was supported per entity. This significantly limited the ability for entities and their internal components to group related attributes into separate objects that could be independently published.Automated value-based Interest Management (IM) operating on FO attributes or interaction parameters was not provided. Instead, a manual HLA-style routing space mechanism was implemented [17, 18] that used regions with independent dimensions. Not only was this difficult to use from user’s perspective, but it also hindered the ability to provide IM when executing in an HLA Federation since routing space region information is not provided to subscribers when receiving attribute reflections or when interactions are received through the RTI.For each entity, the object proxy system provided a single list of all discovered proxies. No special data structures were provided to look up proxies by type, name, Id, or by publishing entity. This made it very difficult for users to develop models that process specifically requested FOs in their algorithms.Components with internal support for IM was not integrated with the Object Proxy system. An efficient hierarchical filtering mechanism was needed to distribute received FOs to subscribing components within an entity.Full support for optimistic processing was inefficient because reflected attributes required cloning the entire proxy. A secondary concern for modelers using the proxy system was that pointers to proxies would change every time their attributes were modified. A space-time representation for attributes was required to eliminate this problem.The Object Proxy system did not allow subscribing entities to modify or enhance the attributes of discovered remote FOs.A non-standard complex packing format was used by the Object Proxy system to bundle attributes into messages. A simplified packing format was needed to not only bundle attributes into messages, but to also coordinate with interest management. Furthermore, the object proxy packing structure did not support the External Data Representation (XDR) standard for strings, variable-length arrays, or optional attributes (XDR was adopted by JSIMS).In early 2000, the Federation Object system was designed and developed to address all of these problems and to replace the now obsolete Object Proxy system. A phased development approach (see  REF _Ref419276732 \h Figure 1) was chosen to first provide all necessary functionality to support the JSIMS Development Agent (DA) modeling needs, second to optimize performance for sequential operation, third to provide scalable support for parallel execution on multiprocessor machines, and fourth to implement rollback-reduction techniques for optimistic event processing. SPEEDES is currently moving from phase one into phase two. This paper documents the phase one design that supports both sequential and parallel (but un-optimized) DSMS layer.Figure  SEQ Figure \* ARABIC 1: Phased development approach for the DSMS layer.Evolution of the DSMS Layer for InteractionsThe early SPEEDES interaction system, developed in the late 1990’s, suffered from serious problems in coordinating dynamically changing interest management interaction filters with logical time. The interaction framework was redesigned to correctly coordinate the delivery of interactions to subscribers using the time tag of the interaction instead of mistakenly using the time tag of the sender. Also, special consideration was made to coordinate interactions with HLA. If possible, the new delivery system sends interactions to the FedGateway early in logical time to account for the federate’s lookahead.Federation ObjectsThe DSMS layer involves several different kinds of classes to coordinate publications, subscriptions, interest management, and the transference of FO attributes between entities.Entities, Components, FOs, and FO ManagersThe Entity class is a special kind of SimObj. It contains a Federation Object Manager (FoMgr) whose role is to manage local FOs created by the entity, discovered remote FOs that were created by other entities, filters for interest management, and registered interaction handlers. DSMS functionality is provided to models that inherit from the Entity or Component class (and their associated user-defined classes). Simulation Objects that do not inherit from the Entity may not access DSMS services.Models can be hierarchically composed of sub-models that inherit from the Component base class. Like Entities, Components also have a FoMgr. The FoMgr in each Component hierarchically connects with its parent FoMgr to support hierarchical subscriptions. In this parent-child hierarchical infrastructure, the Entity defines its FoMgr as the RootFoMgr. This is depicted in  REF _Ref413781552 \h Figure 2.Figure  SEQ Figure \* ARABIC 2: Hierarchical components are used to decompose an entity model into sub-models. The components connect their Federation Object Managers (FoMgrs) in the same hierarchical manner to provide efficient interest management between components within an entity. A Federation Object that is discovered by an entity will be directed to the components within the entity as specified by their interest management filters.Models and sub-models may be further constructed from user-defined classes that require no inheritance from SSA classes. Yet, any user-defined class may provide exportable FO attributes that are mapped into published FOs created by any FoMgr within the Entity-Component structure (see  REF _Ref417118124 \h Figure 3).Figure  SEQ Figure \* ARABIC 3: Each component provides a FoMgr whose role is to manage LocalFos and RemoteFos. The FoMgr provides an interface to create and publish local FOs. The FoMgr also provides an interface to subscribe to remote FOs with or without interest management filters. Application classes may contain special FO attributes that are mapped into created FOs. Operator overloading allows these FO attributes to be used as normal data types. Delivery of updated attributes to subscribers is automated by overloading all of the assignment operators.Any user-defined class may provide polymorphic methods that respond to FO notification events such as discovering a FO, removing a FO, reflecting modified attributes of a remote FO, or reflecting enhanced attributes of a local FO. The polymorphic method system allows models to register their own callback methods that are automatically invoked whenever these types of DSMS events occur.Each FO internally stores an array of FoAttributeHolders that reference attributes. These attributes may be provided by applications in their C++ code through the attribute mapping mechanism, or the attribute holder may point to dangling attributes that were created internally and owned by the FO.Each FoAttributeHolder contains a TimeAttributeList that stores attributes according to their valid time interval (see  REF _Ref417122553 \h Figure 4). The TimeAttributeList is required to support optimistic processing in the case where multiple entities share the same remote FO.When a value is initially set, its value is valid from [–∞, +∞]. At this point, only one value is stored in the TimeAttributeList. If the attribute’s value is changed at time 100, then two values are stored in the TimeAttributeList with time intervals {[–∞, 100], [100, +∞]}. When the simulation’s global virtual time passes 100, the first value is removed from the list. The current simulation time is always used to lookup attributes. The value whose time interval overlaps the current simulation time is returned.Figure  SEQ Figure \* ARABIC 4: The internals of a FO. Each FO inherits from the object factory base class that is used by the FO factory to construct or destruct FOs using free lists. Each FO contains an array of FO attribute holders that stores the actual FO attributes in a space-time attribute list. Values are obtained by looking up the FoAttribute with the right time interval.The TimeAttributeList is required to efficiently support the distribution of reflected FO attributes in optimistic simulations. In contrast to the previous object proxy approach, the entire FO does not require to be cloned when attributes are modified.FO AttributesEleven different kinds of FO attributes are provided as special C++ classes that rely on operator overloading techniques for automating delivery to subscribers when their values are modified. Using default conversion operators, these attributes can be used as normal data types in regular C++ expressions. The eleven kinds of FO attributes are listed in  REF _Ref416776047 \h Table 2.Table  SEQ Table \* ARABIC 2: FO attribute types.FO TypeDescriptionPrimitiveDataTypesFO_int32-bit integer valueFO_double64-bit double precision valueFO_logical32-bit logical value (1=T, 0=F)FO_stringNull terminated stringFO_position3-D positionVariableLengthFO_listKeyed ListFO_bufferByte array with sizeFunctionsOfTimeFO_dynamic_intList of DynamicInt objectsFO_dynamic_doubleList of DynDouble objectsFO_dynamic_logicalList of DynLogical objectsFO_dynamic_positionList of DynPosition objectsAll FO attributes inherit from the FoAttribute base class (see  REF _Ref416778479 \h Figure 5). Regular attributes are static in the sense that their values are constant unless changed to a new value. Dynamic attributes are different from regular attributes in that their values are computed as a function of time. The dynamic FO attribute class provides a rich internal structure that stores dynamic items in a list. Dynamic items provide the actual time-based computations. Each item in the list has a start and end time that defines a time window for the computation. By linking consecutive time-windowed items in the list, complex dynamically computed values are supported over large time intervals.Figure  SEQ Figure \* ARABIC 5: Inheritance structure for FO attributes.A useful collection of dynamic items is provided (see  REF _Ref417118212 \h Figure 6). Dynamic integers are constructed from constant value step functions. Dynamic logicals provide on and off states over consecutive time intervals. Continuous functions are represented by dynamic doubles using constant values, polynomials, cubic and fifth order polynomial splines, exponential distributions, complex exponentials that provide sine and cosine expressions, and extrapolated values using first, second, and third derivatives. Motion is represented by a set of dynamic position items that include constant position, extrapolated motion, great circle, rhumbline, elliptical and circular orbits, polynomials, splines, and loitering.Figure  SEQ Figure \* ARABIC 6: Dynamic FO attributes and their associated dynamic FO items. Each dynamic FO item has a start and end time value that defines a time window for its computations. The dynamic FO attribute manages a list of these items. The item with the right bounding time window is used when computing a value as a function of time.The FO FactoryAn input parameter file, FO.par, defines the FOs described in the FOM. The FO factory class reads this file during initialization and creates a FO template for each type of FO. The templates keep track of inheritance relationships while storing type information about each attribute. FO templates are used when mapping attributes into FOs (see  REF _Ref417118253 \h Figure 7). The template, for example, provides the array Id for attributes given their string name.Figure  SEQ Figure \* ARABIC 7: The FO factory is a rollbackable object factory that is used by FoMgrs to construct FOs. Applications may inherit from the FO base class to provide additional methods to FOs. The FO factory constructs the full set of FO templates during initialization as defined in the FO.par file. Each template manages a FO attribute record for each attribute.Applications may inherit from the FO class in C++ to add new methods to their FOs. These methods can be used to transform data between an application’s internal representation (i.e., their SOM) and some other representation (i.e., the FOM). Virtual functions on FOs may be used to provide polymorphism. This allows FOs to work in algorithms using generic base-types. Optimized attribute lookups may be provided in derived methods to speed up the retrieval of attributes contained within the FO.The FoFactory is a specialized object factory that provides two additional features beyond basic free list object management. First, the FoFactory stores object aliases that allow specific FO types to be identified by multiple names. This feature is useful when communicating with external systems that name their FO types differently.Second, the FoFactory provides a smart allocation algorithm that creates the most specific kind of FO in given its FO.par (or alias) type. For example, suppose FO.par defines Fo.Entity.MovingEntity.Aircraft.F15. Further, suppose that an application defines an AircraftFo class in C++ that inherits from MovingEntityFo that inherits from Entity that inherits from Fo. When the application asks the FoMgr to create an F15, the FoFactory intelligently creates an instance of the AircraftFo class in C++ because it is the most specific kind of class defined by the application. Of course, all of the attributes defined for an F15 are stored within the FO.Related Simulation ObjectsThe DSMS layer uses two special kinds of simulation objects to coordinate interest management and distribution of FOs to local subscribers.An InterestManagement simulation object is created for each type of FO described in FO.par. When executing a simulation on multiple processors, these simulation objects are distributed to different processing nodes to provide an initial parallel processing interest management capability.The LocalFoDistributer simulation object manages a list of locally subscribing entities on its node for each FO having one or more local subscribers. Multiple LocalFoDistributers are created per node to avoid bottlenecks. Hashing on the FoId identifies which LocalFoDistributer is used to distribute the FO to local subscribers. A FO is reconstructed once in the LocalFoDistributer and then its pointer is delivered to local subscribers. Only one copy of the FO per node is ever required. When attributes are updated, all LocalFoDistributers managing the FO on remote nodes are instructed to modify their local copy of the FO. The LocalFoDistributers then notify their local subscribers that attributes have been changed.Animated Class Diagrams for FOsThis section describes the details for scheduling and processing the events necessary to perform various DSMS operations. Readers not interested in these details may skip over this material and proceed to the next section.All of the FO operations are coordinated through a series of events that are scheduled between the Entity, InterestManagement, and LocalFoDistributer simulation objects.When an application publishes a FO (see  REF _Ref417434916 \h Figure 8), the PublishFo event is scheduled on the publishing entity immediately after the current event completes. The PublishFo event schedules the AddPublishFo event for the InterestManagement simulation object representing that FO type. The InterestManagement simulation object records the FoId and any filterable attributes in its list of published FOs. The InterestManagement simulation object schedules the UpdateFoSubscribers event back on the publishing entity to update the FO’s distribution list of subscribing entities. The CreateLocalFo event is scheduled for the LocalFoDistributer on all nodes having one or more subscribers to the FO. This event is used to reconstruct the FO on remote nodes. Then, the AddLocalFoSubscribers event is scheduled to add the list of locally subscribing entities to the LocalFoDistributer’s distribution list for that FO. The AddLocalFoSubscribers event schedules the AddFoPointer event for all subscribers. This event notifies the subscribing entity through polymorphic methods that the FO is discovered.Figure  SEQ Figure \* ARABIC 8: Publishing a Federation Object.Unpublishing a FO works in reverse (see  REF _Ref417437441 \h Figure 9). The same PublishFo event is reused to unpublish the event. It also reuses the AddPublishFo event to unpublish the FO with the InterestManagement simulation object for that FO type. The UpdateFoSubscribers event is reused to remove all subscribers from the FO’s distribution list. The RemoveLocalFoSubscriber event is scheduled by the UpdateFoSubscribers event to remove all locally subscribing entities from the FO. Subscribing entities receive the RemoveFoPointer event and are notified through polymorphic methods that the FO is being removed. Finally, the DeleteLocalFo event is scheduled on all LocalFoDistributers managing the FO to delete the local Fo.Figure  SEQ Figure \* ARABIC 9: Unpublishing a Federation Object.Subscribing to a FO potentially updates one or more InterestManagement simulation objects with subscription information (see  REF _Ref417435703 \h Figure 10) to support generic subscriptions for derived FO types. The InterestManagement simulation objects representing all derived FO types participate in subscriptions to support generic subscriptions on base-class FO types. The SubscribeFo event is scheduled on the subscribing entity immediately after the current event completes. It schedules the AddSubscribeFo event for all InterestManagement simulation objects representing the FO type and its derived types. The AddSubscribeFo event adds the subscribing entity’s object handle and all of its created FO interest management filters to the InterestManagement simulation object’s subscriber list. Upon evaluation of the interest management filters, publishing entities are informed of new subscriptions using the AddFoSubscribers event. As before, the AddFoSubscribers coordinates the rest of the FO delivery to the subscribing entity (see  REF _Ref417434916 \h Figure 8).Figure  SEQ Figure \* ARABIC 10: Subscribing to a Federation Object.Unsubscribing to a FO is accomplished by undoing the FO subscription (see  REF _Ref417540464 \h Figure 11). Some of the same events are reused with reversed operations when processed. As when subscribing to a FO, the SubscribeFo event is scheduled immediately after the current event is completed. This event schedules the AddSubscribeFo event for the appropriate interest management simulation objects to remove the entity’s subscription filter. FOs from publishing entities may need to be notified to remove the unsubscribing entity from their distribution list. This is done by the RemoveFoSubscriber event on the publisher, which in turn schedules the RemoveLocalFoSubscriber event on the LocalFoDistributer, which in turn schedules the RemoveFoPointer event for the unsubscribing entity. The RemoveFoPointer event invokes the RemoveFo polymorphic notification method on the entity. If there are no more subscribing entities on the unsubscriber’s node, then the FO is removed from the LocalFoDistributer.Figure  SEQ Figure \* ARABIC 11: Unsubscribing to a Federation Object.Updating and reflecting FO attributes is automated through operator overloading. The FO attributes automatically schedule the UpdateFoAttribute event when they are modified. Modified attributes within a FO are grouped into a bundle for efficient message delivery. If any of the modified attributes are designated as filterable, then those attributes are also delivered to the InterestManagement simulation object for that FO type. All subscription filters are reevaluated which may result in changes to the FO’s distribution list. The bundled group of modified attributes is delivered to all LocalFoDistributers managing the FO. The attributes are modified using the space-time storage mechanism previously discussed. Then each subscribing entity is notified through polymorphic methods invoked by the ReflectFoAttributes event to indicate which attributes have been modified. This is shown in  REF _Ref417554523 \h Figure 12.Figure  SEQ Figure \* ARABIC 12: Updating the attributes of a Federation Object.Enhancing FO attributes allows remote subscribers to modify the attributes of a discovered FO using any of the Set methods provided by the FO interface (see  REF _Ref417555250 \h Figure 13). When one or more attributes are enhanced, the UpdateFoAttribute event is automatically scheduled to occur immediately after the current event. However, the UpdateFoAttribute event detects that it is not the owner of the FO and schedules the ReceiveRemoteFoAttributes for the publishing entity. The ReceiveRemoteFoAttributes event automatically modifies the set of enhanced attributes, which in turn triggers the UpdateFoAttribute event just as if the publishing entity modified the attributes itself (see again  REF _Ref417554523 \h Figure 12). This activates the update attributes mechanism to redistribute the enhanced attributes to the rest of the subscribers.Figure  SEQ Figure \* ARABIC 13: Enhancing the attributes of a Federation Object.InteractionsInteractions use a different mechanism from Federation Objects for coordinating subscriptions, unsubscriptions, message delivery, interest management, and interaction handling. Each node creates an InteractionDistributer simulation object for each type of interaction defined in the Interactions.par parameter file that is read during initialization. The role of these interaction distributer objects is to coordinate which nodes have subscribing entities in a parallel and distributed global environment.Any object within an entity may subscribe to an interaction by specifying a handler along with an optional filter. If specified, the filter operates on the parameters passed in the interaction to determine if the handler should be invoked. Multiple filters and handlers can be defined by an entity to process subscribed interactions. Multiple handlers may be invoked by an entity when it receives an interaction.Animated Class Diagrams for Interactions REF _Ref418237354 \h Figure 14 shows how entities subscribe to interactions. In the current design, the EntitySubscribeInteraction event is scheduled when subscribing to a particular type of interaction for the first time. If scheduled, this event is processed immediately after the current event completes. The EntitySubscribeInteraction event then schedules an AddLocalSimObjSubscriber event for each of the local InteractionDistributers representing that interaction type and all of its derived interaction types. If this is the first entity on the node to subscribe to that kind of interaction, then the AddRemoteNodeSubscriber event is scheduled for all InteractionDistributers for that type of interaction on other nodes to indicate that the node has at least one subscriber for that type of interaction. The InteractionDistributers keep track of which remote nodes have at least one subscriber and which local entities have subscribed.Figure  SEQ Figure \* ARABIC 14: Subscribing to an interaction. REF _Ref417558882 \h Figure 15 shows how entities unsubscribe to interactions. In the current design, the EntityUnsubscribeInteraction event is scheduled when unsubscribing to a particular type of interaction and no other interaction handlers are defined for that type of interaction. The EntityUnsubscribeInteraction event is processed immediately after the current event completes and schedules a RemoveLocalSimObjSubscriber event for each of the local InteractionDistributers representing that interaction type and all of its derived interaction types. If this is the only entity on the node locally subscribed to that kind of interaction, then the RemoveRemoteNodeSubscriber event is scheduled for all InteractionDistributers for that type of interaction on remote nodes to indicate that the node no longer has any subscribers to that kind of interaction.Figure  SEQ Figure \* ARABIC 15: Unsubscribing to an interaction.When an interaction is scheduled, the interaction is first sent to the local InteractionDistributor for that interaction type. The interaction is then forwarded to all nodes having one or more subscribing entities. The InteractionDistributers then schedule the interaction for all locally subscribing entities. In the current design, interest management filters are applied by subscribing entities to determine which handlers (if any) are invoked. This is shown in  REF _Ref417559758 \h Figure 16.Figure  SEQ Figure \* ARABIC 16: Sending and receiving an interaction.Interest Management DesignSubscribers may create filters to reduce the amount of data received from other entities. Filters for both FOs and interactions contain interest expressions that operate on attributes or parameters. Multiple interest expressions may be applied to individual attributes or parameters. The filter passes if at least one expression for each filterable attribute or parameter passes. In this manner, filter evaluation is an OR of expressions and an AND of attributes or parameters. If a filter contains an expression for a missing attribute or parameter, the expression passes. Filters for both FOs and interactions are coordinated by FoMgrs. The internal structure is shown in  REF _Ref419269899 \h Figure 17.Figure  SEQ Figure \* ARABIC 17: Filters within FoMgrs. Filters are managed in a list within the FoMgr. Filters contain interest expressions that are applied to filterable attributes for remote FOs or parameters for interactions. The FoMgr manages interaction handlers in a list of InteractionName classes for subscribed interactions. Each InteractionName manages a list of interaction filter containers that stores the callback function for the interaction handler and the list of filter names used to determine if the handler should be invoked. The handler is invoked if one or more of its filters pass.The set of expression types for FOs are listed in  REF _Ref419256298 \h Table 3. As appropriate, these expressions also apply to interactions for basic data types such as spatial locations, integers, doubles, and strings.Table  SEQ Table \* ARABIC 3: Interest management expression types for FOs.ExpressionAttribute TypeDescriptionTheaterpositiondynamic positionSpecified by {LatMin, LatMax, LonMin, LonMax} & {AltMin, AltMax} values. Expression passes if the position is within the bounded geographical region.IntervaldoubleintSpecified by {Min, Max} values. Expression passes if attribute is greater than or equal to Min and less than or equal to Max.NumericintSpecified by integer value. Expression passes if attribute is equal to the expression value.EnumintSpecified by enumerated integer value = {0, 1, 2, …, N}. Expression passes if attribute is equal to the enumerated valueBitfieldintSpecified by 32-bit mask. Expression passes if a bit-wise AND of the mask and the attribute is non-zero.StringstringSpecified by a substring value. Expression passes if the attribute matches the specified substring.ObjHandleN/ASpecified by the {Node, EntityType, LocalId} unique identifier of an entity. Expression passes if the object handle stored in the FO matches the expression value.FoIdN/ASpecified by the entity object handle and a unique Id within the entity for the FO. Expression passes if the FoId stored in the FO matches the expression value.FoNameN/ASpecified by the name given to the FO. Expression passes if the FoName matches the expression value.When filterable FO attributes are modified, their values are stored in a parameter set and sent to the corresponding InterestManagement simulation object for that FO type. This is where filtering on FOs between entities is performed. Upon reevaluation of the filters from other subscribers, a new list of subscribing entities with passing filters is returned back to the publishing entity. Because interactions also pass parameters in the parameter set, unified interest management is provided for both FOs and interactions.Phase 1: IM – FunctionalityThe phase one design for interest management focuses on providing the basic capability to filter on FOs and interactions within the DSMS layer using a standard API. This phase has been recently completed. Phase two optimizations are in the beginning stages of development and will be reported in a future publication. In the current Phase One implementation, the InterestManagement simulation objects are distributed among the available processing nodes to perform interest management computations in parallel. The internal design of the InterestManagement object is shown in  REF _Ref419269488 \h Figure 18.However, interest management for FOs is also provided within an entity between its components. At this stage of filtering, the attributes are provided in the FO itself, not in a parameter set. This means that the filter expressions must also provide logic for pass/fail determination with FOs.Filtering between components within an entity is automatically performed during (1) the AddFoPointer event when remote FOs are discovered, (2) the ReflectFoAttributes event whenever filterable attributes of remote FOs are modified, and (3) whenever the subscription filters themselves are modified. When filters are modified, the SubscribeFo event is scheduled to occur immediately after the current event to coordinate interest management between itself and other publishing entities. The SubscribeFo event also coordinates FO interest management between the entity’s internal components caused by modified filters. However, when an application modifies its filters and then requests a FO-related service that is affected by the new filter, the interest management computations are performed immediately in the current event. This approach eliminates annoying notifications that would otherwise occur every time a filter is modified. It waits until the results of the changed filters are needed or until time advances.Figure  SEQ Figure \* ARABIC 18: Internal structure of the InterestManagement simulation objects. A tree of parameter sets containing filterable attributes is maintained for each published FO. The FoId is used as the unique lookup key for this tree. It also provides the object handle of the publisher. Simultaneously, a tree of subscription filter holders is maintained that uses subscriber object handles for its lookup key. One filter holder is maintained for each subscriber. The filter holder maintains a list of filters with interest expressions defined by the subscriber and a list of FoIds that satisfy at least one filter for that subscriber. The FoIdTree is reconstructed whenever a filter is modified. Similarly, the FoIdTree for all subscribers is updated whenever a filterable FO attribute is modified.A special RangeFilterComponent is included within the DSMS layer to provide range-based filtering services based on proximity between moving objects. The design is shown in  REF _Ref419273358 \h Figure 19. Entities can create more than one RangeFilterComponent if necessary to support multiple sensor models within an entity having different detection ranges. The RangeFilterComponent provides the following services.Continuously changing list of FOs that are within the specified rangeA counter semaphore that allows processes to wake up when one or more FOs are within rangePolymorphic notification method invocation when a FO comes within rangePolymorphic notification method invocation when a FO goes out of rangeExtrapolation services to notify models when the motion of a remote FO deviates by a specified tolerance using either constant position, constant velocity, or constant acceleration extrapolation modelsFigure  SEQ Figure \* ARABIC 19: Design of the RangeFilterComponent. Two processes are defined for every FO that is discovered. The FoInRange process computes when FOs come in range and when FOs go out of range. It stores FOs in range in the FoInRangeTree. The NumFosInRange counter semaphore maintains the count of the number of FOs in the FoInRangeTree. Predictions for when FOs come in and out of range are retracted and recomputed whenever the motion of remote FOs change or whenever the motion of the subscribing entity changes. Polymorphic notification methods are invoked to allow models to take action when a FO goes in and out of range. The NotifyExtrapolation process starts when a FO comes within range and notifies models when the extrapolation model exceeds a specified tolerance. It is deactivated when the FO is out of range.Evaluation of interest management filters for interactions is currently applied by receiving entities. This initial approach automatically parallelizes interest management filter computations for interactions. Further optimizations are planned to reduce the computational complexity for filter evaluation and to improve parallel performance when executing optimistically.Phase 2: IM – OptimizationsThe phase two design for interest management focuses on improving the sequential performance of the phase one implementation. This phase is currently ongoing. Features provided during this phase of development include the following techniques.Various internal optimizations to reduce processing overheads, optimize internal data structures, and provide more efficient internal software implementations of phase one algorithms.Provide an attribute throttling mechanism to limit the rate of attribute reflections between entities.Develop a predictive contract mechanism with tolerances for dynamic attribute data types to eliminate reflections that are not needed.Extend the range filter component to include source-based filtering techniques.Develop the multi-resolution hierarchical grid data structure that organizes filterable attributes or parameter with interest management filters and their expressions. This data structure will replace the serial filter evaluation approach used in the InterestManagement simulation object. It will provide better scalability as a function of FOs and filters.Provide FO attribute dependency infrastructure within the local FO distributer to eliminate notification overheads when the entity does not need to respond to reflected attributes. This will have the effect of removing the fan-out type of overheads associated with subscriber reflections.Phase 3: IM – Scalable ParallelismThe phase three design for interest management focuses on supporting better scalable parallel performance.  The primary focus is on distributing the multi-resolution hierarchical grid data structure. Features provided during this phase of development include the following techniques.Develop algorithms to distribute the hierarchical grid data structure.Develop algorithms to lookup which hierarchical grids overlap specified interest expressions.Upgrade the FO distribution list mechanism to coordinate with multiple hierarchical grids.Phase 4: IM – Optimistic ProcessingThe phase four design for interest management focuses on improving parallel performance when executing optimistically.  The primary focus in this phase is to reduce rollbacks. Features provided during this phase of development include the following techniques.Upgrade the predictive contract algorithm to work with lookahead in order to reduce rollbacks.Provide query/reply mechanism to limit optimistic processing by entities that are waiting for known responses from events scheduled.Push filter evaluation computations for interactions back one step to the local interaction distributer. This way, interactions will only be sent to entities that actually process the interaction with one or more handlers.Develop lazy cancellation capabilities to roll events forward when possible. This will significantly reduce rollback overheads for the distribution of FO attributes and interactions.Develop event-reparation techniques to fix events that were processed incorrectly due to received stragglers without reprocessing the entire event. The goal of this effort is to minimize the impact of stragglers by reducing what needs to be rolled back.Sample CodeThe easiest way to understand the DSMS layer from a user’s perspective is to walk through a simple code example. For simplicity, all of the provided code segments are limited to operations on an entity even though components and user-defined classes may also define FO attributes, register notification methods, and provide interaction handlers.Code Segment  SEQ Code_Segment \* ARABIC 1: Defining a ship entity with three FO attributes.SIMOBJ(MyShip) : public Entity {  private:    FO_int NumSensors;    FO_string WeaponName[2];    FO_dynamic_position Position;  public:    MyShip(){}		virtual void Init();		virtual void Terminate(double endTime);		void Discover(Fo *fo)		void Remove(Fo *fo)		void Reflect(Fo *fo, ParameterSet *atts)		void Enh(Fo *fo, ParameterSet *atts)		void Detonation(ParameterSet &parms);};END_SIMOBJ(Ship, MyShip, 10, SCATTER)// FO notification methodsDEFINE_NOTIFY_DISCOVER_FO(MyShip, Discover)DEFINE_NOTIFY_REMOVE_FO(MyShip, Remove)DEFINE_NOTIFY_REFLECT_FO_ATTRIBUTES(	MyShip, Reflect)DEFINE_NOTIFY_REFLECT_ENHANCED_FO_ATTRIBUTES(	MyShip, Enhance)// Interaction handlersDEFINE_INTERACTION_HANDLER(MyShip, Detonation)The SIMOBJ and END_SIMOBJ macros define the class MyShip to be a persistent Ship simulation object type. The Ship object type is plugged into the simulation engine during startup by invoking the macro-generated PLUG_IN_Ship() function. During initialization, 10 of these simulation objects will be created during initialization and distributed to multiple nodes when running in parallel using a SCATTER decomposition algorithm. In general, the MyShip() constructor does not initialize the simulation object because the simulation engine prefers to create all of the simulation objects first before they are initialized. Initialization is automatically performed for each simulation object through the virtual Init() method. The Terminate() method is automatically invoked by the simulation engine when the simulation terminates.Three FO attributes are defined for this simulation object representing an integer, an array of strings, and a dynamic position. These FO attributes are initialized and mapped into a FO during Init(). Four FO notification methods are defined to handle discovery, removal, attribute reflections, and attribute enhancement events. Also, a Detonation() interaction handler is defined. These handlers are automatically invoked by the DSMS layer when FOs are discovered, removed, attributes reflected, attributes enhanced, and subscribed interactions received. REF _Ref421425249 \h Code Segment 2 provides a code example that shows how to create a FO, initialize its attributes, and then publish the FO. The example then shows how to subscribe to FOs published by other entities and how to create FO filters. The FO notification methods and interaction handlers are registered during initialization. Finally, an interaction is scheduled.Code Segment  SEQ Code_Segment \* ARABIC 2: Initializing an entity. In this code example, a Ship FO is created, initialized, and published. Four polymorphic FO notification methods are registered. A subscription is made to “Aircraft” FOs. A Filter is created for all moving entities that are alive with cross section greater than or equal to 1. An interaction handler is registered to subscribe to “Detonation” interactions. A “Detonation” interaction is scheduled.void MyShip::Init() {	SpFo *fo;// Create a Ship FO and then map the attributes	FoMgr.CreateFo(“Entity.MovingEntity.Ship”, fo);	fo->MapAttribute(“NumSensors”, NumSensors);	fo->MapAttribute(“WeaponName”, WeaponName);	fo->MapAttribute(“Position”, Position);// Initialize the FO attributes as if they// were normal data types	NumSensors    = 5;	WeaponName[0] = “CruiseMissile”;	WeaponName[1] = “Bomb”;// Create a great circle object from the// object factory. Initialize it with the start// time, end time, start lat, lon, alt and// end lat, lon, alt. Then insert the great// circle motion into the dynamic position// attribute. Note that angles are represented// in radians and distance in kilometers.	SpDynFoGreatCircle *greatCircle =		NEW_SpDynFoGreatCircle();	greatCircle->InitConstantTime(		0.0, 1000.0,		45.0*PI/180.0, 100.0*PI/180.0, 0.0,		60.0*PI/180.0, 120.0*PI/180.0, 10.0	);	Position.Insert(greatCircle);// Publish the FO	FoMgr.PublishFo(fo);// Subscribe to all aircraft	FoMgr.SubscribeFo(		“Entity.MovingEntity.Aircraft”	);// Subscribe to all entities that are alive// and have a cross section larger than 1.0	SpFilterId filterId;	FoMgr.CreateFoFilter(		“MyFilter”, “Entity”, filterId	);	FoMgr.InsertLogical(		filterId, “Alive”, 1	);	FoMgr.InsertRegion(		filterId, “CrossSection”, 1.0, 1.0e20	);// Register polymorphic FO notification methods	Register_NotifyDiscoverFo_Discover(		this, this	)	Register_NotifyRemoveFo_Remove(		this, this	)	Register_NotifyReflectFoAttributes_Reflect(		this, this	)	Register_NotifyReflectEnhancedFoAttributes_Enh(		this, this	)// Subscribe to the Detonation interaction	SUBSCRIBE_INTERACTION_Detonation(		FoMgr, this, “Detonation”	);// Schedule a Detonation interaction for time 0.0// with one parameter, BombSize = 100.0	SpParameterSet parms;	parms.SetDouble(“BombSize”, 100.0);	SCHEDULE_INTERACTION(0.0, “Detonation”, parms);}SummaryThe phase one SPEEDES DSMS layer is now fully functional. Phase two is just starting with the development of performance optimizations for sequential execution. Phase three will add further optimizations for parallel computing. Phase four will provide further performance improvements for executing in parallel using optimistic time management.AcknowledgementsThis work was sponsored by the SPAWAR System Center in San Diego (SSC-SD) through its development of the SPEEDES-based Common Component Simulation Engine (CCSE) in support of the Joint Simulation System (JSIMS). This work was also funded in part by the High-Performance Computing Modernization Program (HPCMP) through its Common HPC Software Support Initiative (CHSSI).AuthorDr. Jeffrey S. Steinman, Vice President and Chief Scientist at RAM Laboratories received his Ph.D. in 1988 from the University of California Los Angeles in High-Energy Particle Physics. Between 1988 and 1995, Dr. Steinman led several high-performance computing R&D activities at JPL/Caltech in support of Strategic Defense, Air Defense, Ballistic Missile Defense, and NASA space exploration missions.While at JPL/Caltech, Dr. Steinman pioneered the technology and software development of the Synchronous Parallel Environment for Emulation and Discrete-Event Simulation (SPEEDES) framework. This work resulted in four patents and more than forty technical papers in the area of high-performance computing, optimistic discrete-event simulation, data structures, message-passing algorithms, object-oriented design, parallel and distributed multi-resolution interest management algorithms, and HLA.Dr. Steinman directed software engineering teams that developed core infrastructures for several mainstream simulation projects including the Parallel and Distributed Computing Simulation (PDCS), the Parallel Naval Simulation System (NSS), Wargame 2000 (WG2K), the Joint Simulation System (JSIMS), the Joint Modeling and Simulation System (JMASS), High-Performance Computing Run Time Infrastructure (HPC-RTI), and the Human Behavior Representation Testbed (HBR-Testbed). Dr. Steinman was a member of the HLA Time Management and Data Distribution Management working groups and wrote the original design document for DDM Dr. Steinman is currently the acting Technical Director for the JSIMS Common Component Simulation Engine.BIBLIOGRAPHYU.S. Department of Defense, “High Level Architecture Interface Specification, Version 1.3.”U.S. Department of Defense, “High Level Architecture Object Model Template, Version 1.3.”U.S. Department of Defense, “High Level Architecture Rules, Version 1.3.”Kuhl Frederick, Weatherly Richard, and Dahmann Judith, 2000. “Creating Computer Simulation Systems, An Introduction to the High Level Architecture.” Prentice Hall PTR, Upper Saddle River, NJ 07458.Steinman Jeff, Nicol David, Wilson Linda, and Lee Craig, 1995. "Global Virtual Time and Distributed Synchronization." In proceedings of the 1995 Parallel And Distributed Simulation Conference. Pages 139-148.Steinman Jeff, 1998. “Scalable Distributed Military Simulations Using the SPEEDES Object-Oriented Simulation Framework.” In the proceedings of the Object-Oriented Simulation Conference (OOS’98), pages 3-23.Valinski Maria, Driscoll Jonathan., McGraw Robert, and Buchy Doug, 2001. "Providing JMASS with a Distribution Simulation Capability Using SPEEDES." In proceedings of the Summer Computer Simulation Conference.Sperber Joan, 2001. “Up to SPEEDES.” Military Training Technology, MT2, Volume 6, Issue 1, 2001.Bailey Chris, McGraw Robert, Steinman Jeff, and Wong Jennifer, 2001. "SPEEDES: A Brief Overview" In proceedings of SPIE, Enabling Technologies for Simulation Science V, Pages 190-201.Steinman Jeff, 2002. "The Standard Simulation Architecture" In proceedings of the 2004 Spring Simulation Interoperability Workshop, Paper 04S-SIW-100.Joint Simulation System (JSIMS) System Subsystem Design Document.Joint Simulation System (JSIMS) Common Component Simulation Engine (CCSE) Software Design Document (SDD).Joint Simulation System (JSIMS) Common Component Simulation Engine (CCSE) Software User Manual (SUM).Joint Simulation System (JSIMS) Common Component Simulation Engine (CCSE) Interface Requirement Specification (SDD).Clark Joe, Capella Sebastian, Bailey Chris, Steinman Jeff and Peterson Larry, 2002. "The Development of an HLA Compliant High Performance Computing Run-time Infrastructure" In proceedings of the 2002 Spring Simulation Interoperability Workshop, Paper 02S-SIW-016.Steinman Jeff, 1998. “Time Managed Object Proxies in SPEEDES.” In the proceedings of the Object-Oriented Simulation Conference (OOS’98), pages 59-65.Morse Katherine, Steinman Jeff, 1997. “Data Distribution Management in the HLA: Multidimensional Regions and Physically Correct Filtering.” Spring Simulation Interoperability Workshop, No. 97S-SIW-052.Steinman Jeff, Tran Tuan, Burckhardt Jacob, Brutocao Jim, 1999. “Logically Correct Data Distribution Management in SPEEDES”, In proceedings of the1999 Fall Simulation Interoperability Workshop, Paper 99F-SIW-067.	Coordinate systems supported are (X, Y, Z) in Earth Central Inertial (ECI), (X, Y, Z) in Earth Central Rotating (ECR), (Lat, Lon, Alt) in Round Earth, and (Lat, Lon, Alt) in WGS84 ellipsoidal earth.	Keyed list currently supports integer, double, and string keys. Elements in the list can be integers, doubles, strings, or buffers.	FO sequences are implemented as variable-length arrays of arbitrary data types that are stored in FO buffers.	Multi-leg motion may be constructed from different motion types. For example, the motion of an aircraft might be described by the following three segments, each having non-overlapping consecutive time windows {GreatCircle[0,500], Rhumbline[500,2000], LinearMotion[2000, 3600]}.	Cubic splines use the function value and its first derivative at the start and end times to construct a cubic polynomial. Fifth order polynomials include second derivatives to form a fifth order polynomial. 	Extrapolated motion is constructed from the position, velocity, acceleration, and jerk terms at a given start time.	Great circle motion describes shortest path trajectories across a sphere. Changing altitudes are handled while maintaining constant speed.	Rhumbline motion maintains a constant heading. It describes the motion of an entity flying by the compass.	Ellipsoidal motion describes the trajectory of space-based entities obeying the laws of physics under a central gravitational force.	The Model Driver Diagnostic Interface (MDDI) tool developed by JSIMS provides a FO.par and Interactions.par graphical editor. This tool allows applications to quickly tailor the OMDT file in order to describe publication, subscription, and interest management needs.	Attribute lookups normally require searching for the string name of the attribute to find the attribute Id. Through inheritance, derived FOs can define static data members to store the attribute Id when the first FO of a particular type is created. Lookup methods can then use the attribute Id for fast retrievals.	The dot notation is used to indicate inheritance. So, a.b.c is understood to mean that c inherits from b, and b inherits from a.	For example, if there are 10 LocaFoDistributers per node, and the FoId is 26, then LocalFoDistributer 6 on each node is used to distribute the FO to local entities.	FoIds contain an integer Id for the FO and the object handle of the entity that created the FO. The object handle is used for scheduling events back to the entity. If identified, filterable attributes are also passed to the InterestManagement simulation object to support source-based filtering on FOs.	The time tag of the AddLocalFoSubscribers event is adjusted using priority fields to occur immediately after the CreateLocalFo event to ensure that the FO has already been reconstructed within the LocalFoDistributer.	Interest management for FO discovery is performed within the hierarchical component system to allow different components to establish their own filtering criteria.	The time tag of the DeleteLocalFo event is adjusted using priority fields to occur immediately after the RemoveLocalFoSubscriber to ensure that the FO is only deleted after all entities have been notified that the FO is being removed.	An alternative design would have publishers schedule events for all InterestManagement simulation objects managing derived FO types, while only scheduling one event for subscription. However, in practice subscriptions change less frequently than publications (especially when considering how filtering is applied to changing FO attributes). So it is believed that the current design is the better choice.	It is possible for the entity to create more than one filter that causes a particular FO to be discovered. So, it is not always true that Unsubscribing causes FOs to be removed from the unsubscribing entity.	Only attributes that participate in subscription filters should be identified as filterable to minimize overheads associated with interest management. If none of the modified attributes are filterable, then interest management overheads are bypassed.	Further interest management is performed within the hierarchical component system to handle conditions where the evaluation of filters changes. In some cases, components may discover FOs and other components may have FOs removed when filtered attributes change.	In the future, applications may register their reflect attributes notification methods with a dependency list. The method will only be invoked if attributes identified in the dependency list are modified.	Interest management upgrades planned for the future will push the filter evaluation to the InteractionDistributor. This will reduce event-scheduling overheads for subscribing entities whose filters eliminate the interaction. It will also reduce rollback dependencies when optimistically executing in parallel.PAGE  