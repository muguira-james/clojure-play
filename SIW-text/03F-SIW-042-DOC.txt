Verification System Enhancements for an Expanding MissionMike ShadidFrederick KuhlKeven RingSusan SymingtonThe MITRE Corporation7515 Colshire DriveMcLean, VA 22102703 883-7209mshadid@mitre.org Keywords:HLA, RTI, Verification, Verifier, Interface Specification, testing. ABSTRACT: The High Level Architecture (HLA) Run-time Infrastructure (RTI) Verification Facility that was established by the Defense Modeling and Simulation Office (DMSO) has successfully verified twenty-seven RTIs compliant to version 1.3 of the U.S DoD HLA Interface Specification, and two RTIs compliant to the IEEE 1516-2000 series of HLA standards. 1.3-compliant RTIs have been tested on a wide variety of platforms, including Solaris, Windows, IRIX, and Linux; with both Java and C++ APIs; and using numerous compilers. In order to accommodate the multiplicity of platforms and compilers that have been tested, the verification system that was originally developed to verify the first RTIs has had to evolve into a complex operational system.  In addition, although the verification of IEEE 1516 RTIs still uses the same core infrastructure as that used to verify 1.3 RTIs, updating the Verifier framework, software, and test suite to support the verification of 1516 RTIs has added yet another dimension of complexity to the verification software. In this paper, we describe the updates that were made to the original verification system to enable it to verify IEEE 1516 RTIs. We also describe the complexities involved in supporting multiple platforms, compilers, and APIs and explain the efforts that were made throughout the development process to simplify the configuration and maintenance of the Verifier framework and facilitate future expansion.IntroductionThe DoD requires that all services that perform M&S use the HLA because establishment of the HLA is designed to facilitate the interoperability of all types of models and simulations, both within the DoD and abroad. The success of this policy that requires use of the HLA depends upon the availability of HLA-compliant RTI software and upon the ability of HLA users to determine whether an RTI that claims to be HLA-compliant actually is. The RTI software must meet the HLA specifications and hence provide functionally equivalent support to federations. RTI verification testing, administered by an independent and impartial third party, is vital to this process, because it is the mechanism for assuring that RTI implementations function according to the HLA specifications. Without independently administered verification testing to ensure that RTIs available from different sources operate in the same way, the DoD is in danger of having the HLA degenerate into a set of proprietary implementations with non-standard features. Verification testing, on the other hand, reduces the HLA user’s risk while enabling the user to make an informed choice of tools. In 1998 the Defense Modeling and Simulation Office (DMSO) established an RTI Verification Facility to test the compliance of RTI implementations with the U.S. DoD HLA Interface Specification. The first HLA-compliant RTI was the government-supported RTI, which was freely available and was therefore widely used across the M&S community. With a limited number of RTI choices and the availability of a free, government-supported RTI, verification testing, though important, was not critical. Since the first RTI was verified, however, four additional RTI vendors have had their RTIs verified. In addition, support for the government-developed, freely-available RTI software was removed last year, and RTIs from sources other than the DoD have become increasingly available in its place. In this climate of increasing commercialization of RTI development, which is a welcome development for the long-term success of the HLA, providing HLA users with the risk reduction provided by RTI verification has become particularly critical.Verification System ExpansionThe Verification Facility, the verification system (also known as the Verifier), and the verification process have been described previously in [1]; the architecture of the verification system has been explained in detail in [2, 3]. Since its establishment, the HLA RTI Verification Facility has verified twenty-seven RTIs compliant to version 1.3 of the U.S. DoD HLA Interface Specification [4] and two RTIs compliant to the IEEE 1516-2000 series of HLA standards [5,6,7]. 1.3-compliant RTIs have been tested on a wide variety of platforms, including Solaris, Windows, IRIX, and Linux; with both Java and C++ APIs; and using numerous compilers. The Verifier, which was originally developed as a prototype R&D effort to verify the first RTIs, was required to grow significantly beyond the scope of its original design in order to accommodate the multiplicity of platforms, compilers, and APIs that have been tested.Redesign and re-implementation of the Verifier database format, front-end, and GUI tools; enhancements to the Verifier Script Definition Language (SDL) and other improvements to the original Verifier that were part of a software overhaul effort known as Verifier 2 were discussed in [1]. Since then, as the Verifier has evolved into a more complex operational system, a concerted effort was made to systematically reorganize and redesign it with the goals of simplifying its configuration and making it easier to use, learn, understand, maintain, and expand. We call this reorganized and redesigned system “Verifier 3”, and this paper will discuss some of its key design points.Verifier 3 Design GoalsThe Verifier 3 system addresses the inherent complexity and growth of the Verifier 2 software.  It replaces the Verifier 2 system, which evolved from a prototype effort into a large operational system containing over 200,000 lines of Java, C++, and SDL verification test source code.   Initially, the Verifier software was developed as an R&D effort to verify only the first RTIs on limited platform configurations.  Today, the software is used to verify RTIs from a number of different developers in the simulation arena.  Along with the growing market, the responsibilities of the verification facility also grew.  As more RTI vendors have begun to produce commercially viable RTI products, the Verifier system has gone through a series of updates to accommodate the new and increasing verification load.   The introduction of the IEEE 1516 specification added yet another dimension of complexity.  A tester needed detailed knowledge in order to use the Verifier 2 system.  Due to its growth in scope, many components were added to the system to deal with the verification of RTIs with different programming languages (Java or C++), HLA specifications (1.3 or 1516), platforms, compilers, and other issues.  A tester needed knowledge of all of these areas when performing a verification run.  In addition to this, the tester was required to have knowledge of the Verifier 2 system and how to choose the appropriate components within the system to verify an individual RTI.  Verifier 3 focuses its effort around these knowledge areas and redesigns the system in order to:Make the system easier to learn and understand to decrease the amount of time needed to ramp up a new developer or user of the software.Make the system easier to use for current and future users.Make the system easier to maintain for current and future developers.Make the system easier to expand for future developers.The following sections will discuss the Verifier 3 system architecture that was created keeping these goals in mind.  These sections will also discuss some of the newer incorporations into the Verifier system dealing with the 1516 specification.Verifier 3 System ArchitectureAt a high level, the Verifier’s system architecture consists of a database, test controller, federate/RTI launcher, and test federates.  The interaction among these subsystems is shown in Figure 1.  SHAPE  \* MERGEFORMAT Figure  SEQ Figure \* ARABIC 1 - High Level View of the RTI VerifierAs shown in Figure 1, a test controller interacts with a Microsoft Access database that stores the test requirements, test descriptions, and the actual Script Definition Language (SDL) source for the verification tests.  The test controller also interacts with the test launcher in order to spawn and manage test federates and the RTI as needed.   During test execution, the test controller communicates with the federates invoking RTI services and receiving RTI callbacks through five separate points of attachment to the test controller.  The federates, in turn, communicate with the RTI under test using the RTI-provided HLA APIs.  A large part of the complexity in verification software lies in this layer of communication between the Verifier core and a test federate.  Figure 2 displays a simplified view of this layer:  SHAPE  \* MERGEFORMAT Figure  SEQ Figure \* ARABIC 2 - Communication Path between Test Controller and RTIThe test controller, the core of the Verifier written in Java, communicates with a test federate using Java Remote Method Invocation (RMI). Custom-built verification test federates make the necessary translations using middleware, if necessary, to communicate with the RTI API and vice-versa.  If the RTI is written in Java and presents the Java language API, no middleware is necessary and the test federate acts as a pass-through.  If the RTI is written in another language such as C++, a translation layer using middleware is needed in order to communicate with the RTI-presented API.  Different sets of bindings between test controller and federate are needed in order to test 1.3 and 1516 RTIs.The ability to have working bindings that operate with all the possible platform, compiler, RTI, and specification combinations is critical to the Verification Facility.  Not only is it critical to have these bindings available for all the platforms, it is important to have these bindings integrated in a modular fashion into the Verifier system.  The system itself must be easy to understand, maintain, and expand for future verification needs.  The following section will describe each of the subsystems in more detail.  It will also discuss how the Verifier 3 design integrates all of these subsystems.Verifier 3 Subsystem OverviewThe RTI Verifier integrates several different components to perform its functions.  These components include:Database – Verifier 3 communicates with two different Microsoft Access database back-ends for the 1.3 and 1516 databases, respectively.  Each database has a front-end that provides additional functionality to edit tests and test requirements as well as analyze the results of a test run and generate reports.Test Controller – This subsystem provides the core functionality of the Verifier.  It is responsible for database operations on SDL scripts, parsing and execution of two different test script languages (SDL1 and SDL2), and the GUI as well as the core functionality needed to execute testing scripts generalized to work with both the 1.3 or 1516 specifications.  Launcher – This subsystem is responsible for managing federate and RTI processes throughout verification runs.  The Verifier communicates with the Launcher telling it when to start and kill processes as appropriate.1.3 Specific Code – This subsystem is responsible for the various test federate options to link to 1.3 RTIs. 1516 Specific Code – This subsystem is responsible for the various test federate options to link to 1516 RTIs.Figure 3 shows the integration of these systems in the Verifier 3 architecture.  As was mentioned in the previous section, the Test Controller communicates with either a 1.3 or 1516 back-end database which holds information about the verification tests.  The Test Controller also communicates with a Launcher process using RMI to tell it when to start (and kill) five test federates of the same type.  The types of test federates that the launcher spawns are chosen prior to run time and determined by the tester depending upon the RTI that is being tested.  Figure 3 shows that there are currently two different test federate options for verifying 1.3 C++ RTIs; one that uses the Java Native Interface (JNI) and one that uses the Common Object Request Broker Architecture (CORBA). CORBA is an Object Management Group (OMG) specification which provides a standard interface definition between OMG compliant objects.  JNI is a native programming interface for Java that allows code running inside a Java Virtual Machine to interoperate with applications and libraries written in other programming languages such as C++.  The CORBA and JNI bindings in the Verifier are similar in that they both do the necessary work to communicate from Java to C++ and vice-versa.  The two methods currently act as alternatives since neither can function in every case.  For example, the RTI Next Generation (RTI NG) uses CORBA internally to communicate between its local RTI components and RTI executable.  The use of a specific CORBA implementation within the Verifier’s test federates can result in namespace conflicts when both CORBA libraries (the verification test federate’s and the RTI’s) are loaded at runtime.  In this case, the JNI federate provides an alternative method for verifying the RTI.As can be seen in the diagram, the Verifier system must be versatile and able to handle several different APIs presented by a number of test federate types.  The Verifier uses several different test federate options in order to accommodate the different HLA APIs.  Accommodating HLA API Changes in the VerifierThe designers of the Verifier system faced the following problem when work began to add support for HLA 1516. The Verifier had to support DoD version 1.3, then the current version of the HLA specification. The Verifier also was required to support IEEE 1516, which at the time was far from settled. And there was reason to believe that 1516 APIs would change in minor ways after their adoption. Thus the problem was to make the Verifier as flexible as possible with respect to changes in the HLA APIs.The designers tackled this problem in three ways:The details of the HLA API relevant to a test are discovered via Java reflection.Other configuration needed for the Verifier is generated automatically, as much as possible.The datatypes internal to the Verifier abstract the differences that were expected between 1.3 and 1516.Consider first discovery of the HLA API in use. The API consists mainly of two Java interfaces, RTIambassador and FederateAmbassador. The Verifier expects the RTI under test to provide an implementation of RTIambassador, and the Verifier provides an implementation of FederateAmbassador.The Java platform contains mechanisms, called reflection (or introspection in other systems), which allow a program to discover the methods offered by an interface. Reflection was designed for builders of tools that could operate on Java code whose interfaces would be discovered at run time.The Verifier reflects on the RTIambassador and FederateAmbassador interfaces presented to it and builds tables of methods on each. The HLA service names that may be used in SDL invoke and accept statements corresponding to the method names discovered by reflection. The types of parameters needed for service invocation are also discovered by reflection. We discuss transformation of parameters below.There are two ways in which reflection on the interfaces is inadequate for configuring the Verifier. One need for additional information arises from the fact that the correspondence between HLA service names, as used in SDL, and method names on interfaces is not exact. The second inadequacy has to do with the Verifier’s user interface. The user can invoke any HLA service from a menu. The array of HLA services must be grouped into menus in some reasonable fashion to be usable. Reasonable groupings cannot be inferred from reflection.To supply the needed additional information, the Verifier employs a configuration file (in XML, one for each API the Verifier supports) that maps HLA services to interface methods and specifies the arrangement of services into menus in the user interface. The configuration file is to some extent the product of hand editing, particularly regarding menu structures. The Verifier system contains a tool to create a starting point for editing by Java reflection on the interfaces.The final area of accommodation of various APIs is the set of datatypes needed to invoke and receive HLA services. The 1.3 and 1516 APIs differ in the datatypes they employ. Some datatypes, e.g., attributes, are conceptually the same but have different representations, i.e., different Java classes. Some data types have very different representations, like handles. In 1.3 all attribute, federate, and object class handles are represented as small integers.  In 1516 handles are represented by different type-safe handle classes. There are some 1516 types, notably the imposingly named Attribute Set Region Set Pair List that have no corresponding 1.3 type.The Verifier copes with these disparities of data types by translating API types to and from internal types. The Verifier’s internal types were chosen well before 1516 was finalized and represented an educated guess at 1516’s eventual shape. (The guess was largely correct.) The translations are performed by the recursive application of a set of transformations. Sometimes the transformations are guided by hints contained in the configuration file. The transformation of internal handles (represented by small integers) to 1516 handle class instances is accomplished by 1516-specific code that maps integers to cached handle instances.In summary, the Verifier seeks to accommodate two different APIs. It does so using a combination of Java reflection, configuration information, and a small amount of code specific to each API. Thus there are some artifacts that are specific to each API and must be managed accordingly.Redesigning the Verifier  to Ease Use, Development, and Maintenance As was mentioned in previous sections, the Verifier uses introspection, as well as configuration information, to discover and operate on the RTIambassador and FederateAmbassador interfaces at run time.  These interfaces are presented by the different 1.3 and 1516 test federate options developed for the Verifier.  The federates use middleware internally, when necessary, to make the appropriate translations from Java to the RTI native language specific APIs and vice-versa.  With the use of different technologies, various programming languages, and source code to handle the 1.3 and 1516 cases it was important to be organized.   To accomplish this in Verifier 3, an effort was made to restructure and change the Verifier framework. The use of the run-time introspection capabilities provided by Java reflection, coupled with XML configuration information, allowed the developers to effectively split the source into three separate codebases that are independent of one another; the Verifier core, 1.3 specific source, and 1516 specific source.  The Verifier core is written entirely in Java. Some of the federates, however, use middleware internally to talk to C++ RTIs.  Thus these federates are not completely written in Java.  This mix of Java and C++ code increased the need for a good organization.  The use of Java reflection not only allowed the source to be split into different codebases it allowed the SDL parsers to be generalized.  If a specification change is made and then integrated into the Verifier system, no changes need to be made to the SDL language since the service names are not defined in the language but instead are discovered at run-time via Java reflection.The Verifier 3 source was split first into two different subdivisions, one containing Java code and one containing C++ code.  These subdivisions were broken down further into the Verifier core, 1.3 specific source, and 1516 specific source.  Within 1.3 and 1516  subdivisions, source was organized into packages storing the different test federate options as well as several other common packages.  These common packages dealt with the handling of data types and other operations that were common to the federates of the same specification. The Java and C++ source trees parallel each other so that they are straightforward to navigate.  The parallelism allows a developer to easily match source from Java tree which interacts with source in the C++ tree and vice-versa.  The use of Java reflection and RMI technologies coupled with the new source organization allowed the developers to create a system that was not only intuitive to the current developers but will allow future developers to come up to speed more quickly.  It will also ease future maintenance and expansion.  For instance, if in the future a newer specification is released or a different test federate type is needed the system is modularized in a fashion that makes these additions relatively easy.  The Verifier 3 system incorporates an interactive configuration script that takes advantage of this organization.  The same script runs on all of the current verification platforms.  Essentially, the system allows the user to provide information about the RTI that will be tested as well as some Verifier specific configuration.  The system uses  a standard set of makefiles, as well as scripts that store platform and compiler specific information, that build the Verifier system on all of the current verification platforms.  The scripts and makefiles use the information provided by the tester through the interactive configuration script.  The script not only standardizes and automates the build process but also generates the verification configuration which in the past needed to be created manually.  The use of Java technologies and standardization techniques in Verifier 3 have made the system easier to use, maintain, and expand.Additional IEEE 1516 Verification EnhancementsWhile the Verifier was going through a redesign, additional enhancements were made to the software in order to accommodate the 1516 HLA APIs.  Although the verification of RTIs built to the 1516 specification still use the same core infrastructure that is used to verify 1.3 RTIs, the Verifier software had to be updated with functionality specific to 1516.  There were a number of Data Distribution Management changes between the 1.3 specification and the 1516 specification that required changes to the Verifier framework and source code. Notably, for 1516 testing purposes, the Verifier was required to be able to query the range values of dimensions of conveyed region realizations within the confines of the Reflect Attribute Values and Receive Interaction callbacks. Changes between the 1.3 specification and the 1516 specification required that the entire test suite be rewritten.  Many service names were modified, service call arguments were added and deleted, and the Register Object Instance service, which is found in a majority of 1.3 tests, completely changed. SDL2, the second version of SDL, was developed in order to improve the language so that tests written to test 1516 RTIs would be clear and concise. Another enhancement to the Verifier software dealt with Management Object Model (MOM) encodings.  The 1516 standard stipulates that MOM data be sent as binary encoding as compared to the use of ASCII strings in the 1.3 HLA specification.  The use of binary encoding in the 1516 specification required that SDL, the Verifier’s test definition language, be enhanced to include features to facilitate the handling of MOM data.These and other 1516 related enhancements further increased the complexity of the Verifier.  The following section will describe in greater detail the 1516 MOM enhancements that were added to the Verifier.  Management Object Model Encoding Enhancements for IEEE 1516 VerificationDuring the original design of the Verifier, a choice was made to support a simpler implementation of the encoding and decoding of data transmitted across the RTI.  Neither the 1.3 nor the 1516 specification mandates how user data should be transmitted.  Both HLA specifications, however, mandate how the standard portion of the Management Object Model (MOM) data should be encoded, regardless of where the data originates from.  While the MOM data encoding format is mandated by each specification, the format is significantly different between the two specifications.  The 1.3 specification chose a null-terminated string, with specific characters denoting array elements and complex data type component elements.  1516 chose a binary representation.Because 1.3 mandated an encoding scheme of null-terminated strings for MOM data, a choice was made to simplify the Verifier software by sending all data, even for object updates and interactions, as null terminated strings.  String comparisons are easily performed in SDL as they are in most programming languages.  While this choice made the 1.3 script authoring easier, it was still a difficult, tedious, and laborious process.  For example, one of the attributes in the 1.3 MOM object class “ObjectRoot.Manager.Federation” is “FederatesInFederation”.  According to the 1.3 specification, this returns a list of federate handles (which are defined as integers in 1.3).  Since the MOM data is mandated to be encoded as a null-terminated string, this attribute may take on a value similar to ‘1,2,3,4’.  The Verifier compares the received value of an attribute in a callback with the expected value stated in the test script.  The difficulty is that there is no mandate on the order that federate handles are listed in this attribute value.  Thus, the value ‘3,1,4,2’ would also be valid.  This means that the Verifier scripts which test the 1.3 MOM must check a number of possible valid permutations.In 1516, there are still attribute values that contain arrays where elements may be presented in any order.  Due to a forced binary encoding scheme, the process of validating these arrays in the SDL tests was made more difficult.  It is impractical to hand-encode expected binary values into the test scripts.   Because of this encoding change in 1516, SDL was modified so that any encoding requirements for a particular RTI are not visible.  Type-safe translation code, between SDL types and MOM data, was added to the 1516 codebase so that test writers could work directly with the SDL types in the test scripts.   The addition of specific MOM data types to SDL allowed the Verifier developers to hide the encoding details from the SDL test writer as well as make these type-safe translations possible.  The MOM types allow the test writer to declare variables to hold both expected or received values within the test script.  The data types are dynamically determined at runtime by reading the Federation Object Model Document Data (FDD) file.  The FDD file contains information about the object and interaction class hierarchies including attributes and parameters within these hierarchies.  Once a MOM variable has been declared within a script, there are a variety of operations available to the test writer.  Some of these operations include the setting of individual attribute or parameter values, the encoding of MOM data (for transmission over the RTI), and the ability to compare expected data with received data.The act of setting the value of an attribute is a complex process due to the various array and complex data type structures defined in the 1516 FDD.  An approach was taken to require the setting of every primitive value individually (except in special cases, such as strings, which are not considered primitives in 1516).  In addition, there are attributes and parameters that have meaning to the RTI, such as a handle for a federate handle, object class handle, or timestamp.  Since these constructs are represented using opaque data types in 1516, they were treated as type-safe within SDL.  The core infrastructure of the Verifier was given the responsibility for correctly processing these data types. While this approach does tend to make the MOM tests lengthy, the tests still maintain readability. This “face validity” of tests is especially important when attempting to write and debug test scripts.Encoding the MOM data, while complex, is a relatively straight-forward process given the encoding mechanism defined in 1516.2 [7].  Comparing expected MOM data to received MOM data, however, requires some additional work.  In many cases, the control data set specified by a SDL test represents a proper subset of the expected data while in other cases it is an exact representation.   Ordering issues pose other difficulties.  As was mentioned previously, there are times when the ordering of data within an array cannot be guaranteed (e.g. a list of federate handles).  There are also times when the ordering can be guaranteed (e.g. a string).  In 1516, there are many instances of unordered arrays containing ordered arrays.  Because of the need to deal with these more complex data types, the source to encode and validate MOM data was handled in modifications to the core Verifier infrastructure.  These modifications were designed to be modular and incorporated into the Verifier 3 software so that they could be used with implementations of other specifications (e.g. the 1.3 specification) without significant changes.Closing RemarksThe redesign of the verification system into Verifier 3 is a major step toward organizing what is a very complex operational system, supporting two different HLA specifications, into a structure that makes sense.  As a result, the system is easier to use, learn, understand, maintain, and expand. This redesigned verification system, as embodied in Verifier 3, should allow for continued use of the Verifier, as well as for future maintenance and expansion of the Verifier, at reasonable cost.References[1] Symington, S., Kaplan, J., Kuhl, F., Tufarolo, J., Weatherly, R., and Nielsen J.: "Verifying HLA RTIs", Simulation Interoperabily Workshop, September, 2000. [2] Tufarolo, J., Nielsen J., Symington, S., Weatherly, R., Wilson, A., Ivers, J., and Hyon, T.: "Automated Distributed System Testing: Designing an RTI Verification System", 1999 Winter Simulation Conference, pp. 1094-1102, December 1999.[3] Tufarolo, J., Nielsen J., Symington, S., Weatherly, R., Wilson, A., Ivers, J., and Hyon, T.: "Automated Distributed System Testing: Application of an RTI Verification System", 1999 Winter Simulation Conference, pp. 1103-1108, December, 1999.[4] U.S. Department of Defense, Defense Modeling and Simulation Office, High Level Architecture Interface Specification, v1.3,  April 2, 1998.[5] IEEE Standard for Modeling and Simulation (M&S) High Level Architecture (HLA)—Framework and Rules, IEEE Std 1516-2000, 11 December 2000.[6] IEEE Standard for Modeling and Simulation (M&S) High Level Architecture (HLA)—Federate Interface Specification, IEEE Std 1516.1-2000, 9 March 2001. [7] IEEE Standard for Modeling and Simulation (M&S) High Level Architecture (HLA)—Object Model Template (OMT), IEEE Std 1516.2-2000, 9 March 2001.AcknowledgmentsThe authors would like to thank Dave Johnson and James Hughes.  Dave and James both participated in the Verifier 3 effort.Author BiographiesDr. FREDERICK KUHL is a senior principal engineer with The MITRE Corporation. He has been a leader since the beginning in the activities to prototype implementations of the HLA infrastructure, headed the successful effort to have the Object Management Group adopt the HLA, and for several years led the software side of the RTI Verification Facility. Dr. Kuhl holds the Ph.D. in computer science from Texas A&M University.Keven Ring is a lead software engineer with The MITRE Corporation.  He participated in many of the software changes required to support 1516 verification as well as the design of Verifier 3.  He holds a B.S. in Computer Science from Virginia Polytechnic Institute and State University.MIKE Shadid is a senior software systems engineer with The MITRE Corporation.  He led the design and development efforts of Verifier 3.  He holds a B.S. in Computer Science from the University of Virginia.SUSAN SYmINGTON is a lead scientist with the MITRE Corporation where she serves as project manager for RTI Verification. She also chaired the IEEE High Level Architecture Working Group that drafted the three IEEE M&S HLA standards: IEEE1516, IEEE1516.1, and IEEE1516.2. She holds a B.A. in Mathematics and Philosophy from Yale University and an M.S. in Computer Science from the University of Maryland at College Park. Directly, in the case of an RTI with a Java interface, or the Verifier provides one as part of a cross-language “cap,” in the case of non-Java RTIs.This work was supported by the Army under contract #DAAB07-02-C-N200 and is subject to the "Rights in Data" clause at DFARS 252.227-7013 (NOV 95). This work was performed at the MITRE Corporation.Figure  SEQ Figure \* ARABIC 3 - Verifier 3 Component InteractionATTACHMENT POINTSFEDERATES COMMUNICATE WITH 5 VERIFIER ATTACHMENT POINTSRTI-native language (e.g. Java or C++)MiddlewareSPAWNS 5 FEDERATES OF A SINGLE TYPERMIJDBC1516 RTI (C++)1516 RTI (Java)1.3 RTI (C++)1.3 RTI (Java)MIDDLEWAREMIDDLEWARESPEC 1.3 FEDERATESCORBA Test Federate 1.3 (Java side)Future  C++ Test Federate 1516 (Java side)Java Test Federate 1516CORBA Test Federate 1.3 (C++ side)Future C++ Test Federate 1516 (C++ side)TF 1Launchercommunicates managesJNI Test Federate 1.3(C++ side)JNI Test Federate 1.3 (Java side)JavaRTITest Federate Java Test Federate 1.3Test Controller…TF 5TF 2Test ControllerSPEC 1516 FEDERATESLauncherTest ControllerDatabaseDatabase