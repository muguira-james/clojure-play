Issues in software protection for military simulationMartin R. Stytz, Ph.D.Sheila B. Banks, Ph.D.Calculated InsightWright-Patterson AFB, OH  45431Orlando, FL  32828 HYPERLINK "mailto:mstytz@att.net" mstytz@att.net HYPERLINK mailto:sbanks@calculated-insight.com sbanks@calculated-insight.comKeywordssimulation security, application security, distributed simulation, distributed military simulation, software securitySummary:  As distributed simulation environments increase in the complexity, fidelity, scope, and number of geographical locations that participate in the simulation so does the vulnerability of the simulation’s application software and data to theft, piracy, or compromise.  Additionally, simulation capability improvements inevitably increase the value of the simulation software and its data, directly increasing the incentive for attacking or pirating the data and software.  The increase in value of the application software and data is a direct and inevitable result of the improved representation and fidelity of the military system components of the simulation.  Therefore, as the fidelity of the simulation environment increases existing software systems and licensing approaches fail to provide the needed protection and there is a corresponding need for improved security for simulation software and data and this need for improved software and data security will increase as the value of the software and data increases.  Therefore, while the increase in scope, complexity, and fidelity increases the utility of distributed simulation environments, this improvement in simulation system capabilities must be accompanied by a corresponding increase in simulation software security; which is a topic that has received little attention to date.  In this paper, we address the topic of software protection for military simulation and discuss application security as it relates to modeling and simulation.1.	Introduction and backgroundApplication software and its data are increasing in their value because of the cost of acquiring the data, the cost of building the software, and the cost of assembling, testing, and validating ever more complex simulation environments.  Until recently, the need for application software protection and security for its data has been addressed through efforts to provide security for the simulation environment using a dyad of security technologies comprised of network level resources and operating system level resources; this dyad has been supplemented on occasion by some forms of software licensing2-15.  In spite of our best efforts, we have not been able to achieve a sufficient degree of application and simulation environment security and the current meager dyad of security measures has left military simulation software and data at risk.  Traditional software protection schemes, licenses, network-centric defenses, and operating system-based defenses are inadequate to the task of protecting ever more valuable modeling and simulation software and data.  Even with the use of strong encryption technology, network-centric and operating system-based defenses have failed to secure applications from a variety of different types of attacks.  The record and number of successful attacks demonstrates that only placing security technology in the network and the operating system, while necessary, is not sufficient to provide protection and security for the application software and data involved in distributed simulation environments.  Indeed, there is a growing body of literature that provides some insight into how to break or hack into software, this threat continues to growThreat1-5.  As a result, it is increasingly apparent that software and data must be protected using a variety of technologies that are embedded in the application software and data whose purpose is solely to protect the software and data.We believe that application security, which is the field of cybersecurity related to the security of application software and data, will become a more important part of modeling and simulation environments as the environments increase in their fidelity and as more locations participate in larger-scale simulation-based exercises.  Application security will increase in importance because simulation environments will become more valuable and more vulnerable.  The increase in fidelity will increase the value of both the simulation software and of the data and so will make them increasingly valuable targets for attack and, presumably, the increase in value will result in more resources being devoted to pirating the information contained in the simulation software and data.  Simply encrypting the data while in transit between hosts10, 11, 12 is not sufficient to address the spectrum of security threats that must be countered.  Threats to the data exist while it resides on a host in unencrypted form as well as to the software that comprises the simulation environment.  These threats are viable because the network and operating system portions of the simulation environment do not provide the security needed to insure the protection of the data and software.  Therefore, defenses for applications and their data are needed, and these capabilities should be placed in the application since the network and operating system can not provide the security needed and because the application layer provides a logical location for the placement of additional protection capabilities.  These application-based security technologies aim to prevent piracy, theft, and reverse engineering of software and data.  These security objectives are addressed using a variety of techniques, which are today limited to chiefly watermarking, performance degradation, and obfuscation.  However, there are pressing research needs that hinder widespread adoption of even current rudimentary application security technologies.  Some of these research needs include the development of techniques that allow an application to detect attempted compromise, techniques to allow applications to autonomously detect attempts at tampering, and metrics that permit the objective measurement and comparison of software and data protection techniques.In this paper, we discuss the chief application security technical issues facing distributed simulations.  The paper presents some suggestions regarding the use of these protection techniques in distributed simulation applications, a summary of the current state of military software protection, and suggestions for further research in this area.  While software and data protection and security are important issues for the modeling and simulation community, the technology for software protection is more advanced than that for data protection.  As a result, we will concentrate on software protection in this paper and address data protection issues in future work.The remainder of this paper is organized as follows.  The next section presents a brief overview of objectives for military simulation software protection.  Section Three contains a brief background.  Section Four contains a discussion of military simulation software protection goals.  Section Five contains contains a discussion of the apparent research directions for military simulation software protection.  Section Six contains a summary and suggestions for near-term research.2.	Application Security Objectives OverviewIn our view, there are two main objectives for practical military simulation software protection: 1) to make the task of violating an application so difficult that the effort needed to compromise an application is too high for most attackers and 2) to make the task of breaking into a military software application so time-consuming that most attackers who could accomplish a penetration give up.  As a complementary requirement, those attacks that do succeed must be quickly detected in order to limit the damage inflicted.To attain these objectives, protected software should exhibit five critical properties: 1) it should be difficult to change the overall functionality of the software via small, local changes to the code, 2) it should be difficult to analyze the software’s control and data flows, 3) it should be difficult to determine the software’s runtime behavior, 4) it should be difficult to attack/subvert the software via its execution environment/host platform, and 5) the protection should employ strong cryptographic technologies whenever cryptography is used.   Furthermore, defending/protecting software against attacks requires that applications be aware of their environment and must cautiously interact with that environment. Inputs from users, whether those users are human or other software applications, must be carefully scrutinized. The foundation of simulation application security is that simulation environments should be assumed to be hostile and that trust must be established between the operating system and the application before an application can be sure that it can operate securely.3	BackgroundTraditionally, information assurance and the security of a computation and its data have been provided by the network defensive systems and in the authentication mechanisms in the host operating system1-14.  Despite intense and ongoing efforts to strengthen these two types of defensive systems they cannot assure the security of software and data on the host computer and as a result users place their application software and data at risk whenever they use a computer.  Recently, the concept of information assurance has broadened from the traditional dyad of defensive systems to a triad, a triad that employs defensive systems embedded in the application software.  The technological components of application software defense, also called software protection, are a mix of techniques whose individual and composite objective is to deny the pirate or intruder the capability to misuse, reverse engineer, tamper with, or steal application software or data.  Software protection is the last ring of defense for application software and data, with the first two defensive rings being the protection technologies residing in the network resources and the other being the protection technologies residing in the operating system.At a practical, developer’s level there are a number of techniques and practices that have been developed that provide a degree of application security and can be employed directly to improve the security of a distributed simulation application.  As noted by Howard7, these principles should be employed during software development and can improve the security of the application.  In brief, these principles for development of secure software are the following: 1) use a security process, 2) define the application security goals, 3) treat security as a critical product feature, 4) use least privilege for the application, 5) employ defense in depth to protect the application, 6) fail to a secure mode, 7) use secure defaults, and 8) do not depend upon achieving security for an application through obscurity of information or techniques or even source code.  An important adjunct to these principles is security threat modeling via threat case modeling.  The Unified Modeling Language (UML)[UML 1-4] appears to be the means of choice for portraying and modeling application security threats in a manner that is clear and standard as well as extensible.  An accurate model of the threats that an application will face and must defeat is an essential first step in determining the defenses needed by an application.  Clearly, then, the threat model must present a portrayal of the different types of threats, the different strategies applied for each threat, different vulnerabilities each threat attempts to exploit, and the programming languages that each threat targets.  Other components of the threat must also be modeled, the key is that there is a need for standardization in the documentation of threat case format as well as the development of a library of threat cases.Given that the basic techniques for application software protection are applied, the question of how to strengthen the protection naturally arises.  Basically, there are three software-based techniques for application security that are especially relevant to the modeling and simulation world since these techniques address the protection of high-value assets in a networked, threat-rich environment.  These three forms of software-based software protection are; 1) watermarking, 2) obfuscation, and 3) application performance degradation.  These techniques perform three main functions; 1) detection of attempts to pirate, misuse, or tamper with software, 2) protection of software against attempts to pirate, misuse, or tamper with it, and 3) alteration of the software so that its functionality degrades in an undetectable manner if protection fails.  These defensive technologies have been applied in a number of computing platforms ranging from single processors to small computer clusters to traditional supercomputers even to wide-area distributed computing.  We will briefly describe these three software protection techniques in the following paragraphs.To obfuscate a piece of software requires subjecting it to a set of semantics-preserving transformations[Obfuscation 1]. Unfortunately, the literature in this topic is sparse.  These transformations are similar to the optimizing transformations used in compilers, but instead of making the executable smaller or faster obfuscation transformations make it more difficult to understand and reverse engineer application software.  The software obfuscation operation can be described as follows:  Given a set of obfuscating transformations and a program P consisting of source code objects (classes, methods, statements, etc.) find a new program P’ such that: 1) P’ has the same observable behavior as P, i.e. the transformations are semantics-preserving; 2) the obscurity of P’ is maximized, i.e. understanding and reverse engineering P’ will be strictly more time-consuming than understanding and reverse engineering P; 3) the resilience of each transformation is maximized, i.e. it will either be difficult to construct an automatic tool to undo the transformations or executing such a tool will be extremely time-consuming; 4) the stealth of each transformation is maximized, i.e. the statistical properties of the transformed objects of the program are similar to those of the original program and it is difficult to determine which obfuscation techniques have been employed and where; and 5) the cost (the execution time/space penalty incurred by the transformations) of P’ is minimized.  For example, within a program loop, an obfuscation transform would: 1.	choose a part of the loop to obfuscate; 2.	choose an obfuscation algorithm from a pool of candidate algorithms; 3.	apply the algorithm to the software in the loop, and  4. decide whether to continue the process.  The obfuscation transformation should not be able to be detected, that is, the transform should not be detectable upon examination or when compared to other versions of the same software that are not protected.To effectively obfuscate a program, many difficulties must be overcome, we will elaborate on a few of the most relevant challenges here.  First, in order to choose the right part of the application to obfuscate, the developer must know which parts are security sensitive (and hence need a high degree of obfuscation) and which are performance sensitive (and hence can tolerate a lower degree of obfuscation).  This determination is difficult to make even with a solid threat model and software performance model since, in general, the most performance sensitive parts of the application are generally the most security sensitive   A second challenge is that in order to choose an obfuscation algorithm the developer needs to know what effect (as regards performance and security) the algorithm has on a typical piece of code.  In general, these metrics are not available and so performance data must be obtained on a case-by-case basis.  Acquiring the data is costly and time consuming, which tends to inhibit the use of obfuscation protection techniques.  A third challenge is that in order to decide whether to continue the obfuscation process the developer must measure the level of security that has been achieved and how much performance penalty has been added.  Here again we lack metrics and the need for testing tends to inhibit obfuscation’s use.  Nevertheless, in spite of its current weaknesses and the general poor understanding of obfuscation and its application it is one of the best tools currently available for software protection.The software watermarking operation[Watermarking 1-5] can be described as follows:  The task is to embed a structure W (the watermark) into a program P such that: 1) W can be reliably located and extracted from P (the embedding is resilient to de-watermarking attacks); 2) W is large; 3) embedding W into P does not adversely affect the performance of P (the embedding is cheap); 4) embedding W into P does not change any statistical properties of P (the embedding is stealthy); and 5) W has a mathematical property that demonstrates that its presence in P is the result of deliberate actions. Software watermarks come in two types, static and dynamic.  Static watermarks are stored in the application executable, whereas dynamic watermarks are constructed at runtime and stored in the dynamic state of the program.  Static watermarking techniques are easier to develop and control and permit better estimates of their impact on performance to be made; dynamic techniques are more resilient to attack and detection but their impact upon performance is difficult to predict.Application performance degradation is the newest of the three types of software protection technologies.  The strategy for this type of protection is to leave the pirate with software that is useless without the pirate detecting that the change.  Performance degradation depends upon the existence of one or more markers in an application that permit the application to determine if it is under attack.  The markers are generally a combination of watermarks and performance metrics embedded in the software and internal test data and software.  Stealthy authentication between components of an application can also be used as well as authentication with an external device to allow an application to determine if it is under attack or has been subverted.  If an attack or subversion is detected, the protected software responds by degrading its performance in such a manner that the degradation response, whether it is the application’s precision, speed, or memory, is difficult to detect and gradual.We should note in passing that an oft used and even complimentary approach to application security is to use external hardware and keying systems for authentication purposes.  In general, these systems operate by allowing the software application to exchange cryptographically protected authentication messages with the device one or more times during the course of executing the protected program.  This approach has its own difficulties, such as that its use is easily detected and the security transmissions are subject to interception and playback to spoof the software, but does serve to complement the protection techniques that are software based.4.	Software Protection GoalsWhen considering the technologies to be developed to protect simulation systems from compromise, having a clear view of the objectives for the protection efforts is necessary.  In our opinion, the first goal is to preserve the integrity of the system; by which we mean that the system is guaranteed to remain inviolate, no capabilities are removed or modified and no capabilities are added.  The second goal for software protection is to control the use of the system; which requires that the application have inherent capabilities to insure that it invoked only by other authorized applications or human users.  The third goal is to prevent extraction of software subsets. This goal goes hand-in-hand with the second goal.  The second goal prevents the entire system from being abused or misused, the third goal insures that subsets of the system are not abused or misused as well.  Together, these two goals insure that the functionality of he system or any of its component subsets can not be extracted or captured.  The fourth goal is to protect system data, that is to insure that answers can not be stolen or that false data can not be introduced into the system.  This goal has two subgoals, the first subgoal requires a characterization of acceptable input data, the second goal requires the definition of one or more protocols that allow a data generator to verify the identity of a data recipient and the tyoe of data that it is allowed to receive.  The fifth goal is to protect intellectual property.  This goal is supported by the third oal and serves to insure that key algorithms or novel processing techniques that are inherent to the software system can not be extracted or reverse engineered.  The sixth goal addresses the execution properties of the application software as it requires that the software correctly and accurately executes.  So while we have insured that the application’s integrity is insured, this goal looks to protect an application from a slightly different angle and insure that even if the software is tampered with it will still properly execute.  The seventh goal is to insure that the answers produced by the system are accurate and correct.  To do so requires that the application be able to detect that it was changed, that an application can repair tampering and thereby regain the ability to produce correct answers, and that an application be able to test itself for accuracy.  Clearly, all of the technologiues required to provide all of these capabilities are far from being realized but we can employ extant capabilities to improve simulation security and also develop additional required capabilities in order to attain all seven goals.These seven goals apply directly to the military simulation environment as much as to any other environment and more than most.  In general, the content of the simulation environment is composed of data and software that are sensitive; hence protecting them are crucial requirements for simulation environments.  Classification of data and software can address some of the protection requirement but not all.  At some point, information must be in the clear and at that point it can be acted upon by subverted software, so it order to achieve the goals outlined above, the software that comprises the simulation environment must be secure in order for the entire simulation environment to be secure.5.	Research Directions for Modeling and simulation Software protectionIn the preceding sections, we introduced the concept of application software security and the overarching goals for software protection, in this section we turn to a discussion of the research issues that must be addressed to provide practical, effective, and ubiquitous software security for modeling and simulation systems. As should be apparent at this point, the degree of security that we are advocating is beyond that achievable by simple encryption, but rather is a complete solution that provides security for a simulation environment in all its aspects because each component is protected and provides a degree of protection for other components as well.As a first research step, it would be helpful to understand the cost and benefit tradeoffs incurred by the application of software protection technologies.  The application security solution that must be developed will is multidimentional and therefore complex.  As a result, for every application and for the complete simulation environment, the application security solution will be difficult to determine and it will be difficult to prioritize the application of application security technologies to simulation software.  Because of the apparent inherent difficulty, a framework for analysis of security vulnerabilities and the utility of application security technologies may prove useful.  The development of a complete framework is an open research issue, until such a framework is developed allow us to suggest the following baseline framework that can be used to guide the application of application protection technologies.  The framework is the following: 1) Determine the asstes to be protected; 2) Determine the risks to the assets; 3) Determine how well a given security solution mitigates the risks; 4) Determine the other security risks that the security solution causes; and 5) Determine the costs and tradeoffs that the security solution imposes.  As the simulation community gains a better understanding of the various threats, available protection technologies, and protection metrics we will be able to refine the framework to include requirements for protection and degree of security threat that can be accommodated.  Until that time, we will only be able to apply this framework as a rough guide in applying protection technologies to simulation software.In addition to developing a guide and framework for analysis of needed application security technologies for simulation environments, other research questions must be addressed.  Software protection, being a relatively new discipline, faces a set of pressing near-term research issues as well as longer term research issues whose focus must be protection of software executing on hardware with significantly greater computational capability. This difference in research focus provides a structure for addressing the research challenges facing the modeling and simulation community.In the near term, the research goal must be to protect developed software, which means addressing the problem of protecting legacy software.  Near-term research needs must also address the problem of the protection of software across the entire spectrum of hardware platforms, development of the next generation of software watermarking and obfuscation techniques (to provide greater security with less impact on performance), and joining application security techniques to operating system and network-based defensive capabilities to achieve a mutually supporting and more powerful protection capability.  An additional near-term research need is the development of the capability to insert protection techniques directly into the binary form of a program with confidence that the insertion has not compromised either the performance or accuracy of the software coupled with metrics for assessment of performance and degree of protection achieved when a particular protection technique is used.  For the modeling and simulation community, the protection of the High Level Architecture middleware is also an important near-term need and one that poses several challenges in terms of performance impact, stealthiness of protection, and the proper mix of protection techniques.In the longer term, the research focus must shift to the development of techniques and secure integrated development environments that protect software from the moment of its inception throughout its lifecycle and that automatically insert protection techniques in response to defined requirements and expected computational load. Also, given the drive to assemble applications by composition of software components, research to determine how to secure applications whose parts are produced by a variety of sources, sources that must be assumed to be untrustworthy, is needed.  Another long-term research objective is the need for a capability for software to autonomously alter the operation of its protection mechanisms or even insert/activate new mechanisms in response to attempts to compromise the software being protected.  Finally, development of software architectural and design methodologies to incorporate considerations and techniques for the development of secure software as well as comparisons of design methodologies along the application security axis are needed.One of the clearest and most pressing priorities is the need for a lexicon and ontology of modeling and simulation terms as they relate to application security terms.  The current situation is one where terms in both fields are overloaded with numerous meanings; thereby causing confusion and impeding progress in the deployment of application security techniques and assessment of application security capabilities.In the same vein, there is a need for application security test suites for assessing modeling and simulation application protection technologies.  The test suites must include benchmarks, metrics, an evaluation system (or rating system) and security testing scenarios to allow the modeling and simulation community to evaluate the efficacy of different software protection techniques in modeling and simulation applications and environments.  Metrics for resilience and protection are particularly important because they provide insight into the strengths and weaknesses of a given protection technique as well as the estimated time to defeat a technique.  Closely tied to the need for standard application security test suites is a cost/benefit analysis of different software protection technologies within the modeling and simulation domain.  Currently, there is no information available that relates the costs of software protection, which include implementation time, maintenance cost, and computational power consumed, to the benefits of a protection technique, which include the time required to defeat a particular protection technique.  Also, standard test suites and metrics would allow for comparison across and among classes of techniques.  Since no one technique can or should be relied upon to completely protect an application, information is required about which techniques can be combined, the effectiveness of each combination, the costs of each combination, and the performance impact of each combination of techniques within the modeling and simulation arena. To achieve this objective, a threat model is essential and a set of UML use cases (threat cases) that describe how the system should respond to attack shoould be developed as a starting point for the security testing process (as suggested by Alexander1).In addition to the standardization needs highlighted previously, there is also the need for information that can guide the modeling and simulation community in combining network, operating system, and application security capabilities in a mutually reinforcing manner so as to address a given level of threat in a way that have minimal impact upon performance.  This need is especially important given the modeling and simulation community’s increasing reliance upon network connections for distributed simulation and the sensitive data transmitted across it and made vulnerable via the network connection and the corresponding need to protect data assets in a distributed simulation environment.  Because a distributed simulation operates within a continuously varying environment, the modeling and simulation community would benefit from software protection techniques that allow for execution-time composition of application security techniques in concert with network and operating system security techniques so that a desired degree of overall security for a distributed simulation can be maintained even in the face of attack.  To achieve this goal, even in part, the standardization work highlighted previously must be performed and the modeling and simulation community will require application security technologies that enable components of an application and of a distributed simulation system to establish trust (possibly via authentication) among themselves, exchange security interface information and security requirements information, and continuously monitor the application security performance of the other components of their application and of the distributed simulation as a whole.  An additional standardization need is the development of standardized techniques for documenting security needs and security interface requirements for distributed simulations.The development of techniques for detecting if software is under attack requires placement of protection technologies into applications to enable each application to determine if an attack is underway and also to control the use of the protection technologies and protection response.  Given the expected cost of modifying applications to provide them with these capabilities, we believe that a more effective and efficient approach would be to employ a virtual machine to make the determination if an attack is underway and to manage the application of the protection techniques and protection response.  Parathentically, we should note that the virtual machine should have a standard interface so that any application can make use of the virtual machine.  The virtual machine should provide capabilities for protecting software while also giving the software a means for authenticating the operation of the virtual machine and authenticating that the software is, actually, making use of a virtual machine that is authorized to provide security for the application.6.	Summary and conclusionsIn this paper we presented arguments in support of the need for the development and integration of software protection measures in military simulation applications, especially for distributed military simulations.  As we have noted, the need for application security arises from the increased sensitivity of the information contained in and used by military simulation applications, the increased fidelity of the models used in military simulations, and the increased use of real-world command and control systems in military simulations.To effectively deploy software protection technologies for modeling and simulation, there are some research questions that remain to be addressed. A major question that must be addressed is the cost of protection as related to its benefits.  Cost can be broken down into three parts, efficiency cost (what is the performance penalty of a technique or combination of techniques), implementation cost, and maintenance cost (ie., what effect upon software maintenance does the technique incur?). Another need is for the development of a spectrum of protection technologies and evaluation of their associated costs and benefits so that developers can make informed decisions about the degree of protection needed for software based upon the sensitivity of the software and the costs involved in applying the indicated application techniques.  Another major research question is modeling and simulation software protection metrics.  Some metrics that must be refined further are resilience (a measure of how difficult is it to defeat a technique), obscurity (a measure of how difficult it is to determine if a particular protection technique has been employed, aka stealthiness), and expected longevity (a measure of the length of time that a protection technique will afford a worthwhile degree of protection) of each protection technology, the costs and benefits of different mixtures of protection techniques, and the level of protection required for a given application and simulation environment.  Additionally, the modeling and simulation community will require means for determining and measuring the required degree of security needed by an application within different types of distributed simulations and scenarios and the technology options available to address these needs.In conclusion, as military simulation environments increase in their fidelity and become more widely used the sensitivity of their data and their vulnerability to compromise will increase as will the motivation for attacking military simulation application software to gain access to the secrets embedded within.  In the past, the protection provided by network and operating system based security capabilities was adequate for military simulation environments.  However, network and operating system based security technologies can no longer protect military simulation environments and they are not able to stave off compromise and protect the increasingly sensitive information contained within military simulation environments.  Therefore, the time has arrived to replace the dyad of protection techniques (operating system and network based technologies) by a triad of capabilities, one that includes application software security technologies.  We hope that this paper has served to highlight the importance of application software protection and will also serve to motivate military simulation specific research to develop and evaluate software protection technologies.  While this paper has concentrated on issues related to software protection, the data protection problem is just as important to military simulation security.  We plan to report on our research to address data security issues in a future paper and hope other researchers will address simulation data security and protection issues.ReferencesAlexander, I. (2003) “Misuse Cases: Use Cases with Hostile Intent,” IEEE Software, vol. 20, no.  1, January, pp. 58-66.Amoroso, E.G. (1994) Fundamentals of Computer Security Technology. Prentice Hall: Englewood Cliffs, NJ.Collberg, C.; Thomborson, C.; and Low, D. (1998) “Manufacturing Cheap, Resilient, and Stealthy Opaque Constructs,” Principles of Programming Languages 1998, POPL’98, San Diego, CA, January.Denning, D.E. 1999) Information Warfare and Security, Addison-Wesley: Reading, MA.Garfinkel, S. and Spafford, G. (1991) Practical Unix Security. O’Reilly & Associates: Sebastopol, CA.Gollmann, D. (1999) Computer Security.  Wiley: Mew York.Howard, M. and LeBlanc, D. (2002) Writing Secure Code.  Microsoft Press: Redmond, Washington.Jalal, F. and Williams, P. (1999) Digital Certificates:  Applied Internet Security.  Addison-Wesley: Reading, MA.National Security Council. (1999) Trust in Cyberspace.  National Academy Press: Washington, DC.Schneier, B. (1996) Applied Cryptography, John Wiley and Sons: New York.Stallings, W. (1999) Cryptography and Network Security: Principles and Practice.  Prentice Hall: Upper Saddle River, NJ.Summers, R. (1997) Secure Computing: Threats and Safeguards.  McGraw Hill: New York.Shrobe, H. (2002) “Computational Vulnerability Analysis for Information Survivability,” AI Magazine, vol. 23, no., 4, Winter, pp. 81-91.Waltz, E. (1998) Information Warfare: Principles and Operations.  Artech House: Norwood: MA.ThreatErickson, J. (2003) Hacking:  The Art of Exploitation.  No Starch Press: San Francisco.McCkure, S.; Scambray, J.; and Kurtz. (2003) Hacking Exposed: Network Security Secrets and Solutions.  McGraw-Hill: New York.Skoudis, E. (2004) Malware: Fighting Malicious Code.  Prentice Hall: Upper Saddle River, NJ.Whittaker, J.A. (2003) How to Break Software.  Addison-Wesley:  Boston.Whittaker, J.A. and Thompson, H.H. (2004) How to Break Software Security.  Addison-Wesley: New York.Watermarking HYPERLINK "http://citeseer.nj.nec.com/context/960804/15317" Collberg, C., and Thomborson, C. (1999) "Software watermarking: Models and dynamic embeddings,” In Conference Record of POPL '99: The 26th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, Jan. 1999.Kahng, A. B.; Lach, J.; Mangione-Smith, W. H.; Mantik, S.; Markov, I.L.; Potkonjak, M.; Tucker, P.; Wang, H. and Wolfe, G. (1999) “Watermarking Techniques for Intellectual Property Protection,” 35th ACM/IEEE DAC Design Automation Conference (DAC-98), June, pp. 776-781. HYPERLINK "http://citeseer.nj.nec.com/context/1745383/0" Palsberg, J., Krishnaswamy, S., Minseok, K., Ma, D., Shao, Q., and Zhang, Y. (2000) “Experience with Software Watermarking.” Proceedings of the 16th Annual Computer Security Applications Conference, ACSAC '00, pp. 308-316.  HYPERLINK "http://citeseer.nj.nec.com/context/1811520/452412" Nagra, J.; Thomborson, C.; and Collberg, C. (2002) “Software Watermarking: Protective Terminology,” Australasian Computer Science Conference, pp. 177-186.  HYPERLINK "http://citeseer.nj.nec.com/context/1805321/0" Ramarathnam V., Vijay V., and Saurabh S. (2001) “A graph theoretic approach to software watermarking,” In 4th International Information Hiding Workshop, Pittsburgh, PA, April.   HYPERLINK "http://citeseer.nj.nec.com/context/1633791/146955"  HYPERLINK "http://citeseer.nj.nec.com/context/1594306/0" Palsberg, J. 2000. “Software watermarking with Secret keys,” In CERIAS Annual Research Symposium on "Advancing the State and Practice of Information Assurance and Security, " Purdue University, W. Lafayette, IN, April 21. ObfuscationCollberg , C.S.; Thomborson, C.; and Low, D. (1997) “A Taxonomy of Obfuscating Transformations, Technical Report #148, Department of Computer Science, The University of Auckland, July.UMLAlbir, S.S. (1998) UML in a Nutshell, O'Reilly Press, Sebastopol, CA.Booch, G. (1998) The Unified Modeling Language User Guide.  Addison Wesley, Reading, MA.Booch, G.; Rumbaugh, J.; and Jacobson, I. (1999) The Unified Modeling Language User Guide, Addison Wesley, Reading, MA.Henderson-Sellers, B. and Unhelkar, B. (2000) Open Modeling with UML, Addison-Wesly Reading, Mass.About the AuthorsMartin R. Stytz is a retired Lieutenant Colonel in the U.S. Air Force.  He received a Bachelor of Science degree from the U.S. Air Force Academy in 1975, a Master of Arts degree from Central Missouri State University in 1979, a Master of Science degree from the University of Michigan in 1983.  Stytz received his Ph.D. in Computer Science and Engineering from the University of Michigan in 1989.  He is a member of the ACM, the IEEE, the IEEE Computer Society, the IEEE Task Force for Security and Privacy, AAAI, and the Society for Computer Simulation. Sheila B. Banks is a Technical Advisor for the Air Force Research Laboratory’s Human Effectiveness Directorate and is the NATO lead for SAS-ET.V (Exploratory Team for a NATO Virtual Institute for Human Behavior Representation.)  Dr. Banks received her Bachelor of Science from the University of Miami, Coral Gables, FL in 1984 and a Bachelor of Science in Electrical Engineering from North Carolina State University, Raleigh, NC in 1986.  Also from North Carolina State University, Raleigh, NC, she received a Master of Science in Electrical and Computer Engineering in 1987 and her Doctor of Philosophy in Computer Engineering (Artificial Intelligence) from Clemson University, Clemson, SC in 1995. Mr. Jeff Hughes, Air Force Research Laboratory, personal communication.		PAGE  