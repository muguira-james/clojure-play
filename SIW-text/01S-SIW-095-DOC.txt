The Federated-Simulation Development Kit (FDK): A “Source-Available” HLA RTIThom McLeanRichard FujimotoCollege of ComputingGeorgia Institute of TechnologyAtlanta, Georgia 30332-0280404-894-7486, 404-8945615{thom, fujimoto}@cc.gatech.eduKeywords:HLA, RTI, cluster computing, high-performanceABSTRACT:  The Federated-Simulations Development Kit (or FDK) is a software system developed at Georgia Tech that contains composable modules for building run-time infrastructures (RTIs).  It is designed to be a research vehicle for exploring high-performance distributed simulation.  The current version of the FDK includes two complete RTIs.  The Basic RTI (B-RTI) implements services necessary for simple, time-managed, message-passing simulations.   The Detailed RTI (D-RTI) is built to conform to the HLA interface specification.  The FDK is designed so that RTI developers can pick and choose from the set of FDK modules that are most appropriate for their particular RTI implementation. RTI developers can benefit from incorporating these ready-made modules, and through well-defined interfaces, incorporate additional functionality required for their particular simulation environment.  This paper describes experiences in using the FDK software and its included RTIs. in a variety of distributed simulation projects.  We will also present performance measurements of the current FDK release.Introduction Figure  SEQ Figure \* ARABIC 1 - FDK OverviewThe FDK software is the result of several separate research and development efforts.  The FDK has three general types of software.  The RTI-Kit, explained next, is the core set of modules that implement basic services required for distributed simulation.  FDK also includes two RTI implementations: 1) a Basic RTI, and 2) the DRTI, which uses the HLA I/F specification.  Finally, the FDK includes many other utilities to facilitate development of and experimentation with distributed simulation systems.  One utility is Jane, a java-based control module.  A possible use of the FDK is depicted in  REF _Ref378017417 \h Figure 1.The RTI-Kit  RTI-Kit is a collection of libraries designed to support development of RTIs for parallel and distributed simulation systems, especially federated simulation systems, running on high performance computing platforms.  Each library can be used either separately, or together with other RTI-Kit libraries, depending on the functionality required by the user. AdvantagesThis "library-of-libraries" approach to RTI development offers several important advantages.  First, it enhances the modularity of the RTI software because each library within RTI-Kit is designed as a stand alone component that can be used in isolation from other modules. Modularity also enhances maintainability of the software, and facilitates optimization of specific components (e.g., time management algorithms) while minimizing the impact of these changes on other parts of the RTI.  Finally, this design approach facilitates technology transfer to other RTI development projects because utilizing RTI-Kit software is not an "all or nothing" proposition; one can extract modules such as the time management while ignoring other libraries. Architectural FrameworkThe architecture for RTI software constructed using RTI-Kit is shown in  REF _Ref377970335 \h Figure 2 - RTI-Kit Modules. Figure  SEQ Figure \* ARABIC 2 - RTI-Kit ModulesCommunications services.  At the lowest level of the architecture are communication services that provides basic message passing primitives.  Communication services are defined in a module called FM-Lib. This communication layer software acts as a multiplexer to route messages to the appropriate module. The current implementation of FM-Lib implements reliable point-to-point communication. It uses an API based on the Illinois Fast Messages (FM) software  REF _Ref378022288 \n \h [1] for its basic communication services, and provides only slightly enhanced services beyond those of FM.Core Modules. Above the communication layer are modules that implement key functions required by the RTI.  These modules form the heart of the RTI-Kit software.  Specifically, TM-Kit is a library that implements distributed algorithms for realizing time management services.  Similarly, DDM-Kit implements functionality required for data distribution management services.  MCAST is a module that implements group communication services.  Other code provides utilities such as software for buffer and queue management.Interface. An interface layer utilizes the primitive operations defined by these modules to implement a specific Application Program Interface (API) such as the HLA Interface Specification.  The implementation of an HLA RTI is facilitated by the RTICore module.  RTI Core pulls together the resources of the other libraries within FDK to present a unified interface to the RTI developer.  RTI Core’s main focus is to provide basic time management functionality that is useful to a wide range of RTIs.  RTI Core manages starting LBTS computation, responding to LBTS computation, and the delivery of messages freeing the RTI developer from these tasks.  RTI Core also provides Retraction Handle Management (RHM).  RHM maintains retraction handle information on all messages sent and received and provides a mechanism for determining if a sent message may be retracted, and a mechanism to support the annihilation of messages within the RTI.Design ConsiderationsThe RTI-Kit architecture is designed to minimize the number of software layers that must be traversed by distributed simulation services.  For example, TM-Kit does not utilize the MCAST library for communication, but rather directly accesses the low-level primitives provided in FM-Lib.  This is important in cluster computing environments because low level communications are on the order of a few microseconds latency for short messages, compared to hundreds of microseconds or more when using conventional networking software such as TCP/IP.  Thus, if not carefully controlled, overheads introduced by RTI software could severely degrade performance in cluster environments, whereas such overheads would be insignificant in traditional networking environments where the time required for basic communication services is very high.  Measurements indicate the overheads introduced by RTI-Kit are small; a federation of optimistic sequential simulators based on the Georgia Tech Time Warp (GTW) software interconnected via RTI-Kit was observed to yield performance comparable to the native, parallel, GTW implementation  REF _Ref378022383 \n \h [4].RTI implementationThis section explains the implementation of an RTI using RTI-Kit.  A specific example is given, based on the HLA IFSpec definition of the Time Advance Request service.The paradigmAs shown in  REF _Ref378022487 \h Figure 2, an RTI implementation can be thought of as an interface to RTI-Kit functionality.  An RTI implementation presents services to the federate according to a specific paradigm for simulation execution management and exchange of data (e.g. HLA).  Each RTI implementation must manage whatever global and local state information is required for its paradigm.  ImplementationTypically, an RTI will have state variables which include time management information (such as local time, result of the most recent LBTS computation, lookahead, the state of any federate requests to advance time), communication information (such as the multicast groups, and group membership, and the mapping of groups to message types) and the state of execution management processes (such as pause/resume, save/restore, join/resign).  The RTI must also have a means for delivering messages and other information to the federate.  In the case of an HLA federate, this is done using callback functions.  Therefore, the RTI must have a means of registering callback functions.Design Trade-offs.  One important feature of a modular RTI design is the ability to explore design trade-offs. The overhead of a  particular interface design may lead one to choose a modified, or partial implementation.  This may produce a more efficient execution for the target federation. This is a reasonable trade-off, even in an HLA execution environment, considering that freely available compliant RTIs exist, and the principle reason for choosing a different implementation would either be for 1) performance or 2) federation specific architectural considerations.  Example. An example of this type of trade-off is evident when considering the flexibility in configuring object attribute updates.  The HLA IF specification allows for the ownership, transport and ordering of every attribute of every object to be individually set.  While this could be a powerful tool for customizing the communications configuration of a federation execution, there is a significant overhead associated with checking each attribute in an attribute handle-value pair set (AHVPS).  In federations where ownership is static, and transport is never altered from the default, a significant simplification is possible.  This fact was exploited in the design of the FDK’s AHVPS class. The design assumes that a new AHVPS (or Parameter HVPS) will eventually be sent as an object attribute update or an interaction message.  The AHVPS constructor allocates memory for the entire message, marshalling the AHVPS data into the appropriate slot.  This eliminates the need to copy any data during an UpdateObjectAttributeValue() or SendInteraction() call.  Such an implementation would not be efficient if attribute updates cannot be assumed to be atomic.Included RTIsBRTI/* declaration management services */RTI_ObjClassDesignator RTI_GetObjClassHandle (char *);RTI_ObjInstanceDesignator RTI_RegisterObjInstance (RTI_ObjClassDesignator);void RTI_PublishObjClass (RTI_ObjClassDesignator);void RTI_InitObjClassSubscription (RTI_ObjClassDesignator, MCAST_WhereProc, void *);BOOLEAN RTI_IsClassSubscriptionInitialized (RTI_ObjClassDesignator);void RTI_SubscribeObjClassAttributes (RTI_ObjClassDesignator);RTI_ObjClassDesignator RTI_CreateClass(char *);/* object management services */void ReflectAttributeValues (TM_Time, struct MsgS *, long, long);EventRetractionHandle RTI_UpdateAttributeValues(RTI_ObjInstanceDesignator, struct MsgS *, long, long);/* time management services */void TimeAdvanceGrant (TM_Time);void RTI_NextEventRequest (TM_Time);void RTI_TimeAdvanceRequest (TM_Time);void RTI_SetLookAhead(TM_Time);TM_Time RTI_GetLookAhead(void);void RTI_Retract(EventRetractionHandle);void RTI_FlushQueueRequest(TM_Time);void RequestRetraction(EventRetractionHandle); /*To be supplied by federate*/void BRTI_Tick( void );Table  SEQ Table \* ARABIC 1 - BRTI ServicesThe Basic-RTI or BRTI, is a fully capable simulation infrastructure, which can be used to connect time managed, message passing simulations.  The BRTI does not make any assumptions about the content of the messages that are passed.  However, the BRTI does offer simple class-based publication and subscription, and object registration and updates (although there is no error checking on ownership).  The BRTI also implements all three HLA paradigms for advancing time (Time Advance Request, Next Event Request and Flush Queue Request)..  The BRTI is small; the source file is a mere 17K. This makes the BRTI a good place to start for those wishing to familiarize themselves with an RTI implementation.  This is also a good place to begin for researchers who are interested in raw performance analysis of various RTI alternatives.DRTI The FDK’s Detailed RTI (DRTI) follows the HLA I/F Specification in  REF _Ref378024977 \n \h [3].  The current DRTI implements or partially implements over half of the 1.3 Interface Specification.  As each new service is implemented, the performance of the RTI is re-checked, to ensure that no unintentional compromises are made.  As with the RTI-Kit itself, performance is never compromised simply to get additional services implemented.  The DRTI design is also being steered by the principle that a user should not have to pay a performance cost for services that they do not use.  In some cases, this has delayed implementation or inclusion of services where the performance impact was unacceptable.  The design of the DRTI is depicted in  REF _Ref378025087 \h Figure 3.Figure  SEQ Figure \* ARABIC 3 - DRTI ImplementationThe DRTI has additional services that support its intended use as a research tool.  For example, in cluster environments we often want to ensure that all Federates begin together, after everyone has checked in.  There is no convenient way to do this using the HLA I/F Spec, so the DRTI retains a simple barrier() function which simply blocks until all federates enter the barrier.  The DRTI also includes debugging and timing code, convenient for performance tests.Running Simulations ExecutionsAs currently implemented, (in FDK version 3.0) the RTI-Kit is limited to running single federation execution, and dynamic joins and resigns are not supported.  In a cluster computing environment, this is not usually a serious limitation. Most often, a cluster is being used for a single experiment at a time.  The benefit of this is that there is no fedexec or rtiexec required during the execution, and no resources are wasted polling for createFederation, or joinFederationExecution messages.  This goes along with the philosophy that a user shouldn’t have to pay for features that are not used. In many cases, the RTI-Kit paradigm may simplify the execution of a simulation by a single individual.Two simple test programs are included with the FDK.  APSIM is a simple airport simulation, used for instructional purposes.  The other, tm-ping, is useful in understanding the basics of working with the RTIs and also for testing the installation.   To run any federate with the DRTI, one must pass in certain environment information.  The following sections explain the various options available for running federations.Using runonA script named “runon” is included in the executable directory.  This script will execute a single executable on any number of machines, which are provided as arguments to the script.  In order to work properly, the user must set the environment variables FMTYPE and ARCH.  FMTYPE is one of TCP, SHM or MYR.  ARCH is as specified during compilation.  This information allows runon to find the appropriate executable, construct needed initialization information, and start up the executable on each listed machine.  The script uses a simply rsh call to all processors, passing in the number of processors and the names, to allow the RTI-Kit to initialize with a known set of federates. One the rsh calls have been made, the federates run on their own, to completion.Using the spawnerThe spawner is an executable that spawns remote jobs in much the same way as the runon script with.  The spawner, however, proffers a more direct link to the RTI-Kit initialization, through the Session Manager module.  The spawner will communicate initialization data to the federates, but will remain in control of the execution, permitting an abort, or halt, or other action as allowed for by the programmer.  The spawner also simplifies debugging in that each federates output is sent to a unique file, rather than to the console.  An example script that invokes the spawner is included in the FDK. Using JaneThe FDK also provides a more sophisticated way to control remote federates: Jane.  Jane is primarily a graphical user interface system to parallel and distributed simulations. In addition to providing default graphical controls and displays for the core simulation systems in a simulator-neutral fashion, Jane provides robust and extensible mechanisms for users to incorporate their own model-specific views to override or supplement the default views.   Jane is a JAVA-based client-server system that controls federates through the Session Manager, in much the same as the spawner, above.  For further information on Jane, refer to  REF _Ref378022677 \n \h [11] or the FDK home page.Running Federates ManuallyIn order to run a federation manually, one must set the environment so that RTI initialization can happen correctly.  On every machine where a federate will run, the user must set an environment variable name NODEINFO.  This variable informs the RTI of the number and names of each of the participants in the federation.  Another variable, SESSIONNAME, is used by each federate to determine the port on with RTI initialization will occur.  During startup, the first federate (LP0) will write the port number to a file that is named according to the value of SESSIONNAME.  In the case where the machines share a common file system, the remaining federates will read the file and begin the communicating with LP0.  However, if there is no shared file system, the user must intervene and replicate the file and contents remotely.  This method has been used to create executions outside a cluster environment, but will be replaced by a more robust initialization process in a future release.The Current State of the DRTIThe DRTI is uses the 1.3r6 I/F Spec.  Federates have been interoperably tested with the DMSO RTI and DRTI to ensure correctness.  Tested federates include HelloWorld, the Testfederate, and HLA ModSAF.  Each executes reliably with the DRTI, however, no performance comparisons have been done.   Coverage of the APIThe DRTI covers the majority of the C++ API, and this is increasing all the time.  An overview of the coverage is given in  REF _Ref378017728 \h Table 2.  Several functional groups of services have not yet been integrated, including methods for ownership transfer, federation create/destroy, synchronization points and save/restore.   No part of the Management Object Model has been implemented.  Of course, implementation priorities are driven by our current research projects.  Integration of DDM functions, as reported on in  REF _Ref378025473 \n \h [7], are currently being integrated.PerformanceSince the FDK is designed for simulation research, the developers have always been focused on performance.  Through numerous changes and the addition of several features, (including a rewrite of the entire DRTI,) the RTI-Kit performance has not been seriously degraded from the original results published in  REF _Ref378023247 \n \h [10],  REF _Ref378023274 \n \h [9] and  REF _Ref378023284 \n \h [12].   REF _Ref378017051 \h Figure 4 shows the current performance of the DRTI in terms of Time Advance Grants per second, for various processor configurations.  The test was conducted with zero lookahead and equal time advances for each federate.  Table  SEQ Table \* ARABIC 2 - DRTI I/F Spec CoverageAvailabilityDistributionFigure  SEQ Figure \* ARABIC 4 - DRTI PerformanceThe FDK is freely available by request to  HYPERLINK "mailto:fdk@cc.gatech.edu" fdk@cc.gatech.edu.  All source code is, of course, provided.  There are certain export restrictions, which are not usually a problem and only apply to a few countries.  As with most software, there are the usual liability clauses.  As the FDK is intended to be used to support research, you are welcome to change whatever you want, and use it for whatever you want.  However, redistribution of the FDK is not allowed, and including the FDK in a commercial product or reselling it would require a licensing agreement with Georgia Tech Research Corporation. Additions or collaboration on enhancements are very welcome.Projects that use it nowThere are several projects at Georgia Tech that currently use the FDK.  These include network and telecommunication simulation projects, and aviation related projects.  Recently work began on the simulation of mixed signal integrated circuits for Yamacraw,  a program funded by the state of Georgia.  The FDK is also a primary instructional tool for classes in parallel and distributed simulation in the College of Computing.Beyond Georgia Tech, the FDK has been used in several projects relating to RTIs, including the development of  RTIs for cluster computing environments and  hierarchical federations (Defence Evaluation Research Agency, UK), development of RTIs that work over ATM networks (Univ. of Singapore), and  research into data distribution management (Univ. North Texas).  Recently the FDK was used to explore ways in which an RTI could use active network technology.  The results of that research are being presented in (TASC PAPER)The FDK has also been used apart from RTI research, where RTI performance is critical.  The FDK has been used for air traffic control simulations (MITRE), and recently in an SBIR evaluating novel time management techniques.  The package has been downloaded by a number of other users.More information on FDK distribution is available at  HYPERLINK "http://www.cc.gatech.edu/computing/pads/fdk.html" http://www.cc.gatech.edu/computing/pads/fdk.html or you can mail your questions to  HYPERLINK "mailto:fdk@cc.gatech.edu" fdk@cc.gatech.edu.ConclusionRTI-Kit provides a software base for research and development of distributed simulation systems.  Although it was designed with the High Level Architecture in mind, the software is applicable to many other classes of parallel and/or distributed simulation systems.  The modular design approach makes RTI-Kit will suited for experimental research in federated simulation systems.  RTI-Kit is currently distributed as part of the Federated Distributed Simulation Tool Kit (FDK) package.  It is being used in a variety of educational and research projects such as research in DDM, use of high bandwidth and active networks for distributed simulations, and federated simulations for modeling telecommunication networks.  The DRTI is a source available RTI which can be used to study the effective implementation of HLA services, or which can be used as a basis for development of a complete RTI implementation.  ReferencesPakin, S., et al., Fast Message (FM) 2.0 Users Documentation, . 1997, Department of Computer Science, University of Illinois: Urbana, ILKuhl, F., R. Weatherly, and J. Dahmann, Creating Computer Simulation Systems: An Introduction to the High Level Architecture for Simulation. 1999: Prentice Hall.Defense Modeling and Simulation Office, High Level Architecture Interface Specification, Version 1.3, . 1998: Washington D.C.Ferenci, S.L., K.S. Perumalla, and R.M. Fujimoto, An Approach for Federating Parallel Simulators, in Proceedings of the 14th Workshop on Parallel and Distributed Simulation. 2000, IEEE Computer Society. p. 63-70.Fujimoto, R.M., Time Management in the High Level Architecture. Simulation, 1998. 71(6): p. 388-400.Fujimoto, R.M., Parallel and Distributed Simulation Systems. 2000: Wiley Interscience.Tacic, I. and R.M. Fujimoto, Synchronized Data Distribution Management in Distributed Simulations, in Proceedings of the Workshop on Parallel and Distributed Simulation. 1998.R. M. Fujimoto, T. McLean, K. Perumalla, I. Tacic, "Design of High Performance RTI Software," Workshop on Distributed Interactive Simulations and Real-Time Applications, August 2000.S. Ferenci and R. Fujimoto, “RTI Performance on Shared Memory and Message Passing Architectures,” 1999 Spring Simulation Interoperability Workshop, March 1999.R. Fujimoto and P. Hoare, “HLA RTI Performance in High Speed LAN Environments,” 1998 Fall Simulation Interoperability Workshop, September 1998. K. Perumalla and R. Fujimoto, “Jane: An Architecture for Interactive Parallel Simulation,” WEBSIM '99, January 1999.R. Fujimoto, et al, “Design of High Performance RTI Software,” Fourth IEEE International Workshop on Distributed Simulation and Real Time Applications (DIS-RT 2000), August 24-26, 2000, San Fransisco, CA.M. Dorsch, and V. Skowronski, “Modifying the RTI for Active Networks,” in Proceedings of the Spring Simulation Interoperability Workshop. 2001: Orlando, FL. p. Paper 01S-SIW-007.Author BiographiesTHOM McLEAN is a PhD candidate in the College of Computing and a research scientist at the Georgia Tech Research Institute.  His research interests include distributed simulation and real-time systems.RICHARD FUJIMOTO is a Professor in the College of Computing at the Georgia Institute of Technology. His research interests include computer architecture, parallel processing and parallel and distributed simulation.  He is the author of Parallel and Distributed Simulation Systems, a textbook published by Wiley Interscience.