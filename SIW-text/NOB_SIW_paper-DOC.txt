Network Object Builder (NOB) Interface LibrarySean M. ReillyNaval Undersea Warfare Center1176 Howell StreetNewport, RI 02841-1708401-832-8724 HYPERLINK mailto:reillysm@npt.nuwc.navy.mil reillysm@npt.nuwc.navy.milKeywords:RTI, interface library, object oriented programmingABSTRACT: The Network Object Builder (NOB) is an interface library that automates common RTI functions by adding an object oriented C++ layer to the API structure.  Instead of being designed to isolate the user from the native RTI layer, the NOB library enhances the RTI by standardizing common tasks. In this fashion, the NOB library attempts to minimize the amount of standard code that must be repeated between projects, decrease the cost of migrating to the HLA, and improve the reliability of HLA implementations. This paper will outline the core features of the NOB implementation and provide examples that illustrate its utility as a programming tool. Its intended audience is C++ programmers who are interested in using NOB in their applications.IntroductionThe High Level Architecture (HLA), originally outlined in the DoD Modeling and Simulation Master Plan (MSMP)1, is a standard mechanism for sharing simulation data across wide area networks.  It is currently mandated for all DoD simulation systems as a common technical framework to facilitate interoperability and reuse2.  The Run Time Infrastructure (RTI), distributed through the Defense Modeling and Simulation Office (DMSO), provides users with a common Application Programmer’s Interface (API) to the HLA3.  The RTI is designed to provide a generic and non-language specific interface between the application and the distributed simulation network.Many of the RTI tasks performed by the application are often common across applications:Initialization of the RTI and joining the federation,Maintaining lists of the currently active objects,Searching for objects or attributes by ID number, andTranslating attributes and parameters between the application and the RTI.The Network Object Builder (NOB) library automates these functions by adding an object oriented, C++ layer to the API structure.  Instead of being designed to isolate the user from the native RTI layer, the NOB library merely augments the RTI by standardizing common tasks.  By analogy, NOB attempts to abstract the RTI’s functionality using the same paradigm by which Motif and OpenLook enhance the underlying X-Windows API.This paper provides a technical description of the Network Object Builder (NOB) interface. In addition to a working knowledge of C++, this paper assumes that the reader is familiar with the High Level Architecture (HLA) for Modeling and Simulation and with the programming details of the Run Time Infrastructure (RTI)4.Design GoalsThe utility of any model derives from the linkage between its interface and the underlying implementation.  The HLA API, because of its requirements for cross language support, requires application developers to manually transfer data between the local address space and the RTI.  This mechanism creates a loose interface/implementation linkage and adds a variety of data management tasks to the application development process.  The NOB library automates data management by deriving all network aware objects, interactions, attributes, and parameters from a set of self-maintaining base classes. A standard subclass of the RTI’s FederateAmbassador class was also created to manage these network aware objects/interactions and create robust default behaviors for RTI callback events.  The goals for this design are:Network attributes and parameters should be addressable by the application in a manner similar to that used for ordinary variables.Network attributes and parameters should be bundled with all of the flags needed to manage their RTI communications.Platform specific data marshalling for endian order and other format translations should be transparent to the developer.Class inheritance of new network objects or interactions should automatically incorporate all network attributes and parameters of the parent class.The actual transfer of attribute or parameter data between the object/interaction and the RTI should be transparent to the developer.Core ClassesThe core functionality of the NOB interface library is managed by four (4) classes: NetAttribute, NetObject, NetInteraction, and NetObjectManager.   REF _Ref422903354 \h Figure 3.1 illustrates the relationship between these classes.   EMBED Word.Picture.8  Figure  STYLEREF 1 \s 3. SEQ Figure \* ARABIC \s 1 1   Core ClassesNetAttribute provides a base class for self-managing attributes and parameters. This class is used to represent both local and remote attributes.  NetAttribute variables are added to NetObject and NetInteraction objects as C++ variables with special constructors. Application developers specify the attributes by name in their own code and these names are resolved into RTI handles within the constructor.  Single bit control flags are used to maintain publish/subscribe, transfer/accept, local/remote, and other attribute state information.  Access and assignment for the variable’s internal value are funneled through the operator() function which automatically tracks the value’s update state and the latest update time (useful for dead reckoning).  Each NetAttribute includes a overloaded version of the update() and reflect() functions which are used by the parent NetObject to automatically translate data between the RTI and the internal address space.To support byte-endian marshalling, each data type must support a version of the net2host() and host2net() functions.  Standard versions of these functions are supported for each basic RTI type (such as RTI::ULong).  Complex types derive their own versions of these functions based on the marshalling routines of their constituent data members.NetObject provides a C++ base class for network-aware objects and interactions.   The primary function of this class is to route individual attribute updates between their local NetAttribute representation and the name/value pair lists used by the RTI.  The NetObject reflect() function parses incoming AttributeHandleValuePairSets, maps the attribute handles to local memory pointers, and updates the variables with new values.  Local NetAttribute memory pointers are stored in an ANSI C++ “map” container to provide quick lookup capability.  For outgoing values, the NetObject update() function loops through local attributes, builds, and transmits an RTI name/value pair list from those values which have changed since the last update cycle.NetInteraction is a specialization of NetObject which acts as a base class for network-aware interactions.  Interactions differ from objects in that they represent discreet simulation events instead of long-term state maintaining values.  By inheriting from NetObject, the NetInteraction class shares all of the data translation features of NetAttribute values.  The NOB library includes a mechanism to automatically forward incoming interactions to local recipient objects.  This routing comes in two variants that allow distribution based either on object class or RTI object ID.  This treatment allows interaction event models to be implemented as member functions of the recipient objects themselves. Unfortunately, no such automated NOB linkage between object member functions and interactions exists for outgoing interactions.The NetObjectManager class ties the NOB object model’s functionality together into a coherent whole.  It is a subclass of the standard FederateAmbassador which defines default behaviors for all of the RTI callback functions including reflectAttributeValues() and receiveInteraction().  Like NetObject, the NetObjectManager has the capability to automatically route incoming information to local object and interaction instances using an ANSI C++ “map” container.  It includes its own version of the timeAdvanceRequest() function that not only advances the RTI time, but also broadcasts pending update information for all local objects. The NetObjectManager class also simplifies many other common operations for the RTI.  Since each class derived from NetObject tracks its own internal state, the NetObjectManager is able accomplish subscription using only an example of the desired object or interaction.  Update state changes and attribute transfers are also handled automatically by the NetObjectManager.NetObjectManager can not provide all of the RTI callbacks with truly meaningful implementations.  Abbreviated functions include save/restore, object discovery, update retraction, and DDM threshold changes.  It is assumed that application developers will sub-class their own NetObjectManager to provide these functions. Even in cases where NetObjectManager does not provide its own functionality, a polite refusal is always supplied as a default behavior.  For example, NOB responds to initiateFederateSave()with federateSaveNotAchieved().  Generally, the discoverObject() function is the only case for which application developers are required to supply their own implementation for a minimally functional RTI simulation.Support ClassesThe Network Object Builder (NOB) library also comes with a set of support classes that simplify the task of defining NOB compliant classes.  The NetAttribute Template<> template class translates C++ classes into network aware attributes.  Another version of this template, called NetArray<>, used the ANSI C++ “vector” container to translate C++ classes into network aware arrays.  As shown in  REF _Ref422974841 \h Table 41, standard attribute and array type definitions are provided for each atomic C++ data type.  These templates also provide the application developer with a mechanism for defining their own complex data types. Enumerations are handled by the NetEnum<> and NetEnumArray<> templates.  Enumerations require special templates because the system must track not only the C++ enum for each value, but also an underlying data type for network interaction.  For example, 8, 16, or even 32 bits are commonly used to represent an enumeration with 100 values.  These templates tie the values and the storage class together.Table  STYLEREF 1 \s 4 SEQ Table \* ARABIC \s 1 1   NOB Standard TypesC++ TypeBitsGeneric AliasNetAttribute NetArray unsigned short16RTI:: UShortNetUShortNetUShortArrayshort16RTI:: ShortNetShortNetShort Arrayunsigned long32RTI:: ULongNetULongNetULongArraylong32RTI:: LongNetLongNetLong Arraydouble64RTI:: DoubleNetDoubleNetDoubleArrayfloat32RTI:: FloatNetFloatNetFloat Arraybool32RTI:: BooleanNetBooleanNetBooleanArrayunsigned char8UByteNetUByteNetUByte Arraychar8ByteNetByteNetByte Arraystringanyn/aNetStringn/aNOBgen: Automated Code GenerationAlthough the core functions of the Network Object Builder center on its utility as a coding library, it also comes with NOBgen, a utility to generate NOB compatible C++ source code from HLA Object Model Template (OMT) data interchange files.  NOBgen creates a series of source code files that represent the shell of a C++ implementation that mirrors the layout of the specified OMT.All enumerated types are output to a single file called “enumeration.h”.  This file creates four types of objects for each enumeration:a C++ definition of the enumeration,an alias for the storage type of the enumeration value for use in complex data types,a NetEnum version of the enumeration, anda NetEnumArray version of the enumeration.All complex data types are output to a single file called “complextypes.h”.  This file includes four types of definitions for each complex data type:a C++ definition of the data structure,host2net() and net2host() functions which convert each sub-field,a NetAttributeTemplate version of the complex data type, anda NetArray version of the complex data type.In addition to setting up all of the standard NOB characteristics for each complex type, NOBgen goes a step further to create assignment and access routines for each individual attribute.  These assignment and access routines use the name of the attribute as their function name.  If any attributes in a structure are changed using these functions, the entire structure will be transmitted to the RTI on the next update cycle.Each object and interaction class is written out to a pair of files: one for the header (*.h), and one for the body (*.cpp).  The name of the files, and the C++ classes is the same as the name of the object class in the HLA data interchange file. Attribute control flags are automatically defined based on the settings in the OMT file.In addition class to definition operations, the automated code generator creates a fully functional distribution routing function for each interaction based on its OMT “receiving object” list. The NOBgen program also incorporates a blank implementation of an event handler to each object class cross-referenced to this interaction.ConclusionsGiven this suite of HLA tools, application developers can focus their efforts on model implementation and ignore many of the common RTI management tasks.  The minimum development required to create a new HLA application is reduced to the following steps:Using NOBgen, create a series of NOB class file shells that mirror the organization of your Object Model Template.Modify the class shells to create implementations for these objects. Use the operator() function to manipulate attributes in the local address space.  Use native RTI calls to access HLA functionality not provided by NOB.Sub-class a version of the NetworkObjectManager to meet your simulation’s needs.  Use the NOB class files defined in the previous steps to define the subscription and object discovery functions.Create a main simulation loop which calls NetworkObjectManager::timeAdvanceRequest() each time it wishes to exchange data with the RTI.By automating many RTI functions, the NOB library attempts to minimize the amount of standard code that must be repeated between projects.  This type of approach decreases the cost of migrating to the HLA and improves the reliability of HLA implementations.The object libraries for NOB are freely available to U. S. DoD activities from the Naval Undersea Warfare Center. The current release of NOB is a beta-test version which supports RTI 1.0.3 on Windows™ based platforms.  Future releases will be ported to other platforms and operating systems. Other arrangements including distribution to commercial activities and source code availability can be arranged on a case-by-case basis.References 	“Department of Defense Modeling and Simulation (M&S) Master Plan,” DoD 5000.59-P, Under Secretary of Defense for Acquisition and Technology, October 1995.2 	Under Secretary of Defense for Acquisition and Technology Policy Letter on DoD High Level Architecture (HLA) for Simulations, September 1996.3 	“High Level Architecture Interface Specification, Version 1.2,” Department of Defense, 13 August 1997.4 	“High Level Architecture Run-Time Infrastructure Programmer’s Guide, Version 1.0 Release 3,” Department of Defense, 14 November 1997.Author BiographySean Reilly is employed by the Surface Ship Directorate, Modeling and Simulation Branch (Code 3111) at the Naval Undersea Warfare Center Division Newport (NUWCDIVNPT), Newport, RI.  He holds a B. S. and M. S. in Physics from the University of Connecticut.  Mr. Reilly is currently NUWCDIVNPT’s Chief Engineer for the AN/SQQ-89(V)-T() On Board Trainer and editor of the Guidance Documentation for the Real-time Platform-level Reference Federation Object Model (RPR-FOM).