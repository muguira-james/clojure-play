A Non-Intrusive HLA Distributed Data LoggerDarren R. WetzelKevin JohnsonMaK Technologies, Inc.185 Alewife Brook ParkwayCambridge, MA 02138617-876-8085wetzel@mak.com, kevinj@mak.com Keywords:HLA, Distributed Data LoggerABSTRACT:A data logger usually logs a superset of the simulation exercise data set.  So by using a data logger we increase the consumption of network bandwidth, since the data logger is requesting data that otherwise would not be transmitted by the simulators.  In a distributed simulation environment using WAN connections, a single process data logger can adversely affect simulation performance by consuming precious WAN bandwidth with this additional data.  A Distributed Data Logger consisting of multiple Data Logger Agent processes can collect simulation exercise data local to the simulators.  Correctly configured, a Distributed Data Logger can collect all exercise data without adding any additional traffic to WAN connections.  Using a Distributed Data Logger should not mean that users must rebuild their simulators.  By creating a logger data harvesting library that fits between the simulator and the RTI, users can configure and use the Distributed Data Logger without changing their applications. MaK Technologies, under a STRICOM funded SBIR, is developing a non-intrusive Distributed Data Logger that eliminates data logger provoked WAN traffic and can be used for any HLA simulation application without requiring any changes to the application.1. IntroductionIn any scientific environment, a good measurement or analysis tool does not perturb the environment it’s measuring.  When logging a distributed simulation exercise, the same holds true: a data logger should not alter the exercise environment or change the exercise it’s logging.  Traditionally, a data logger is a single process that collects all exercise data from all simulators.  In a high bandwidth LAN environment, this can be a reasonable solution.  As players in a simulation exercise are spread over wider areas using lower bandwidth connections, the single data logger solution begins to perturb the environment it’s recording.  Since a data logger should collect a superset of exercise information, exercise data unwanted by other simulators can be pulled across the network by the lone data logger.  As the data logger increases data flow over these low bandwidth connections, exercise data needed by other simulators can be delayed, negatively impacting the accuracy of the simulation.The solution to this problem is a Distributed Data Logger.   A Distributed Data Logger is a data logger consisting of multiple, distributed processes (Data Logger Agents) spread over the network to harvest exercise data from multiple points.  Correctly placed and configured, these Data Logger Agents can collect local simulation data over high bandwidth connections and avoid pulling data from remote simulators across the slower connections.MaK Technologies is developing a Distributed Data Logger under a STRICOM funded SBIR.   The following paper will cover the architecture of this Distributed Data Logger (DDL) and how a user can employ it to record a distributed simulation exercise. 2.  Current Data Logger ProblemIn an HLA simulation environment, current single-process data loggers can cause performance problems when recording widely distributed simulation exercises.  The bandwidth savings HLA Declaration Management (DM) may yield are lost when a data logger begins recording an exercise.  HLA DM uses a publication/subscription mechanism to determine what exercise data must be sent and what data is unnecessary.   To generate a complete archive of an exercise, a data logger must subscribe to all available simulation data.  By subscribing to the data, the data logger forces the simulators to put all of their data out onto the network.  This can result in a significant increase in bandwidth consumption.This may not be an issue in a high bandwidth LAN environment.  Bandwidth may be readily available for this additional traffic and the exercise proceeds without any negative affects. When a simulation exercise incorporates lower bandwidth WAN connections, the additional traffic the data logger provokes may consume bandwidth needed by the simulation.  At this point packets the simulators need from each other may be delayed, resulting in inaccuracies in the exercise.To illustrate the problem, consider a simulation involving an A10 aircraft attacking a T72 tank.  For this example only a simple data set, or HLA Federation Object Model (FOM), will be used.  The FOM is as follows:Object Class Vehicle	Attributes: Position		    Orientation                                 Throttle-setting   So, for this example, there is one object class, “Vehicle”, and that class has three attributes.  During the course of the example exercise, the T72 and the A10 need position and orientation information from each other. They, however, do not have access to each other’s throttle-setting.  Using HLA DM, the T72 simulator would publish its position, orientation, and throttle setting.  The T72 only subscribes to position and orientation data since it either doesn’t care about the throttle-setting of other vehicles, or, in this case, it can’t know the throttle setting of others.  The A10 simulator publishes position, orientation, and throttle-setting, and also subscribes to only Vehicle position and orientation attributes.   In an exercise involving just these two simulators, the traffic on the network will consist of updates of position and orientation sent by the two simulator federates.  Throttle-setting updates are not sent onto the network, since no federate has subscribed to the throttle-setting attribute.  Figure 1 shows our example simulation exercise in a LAN environment.  The simulators send position and orientation updates.  Throttle-setting updates never make it to the network. 2.1 Exercise CriteriaTo comprehensively log this exercise, a data logger must collect position, orientation, and throttle-setting updates.  Even though the T72 doesn’t receive throttle information from the A10, and vice-versa, it may be quite important to an after-action reviewer to know the throttle-settings of the vehicles involved.  Throttle data may be used to analyze a driver/pilot’s control actions or to chart fuel consumption during the exercise.  A traditional data logger joining this HLA federation would subscribe to all Vehicle attributes, resulting in the A10 and T72 simulators outputting throttle-setting updates onto the network. With the T72 moving evasively, and the A10 maneuvering to line up the attack, throttle settings may be changed quite often.  The presence of the data logger in the federation could then result in a significant increase in the amount of network traffic. Figure 2 shows the increase in traffic the data logger provokes.  In a real simulation exercise with a mature FOM (perhaps hundreds of attributes), the percentage of network traffic directly attributable to the presence of a data logger can be sizable.A LAN may have plenty of bandwidth to transmit the additional data without any delay.  A widely distributed exercise, perhaps using modem lines, may not have the bandwidth to handle an increase in traffic.  The increased load can result in dropped packets or packets arriving too late to be useful.  In this case, the addition of a data logger has changed the simulation execution. A successful solution to this problem would allow the data logger user to collect all data from a simulation exercise without increasing the consumption of bandwidth on low bandwidth connections.  Distributed Data Logger ApproachesThe problem detailed in the previous section has an obvious solution.  Clearly by putting data logger processes on both sides of the WAN, data can be collected without forcing any additional packets across the WAN.  The two Data Logger processes can be time-synchronized using a Network Time Protocol (NTP) product.  They can then be started in unison, each collecting part of the simulation data, and later merge their archives together into one log.As shown in Figure 3, Data Logger Agent 1 collects data from the T72 tank simulator, and Data Logger Agent 2 logs data from the A10 simulator.  Since the two Logger Agents are time synchronized, the two archives can be merged into one archive containing all of the exercise data.  This is the ideal solution to the problem.Unfortunately, implementing this plan is not trivial.   Partitioning the simulation data between multiple logger agents while ensuring that the data is not also forwarded across WAN connections proves to be a problem.  Two methods were investigated to solve this problem; HLA Data Distribution Management service[1] and wrapping the RTI layer.3.1.  Partitioning data using HLA Data Distribution Management (DDM)Initially, it was felt that the HLA DDM service would be the key to the solution.  DDM is intended to regulate the delivery of simulation data using routing spaces and regions within those spaces.  A routing space based on network topology could be created and include a region within the network topology space for each LAN.  When a Data Logger Agent started, it could subscribe to all simulation data for its local LAN routing space region.  During the exercise, the Agent would only receive the exercise data sent by simulators on its LAN.This appeared to be the optimal solution.  It would leverage existing code to tackle the difficult task in the implementation.Unfortunately, after closer inspection, this solution started to show limitations.  The first concern was the implementation of the DDM service in the RTI.  The design was based on the premise that DDM was a filter at the source end.  In other words, the federate sending updates into a routing space region would ensure that the data was only transmitted to federates subscribed to data for that space and region. Another possible DDM implementation would be to filter out data at the receiving federate.  In this implementation, every federate's RTI would receive every update, then the RTI would only pass updates for the correct space and region up to the simulator or application.  If DDM is a receive-end filter, the design will do little to minimize the consumption of WAN bandwidth.  All updates would be transmitted to all federate RTIs, which would then decide which updates to pass on to the application.  The HLA interface specification does not dictate how DDM is implemented, so using DDM can not guarantee the bandwidth savings we’re looking for.Additionally, using DDM would require users to modify their FED files and their applications.  Our network topology routing space would need to be defined in the FED file.  The simulator would then need to publish its data into a region in that space based on its location in the network.  Since many users may not have access to their simulator’s source code, the tools to perform the change, or the inclination to rebuild their simulator, using DDM no longer appeared to be the correct choice.Wrapping the RTIAs it became clear that RTI services would not provide a guaranteed solution, the investigation turned to the possibility of using an RTI wrapper.  An RTI wrapper intercepts the data updates before they reach the RTI.   This wrapper could then be certain to control the usage of WAN bandwidth.The use of an RTI wrapper is not a new idea.  At the Spring 1999 SIW, there were at least two papers [2][3] that discussed the use of an RTI wrapper to collect simulation data before it reached the RTI.  The wrapper is a layer of software covering the RTIAmbassador and FederateAmbassador RTI objects.  The wrapper records the subscription information the RTI passes to it, then indicates to the application that every attribute has been subscribed to.  Since the application was told to send updates of all attributes, whenever any attribute changes, the application sends an update message.  The wrapper logs all of these updates to an archive.  It also checks it’s list of external subscriptions, and if the attribute was subscribed to by another federate, the wrapper passes the update on to the RTI for distribution over the network.The RTI wrapper strategy effectively limits bandwidth consumption.  Only data required by other federates ever reaches the network, while the wrapper creates a complete archive of all attribute updates.The downside of using the RTI wrapper is the requirement that the application be rebuilt.  The wrapper classes need to be constructed in the application instead of the RTIAmbassador and the FederateAmbassador.  So to use the wrapper, the user must change several lines of simulator code, then recompile and re-link their application.  As with the DDM solution, this is not always an option.  Users may never get a simulator’s source code, nor would they want to change the source and rebuild it even if they did.  This prevents the RTI wrapper logger from ever being a “shrink-wrapped” solution.MaK’s SolutionMaK’s Distributed Data Logger  (DDL) solution consists of three components: the Data Logger Master, Data Logger Agents, and the Data Logger Interface Layer.  Using these three components, the DDL will efficiently log widely distributed exercises without adding to WAN traffic.  Additionally the solution solves the RTI wrapper code modification issue.  A user will be able to load the DDL onto their system, configure it to optimally log their exercise, taking into account network topology and bandwidth constraints, and hit the “record” button.Data Logger Interface Layer (DLIL)The first component of this solution is the Data Logger Interface Layer (DLIL).  The RTI wrapper solution discussed in Section 3.2 solves the bandwidth consumption problem covered in Section 2, so this was the starting point.  If a wrapper or software layer could be inserted between the simulator and the RTI without rebuilding the simulator application, this would solve all of the issues.Instead of modifying the application the investigation turned to how a program loader loads the RTI at runtime.  Wintel platforms differ from Unix, but each OS provided opportunities to change how the RTI was loaded.WindowsNT/95 Data Logger Interface LayerThe solution for Wintel OS’s proved to be simpler than for Unix.  It was discovered that a library could be created with the same symbol names found in the RTI and have the application load it also. This solution works because of how Windows handles shared-library namespaces.  Once the DLIL library was loaded, it would dynamically load the real RTI.  With the load complete, the DLIL acts in a go-between role between the simulator and the RTI.  The layer behaves similarly to the RTI wrapper discussed in Section 3.2, collecting outgoing data and archiving the data to a file or sending it point-to-point to a LAN-local logging agent.This solution solves the WAN bandwidth consumption problem by intercepting the data before the RTI can send it across the WAN.  Since the program loader has been tricked into loading the DLIL layer instead of the RTI, the simulation application is not modified.  The only change the user must make is placing our DLIL library into the RTI directory so it gets loaded first.Unix Data Logger Interface LayerThe Unix solution was slightly more difficult.  The program loader on the Unix platforms looked at (IRIX and Linux) uses only one namespace.  To permit the DLIL layer to co-exist with the RTI, the RTI symbol names needed to change to avoid name collisions.  A utility program was developed that will accept any Unix RTI and mangle its symbol names.  With this slightly altered RTI, the program loading sequence occurs as it does on the Windows platforms.  The program loader loads the DLIL library instead of the RTI.  The layer then pulls in the real name-mangled RTI.  This solution requires slightly more setup effort from the user.  The name-mangling utility will be provided with the Distributed Data Logger.  But the key point stressed in the previous section is the same: the user will not modify source code or rebuild the simulation application.Data Logger Interface Layer OperationThe DLIL provides a great deal of flexibility to the rest of the implementation.  The layer may save the simulation data directly to disk, or it may pass it on to another process for archiving.  If a separate logger process is chosen, the layer can use shared memory or a communications protocol to pass the data from the logging layer to the logger process.Knowing that the logging layer can be modified down-the-road to provide more options and flexibility, the first implementation will use TCP/IP to pass logged simulator data from the DLIL logging layer to separate Data Logger Agent processes.  Data Logger Agent (DLA)In this solution, the Data Logger Agent (DLA) is responsible for initiating contact to the Data Logger Interface Layers (DLIL) running on its LAN and for storing simulation data to an archive.  Through the Data Logger Master, the user may configure the DLA to log data from a single DLIL or from all DLILs active on its LAN.When a DLA starts up, it can use the HLA MOM to determine what federates are active.  Since the MOM data includes a federate’s hostname, the DLA can determine where a federate resides in the network topology, and can contact it through a known port number. DLAs will be configurable to log federates based on IP addresses or any of a number of other criteria.  If a DLA determines it should be logging data for a particular federate, the DLA contacts that federates DLIL.   A TCP connection is created by the DLA to the DLIL.  Once the DLA-to-DLIL connection is made, the DLIL will start sending simulation data to the DLA.  Figure 4 illustrates operation after the connection has been made.  The HLA MOM data can also be used to find late joiners to the exercise.  This will ensure that no data is missed from the log. A Data Logger Master process will coordinate the activities of the Data Logger Agents.  Figure 4 shows the Data Logger Master process and its agents. Data Logger Master (DLM)The Data Logger Master (DLM) process will be the control point for the Distributed Data Logger.  The user will sit at the DLM user interface and control the spawning and configuration of the remote agents.  Once the Data Logger Agents have been spawned and the DLM has given them their assignments, the DLM will send commands to the agents  (play, record, rewind, etc.) and the multiple processes will work in unison.  The DLM will also be responsible for collecting the agents’ archives and combining them into one archive.  Figure 5 shows the network topology of the Distributed Data Logger with one DLM coordinating the activities of multiple DLAs.5. ConclusionUsing a single process data logger in a widely distributed HLA exercise will result in network delays negatively impacting the accuracy of the simulation.  By distributing Data Logger Agent processes through the simulation exercise network, and trapping data before it reaches the RTI, we can eliminate this additional WAN loading.  And by substituting our Data Logger Interface Layer shared library for the RTI shared library during program loading, we can insert a logging layer between the simulator and the RTI without requiring simulator code modifications.5. References[1] IEEE P1526.1, M&S HLA – Federate I/F Spec, Draft, July 1998.[2] SISO 99S-SIW-022, Data Collection in an HLA Federation, Jerry W Black, March 1999.[3] SISO 99S-SIW-084, Lessons Learned from an Implementation of a Fully Distributed Data Collection Tool, Gerry Magee, July 1998.Author BiographiesDARREN WETZEL is a senior engineer at MäK Technologies.  He is the principle investigator for the RAM Tools SBIR.  He has a B.S. in Electrical Engineering from Cornell University.KEVIN JOHNSON is a senior engineer at MäK Technologies and is currently working on the RAM Tools SBIR.  He has a BS in Electrical Engineering from Ohio University and an MS in Computer Engineering from Rochester Institute of Technology.  Position LANThrottle A10 Plane SimulatorOrientation LANData Logger     AgentData Logger     AgentData Logger     AgentData Logger     MasterWANPosition LANA10 Plane SimulatorHLA RTIT72 Tank SimulatorHLA RTIOrientation Position Figure 1. LAN simulation environmentWANData  Logger     Agent 1  HLA RTIThrottle Throttle Orientation Orientation Position Orientation Position Orientation Position TCP/IPOrientation Position Throttle Orientation Position             Data Logger Interface Layer       (DLIL)          WANData  Logger Agent (DLA)LANA10 Plane Simulator               HLA RTIFigure 4. DLIL and Data Logger AgentWANData  Logger  HLA RTIThrottle Throttle Orientation Position Orientation Position LANA10 Plane SimulatorHLA RTIT72 Tank SimulatorHLA RTIFigure 2. WAN environment with a Data LoggerHLA RTIT72 Tank SimulatorHLA RTIFigure 3. WAN environment with Data Logger AgemtsData  Logger      Agent 2  HLA RTIFigure 5. Data Logger Master and Agents