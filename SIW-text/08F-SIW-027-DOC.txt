A Software Architecture for Measuring User Performance in Simulation-based TrainingBo Sun, Don Kemper, Larry Davis, and Cali FidopiastisInstitute for Simulation and TrainingUniversity of Central Florida3100 Technology ParkwayOrlando, FL 32826 USA(407) 882-1300bsun, dkemper, ldavis, and cfidopia “at” ist.ucf.eduKeywordsPerformance Measurement, Software Architecture, Personal Area Logger, Service-Oriented ArchitectureABSTRACT: A goal of simulation-based training systems is the capability to measure user performance within the context of the training given.  A system or application that is capable of recording individual data from multiple sources within a simulation must meet several requirements, such as real-time data availability, synchronization of multiple sources, network connectivity, and playback capability.  This paper presents the Personal Area Logger (PAL), a service-oriented performance measurement architecture that is modular and flexible and meets the previously described requirements for performance measurement and data recording.  The intended audience for this article is software developers to understand the PAL organization for implementation.1. IntroductionSimulation-based training systems are developed and used everyday, ranging from single-user training environments to distributed simulation worlds with multiple networked users.  Live, virtual, and/or constructive embodiments serve as metaphors to reality whose goal is facilitating learning while minimizing consequences and costs.  Simulation-based training is particularly useful in military training contexts, where reproducing training scenarios in the real world may be too dangerous or costly.   An objective of simulation-based training systems is the capability to measure user performance within the context of the training given.  Performance may be evaluated either during the training session or at the conclusion of the training session by using an after action review (AAR) system.  The performance metrics may be manually computed by the trainer or automatically computed by the training system.Regardless of how the performance of the user is computed, data must first be made available.  The data may include user interactions within the simulation, human-computer interface devices, and/or neurophysiological monitoring devices physically connected to the user.  Along with this array of data inputs, the issue is further complicated if there is a requirement to compute performance measures in real-time, or to use the performance data to enable training mitigations. A system or application that is capable of recording data from multiple sources within a simulation must meet several requirements.  First, the system must provide a standard, reusable interface for acquiring data. Next, the data collected must be available for use in real-time immediately upon collection.  Otherwise, the system must be able to log the data in the appropriate format for future use.  Also, the system should have the capability to synchronize and incorporate data from devices and simulations.  Furthermore, the system must provide an interface for data visualization.  Finally, the data recording capability must be usable in a networked environment and be compatible with simulation standards such as High Level Architecture (HLA).To address these requirements, an approach inspired by personal area networks was embodied.  The concept of a personal area network was introduced by Zimmerman and relates to the fact that at any given time, a person will have multiple devices that duplicate resources (e.g. a cell phone and a laptop both have screens) [1].  With proper networking, data can be shared between the devices, increasing the usefulness of each device and allowing for a greater functionality as a synergistic whole.Aggregate data from the simulation and neurophysiological devices attached to a user can provide snapshots of performance while training occurs. Thus, such history of this aggregate data is, in fact, the performance history of the user as measured in the personal area network. In the context of simulation-based training, the personal area network is a combination of the simulation and the devices attached to the user.In this capacity, we introduce the Personal Area Logger (PAL).  The PAL is a service-oriented architecture (SOA) that is modular and flexible.  The architecture uses XML for (re)configuration and is open source, government-owned software.  Multiple clients and servers may exist on the same network, which provide communication between data sources.  These traits enable the PAL software architecture to meet the previously described requirements for performance measurement and data recording.  The intended audience for this work is software developers that wish to understand the structure of the PAL architecture for purposes of implementation.  The remaining content of the paper starts with a review of related work pursued within the context of data aggregation for performance measurement.  Next, the conceptual design and features of the PAL are discussed.  Then, a detailed discussion of the underlying PAL formation is presented.  The paper concludes with an outline of open topics and research to be pursued.2. BackgroundThe PAL a is SOA, formally defined by Agrawal et al. as a software architecture that “combines the ability to invoke remote objects and functions (called “services”) with tools for dynamic service discovery, placing an emphasis on interoperability.” [2] In this case, services relate to functionality for sending and receiving synchronized, multimodal user data with the intent to infer user performance from it.  Our investigations of previous, related research efforts are therefore focused upon performance measurement efforts, multimodal measurements, and data synchronization. 2.1 Performance MeasurementJohnston et al. presented a team performance measurement procedure based upon the structure and organization of the team [3]. The structure and organization was inferred from the communication between team members.  In a later effort, Stacey et al. created Performance Measurement Objects (PMO) within the context of HLA-based simulations [4].  The PMOs passed customizable, hierarchical performance criteria without requiring direct modifications to the simulation.  The PMOs were then later used to create a specific XML schema called Human Performance Modeling Language (HPML) to simplify the description of automated performance measurements [5].  A closely related effort was pursed in [6].The PAL is the successor of a previous service-based architecture presented in [7].  The PAL extends the functionality of this work by enhancing the re-configurability, by adding an improved distributed functionality, and by incorporating simulation events from graphical user interfaces. 2.2 Multimodal MeasurementsBy using multiple types of neurophysiological sensors, it may be possible to detect the cognitive state of a user in a training system.  Several research efforts within the Augmented Cognition community have centered on this practice.    Erdogmus et al. suggest that multimodal data acquisition yields a better estimate of the cognitive state of a user [8].  St. John et al. utilized head tracking, eye tracking, and EEG to measure the vigilance of users within a training environment [9].  Schnell et al. used many multimodal measures to monitor the mental state of pilots while flying in simulated and real aircraft [10].  Crosby & Ikehara used eye tracking, temperature, blood oxygenation, and galvanic skin response in determining individual differences in responding to similar tasks [11].2.3 Synchronizing DataWhen attempting to use multiple data sources, a common time reference must be established to match events temporally.  However, synchronizing and determining relevant meaning of the multiple data streams is an ongoing issue. Many approaches to solving this problem have been explored.Hall & Llinas summarized a large variety of techniques for fusing multi-sensor data [12] relating to the decision fusion technique utilized by Sharma et al. [13].  A client/server model for synchronization was used by Chou & Wang [14].  Tourainne et al. produced a framework for managing multimodal fusion in virtual environments [15].  The research was based upon a master/slave distributed architecture. Individual computing units hosted single devices or multiple devices running within separate threaded processes.  A similar approach was adopted by the Distributed Multimodal Synchronizing Protocol [16] and by Schnell et al. [9] where each sensor was attached to a single computer.  Michel & Stanford [17] relied upon pulsed electrical signals to achieve synchronization between audio and video. Commercial data synchronization packages include National Instruments LabView [18] and Noldus Observer XT [19].  However, both systems use propriety software.  In addition, both systems require external synchronization through add-on hardware (by video with Observer and by hardware interface with LabView).  Both solutions are quite robust but are limited in that they require external hardware, extensive learning curves, and/or extensive computer resources.2.4 Advances Achieved by PALThe PAL offers several advances over previous approaches.  First, the PAL architecture can monitor multiple users simultaneously without adjustment to the HLA federations.  Next, the PAL can be extended to accommodate different kinds of external sensors and devices without changes to the simulation.  The PAL can also synchronize data using an internal low precision timer or an external, high precision timer.  Furthermore, the PAL can be run on heterogeneous computing networks, including handheld devices.3. The PAL Paradigm3.1	DesignThe PAL project was engendered in hopes of generalizing and extending a standard, unified message passing architecture to any application in need of logging or sharing performance data.  The PAL is a message passing architecture that combines high serviceability with consistency and flexibility.The PAL must be instantiated within the simulation to send and receive data to and from simulation events.  This is achieved through the use of C++ libraries that add the desired functionality for observation and recording.  External data from sensors and other devices are recorded through functionality that can be embedded within a simulation or through an external application created with the PAL libraries.Within a single application environment, the PAL provides the user application with the tractable means to collect and log data both consistently and flexibly.  Utilizing a unified logging architecture enhances data coherence between multiple sources.  For instance, time sensitive data from several sensing instruments can be encoded with a common timestamp to avoid the mismatch of time.An environment with multiple PAL-enabled applications provides the means to subscribe to PAL Messages from any other component within the PAL framework.   For instance, a system with several sensing instruments connected individually to applications for extracting data would be an ideal candidate for PAL implementation.  Once PAL-compliant, each application would generate PAL Messages that any other component could subscribe to.  The loose organization of the PAL architecture allows for free interaction between different PAL Components, which is ideal for any environment that relies on synergy between data sources.  New insights can be generated by combining multiple sources of performance data, which may yield creative and novel vantages.3.2	ConceptsThis section lists commonly used terms that aid in defining the PAL Architecture.PAL Address - Like any other type of address, PAL Addresses are used as the source or destination markers to facilitate data delivery in PAL Transport.PAL Client - PAL Clients are a type of PAL Component that send and receive PAL Messages, but do not log data.  PAL Clients may only send and receive PAL Messages to and from its local PAL Node Manager.PAL Compliance – PAL Compliancy refers to adhering to the PAL architecture.  PAL Compliant applications must incorporate a PAL Client.  Each PAL Compliant computing node must run exactly one instance of the PAL Node Manager.  A PAL Compliant network must be linked with at least two PAL Compliant computing nodes.PAL Components - The PAL Components refer to the sender and receiver of PAL Messages.  Each unique instance of a PAL Component must have a unique PAL Address.  The two types of base components are the PAL Client and the PAL Node Manager.PAL Messages - The PAL Message class encapsulates all data that is to be transported across PAL Space to other PAL components.PAL Node Manager - PAL Node Managers are a type of PAL Component that route PAL Messages between PAL Clients and logs their data.  In a network setting, each physical computer should correspond with a single instance of a PAL Node Manager.PAL Space - Also known as PAL Address Space, this term refers to the topological organization of PAL components and their PAL Addresses.PAL Transport - In order to deliver PAL Messages, PAL Transport such as UDP or Shared Memory must be available.  Because PAL Components can be distributed, the actual medium of the PAL Transport will be chosen dynamically.3.3 The Focus of PALThe three main focuses of the PAL architecture are to provide a common architecture for training data reuse, to store such data in a universal format, and to share data with contemporary applications.  The commonality of the PAL architecture brings a structured interface across a network of applications in order to provide reusability of formatted data by any application that is PAL-Compliant.  With a unified architecture, standards in data collection and data transmission can be regulated to avoid latency and proprietary data generation within the scope of the PAL architecture.Two important features of the PAL architecture are storing data in a universal format and maintaining data logging that is dynamic, robust, and reliable.  As all PAL Messages are stored in a binary format, the serialization and de-serialization of data is done independently to allow for modularization.  Although the PAL architecture provides interface tools to make binary data human-readable, de-serialization is not enforced as a part of PAL Compliancy.  Done in this fashion, the PAL architecture provides users with full customizability of PAL Messages with minimal restrictions.Sharing data pertains to routing of binary data to other subscribing components in PAL Space (i.e. sharing data between two PAL compliant applications).  Since the serialization and de-serialization of PAL Messages is performed independently, modularization allows for the sharing of any set of data with minimal restrictions. UDP or Shared Memory must be available for transport of PAL Messages.  Because PAL Components can be run in a distributed fashion, the actual medium of the PAL Transport is chosen dynamically.  More details are provided in Section 4.4. PAL DetailsIn this section, we provide details pertaining to the topology, message structure, and components used within PAL space.4.1 Topology4.1.1 Application and PAL layersThe underlying blueprint for handling interaction between applications, PAL Clients, and PAL Node Managers are discussed in this section.4.1.1.1 Application to PAL ClientEach PAL-Compliant application must incorporate a single PAL Client into its design (see Figure 4.1).  Any data that the host application wishes to log or share in PAL Space is exposed through the Client interface.  Any data the host application does not wish to expose to connected networks should not be sent via PAL Transports. SHAPE  \* MERGEFORMAT Figure 4.1, Application to PAL Client Relationships4.1.1.2 PAL Client to PAL Node ManagerAll data transmitted by a PAL Client is received by a PAL Node Manager (see Figure 4.2).  The PAL Node Manager then logs the data and/or routes it to other PAL Clients on the node (see next section). SHAPE  \* MERGEFORMAT Figure 4.2, PAL Client to PAL Node Manager Relationships4.1.1.3 PAL Node Manager to PAL ClientThis subsection details one of the main focuses of the PAL Architecture: Data Sharing.  As PAL Messages are sent to PAL Node Managers, it is the task of the PAL Node Manager to route incoming PAL Messages based on the needs of other PAL Clients.  In Figure 4.3, if Client B requests data from Client A through a subscription, the Node Manager will forward messages desired by the subscriber.  That is, all messages from Client A will be routed to Client B by the Node Manager.  Please note that Client B does not directly communicate with Client A during any step of the subscription process.  Client B simply queries the local PAL Node Manager for available data streams and then subscribes to the desired available stream(s). SHAPE  \* MERGEFORMAT Figure 4.3, PAL Node Manager to PAL Client Relationships 4.1.1.4 PAL Node Manager to PAL Node ManagerIn a PAL-Compliant network, each PAL Node Manager is associated with a single and unique computing node.  Because PAL Clients may only exchange information to the PAL Node Manager that exists on its local machine, PAL Node Manager to PAL Node Manager communication must exist in order for PAL Clients existing on disparate machines to share data (see Figure 4.4).  The organization for multi-Node Manager setup is automatic and should be handled once additional Node Managers are discovered.  During the initialization of additional Node Managers, configuration synchronization should occur to maintain data consistency. SHAPE  \* MERGEFORMAT Figure 4.4, PAL Node Manager to PAL Node Manager Relationships4.1.2 PAL AddressingPAL Addresses are composed of 32 contiguous bits which is described in Table 4.1.PAL Address SubfieldSize (bits)Participant ID6Node ID12Client Type ID10Instance ID4Table 4.1, PAL Address CompositionParticipant ID: 6 bits designate the user whom logged data is associated with.Node ID: 12 bits designate the Node Manager the data originated from.Client Type ID: 10 bits designate the type of PAL Client Component. Types of client components include EEG sensors, simulations, etc. that are customizable through XML settings.Instance ID: 4 bits designate the instance number of a specific type of PAL Client associated with a node manager.4.2 Data TypesThe PAL Architecture supports Primitive and Custom Data types.  Primitive types form the basis for all Custom Data types.  Because there is no restriction on the creation of Custom Data types, any type of data can be stored in a PAL Message as long as the Custom Data type decomposes into a series of Primitive data types; a fact that is guaranteed since computers store data digitally.4.2.1 Primitive Integer TypesIn the PAL architecture, eight integer types are supported.  The types are described in Table 4.2.NameDetailsSize (bits)RangeChar8Signed Char8ASCII or -127 to 127UChar8Unsigned Char80 to 255Int16Signed Integer16-215 to 215-1UInt16Unsigned Integer160 to 216-1Int32Signed Integer32-231 to 231-1UInt32Unsigned Integer320 to 232-1Int64Singed Integer64-263 to 263-1UInt64Unsigned Integer640 to 264-1Table 4.2, Integer Number Specification4.2.2 Floating point TypesThe PAL floating point numbers follow the specification of the IEEE-754 standard.  Two types of floating point numbers are supported in the PAL architecture (see Table 4.3).NameDetailsExponent Size (bits)Mantissa Size (bits)Total Size (bits)Float32Single-Precision82332Float64Double-Precision115264Control FunctionBit-0Bit-1Single00First Packet01Normal10Last11 Table 4.3, Floating-Point Number Specification4.3 Message StructureEach PAL Message is composed of a Message Header and a Message Body.   The Message Header provides metadata used during the transportation and logging process.  The Message Body contains the data to be used by applications within PAL Space.4.3.1 Message Header CompositionThe Message Header contains transport information for routing and transmission control of PAL Messages using 18 contiguous bytes of information that describes the Message. The Message Header is composed of the Message Properties, Sequence Number, Source ID, Message Code, Timestamp, and Data Size.4.3.1.1 Message PropertiesThe Message Properties field consists of ten contiguous bytes that are arranged in the following Table 4.4.PropertyVersionControlRetransmitReservedBit0123456789101112131415Table 4.4, Message Properties Bit Values	Version: Four bits specify the unique version number. “0000” represents the PAL version beta used in this specification.Control: Two bits to indicate if the message is part of a multi-packet sequence (see Table 4.5 for values).  Depending on the transport medium being used, PAL Messages above a specified size may need to be split in a multi-packet sequence.  Data Control is used to identify if a packet is part of a sequence so that the message may be re-assembled.Retransmit: One bit specifies if the message is being retransmitted.Reserved: Nine bits are reserved for future use.Table 4.5, Data Control Bit ValuesSingle: Default; normal and atomic PAL Message.First Packet: First Packet of a multi-packet sequence.Normal: Normal packet that is part of a multi-packet sequence.Last: Last Packet of a multi-packet sequence. Sequence NumberIn a multi-packet transmission of a message, the Sequence Number (of UInt16 type) designates the position of the packet in the series in order to successfully reintegrate the data.  The Sequence Number field is two bytes and stores up to 216 unique states.4.3.1.3 Source IDSource ID is a four-byte data field of the PAL Address type which stores the PAL Address of the component generating the Message.4.3.1.4 Message CodeThe Message Code (of UInt16 type) can uniquely represent 216 states.  Each type of PAL Message has a unique Message Code and a corresponding meaning.  Table 4.6 describes the range and meaning of PAL Message Codes.RangeReserved Meaning0000h to 01ffhSystem-Level Messages.0200h to ffffhUser-Defined MessagesTable 4.6, Message Code DetailsSystem-Level Messages: Reserved for inter-component system commandsUser-Defined Messages: Reserved for custom Message types.4.3.1.5 TimestampAll Messages carry a timestamp that is initialized at the creation of the PAL Message.  This time should be synchronized across multiple system environments in order for latency to be minimized.  Please refer to the Table 4.7 below for details of the Timestamp format.TimeRangeSize (Bits)Day1-315Hour0-235Minute0-596Second0-596Millisecond0-99910Table 4.7, Timestamp Format4.3.1.6 Data SizeData Size is a UInt32 type attribute which refers to the payload of the PAL Message.  For PAL Messages without a Message Body, this field should be always set to zero.4.3.2 Complete High-Level Diagram of the PAL Message HeaderHeader SubfieldSize (bits)Message Properties16Sequence Number16Source ID32Message Code16Timestamp32Data Size32Total Bits144Table 4.8, Complete High-Level View of the PAL Message Header4.3.3 Message BodyThe PAL Message Body is the area of the Message where the user can transmit a supplemental payload.The size of the Message Body should vary in accordance to the Message type.  For instance, a custom PAL Message type for “Mouse click” might include the x and y position of the mouse click (stored in two UInt16’s) as part of the Message Body.  Another custom Message type for “Key Press” might only need a single ASCII Char8 as part of the Message Body.  Custom PAL Messages should define their own Message Body size.All PAL Messages must be serialized prior to transmission and logging.  The “Little-endian” method is standard for PAL running on x86 CPUs.4.4 Components4.4.1 PAL Client4.4.1.1General DescriptionPAL Clients are responsible for the transmission of PAL messages (generated by the host application) to the PAL Node Manager that exists on the local machine.  Another function of the PAL Client is to act as the transceiver for subscription data between the PAL Node Manager and the host application.  PAL Clients may query the PAL node manager for available streams of data and subscribe to available streams at will.  Each PAL-compliant application will contain at least one PAL client object.  All PAL Clients must be able to send and receive PAL Messages to and from any local Node Managers.4.4.1.2 Initialization, Ready State and ShutdownWhen a PAL Client comes online it should broadcast a “Client Startup Message” over the local machine via UDP and TCP.  If a Node Manager returns with a “Client Coupling Success” Message within an allotted timeout period, the PAL Client moves into the ready-state.  If no Node Managers answer within the timeout period, then the Client may choose to shut down or wait for a “Node Manager Startup Message” before retrying initialization.Once a PAL Client enters the “ready-state,” it may send or receive System-Level, or custom User-Defined Messages. As the host application shuts down or disables its PAL functionality, the PAL Client should broadcast a “Client Shutdown Message” over the local machine via UDP and TCP.  The present Node Manager does not need to acknowledge or confirm.4.4.2 PAL Node Manager4.4.2.1 General DescriptionThe PAL Node Manager (one per computing node) is responsible for coordinating all PAL Clients on the node.  Detailed duties include actual I/O to disk, redirection of PAL Messages to other Clients and/or Node Managers, and the broadcast/multicast of System-Level PAL Messages.  All PAL Node Managers must be able to send and receive PAL Messages to and from local PAL Clients or any existing Node Managers.4.4.2.2 Initialization, Ready State, and ShutdownUpon the startup of a PAL Node Manager, a “Node Manager Startup Message” should be broadcasted via UDP and TCP on the local machine.  It should wait for an allotted timeout period to confirm no other Node Manager exist on the local machine and then move to the “ready-state.”  If the initializing Node Manager is one of many Node Managers on the network, a quick calculation for the time differential between the initial Node Manager and any other Node Manager.  This time differential used to adjust and synchronize timestamps for logging and retransmitting PAL Messages.Once initialized, the Node Manager will be sending and receiving PAL Messages.  Another duty of the Node Manger is to redirect subscriptions to the matching subscribers by rerouting outbound PAL Messages to the respective subscribers.  Before a Node Manager shuts down, it should send the “Node Manager Shutdown Message” to all other PAL Components.  No other components need to acknowledge the shutdown.5. Overall PAL Representation in UMLThe UML diagram in Figure 1 is a schematic representing the relations between classes within the PAL architecture.  CxUtils is an open-source library that adds low level functionality such as socket communication and shared memory.  The various Connection Handler classes represent the PAL Component’s Transport module.  The Message Handler class acts as the incoming mailbox for PAL Components.All PAL Components are designed to be multi-threaded in operation.  In Figure 1, Client classes require two threads and Node Manager classes require four threads to run.References of elements of Object-Oriented Programming Languages can be seen in the UML diagram.  Our implementation of PAL uses C++ as the primary language; however, C# or Java may also be easily used as well.Figure 5.1, PAL UML Class Diagram6. Discussion and Future WorkThe lack of timers with microsecond precision in the Windows operating system may adversely impact events and/or physiological sensors that produce data at high frequencies.  A work around for this issue is the use of external high precision timers (such as GPS clocks or implementation in Linux).Another shortcoming of the PAL architecture is that in order for an application with user-interactive/GUI-related events to become PAL-compliant, the applications source code must be available for modification so that such user-interaction can be sent internally via an instantiated PAL Client.  This can only be done from source code.   A workaround for this constraint is the use of the Human Performance Modeling Language (HPML) as described in [5].  However, using the HPML has the tradeoff of reduced effectiveness of high precision timers.Future work includes a C# Node Manager and Client to be implemented on handheld/ultra-portable computing platforms.  We also intend to extend the architecture to the use of high-performance computing nodes.  The flexibility of the PAL architecture is expected to ease the realization of these goals.7. AcknowledgementsThis work is supported by the Office of Naval Research under contract number N000140710098. The views and conclusions contained in this document are those of the authors and should not be interpreted as representing the official policies, either expressed or implied, of the ONR or the US Government.  The US Government is authorized to reproduce and distribute reprints for Government purposes notwithstanding any copyright notation hereon.8. ReferencesZimmerman, T. G., (1996). Personal Area Networks: Near-field intrabody communication. IBM Systems Journal, vol. 35, No. 3 & 4, MIT Media Lab.Agrawal, R., Bayardo, R. J., Gruhl, D., and Papadimitriou, S. (2001). Vinci: a service-oriented architecture for rapid development of web applications. In Proceedings of the 10th international Conference on World Wide Web (Hong Kong, Hong Kong, May 01 - 05, 2001). WWW '01. ACM, New York, NY, 355-365. Johnston, J. H., Freeman, J., & Serfaty, D. (2003). Performance measurement for diagnosing and debriefing distributed command and control teams. Proceedings of the 8th International Command and Control Research and Technology Symposium, Washington, DC.Stacy, W., Freeman, J., Lackey, S., & Merket, D. (2004). Enhancing simulation-based training with Performance Measurement Objects. Proceedings of the Interservice/Industry Training, Simulation and Education Conference (I/ITSEC). Arlington, VA: NDIA.Stacy, W., Merket, D., Freeman, J., Wiese, E., & Jackson, C. (2005). A language for rapidly creating performance measures in simulators. Proceedings of the Interservice/Industry Training, Simulation and Education Conference (I/ITSEC). Arlington, VA: NDIA.Cornell, G., Boland, W., & Frank, G. (2007) Automating human performance measurement using XSLT in simulation-based exercises. Proceedings of the Interservice/Industry Training, Simulation and Education Conference (I/ITSEC). Arlington, VA: NDIA.Kemper, D., Davis, L., Fidopiastis, C., & Nicholson, D. (2008) Proceedings of the Human Factors and Ergonomics Society 53rd Annual Meeting (in Press). New York, NY: HFES.St. John, M., Risser, M., & Kobus, D. (2006). Toward a usable closed-loop attention management system: predicting vigilance from minimal contact head, eye, and EEG measures. In Foundations of Augmented Cognition: Proceedings of the Augmented Cognition International Conference 2006 (San Francisco, CA. October 15-17, 2006). Volume 2. D. Schmorrow, K. Stanney, and  L. Reeves, Eds. Strategic Analysis, Inc., Arlington, VA, United States(US), 12-18.Schnell, T., Macuda, T., Poolman, P., Craig, G., Erdos, R., Carignan, S., Allison, R., Lenert, A., Jennings, S., Swail, C., Ellis, K., & Gubbels, A. (2006). Toward the “cognitive cockpit”: flight test platforms and methods for monitoring pilot mental state.  In Foundations of Augmented Cognition: Proceedings of the Augmented Cognition International Conference 2006 (San Francisco, CA. October 15-17, 2006). Volume 2. D. Schmorrow, K. Stanney, and  L. Reeves, Eds. Strategic Analysis, Inc., Arlington, VA, USA, 268-278.Crosby, M., Ikehara C. (2006). Using physiological measures to identify individual differences in response to task attributes. In Foundations of Augmented Cognition: Proceedings of the Augmented Cognition International Conference 2006 (San Francisco, CA. October 15-17, 2006). Volume 2. D. Schmorrow, K. Stanney, and  L. Reeves, Eds. Strategic Analysis, Inc., Arlington, VA, United States(US), 162-168.Erdogmus, D., Adami, A., Pavel, M., Lan, T., Mathan, S., Whitlow, S., & Dorneich, M. (2005). Cognitive state estimation based in EEG for augmented cognition. In Proceedings of the 2nd International IEEE EMBS Conference in Neural Engineering (Arlington, Virginia, March 16-19, 2005).Hall, D. & Llinas, J. (1997). An introduction to multisensor data fusion,” Proceedings of the IEEE, 85 (1), 6-23.Sharma, R., Pavlovic, V., & Huang, T. (1998). Toward multimodal human-computer interface. Proceedings of the IEEE, 86 (5), 853 – 869.Chou, W & Wang, T. (2001). The design of multimodal human-machine interface for teleoperation. In Proceedings of the IEEE International Conference on Systems, Man, and Cybernetics 2001 (Oct. 7-10, 2001). Volume 5. IEEE Press, Piscataway, NJ, USA, 3187 – 3192.Touraine, D., Bourdot, P., Bellik, Y., & Bolot, L. (2002). A framework to manage multimodal fusion of events for advanced interactions within virtual environments. In Proceedings of the Workshop on Virtual Environments 2002 (Barcelona, Spain, May 30 - 31, 2002). W. Stürzlinger and S. Müller, Eds. ACM International Conference Proceeding Series, vol. 23. Eurographics Association, Aire-la-Ville, Switzerland, 159-168.DMSP (2006). Distributed multimodal synchronizing protocol. Retrieved May 31, 2007, from http://ietfreport.isoc.org/idref/draft-engelsma-dmsp/.Michel, M. & Stanford, V. (2006). Synchronizing multimodal data streams acquired using commodity hardware. In Proceedings of the 4th ACM international Workshop on Video Surveillance and Sensor Networks (Santa Barbara, California, USA, October 27 - 27, 2006). VSSN '06. ACM Press, New York, NY, 3-8.National Instruments LabView  (2008).  Austin, TX: National Instruments Corporation.  Noldus Observer XT (2008).  Leesburg, VA: Information Technology Inc. Sun, B. (2008) “Personal Area Logger Reference Architecture,” retrieved July 02, 2008 from  HYPERLINK "http://active.ist.ucf.edu" http://active.ist.ucf.edu .Author BiographiesBO SUN is a Graduate Research Assistant in the Applied Cognition and Training in Immersive Virtual Environments (ACTIVE) Laboratory at the Institute for Simulation and Training.  He is pursuing a doctoral degree in Computer Science at the University of Central Florida.DON KEMPER is a Graduate Research Assistant in the ACTIVE Laboratory at the Institute for Simulation and Training.  He is completing a doctoral degree in Modeling and Simulation at the University of Central Florida.LARRY DAVIS, PH.D. is the Associate Director for Interfaces and Integration of the ACTIVE Laboratory at the Institute for Simulation and Training.  Dr. Davis is conducting research on interfaces for simulation.CALI FIDOPIASTIS, PH.D. is the Associate Director for Cognition of the ACTIVE Laboratory at the Institute for Simulation and Training.  Dr. Fidopisastis is conducting research on brain interfaces and  the detection of cognitive states using neurophysiological sensors.