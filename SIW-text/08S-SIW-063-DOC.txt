Functional Component Testing for Distributed SimulationsKeith SnivelyDynamic Animation Systems12015 Lee Jackson HwySuite 200Fairfax, VA 22033 HYPERLINK "mailto:ksnively@d-a-s.com" ksnively@d-a-s.comPaul McCrayDynamic Animation Systems12015 Lee Jackson HwySuite 200Fairfax, VA 22033 HYPERLINK "mailto:pmccray@d-a-s.com"pmccray@d-a-s.comKeywords:Simulation, Design, Testing, ModelAbstract:  Testing for distributed simulation environments is usually a two step process. Models are tested individually based on the system design before being integrated into the larger system and the system is tested as a whole. Testing components individually is difficult due to the need to provide the appropriate stimuli in the correct order and circumstances. The data dependencies grow quickly and the circular dependencies force many development groups to test the system as a whole completely skipping individual model testing.  Furthermore, test cases tend to have no direct link to the system design and are manually implemented according to the interpretations of the test developer.To address the difficulties of model testing in accordance with the system design, MATREX has developed a process and set of tools to facilitate functional testing of models.  The functional test cases can be imported from the MATREX System Design Description (SDD) and therefore mature automatically with the system design [3]. Linking the testing to the design ensures that both the developers and integrators are starting with the same basis and eliminates confusion from interpretation or lack of detail. The system design staff provides all the information necessary to agree on before final development and integration based on the system requirements, design decisions and scenario-specific data. To realize this process, MATREX has built a tool called the Advanced Testing Capability (ATC) that provides the capability to build, store and execute tests over a transport abstraction layer, the ProtoCore. The test cases are in the form of a sequence diagram of the information necessary to test any particular model or group of models. The ATC generates code for test federates based on the sequence diagram. The test federate provides the specified stimuli and listens for the output from the model(s) under test and verifies the data against allowable value ranges from the test case. The ATC can provide the stimulus that may not be available from other models. This allows developers to test their models locally before delivering outside their development environments.  The process and tools ensure that the test cases accurately reflect the system design, provide portability of test cases across transport protocols with the SDD, and reduce time and costs involved in federation wide integration events.  1. IntroductionDistributed simulation has had a widespread impact on the defense industry for several years and has arguably led to cost savings through model reuse and interoperability.  Experimentation using actual resources such as communication equipment, vehicles, troops, etc. is costly, can be dangerous, does not scale well and often does not provide sufficient means of control for comprehensive experimentation.  Virtual (simulated) systems that include detailed models of military commodities help to overcome these limitations.  As reliance upon distributed modeling and simulation has increased in acquisition and training programs, there has been an increased emphasis upon creating a detailed design at the system level.  Typically an object model captures the syntax for communication among the simulation applications.  A meaningful system design however also needs to capture the breakdown of the simulation into functional components, the semantics of interactions among the simulators, and the linking the design back to the system requirements and design decisions.  The system design however is only relevant if the simulations accurately implement that design.  Testing at the functional level typically is done by the simulation developers or even skipped without any direct link to the simulation design.   This situation exists not only for newly developed simulations but also for existing models.  Reusing existing simulation models save tremendous development time and cost.  However, when a model is reused, it may or may not be used in its existing form.  These models can be modified to change the model's interface and its interaction within the simulation.  While the models themselves may have been through a VVA process, the interaction at the system integration level must still be verified.  To ensure the model’s interoperability within the simulation framework accurately reflects the system design, MATREX has developed a set of processes and tools for functional component testing.  These processes ensure that test cases remain current with the system design and that all components pass assigned test cases before entering integration.  The test cases are created and executed using a tool called ATC.  This tool provides the capability to build, store, and execute tests over a transparent abstraction layer.  2. Design Driven Testing2.1 Need for Functional TestingFunctional testing of components in a complex simulation system are essential for the success of the simulation achieving its goals.  The functional tests ensure the components adhere to the interface specification provided by the system design.  In this case, the interfaces being tested are those across the distributed simulation transport, expressed in terms of the object model and associated semantics.Some benefits of functional testing are reducing time spent in integration of the system and development of components.  During system integration, scenario tests provide feedback on execution of the system as a whole, but can be hampered by components with many bugs.  As system complexity and size grows, many bugs in many components may prevent some components from any testing until known bugs are fixed and patches delivered in the other components.  Ideally, component developers also use testing to check accuracy of the simulation component as it is implemented.  However, it is not practical to perform this testing within a large and complex system.  Such tests would also be difficult to focus on a specific aspect of a component's behavior.  During development, isolated functional tests can be used to detect faults early and fix as the subsystem is implemented.It is therefore essential for MATREX program to have accurate and complete functional testing for each of its components.  Such testing also needs to be consistent across all the components of the system.  In order to accomplish these goals, test cases must be directly linked to the system design.  Furthermore MATREX needs a common tool developers can use to rapidly create test cases.  2.2 Linking Test Cases to DesignOne requirement for accurate functional testing is a detailed enough design to create test cases.  Without such a design, developers of test cases are left to fill in the details based upon their interpretation.    Testing is then at best inconsistent and at worst, skipped altogether.  In addition, the component developer may not create a complete set of functional tests, leaving some capability untested into system integration and beyond.  A detailed and unambiguous system design can alleviate these problems.For MATREX, the System Design Description (SDD) captures the system design at a functional level and links the functional design to the technical design [3].  This design includes the syntax and semantics of interaction among the functions as well as allocation of function to components.  The system architects, system engineers and component developers create and agree upon the system design represented in the SDD.  This design then serves as the contract for a component's capabilities and interaction within the system.  By linking the technical design to the test cases, the simulation system developers than have the ability to test a component's adherence to that contract. Test cases for each component are derived from the SDD functions allocated to that component.  The functions contain sequences of events between the participants of that function within the system.  All the functions a component participates in can be accessed by developers in the SDD on the MATREX IDE (Integrated Development Environment) website.  From the sequence, an individual test case defines which components in the sequence to test and which will be played by a test agent.  The test case also requires values, or rules to generate values, for events that are generated by the test agent and to verify events generated by the component under test.   Currently the tests require actual values or value ranges for verification and generation.  Future development effort will add the ability to be able to specify other rules, such as one value being derived from other values in the test using a given formula or function.  Within the next 12 months, version 5 of the SDD will provide some of these values and functions where possible, thus reducing work in creating test cases.One drawback to functional tests is that a component may require a large number of test cases to cover all its allocated functions.   Even with a generalized tool to build test cases, creating all the necessary test cases can be time consuming.  Automation overcomes this problem.   The SDD captures the sequences in a computer digestible and unambiguous format.  Future work will allow the tests cases to be automatically generated from the SDD and ingested into ATC.  This removes the manual step of keeping the test cases for each component current with design.  Once the test cases have been captured for a version of the system design, they can be stored and executed at any time.   Furthermore, most test cases will be able to be used with newer versions of the design with little or no modification.By creating test cases from the SDD, the test cases can be linked to functions with the design and from there, design decisions and system requirements.  In the future, the test cases will be available and linked on the SDD.  This allows system architects to verify completeness of testing in that all functions and requirements are covered by test cases for each participating component.  The automation of test case generation will provide the accuracy of testing according to the design for each component.  In order to ensure that a component adheres to the applicable design contract, the MATREX program requires that components delivered to integration are delivered with its ATC test cases.  These test cases are created by automation or the integration team to avoid misinterpretation.  The first stage of integration verifies that the component passes all the ATC test cases before integration into the system.    This procedure helps identify any potential issues early in the integration process.  In addition, test cases are run where multiple components are tested simultaneously within a sequence.  In fact, the testing harness can act merely as a listener to verify interaction of the system as a whole with respect to that sequence.  This process ensures testing is consistent across all components.3. ATC OverviewThe primary purpose of the ATC is to provide meaningful and repeatable “black box” level testing on any given target model that must be integrated into a distributed simulation environment.  As a “black box” test harness it does not perform testing on the models internal functionality.  Instead, the focus is on testing the interoperability of the target model in the rest of the simulation environment.  Through an advanced graphical user interface the user is able to graphically define tests in a common UML format, the sequence diagram.  Figure 2.1 shows an example test under development.Figure 2.1The sequence diagram is a form of interaction diagram which shows models as lifelines running down the GUI, with their interactions over time represented as messages drawn as arrows from the source to the target model, where the sender is green and the target is red.  Sequence diagrams are good at showing which models communicate with other models throughout the distributed simulation environment.  The communication topology is defined within the simulation SDD realized as the MDD (Model Design Description).  Sequence diagrams are also good at showing the “flow” of a test case, which communication triggers another and also what the desired response should be from the model under test.  2.1 Bridging the Gap for Multiple ArchitecturesOne of the challenges in distributed simulations is the vast number of architectures available upon which to build models.  In order to deal with these different architectures, typically models are refactored to operate in each individual environment or gateways are built to bridge the varying environments.  The MATREX program developed the ProtoCore in order to address these interoperability problems.  Over time, the number of communication infrastructures used within the Modeling and Simulation community has continued its rapid growth, thus ATC is built upon the ProtoCore.    The ProtoCore is an abstraction system that allows simulation developers to write to a single API and object model, and run the simulation on a variety of network transport subsystems.  The translation to a specific protocol is handled within a plugin library in the same process.  This makes the transition, for testing model interfaces built on different architectures, virtually seamless for the ATC.    2.2 Concept and StructureATC is a JAVA application which can be used on multiple platforms.  It utilizes JAVA reflection which allows the application to ingest a compiled object model library and decompose it in order to populate displays for the editing and validation of individual attributes, see Figure 2.1.  This efficient programming technique makes ATC easily compliant with the MATREX FOM (Federate Object Model) and many others as well.  As the design matures, the changes can be easily incorporated into ATC for testing and validation purposes.  The basic concept of ATC is to treat the system under test as a black box and all of the other systems external to the system under test as part of the test harness.  The test harness is represented by ATC itself, and thus, there is no need for any other external components to actually test the given system.  In the test depicted below in Figure 2.2 there are 3 components (OTB, OCS, and SANDS).  The system under test is OCS and ATC is acting on the behalf of OTB and SANDS components.  Events defined in the sequence diagrams are used to stimulate the system under test and generate responses which can be captured by ATC and validated.  The validation types currently supported are ranges (for primitive floating points), integers, enumerations, and strings.  ATC has the capability to wait a user specified amount of time to both send out an event and to also receive and validate a response.  In the test depicted below the system passed.Figure 2.2If the system under test sends out multiple interactions during the testing sequence in between events, ATC has the capability to simply ignore them without ruining the integrity of the test.  It is possible to create sequences of events that only provide stimulus and don’t expect responses but that type of test does not fully utilize all of the capabilities ATC provides.  However, certain labs have found this to be an efficient way of testing the setup of their simulation environment. 4. Conclusion and Future PossibilitiesATC test cases provide traceability back to system level requirements found in the System Design Document (SDD).  MATREX has defined an information model that is capable of capturing the program-level SDD. That information model, realized as an on-line content management system (MATREX IDE), provides the ability to include design decisions, semantic information, functional decomposition, and allocation of responsibilities to components, along with an object model, in a transport independent manner. With the completeness of the SDD, we are able to support a test process that automatically generates tests from the design, and keeps tests consistent with that design, and allows traceability back to that design. The tests are separately bound to a particular protocol, such as TENA and HLA, using a protocol abstraction layer. This allows tests to be preserved as the underlying protocol matures or changes.  These tests can then be provided to model developers and the validation of a component using these tests can be made a prerequisite for acceptance.  Using this process significantly reduces time and cost associated with federation wide integration events.5.  References[1] Keith Snively, Philip Grim II, (2004).  ProtoCore:  A Transport Independent Solution for Simulation Interoperability[2] Simon Taylor, Richard Fujimoto, Steffen StraBurger, Agostino Bruzzone, Boon Ping Gan, Ray J. Paul (2002).  Distributed Simulation and Industry: Potentials and Pitfalls[3] Scott Gallant, David Itkin, Paul McCray, Keith Snively (2008). Effective Distributed Simulation Design for Cross-Domain InteroperabilityAuthor BiographiesPaul McCray is a Senior Software Engineer with Dynamic Animation Systems Inc.  He has a BS in Computer Science and a Minor in Mathematics from Virginia Polytechnic Institute.  His experience includes developing aircraft systems software for Air Force flight simulators and developing radar simulations for Navy trainers.  He also has experience running distributed simulation experiments for the Army’s FCS program.  Recently, Mr. McCray has done extensive work to enhance the functionality of the ATC application to meet the evolving demands of the defense industries distributed simulation arena. KEITH SNIVELY is a Senior Software Engineer with Dynamic Animation Systems Inc.  He has over ten years experience in DoD modeling and simulation.  His experience includes several years working on design and development of the DMSO RTI-NG.  He has also worked on development for the TENA middleware.  Recently Mr. Snively participated in the development of the HLA 1516 Evolved specification.  Currently Mr. Snively serves as a software developer for the MATREX program and specifically supports design and development of the MATREX RTI-NG and ProtoCore.