1. IntroductionMovement within a simulated environment is generally described in terms of position, velocity, acceleration, and/or rotation.  In a distributed simulation environment, a simulation component may need to know these attributes for remote entities.  Bandwidth limitations, however, may make sending a constant stream of entity updates impractical.One way to keep track of the location of remote entities up to date while reducing the number of network messages required is to make use of dead reckoning.  First order dead reckoning assumes a constant rate of change in positional attributes, such as a constant velocity, and uses that assumption to determine where an entity is over time.  Second order dead reckoning assumes a constant rate of change to the rates of change, such as a constant acceleration.  These assumptions provide smooth movement between updates and allow the host of the entity in question to send fewer updates by only updating the entity when this assumption is broken.There are limitations to how much can be accomplished with this manner of dead reckoning.  An entity that frequently changes velocity or acceleration violates these constraints frequently and will benefit less from such a model.  Furthermore, latency between the time an update is sent and the time it is received may produce discrepancies between the dead-reckoned position and the actual position.  These discrepancies must be corrected in some fashion, such as teleporting the entity into the correct position or interpolating the positions over time. [1]To attempt to produce smooth movement for remote ground vehicles in distributed simulations in a bandwidth-effective manner, Lockheed Martin began development of a new movement and dead reckoning model in 2004 called Road-Based Dead Reckoning.  Road-Based Dead Reckoning describes movement relative to the simulation’s road network instead of using absolute world coordinates and vectors.  One limitation of the model developed was that it did not lend itself to interoperability.  Simulation components without the road-based dead reckoning algorithm could not calculate the position of entities using the new model.  Furthermore, support for the algorithm could not easily be added to a simulation component.  The underlying algorithm was too complex for easy native implementation, and the existing library that had been developed to implement the algorithm had too many dependencies to be easily used by other applications.  To address this, work began on a standalone API that provided an implementation of the Road-Based Dead Reckoning in an easy-to-integrate fashion.This paper provides a quick introduction to the Road-Based Dead Reckoning algorithm, a description of the integration challenges it posed, and detail the design and creation of the API.2. Road-Based Dead Reckoning2.1 OverviewTraditional dead reckoning algorithms describe position and movement in terms of world coordinates.  First-order dead reckoning describes entities in terms of an attribute and a rate of change, such as position and velocity.  Second-order dead reckoning includes the change to the rate of change; position, velocity, and acceleration, or orientation, rotation, and rotational acceleration.Road-Based Dead Reckoning is unlike conventional dead reckoning algorithms in that it describes movement relative to road networks instead of absolute world coordinates.  Some attributes included in the Road-Based Dead Reckoning state data include the road traveled upon, current and target speed along the road, distance from the end of the road, the next road the vehicle intends to travel upon, and the road distance at which the vehicle intends to stop.  [2]  A Road-Based Dead Reckoning aware simulation can then take this information and, in conjunction with a terrain database containing data on the road network, convert this information into its native coordinate system.2.2 RationaleThere were two primary motivations for developing Road-Based Dead Reckoning: reducing bandwidth consumption to improve network scalability and reducing the impact of latency on the quality of vehicle movement.  [2]  Additionally, it was used to provide more realistic vehicle movement behaviors such as acceleration, deceleration, vehicles passing each other, and smooth turning.  These behaviors are possible under conventional first- or second-order dead reckoning but would require additional state updates, increasing bandwidth consumption and exacerbating latency issues.2.2.1 BandwidthAs described in the overview, first- and second-order dead reckoning include not only the present position of an entity, but also information on how the entity will change its position over time.  This can be used to provide estimates of entity's location between state updates.  If the entity moves in a reasonably predictable fashion that matches the dead reckoning information, such as moving with constant velocity or acceleration, this can be used as a tool to reduce the number of state updates that need to be communicated.  [3]As an example, the IEEE 1278 Distributed Interactive Simulation (DIS) standard assigns entities three positional thresholds and three rotational thresholds.  [4]  An update only needs to be sent when the entity's actual state has diverged from the dead reckoned state by an amount greater than the thresholds.  In DARPA's Distributed Simulation Networking (SIMNET) program, such a scheme reduced network traffic by 83%. [3]  Although this is a significant improvement, some of the target applications for Road-Based Dead Reckoning generate hundreds of thousands to millions of entities.  [1] [5]  When moving, these entities can produce enough entity state updates to overwhelm even very robust networks.  In some applications, limiting the number of entities a simulator or viewing application can subscribe to by filtering entities geographically and restricting subscription area proved necessary to make the simulation possible.  [5]  There remained a demand to further reduce bandwidth requirements.Road-Based Dead Reckoning offers several potential improvements to bandwidth usage over either first- or second- order dead reckoning.  The vehicle's intended stopping distance and desired speed are included in the state information.  This allows the vehicle to accelerate, move at a constant velocity, decelerate, and come to a stop with only a single update.  Second order dead reckoning would require at least four updates to accomplish the same thing, as the vehicle's acceleration changes four times, and first-order dead reckoning would either require significantly more updates during the acceleration and deceleration phases or would poorly predict the vehicle’s movement.Another advantage of Road-Based Dead Reckoning is that it takes advantage of the clients' awareness of the road topography.  This means that a vehicle can conform to bends or slopes in the road without requiring additional updates.  Obviously, the frequency of updates is not the only factor.  The size of the updates must be considered as well as the number of updates.  Under a recent implementation of Road-Based Dead Reckoning, the example above would require 84 bytes over two updates.  This is the same size as it would take to transmit a second order dead reckoning update in the application Road-Based Dead Reckoning was initially implemented in, using a three-axis position with 64 bit precision and velocity, acceleration, orientation, rotation, and rotational acceleration on three axes with 32 bit precision.   Even discounting network overhead associated with an update and using the best case of the vehicle traveling in a straight line and requiring no orientation, rotation, and rotational acceleration updates after the first, the second order dead reckoning will use significantly more bandwidth than Road-Based Dead Reckoning in this scenario.Additionally, under Road-Based Dead Reckoning if a vehicle's movement changes while on a road (due to traffic, for example), the required update is usually significantly smaller, consisting primarily of the new stopping distance of the vehicle.Communicating the movement of vehicles passing through an intersection can also be made inexpensive.  By using local knowledge the vehicle’s physical parameters and the road geometry, the vehicle’s movement through the intersection can calculated using only the time the vehicle entered the intersection, the road speed at time of entry, and which road the vehicle is transitioning to.  Other complex but predictable behaviors such as passing can similarly benefit by using a deterministic behavior that each simulator can calculate locally.The overall bandwidth efficiency of Road-Based Dead Reckoning depends on the road and road traffic conditions.  It performs optimally under extremely light traffic, where few updates are required, or extremely heavy traffic where stop-and-go behavior requires numerous state updates, allowing Road-Based Dead Reckoning to take advantage of the reduced size of the same-road state update.  In at least one case, it can under perform first- or second order dead reckoning: a long road with a moderate traffic load moving at a constant speed.  In this instance a constant stream of vehicles leaving the road will cause frequent stopping distance updates to other vehicles on the road when there is no change in velocity or acceleration.At present, however, this case is fairly rare as the majority of the simulations that use Road-Based Dead Reckoning either tend to produce very light traffic, or traffic heavy enough that most of the vehicles are in stop-and-go traffic.  Should it become desirable to improve the performance in these cases, there are several ways this could be remedied.  One improvement would be to defer stopping distance updates until they are necessary to cull redundant updates.  Another improvement would be to monitor the available space in outgoing lanes to detect when traffic will be able to flow uninterrupted, and include this in the stopping distances sent.2.2.2 LatencyThe other motivation for using Road-Based Dead Reckoning was to improve the quality of vehicle movement.  Many of the applications that Road-Based Dead Reckoning is used in work in a distributed environment, where there may be a non-trivial delay between when an update is sent and when an update is received.  This can produce a variety of unwanted behaviors that are highly visible to a user, such as vehicles passing through each other, appearing to teleport when a state update reveals the entity is not where the viewer thought it was, or driving off of roads when the road curves and an update is delayed.  Some of these issues can be prevented or reduced by interpolating between the expected and actual position when a late update occurs, but not all.  [1] [2]Road-Based Dead Reckoning helps deal with latency-induced errors in several ways.  The primary advantage is that it better predicts the vehicles' behavior so that fewer updates are needed, and thus fewer updates will arrive late and need correction.  As described in the previous section, an update is not needed to stop the vehicle or to conform to a bend in the road.  This completely eliminates vehicles driving off the road because of a bend in the road, and eliminates vehicles overrunning each other and co-locating in all but the worst network conditions.Additionally, Road-Based Dead Reckoning can use a cross-network synchronized clock to predict when an update was sent, rather than assuming that the update's state change occurred at the time it was received.  This makes a remote entity's predicted state closer to what it is on the simulator locally simulating it, and helps reduce corrections on future updates.Finally, Road-Based Dead Reckoning performs interpolation between expected and actual state to smooth out errors in the predicted position when an update is received late.3. Interoperability3.1 Challenges to InteroperabilityOne of the major limitations of Road-Based Dead Reckoning is that it made interoperability difficult.  In addition to being a new, non-standard algorithm it was very complex.  The algorithms and logic trees it used to calculate a vehicle's position were sufficiently difficult to explain that it could not easily be re-implemented by another simulation.  Furthermore, the library that performed the calculations had many dependencies and could not easily be integrated into other applications.Several applications used in joint simulations needed to be able to determine the location of entities simulated with the road travel model and Road-Based Dead Reckoning.  Other applications wanted to integrate Road-Based Dead Reckoning into their application to receive the reduced bandwidth usage, increased latency management, and advanced vehicle movement provided by the application.  In most cases, the amount of development effort required to integrate Road-Based Dead Reckoning proved to be too high and the clients decided not to integrate the model into their software.3.2 WorkaroundsIn response to the need for other simulations to be able to determine the position of vehicles using the road travel movement model, two workarounds were developed.The most basic workaround is to publish both the Road-Based Dead Reckoning state data and the standard first-order dead reckoning data concurrently.  This is sufficient for smaller simulations, but is also inefficient.  In terms of CPU consumption, it required constant polling from the simulator running the road travel model to convert that data into first-order dead reckoning information and check the dead-reckoning thresholds.  In terms of bandwidth consumption, it is necessarily worse because it sends the full amount of data required for each movement model.A second, more sophisticated approach is to have a Road-Based Dead Reckoning aware gateway application running.  This application listens to the road travel state updates and then converts them to first-order dead reckoning updates.  By running such a gateway on each LAN in the distributed system, transmission of the first-order dead reckoning updates can be filtered and needs not be sent over the more bandwidth-limited WAN.  This solution also offloads the CPU burden of converting from Road-Based Dead Reckoning to first-order dead reckoning from the generally heavily loaded entity simulators to the machine acting as a gateway.The second solution was not ideal for several reasons.  It was more complex, requiring an additional simulation component and an appropriate network setup.  Furthermore, the gateway received the traffic of all entities instead of benefiting from geographical filtering of entities, which could produce an overwhelming barrage of data.  It is possible to imagine a setup involving multiple gateways assigned a subset of geographical areas of interest, but doing so further complicates the simulation configuration.3.3 Developing an API3.3.1 IntroductionThe dual-algorithm and gateway approaches allowed interoperability in most cases, but had disadvantages as described.  Furthermore, neither approach allowed for simulations not capable of processing Road-Based Dead Reckoning updates to benefit from the advantages of Road-Based Dead Reckoning described in section two of this paper.  Because the road movement model was sufficiently complex that simplifying the algorithm seemed unlikely, it was decided to approach the problem from a software integration angle.  The objective was to develop an easy-to-distribute API that would be simple to use and that had a minimum of dependencies.Developing the API was primarily a matter of trimming extraneous software dependencies and developing an interface class to simplify initialization and utilization of the library.  Three major obstacles to the development of an API were dealing with the network layer, Road-Based Dead Reckoning's expectation of a synchronized clock, and providing the terrain and road network data.3.3.2 NetworkingThe applications the road travel model and Road-Based Dead Reckoning are integrated locally in use a High Level Architecture (HLA) for their network communications, consisting of a runtime infrastructure (RTI) and an object model template (OMT).  Integrating this into the API would greatly increase the number of dependencies.  Furthermore, if the customer uses a different networking scheme, this would greatly complicate integration for them.  As several simulations that interact with simulations that implement Road-Based Dead Reckoning natively communicate using DIS through a HLA/DIS gateway, this is a significant consideration.Instead, the API defines data structures that parallel the network data it expects to receive.  The responsibility for managing network communications is left to the integrating application.  Since the target applications for the API are already interacting with the Road-Based Dead Reckoning native applications, such capability must already exist in those applications.  The client application receives the Road-Based Dead Reckoning updates over its native networking capability, uses the data received to fill out the structures defined by the API, and passes them in to the API as they are received.3.3.3 Clock SynchronizationProviding a clock synchronized with the Road-Based Dead Reckoning native applications was another challenge.  The time synchronization library used by Road-Based Dead Reckoning makes significant use of the applications' networking code, which as described in 3.3.2 is not included in the API.  Furthermore, it requires a millisecond-accurate clock to synchronize.  Three solutions to this problem were considered.One possible solution would be to unload the burden of providing a synchronized clock on the client.  The client would need to maintain a millisecond-accurate clock that was synchronized to the time stamp values included in the Road-Based Dead Reckoning entity state updates.  Unlike basic network interoperability, as mentioned in 3.3.2, this functionality does not necessarily exist in the target applications.  Because this would significantly increase the integration burden on the client, this solution was not used.A second solution would be to isolate the time synchronization library and either include it in the Road-Based Dead Reckoning API or provide it as a separate API, allowing the client the flexibility to use the second API or integrate their own time synchronization as they see fit.  The client would pass network data down through intervening structures as it does with the Road-Based Dead Reckoning state updates.  The synchronization library's dependency on functionality specific to it's normal network layer would need to be removed.  This solution provides the maximum combination of ease-of-integration and functionality.The initial target audience of the API, however, was known to be working in a LAN environment where latency would be very small.  For the initial implementation of the API, instead the library's dependency on a synchronized clock was removed.  The client provides a millisecond-accurate clock that is not synchronized, and all updates are assumed to have occurred at the time they are received rather.  In low latency environments, this produced movement of equal or better quality than the synchronized time method, and in moderate (< 1s) latency the difference in movement quality is largely not noticeable.  Only in high latency environments does the absence of a synchronized clock produce a noticable decrease in movement quality.The isolation of time synchronization library remains an option to further expand the target audience of the API.  Additionally, the Road-Based Dead Reckoning and movement model could be modified to function in a more latency-tolerant environment in the absence of a synchronized clock.3.3.4 TerrainAnother obstacle to the development of the API was the necessity of providing the terrain and road data to the client.  The terrain library that the road movement model uses has a significant number of dependencies, which would vastly increase the size of the API.The road movement and dead reckoning library, however, accessed the terrain library through an intermediate library which had fewer dependencies and used only a subset of the terrain data available.  We overcame the dependency on the terrain library by splitting the terrain accessing library into two libraries.  One library accesses the terrain library directly upon startup and produces a data file based upon the result, and the second library provides the terrain querying functionality and reads from the produced data file instead of the terrain library.  In this way the road movement model need not depend on our terrain library, as long as the appropriate data file is provided.As an added bonus, the data file produced proved relatively small compared to the full terrain database.  The terrain database used during the development of the API, for example, was about 50 MB when compressed while the comparable road data file was under 2 MB.  This allows for easy dissemination of the data files through e-mail, which can simplify providing new terrain data to off-site clients of the API.One other consideration is a common problem in simulations: terrain correlation.  The API provides absolute world coordinates to the client application.  Unless the client application's terrain database's road network corresponds precisely to the road network of the simulating application, the vehicles rendered on the client end will not appear to be driving on roads.This problem is not unique to Road-Based Dead Reckoning.  The same problem existed under first- and second- order dead reckoning.  It is also not an easy problem to address.  Mapping the roads in the data file to the roads in the client's terrain database, for example, would produce illogical results such as vehicles driving through each other or jumping from road to road because the source and target roads would vary in length, positioning, and quantity.For many simulations, however, precise positioning may not matter.  Especially in the absence of human operators and a 3D viewer, the fact that the vehicles do not precisely follow the roads on the client application may be irrelevant.  Other clients may have generated their terrain database from the same data as the road-traveling entities and have proper corresponding roads.  Correspondence could also be obtained by having the road entity simulators use a terrain generated from the client's terrain.The presence of the road terrain data file associated with the API offers one new possible solution to clients that care about precise correspondence.  At the cost of an additional development burden on the client, the client application could be made to combine the API road data with their local terrain database to place roads in the corresponding locations.3.3.5 Future WorkSeveral possibilities exist to improve upon the development effort for the API.  The time synchronization improvements were discussed in 3.3.3 are one such area, as are the terrain correspondence solutions in 3.3.4.  One other major opportunity is to offer client applications the ability to use Road-Based Dead Reckoning on their locally simulated entities.Providing this functionality would require two major additions.  First, the client would need to be able to generate their own road data file.  The ability to load multiple road data files would likely also be desirable, as the Road-Based Dead Reckoning native applications cannot use a road data file as their primary terrain source when loading and may also wish to use their terrain file's road networks.  Neither of these steps would be especially difficult.  The primary development effort would be for the client application to write a library to produce a road data file as defined by the API.A slightly more difficult component would be providing the logic to make the vehicles avoid each other and obey traffic laws.  This would require either the development of an API from the matching libraries on the Road-Based Dead Reckoning native applications or equivalent libraries on the client side.  Alternately, the client could modify their native collision avoidance models to be able to anticipate and avoid collisions under road movement, or ignore vehicle collisions.5. ConclusionInteroperability is an extremely useful trait for a simulation to possess.  Multiple different simulations working together may be able to produce a stronger and more tightly integrated simulation environment than they could produce running independently.  The road movement model and Road-Based Dead Reckoning accomplished their design objectives, but proved difficult to integrate with other simulations.  By producing an API with minimal dependencies and a simple interface, we have provided a way for simulators not possessing Road-Based Dead Reckoning natively to understand updates from vehicles using the road movement model.  Future improvements may make it possible for client applications to produce a corresponding road network or use the road movement model on their local entities.References[1] Moyer, D.  2006.  Obstacles to Producing Realistic Urban Traffic in a Distributed Environment. 2006 Spring Simulation Interoperability Workshop. (SIW)[2]  Moyer, D.  & Speicher, D.  2005.  A Road-Based Algorithm for Dead Reckoning.  2005 Spring Simulation Interoperability Workshop.  (SIW)[3]  Schaffer, R.  1992.  The Applicability of Distributed Simulation Techniques to High Performance Aircraft.  American Institute of Aeronautics and Astronautics.[4]  IEEE Standards Committee.  1996.  IEEE Standard for Distributed Interation Simulation- Application Protocols.  The Institute of Electrical and Electronic Engineers, Inc.   NY, NY.[5]  Ceranowicz, A. & Torpey, M.  2004.  Adapting to Urban Warfare.  Interservice/Industry Training,      Simulation, & Education Conference (I/ITSEC).Generating an API to Simplify Interoperability With Road-Based Dead ReckoningDale MoyerLockheed MartinSimulation, Training, & SupportAdvanced Simulation Center35 Corporate Dr.Burlington, MA 01803HYPERLINK "dale.moyer@lmco.com"dale.moyer@lmco.com, HYPERLINK "dan.speicher@lmco.com"dan.speicher@lmco.comABSTRACT:  	Simulation of urban traffic at the entity level is a difficult task.  The volume of entities in a city can require significant resources to simulate.  The density of these entities combined with modern, large-area sensors such as satellites can foil many divide-and-conquer approaches.  Furthermore, the frequent changes in velocity due to frequent turns and stop-and-go traffic can make it very difficult to provide smooth movement for the simulated entities.	In early 2005, Lockheed Martin Simulation, Training, and Support began development of a dead reckoning algorithm that described movement in terms of roads, in order to improve the scalability and quality of movement for civilian vehicles in a large-scale simulation environment.  This effort was successful, but it posed interoperability issues because other simulations were not equipped with the new algorithm and could not determine the location and velocity of vehicles using it.	Several participants in joint simulations with our software asked about integrating the new algorithm, but the new algorithm had many software dependencies.  The amount of effort required to integrate it caused most of those who inquired about using it to lose interest in doing so.  In 2007, work began on the development of an API for the road-based dead reckoning algorithm.  The intention was to provide a path to interoperability with vehicles using road-based dead reckoning that would require minimal development effort.  This paper details the development of the API including a brief history of the project and algorithm, the objective and requirements for the API, and obstacles to interoperability overcome during development.Figure 3.1 Conversion of Road DR data to world coordinates through the API