The Portico Project: A Funded Open-Source InitiativeMr. Tim PokornyDistributed Simulation Laboratory,University of Ballarat, Australia HYPERLINK "mailto:t.pokorny@ballarat.edu.au" t.pokorny@ballarat.edu.auKeywords:HLA, RTI, Open Source ABSTRACT: Over the past five years the use of Open Source Software (OSS) has become increasingly prevalent in all domains of software development. Of particular note is the level of acceptance OSS has gained in the commercial sector. With the advent of licenses that are designed specifically to permit the use of OSS along side proprietary code, more and more commercial applications are beginning to leverage the significant benefits these free alternatives provide.Open source projects have the ability to provide numerous advantages over their proprietary counterparts. Apart from being free of licensing costs, they provide users with the right to modify and redistribute the project according to their requirements. Further, open source projects tend to be more agile and responsive, especially with regard to bug fixes and the development of cutting edge features.Despite these advantages, the use of OSS within the HLA community has been noticeably lacklustre. However, a small number of OSS-based projects are now beginning to appear and their use is starting to increase. One such example is the Portico Project. Portico was founded with the goal of producing a high quality open source Run-Time Infrastructure (RTI) that addressed addresses many of the common shortcomings of open source projects (such as reliable long term support, useability issues, testing and a systemic lack of documentation). Realizing the potential benefits such a project could provide, the Australian Defence Force (ADF) have has provided funding to aidfor continued long term in the development and support of Portico, so that it becomes and to help turn it into a professional quality RTI implementation that can evolve to become a drop-in replacement foralternative to current commercial offerings. This paper describes some of the key features provided by the Portico Project along with the community development and professional support plans.1. IntroductionThe popularity of Open Source Software (OSS) is well and truly on the rise. Over the past 10 years, OSS has begun to gained more and more acceptance within commercial environments. While some still view such endeavours as the domain of enthusiasts or hobbyists, such standpoints ignore market realities and entirely discount the extremely large companies making significant profits for thethrough sale, support and services of open source solutions. Be it the common lack of exposure to OSS environments, or a lack of imagination on behalf of such view holders, these perceptions still manage to persist – even in domains demanding a largely technical background (places where OSS traditionally fares well).The focus of open source software is freedom. While many people continue to view OSS purely as a source of cheap solutions, much of the IT world is beginning to understand the broader realities. OSS is not zero-cost software. Like all software packages, open source demands an investment of time and effort by the user [1], neither of which is free. For a variety of reasons, many open source projects have gained a reputation for being difficult to deploy or arduous to maintain. While there are situations in which this is most definitely true, a large proportion of open source projects now provide user experiences that either meet those of proprietary alternatives, or vastly exceed them.Within the distributed simulation domain, the availability and use of open source software has generally been minimal [2]. However, as time progresses, a small number of open source projects have begun to emerge, primarily focusing in Run-Time Infrastructure (RTI) implementations. In addition to a brief introduction to the benefits and problems of OSS, this paper focuses on the Portico open source RTI project.2. Open Source SoftwareOpen source software is about freedom. Many people misunderstand this to mean purely the provision of access to the source code of a software system. Although such access is an integral part of the open source philosophy, the concept of freedom extends much further. Implicit to OSS are a number of additional freedoms that are not associated with proprietary alternatives.Freedom to modifyThe right to modify the source code of OSS is essential. Users can alter, improve or customise a piece of software for their particular use as they see fit, or as their requirements demand [3].Freedom to distributeWhile the right to access and modify OSS is perhaps the most well known, a user also has the freedom to redistribute a piece of software as they desire [3]. This freedom doesn’t just relate to situations in which modifications are made, but to all general cases. Often times, a user may wish to distribute a piece of software that their application depends on. Under a proprietary license, this action would be prohibited, increasing the installation complexity and effort required to deploy and maintain such a piece of software.Freedom to contributeOpen source software is a community driven life form where participation isn’t restricted to “gold partners,” or those with enough money to ensure they are heard. All users, regardless of size, power or standing, are free to contribute to a project. In cases where project maintainers decide that they do not wish to accept a particular contribution, the user is still free to use or provide a version of the software with their desired enhancements.Open source is about community. A group of people, motivated by a common set of problems, work together to create a shared solution. Unlike proprietary software, which is closed off entirely from its users, the rights of an individual or group within an open source project are determined by their level of participation.As many people are coming to realise, participation and contribution are not restricted to the development of application code. Increasingly, contribution comes in many other forms. The identification and reporting of defects, or the act of helping other users with their problems both constitute welcome and appreciated contributions.2.1 Open Source AdvantagesThe advantages of OSS have been widely documented. In this section we will take a brief look at some of the major points.AgilityOpen source projects tend to be much more agile than proprietary alternatives. The development of proprietary software is closed off from its users, and as such, they are forced to wait for the next major release of a piece of software in order to benefit from bugs fixes or enhancements. As the source code of OSS projects is made publicly available on an ongoing basis, users are able to gain access to (and begin benefiting from) unreleased software the moment it has been created. Further, innovation in open source software tends to occur more rapidly as contributors are drawn into the lightweight development environment. Although distinguishable structure and hierarchies exist in many open source projects, the overhead is often much lower when compared to layers of management often associated with commercial competitors [4].User Driven DevelopmentOSS development tends to focus on the concrete needs of its user base, rather than collapse into some relentless pursuit of adding more and more unwanted features. Indeed, the development of a solution for a specific user problem is the typical motivation for an open source project, and is generally how they come into existence [5].Beyond this, a user is a first class citizen in the open source environment. In situations where a user has a specific requirement, they are generally able to submit a feature (or bug fix) request to a proprietary vendor. Whether or not the problem will ever be addressed (and the timeframe in which it may be done) is entirely at the vendor’s prerogative. While this is no different from an open source project, in a proprietary setting, the user is left with no choice but to comply. In an open source environment, a user is still able to leverage the existing work and build their specific enhancement or bug fix themselves, rather than be held hostage by a closed codebase. OpennessThe open source development process is much more open to its community. Direct access is provided to the primary development group and users have a far greater ability to help shape the future direction of a project. Many users coming from a proprietary background often see this as an opportunity to leverage free labour and get their specific needs met. However, this is most definitely not the case.As mentioned above, the rights of a particular user or group are dictated by their level of participation within a project. Those whose only contribution is to try and push development in a direction that fulfils their individual needs will quickly be ignored (if doing so doesn’t align with the goals of the larger community). However, even in this situation, such a user is still free to make the desired modifications themselves, and by contributing them back to a project, they can begin to build standing within the community and gain the benefits of this. In this regard, open source software is rarely free.User RightsOpen source licenses exist to inform a user of what they can do; proprietary licenses exist to tell them what they can’t. Open source software grants you the freedom to use it as you see fit [6], where proprietary software grants you the freedom to use it as your vendor sees fit. The obvious problem with this is that a vendor requires you to use their software only in ways that best serve and protect their position, regardless of your individual needs or requirements. As a user of open source software, you have rights that are not eroded by a continual stream of disclaimers in an ever-changing end user license agreement.2.2 Open Source ProblemsAlthough capable to of providing many compelling and significant advantages, open source projects typically suffer from a number of problems. These issues generally have little to do with the functionality of the software in question, and more to do with the supporting project management infrastructure. This section introduces some of the common difficulties often associated with open source software.UseabilityUseability is an often-cited problem of OSS. By and large, open source projects are voluntary efforts. As such, the primary focus of development seems to be the core features. Periphery issues such as the “user experience” are often ignored entirely. Exacerbating this problem is the fact that developers posses possess an intimate knowledge of their system and often haven’t the time to think about the problems of new users. Often times, simply getting an application installed and running is the most difficult hurdle to overcome.Whereas these types of problems are quickly identified and rectified in commercially funded software, Quality Assurance (QA) processes are often omitted in OSS. Given the voluntary nature of open source, this is generally expected. Developers are initially driven to create a project either out of their need to meet some particular problem, or out of a desire to work on interesting problems. Ensuring that installation procedures are simple enough for new users, or performing proper QA in order to find bugs before an application is released are not highly interesting activities when compared to the primary development of new features. As such, the number of developers offering their limited time to perform these mundane (yet vitally important) tasks is limited [7].DocumentationOne of the most common and persistent criticisms of open source software is a seemingly systemic lack of documentation. If an application we were excessively simple to use and easy to install, perhaps this shortcoming could be forgiven. However, as mentioned above, OSS also tends tocan suffer from useability issues.While a lack of documentation is not an affliction demonstrated in all open source projects, cases of good documentation tend to be few and far between. Many projects even forgo any form of documentation entirely! Even in situations where it does exist, open source documentation has a reputation for being sparse, of poor quality and generally difficult to use. The results of this situation are predictable. Without documentation, even the most feature-packed and polished application will provide a user experience that betrays the effort put into its development. If a user can’t find answers to simple questions, they have no choice but to ignore a project under the assumption that it cannot meet their needs. Even in situations where they do persist, without documentation explaining the features of an application, they may never use it in more than a rudimentary fashion, invalidating all the hard work spent developing many features.SupportOpen source project developers are busy people. The voluntary nature of open source development means that many “optional” elements of software development (often defined as everything except the main code) are ignored. Among these is proper support. The open source software ecosystem is predicated on the concept of community. As such, support around open source projects tends to be more informal than commercial equivalents. If not pursued through the correct channels, requests for help or support can often go unheard or missed. The main problem is that there are many potential collaboration tools that can be used for project coordination and support, and each project has its own standards [8].Identifying these channels can often be difficult due to a lack of clear documentation or the confusion that can be caused through delayed responses as the demands on a developer’s time vary. The only remedy for this situation is the clear marking of support resources and some understanding on behalf of a user. If a project community grows sufficiently, at some point it will become large enough that users will be able to help one another.Beyond basic user support, further services are also required in order to foster an open nature of development. These include some form of access to current and future projects plans, a forum in which users can contribute their thoughts and a central location where bugs and feature requests can be recorded and tracked. Sadly, again, open source project administrators often ignore many of these facilities, and this serves only to restrict the growth of a community around a project.Expectations MismatchProprietary software has created within users an expectation about how they interact with software producers. A vendor creates an application that a user then buys and uses. Beyond this, there is little interaction between the user and the developer. If a user encounters a bug, they generally won’t contact the vendor (but will rather assume that it will be fixed later). The level of interaction between vendor and user is minimal.On the other hand, an open source model is far more interactive. Developers expect users to report bugs or problems, and to discuss potential new features directly with them. One of the major strengths of open source is that any user can get direct access to the primary developers and help influence and improve the evolution of a product. People used to the disconnected atmosphere often observed around proprietary software are generally not prepared for the culture shift involved in open source software. Users often view it as nothing more than a vehicle for obtaining free applications, and tend to fall back into their disconnected ways. As has been stated over and over, open source software is about community, and the only way to extract the full value from a project is to get involved by reporting bugs, making feature requests and helping others.The problems of expectation mismatch do not flow in only the one direction. There is a common misconception among many software developers that starting an open source project will give them access to a large pool of other developers from which they can draw help (build it, and they will come) [8]. This is quite simply not the case, and as such, a great many projects lay abandoned because their creator did not get the response they expected.Most successful open source projects are lead by a small number of developers who have a strong desire to see it succeed. The building of an open source community takes time and requires much dedication and hard work from this core team. Simply releasing some code as open source and expecting “the community” to pick it up will only result in a silent fall.LicensingPerhaps the single biggest obstacle to a broader use of OSS is are the licensing model’s models they typically employ. Within the wider business community, there is a perception that open source licenses are viral and a source of significant legal risk [5]. In some circumstances these perceptions are valid, in particular, with regard to the GPL license.Less restrictive open source licenses that allow a user to do virtually anything they wish with open source software (including use it in commercial products) have always existed. However, as the business community has come to understand and accept that open source communities can provide sizeable benefits, newer licenses, aimed at alleviating many of the legal concerns involved with combing combining open source and proprietary software, have become popular.Licenses such as the Common Developer and Distribution License (CDDL) or the Mozilla Public License (MPL) aim to protect the efforts of open source developers, while still permitting the use of open source software within proprietary applications.The essence of these licenses is that they permit covered applications or libraries (in an unmodified format) to be linked to, and distributed with, proprietary software [9]. However, should the open source code need to be modified or altered in any way, those alterations would need to be released as open source. It is important to note in this situation that only the alterations would need to be released, not the source of a product that uses them.This provision helps protect the open source project from exploitation by a vendor who seeks to add proprietary customisations to a project, yet still allows closed-source applications to make use of open source software without requiring that they to too become open source.2.3 SummaryThe common thread running through each of the shortcomings presented here is that of structure. Given the informal nature of most open source projects, many fail to provide the adequate structure and facilities required to grow a community. There is a fundamental misunderstanding among many open source developers that “if they build it, the community will come”. Nothing could be further from the truth, and neglecting to address and provide the adequate resources and structure necessary to bring people together will only ever lead to failed projects.OSS has long been missing from the HLA and distributed simulation domains. While the use of open source software such as Linux have enjoyed pervasive use within the community (as in the broader computing world), I am referring more to the prevalence of open source tools that target the distributed simulation environment. It is only recently that some true open source projects have begun to appear and gain use. One such project is an open source Runtime Infrastructure (RTI) implementation: Portico.The next section discusses how it is structured (both architecturally and socially) to realise the advantages of open source, while avoiding the many shortcomings discussed here3. An Open Source RTIThe Portico Project focuses on the development and distribution of a high-quality, cross-platform RTI implementation. While a major goal of Portico is to provide a free RTI that can be used to build and run HLA-based distributed simulations, the primary goals extend much further.Portico is motivated by a desire to connect a community. A primary design feature of Portico is its modular, extensible architecture (introduced below). Considerable work has been put into developing an architecture that can facilitates extension and vastly simplify simplifies the development of plug-in behaviour. Users are not only free to alter or extend the RTI for their specific needs; but the framework employed also actively supports them.The motivations for this are two-fold. Firstly, unlike proprietary RTI implementations, this approach supports users who have a desire to create and share uncommon or novel extensions. No single group or company has the time or resources to explore all the potentially interesting roads that may lead to significant functionality enhancements. Where proprietary approaches aim to limit and restrict a community’s ability to collectively investigate new feature ideas, the Portico Project aims to support and encourage it.Secondly, Portico is designed to actively support research. Despite a strong academic presence within the distributed simulation community, too often, valuable research is lost because it holds no direct, standalone commercial interest. In this respect, the provision of an open, extensible infrastructure can help provide a shared environment in which research can be undertaken, with the results easily leveraged by the community. Broadly speaking, the Portico Project is designed to facilitate and support innovation.While the architecture employed has been designed to assist extension, the license chosen for Portico has also kept in mind the fact that not everyone prefers open source. As such, Portico is licensed under the CDDL. This affords users all the benefits of an open source project (such as the right to redistribute), while also allowing extension developers to keep their work closed-source if they so desire. Naturally, the developers advocate a fully open approach, but ultimately, this is an individual choice to be made on an individual basis.The remainder of this section will briefly outline some of the primary features of Portico and introduce its basic architecture. Following this, the community aspects and facilities of the Portico Project will be introduced and discussed in the context of the common problems highlighted in section 2.3.1 Portico Technical OverviewBefore delving into an overview of the internal structure of Portico, it is important to outline the basic features it provides. Although there were many motivations driving the project, one of the primary goals (quite obviously) was to create a functional, easy to use RTI implementation. After all, what good would an RTI be if it could not behave as an RTI?3.1.1 Portico Technical OverviewThe Portico Project provides various Java interfaces implementing the core HLA standards: 1.3 and IEEE 1516-2000. Additionally, a compatibility library is provided to mimic the interface often used with the older DMSO RTI-NG (in the hla.rti13.java1 package). A HLA 1.3 C++ interface has also been developed, first released in August 2007. Although a number of interfaces are provided, not all of the HLA services are implemented. The set of HLA features implemented as at July 2007 includes:Basic Services (create/destroy)Synchronization ServicesPublish and Subscribe SupportObject Creation, update and RemovalInteraction SendingTime Management (not including optimistic)The key features missing from this list are support for Data Distribution Management (DDM), Ownership Management and Save/Restore support. However, as with all open source projects, Portico is a work-in-progress.3.1.2 Architecture OverviewOne of the primary purposes of the Portico Project was to develop an RTI implementation that could function both as an RTI for general use, as well as a flexible environment in which extensions could be quickly developed, and easily deployed (be they for research or other purposes). As such, a significant amount of effort has been put into the creation of an underlying architecture to support this objective. Figure One represents a conceptual overview of the Portico internal framework.While the actual implementation of Portico is somewhat more complex (having to deal with things like multiple execution threads), figure one outlines the concept. This diagram shows how Portico consists of a series of Message Sinks.Everything that requires processing in Portico is packaged as a message. When a federate makes a request on the RTI, it is packaged up as a message and sent through a series of Message Sinks. That request may in turn trigger a federate callback, destined for its Federate Ambassador. This callback is also packaged as a message and sent through a series of sinks until it arrives at its destination. The purpose of a Message Sink is to provide some sort of processing structure that can work on any given message.Within each Message Sink is a number of Message Handlers. The job of these handlers is to perform the actual processing of the various messages that pass through the sink. When a message is passed into a sink, the appropriate handler for that type of message is selected and asked to process it. Figure two (below) shows how a Message Sink is structured.Message Handlers don’t have to be a single unit. In situations where more than one message handler may want to work on a particular type of message, they can be arranged into chains. As figure two shows, when a message is passed into and out of a sink, it will go through two such chains before being passed to the designated handler for that message type (which may be a chain itself).It is this simple, message-based structure that provides Portico with much of its power and flexibility. As a message passes through the Portico framework, many handlers may intercept it, each of which can perform some part of the processing necessary to fulfil the request. For example, as a message passes through the LRC-Request sink, some basic error checking might be performed before the message is sent to the RTI. However, the actual processing of the request will be left for the RTI-Request and possibility the RTI-Action sinks to handle.One important point to note is the separation of the RTI itself into two distinct sinks (with a queue in the middle). This is necessary as the asynchronous HLA model necessitates that the RTI perform work outside the scope of a single request. The RTI must acknowledge to the LRC that the message has been received, but it does not wait until all the work for that request has been done before returning this acknowledgement.So that information can be sent back in response to the initial request, an extra request is placed on a queue for later processing. This allows the handlers in the RTI-Request sink to finish processing by passing back an acknowledgement that the request was received (or even some additional information), without having to wait for the complete processing of the request. This process is very much like hardware interrupt handling in the Linux kernel. When an interrupt is received, a handler takes care of all the immediate needs, before deferring the more intensive processing to a “bottom half” that is executed later [10].3.1.3 Modular and FlexibleYou may have noticed that the architecture in figure one sheds little (if any) light on the manner in which HLA requests are processed. While it does introduce the notions of an LRC and RTI, nothing more is mentioned. Where is object registration information stored? How is time advancement calculated? Where is synchronization point information stored? Is Portico centralized or fully distributed?The list of possible questions could go on and on, and the reason for it is that the actual HLA behaviour provided by Portico has nothing to do with its structure. The fact that Portico even does “HLA” things is purely a by-product of the default handlers that are packaged with it. This characteristic is important for two reasons:Firstly, it demonstrates the modularity of the framework. If you wanted a system that didn’t respond to various types of requests, you could omit the handlers that process them. If you wanted to alter the existing behaviour, you could replace or augment the existing handlers with a set that met your needs. Further, if you wanted to extend the basic functionality provided by Portico, you could develop a suite of additional handlers and package them in a single module that could be deployed alongside any Portico installation.Secondly, it is not linked directly to the HLA. This means that the Portico framework could support non-HLA behaviour as a simple matter of course. One such example is provided by the Portico Console project [11]. Implemented by Michael Fraser, the Portico console is in effect a federate replacement. It excludes an LRC altogether and communicates directly with the RTI. Internally, the console uses the same messaging primitives used by Portico in order to support extensions of its own. It does not take much imagination to create a lengthy list of periphery tools that could benefit from the infrastructure provided by Portico.Modularity and extensibility within Portico is not limited to the processing of messages. Modularity also extends to the method of communications used between federates and the RTI. Internally, the LRC and RTI are shielded from the details of how messages are exchanged between them. This allows communications bindings to be developed and deployed without giving any consideration to the fact that they are transporting HLA-style requests and callbacks. To date, two such bindings exist.The default binding supports the typical model of communications where the federate and RTI communicate across a network connection. However, for situations where extremely low I/O overhead is required, a “JVM” (or “shared memory”) binding has been developed, allowing federates to be executed as separate threads in the same virtual machine as the RTI (with testing showing dramatic performance improvements). Given the shielding provided by the Portico framework, federates using different communications bindings are free to work together within the same federation.As exciting and useful as this feature is, there are situations in which this facility can be used to violate expected HLA behaviour. For example, if a binding that communicated all messages over an unreliable protocol was deployed, there would be no way to guarantee that messages described within the Federation Object Model (FOM) as “reliable” would be sent over a reliable connection. While this is an unfortunate side effect of the Portico model, it is easily avoided by ensuring that only a suitable binding for one’s requirements is used. Finally, a facility known as Bootstraps allow arbitrary threads of execution to be started within the RTI. Primarily used by communications bindings as a mechanism to start listening for requests, they could be used for any purpose (perhaps the starting of an embedded database or web server).3.2 Portico Social / Community FeaturesAs discussed in section 2 of this paper, when it comes to non-technical aspects, open source projects have earned a reputation for falling short in a number of areas. As important as the facilities and features discussed in the previous section are, if the experience of traversing project documentation or attempting to gain some kind of support were so terrible that it caused otherwise sane people to run screaming from their houses, the project would be a failure.The lifeblood of any open source project is its community, and while many choose to ignore this reality, the expectation that building a piece of software is enough to make it popular is an all too common myth in the open source world. To grow and thrive, a community needs access to documentation and shared spaces to come together and interact. Hopefully learning from the common mistakes of other open source projects, this section describes the community-oriented services put in place to support Portico.3.2.1 DocumentationIt is a familiar stereotype of open source projects. They may be functional and useful pieces of software, but there is such a lack of documentation that nobody outside of the development team can figure out how to use them. Addressing this problem involves two steps:Write documentationUse a collaborative toolAs helpful as it is, documentation is not much fun to write. In an environment that is primarily driven by volunteers, tasks that aren’t fun are generally forgotten. Unfortunately, projects that aren’t documented are also generally forgotten. The only genuine remedy for this is to swallow the bitter pill, put the compiler down, and start writing some useful guides. This has been a particular focus of Portico to this point and a considerable amount of documentation has been produced. Extending on this, some funding (discussed later in this paper) has helped to grow the amount of documentation aimed at developers.While some documentation is an advantage, effort must be put into ensuring that it is both easy to navigate and edit. It is one thing to have documentation, but a user needs to be able to find the piece that helps them with their problems. While including a Frequently Asked Questions (FAQ) document is essential in this process [8], the structure of documentation is also important. The Portico Project website attempts to make it easier on a potential user by dividing documentation into two main categories: documentation aimed at the user, and that aimed at potential developers.Although documentation is seen as a chore for the people most interested in writing software, there is one group of users among whom it is given much more importance: users. Providing facilities that allow documentation to be easily created and edited vastly reduces the barrier to entry and opens the possibility of user-contributed documentation. Wiki’s (the software used to power sites like Wikipedia) are excellent for this. Expectations should remain limited however, and assuming that someone else will come along and document your entire project is quite obviously foolish. That said, the most a project administrator can do is put in place the facilities that make this as simple as possible, and Portico follows this ethos.  3.2.2 Different Levels of SupportNo matter how good the documentation for a project might be, users will always have questions. In this case, it is vital that clearly marked paths to the places they can get this help are defined. Additionally, provisions must be made for the different ways in which people prefer to interact with a project.Beyond documentation, the primary mode of support provided for Portico is through online forums. While mailing lists are the de-facto form of support for open source projects, when considering the population at large, mailing lists are foreign to many users. Web-based forums provide a much simpler interface and still retain the benefits of being persistent and searchable. This is especially important, as the best way to solve a problem is to find someone who has already solved it. The forums allow users to search the problems of others, and find solutions they can employ right away.In addition to providing some form of persistent, searchable support, many users like to interact with an open source project in a more real time fashion. To support this kind of interaction, Portico has recently begun providing support for IRC. Whether it is formal requests for help, or just a venue in which to make contact with the development team, the ability to chat in real time with developers adds an important human aspect to the project and demystifies the environment. Developers are people too.Finally, when all other avenues of support fail, and a user has come up against a problem that cannot be overcome because of either a bug, or the lack of a feature, facilities must be provided to alert the development team. Further, these facilities must allow the user to participate in the process of rectifying the situation. The Portico Project uses a centralised issue tracker that provides support for email notifications. In this way, a user can register a bug or make a feature request, and they can be notified by email when some action occurs. This interaction helps a user keep in touch with the project, and allows them to gauge the progress of a given bug or request. It may only be a little thing, but it is much preferred to the typical process of submitting a request to a vendor and having to wait for version after version to see if anything was ever done about it.3.2.3 Open DevelopmentAdopting open source software means a lot more than applying a new license. Open source development involves opening up the process to people beyond the core development team. A major advantage of OSS is the level of interaction users can have with a project. While commercial activities tend to wall off users from participating in this process, open source projects should actively seek their involvement. While most will rarely avail themselves of such facilities, the spirit in which it is offered goes a long way to creating a better user experience. Even if users are not actively involved, they should still be able to obtain information on the current state of development.To truly support an open development process, a project should focus on three main areas:Keep people informed of current developments and plansProvide a venue where plans can be discussedAllow users to see progress (no matter how slow it might be)In Portico, people are kept informed in many ways. The documentation provides a roadmap that outlines the broad plans for development in upcoming versions. To augment this, there is a separate section on the forums that provides a dedicated venue in which development activities can be announced and discussed. Finally, an “announcement” mailing list is maintained. Periodically, updates are sent to this list so that its subscribers can keep abreast of developments. The online issue tracker is provided as the primary mechanism for tracking development progress. Each item of work has a dedicated issue (be it a bug, task or feature request) that can be tracked independently. Users are able to sign up for notifications on a per-issue basis, rather than having to sift through an avalanche of updates for the information they are interested in. Further, each issue can also be marked with the intended version in which it will be addressed, allowing users to see the current priority of a given task (and haggle with the developers as necessary). Once again, the support facilities (forums and live chat) provide a direct link from the community to the core development team. Questions about progress or the submission of contributions can be asked and answered through these services in a rapid fashion.3.2.3 UseabilityExtensive work has been put into making Portico as usable as possible. The suite of community tools discussed here serves to make the overall experience of using Portico (from installation to getting help) as simple and effective as possible. While each facilities itself may not make a dramatic difference, the combination of tools provided have been assembled to encourage user feedback and participation. All these facets help to make it as easy as possible for people to become involved (in whatever capacity) and build a stronger sense of involvement and community. While they are by no means a guarantee of success, they do help increase its likelihood and overcome many of the problems typically associated with open source software.Finally, a facility known as Bootstraps allow arbitrary threads of execution to be started within the RTI. Primarily used by communications bindings as a mechanism to start listening for requests, they could be used for any purpose (perhaps the starting of an embedded database or web server).3.3 Funding and Commercial SupportOver its lifetime, the Portico Project has attracted significant attention and interest from the simulation community. Realizing the potential benefits of that a freely available, freely extensible and freely distributable RTI implement could provide, the Australian Defence Simulation Office (ADSO) have has provided some funding to help turn Portico into a professional quality RTI implementation that can evolve to becomeinto a drop-in replacementviable alternative for current commercial offerings.This money is being used to extend the feature set offered by the Portico and to help provide all the elements often associated with a professional software product that are often missing in the open source environment. Many of the endeavours discussed here are being directly supported through this funding.Beyond the provision of funds to help development, this contribution shows that unlike many open source projects, Portico is being taken seriously enough to warrant such expenditure. This reinforces an original goal of the project: that was to establish an RTI implementation capable of supporting real people doing real work.3.3.1 Commercial SupportUnquestionably, one of the biggest advantages any commercial solution has over an open source alternative is the availability of commercial support. Inherent to the open source model is the idea of contribution. If a particular user has a problem, they bear the entire burden of addressing this. Where commercial support is not available, organizations must invest more heavily in internal resources to get them to a level capable of fulfilling their support needs (and this is typically the case when OSS is used). However, in instances where commercial support is available, users are able to access a channel of expert assistance. The continued demonstration that Portico is a serious project capable of supporting critical developments has helped raise awareness of the need for the provision of commercial support. It is anticipated that by the end of 2007 arrangements will have been made that will see commercial support for Portico become available by the end of 2007.4. ConclusionThere is nothing new or groundbreaking within Portico. The concepts that have been used in its implementation exist in many forms and within many other software systems. However, the Portico’s particular combination usedimplementation, in addition to the freedoms provided by the open source license, help to create an exciting environment in which users can be supported and research can be freely undertaken and distributed. For those people not interested in such pursuits, Portico still represents a freely available RTI that may also provide additional value through the extensions developed by others.5. References[1] Pearce, T. (2006) Potentials and Constraints for Open Source regarding Standard Developments (Presentation). Academic Evening, 2006 Fall Simulation Interoperability Workshop[2] Pokorny, T. (2006) Open Source and the HLA: I Swear it's Here Somewhere In Proceedings of Fall Simulation Interoperability Workshop. Paper-ID: 06F-SIW-035[3] The Open Source Definition. URL:  HYPERLINK "http://www.opensource.org/docs/definition.php" http://www.opensource.org/docs/definition.php (retrieved on Jan 19, 2007)[4] Webber, S. (2004) The Success of Open Source. Cambridge, Massachusetts: Harvard University Press[5] Feller, J. & Fitzgerald, B. (2002) Understanding Open Source Software Development. London: Addison-Wesley[6] Stallman, R. (1994) Why Software Should Not Have Owners. URL  HYPERLINK "http://www.gnu.org/philosophy/why-free.html" http://www.gnu.org/philosophy/why-free.html (retrieved on Jan 19, 2007)[7] Lakhani, K. & Hippel, E. (2002) How open source software works: “free” user-to-user assistance. Research Policy (32), 923-943[8] Fogel, K. (2006) Producing Open Source Software. Sepastopol: O’Reilly Media[9] Laurent, A. (2004) Understanding Open Source & Free Software Licensing. Sepastopol: O’Reilley Media[10] Love, B. (2005) Linux Kernel Development (2nd ed.). Novell Press.[11] http://porticoproject.org/index.php?title=Portico_ConsoleAuthor BiographiesTIM POKORNY (by day) is currently a PhD student at the University of Ballarat, Australia investigating approaches to expanding the use of the HLA into the wider business community. By night, Tim is an open source developer, working on projects such as theincluding Portico.Figure Two: Message Sink StructureGlobal Post-Process Handler ChainGlobal Pre-Process Handler ChainMessage Handler or ChainFigure One: Portico ArchitectureQueueRTISideClient / FederateSideCommunicationsBindingRTI-ActionMessage SinkLRC-CallbackMessage SinkRTI-RequestMessage SinkLRC-RequestMessage SinkLocal RuntimeComponent1.3/1516