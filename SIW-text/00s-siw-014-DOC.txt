Lessons Learned While Using a ComponentFramework to Reconstruct a Legacy Analytic ModelKimberly NeffTRWOne Federal Systems Park DriveFairfax, VA  22033703-968-2094kimberly.neff@trw.com Stéphane VermetteVirtual Prototypes, Inc.4700 de la Savane, Suite 300Montréal, QC  Canada  H4P 1T7514-341-3874 Ext. 267vermette@virtualprototypes.ca Keywords:Legacy model, HLA, component framework.ABSTRACT: An event-driven analytic model, developed by the U.S. Government, was reconstructed and extended to evaluate the benefits of a component framework.  This Microsoft Excel model, developed over four to six staff-months, is referred to as the Combat Identification (CID) model in this paper.  It supports statistical analysis of combat identification scenarios under a variety of conditions.  The methodology of this model was preserved and the new implementation allows the model to run as part of a High Level Architecture (HLA) federation using an agent-based architecture and dynamic objects.  The resulting model is called the Proof-of-Concept (POC) application.  Extensions to the POC application implemented command and control functionality with hooks for movement and provided insights to a commander’s perception of the battlespace.This work was performed under contract to the U.S. Government as a means to evaluate the suitability of the component framework, Sequoia, for rapidly prototyping analytic models and for achieving HLA-compliance of new and legacy models.  This paper provides an overview of the CID model and the final POC application.  It also describes the Sequoia components used for this work and the lessons learned about the suitability of Sequoia for rapid prototyping of HLA-compliant simulations.IntroductionThe U.S. Government runs a variety of analytical models to answer a myriad of questions about war fighting.  When satisfactory legacy models are available, they are used.  New models are developed with the appropriate assumptions and initial conditions, when needed.  Each model is merely a tool in the analyst’s toolbox.  Some times a single tool will do the job and other times a combination of tools are required.  When new models are needed, they must be developed quickly.  Therefore, the U.S. Government must have a capability for tying models together quickly and easily, and for rapidly developing new models.Sequoia is a product under development by Virtual Prototypes Inc. (VPI).  The U.S. Government became interested in this product and hired TRW to perform an evaluation of this product with respect to rapidly prototyping analytical models and achieving High Level Architecture (HLA)-compliance of new and legacy models.  To support an effective evaluation, the U.S. Government provided a legacy Combat Identification (CID) model to TRW.  During the evaluation, TRW was to reconstruct this model within the framework provided by Sequoia.  This paper describes the original CID model, the application resulting from the reconstruction, the Sequoia components used for this work and the resulting lessons learned.Project SynopsisThe first phase of the project focused on requirements definition.  Using a variety of documents provided by the U.S. Government in combination with discussions with one of the government analysts, a set of requirements was developed that described the government’s needs for a tool supporting analysis through rapid development and the ability to achieve HLA-compliance.  Based on these requirements, a basic reconstruction of the CID methodology was created using Sequoia.  Then a set of modifications were made to this basic model in a series of subsequent extensions to allow further evaluation of the technical capabilities and applicability of the Sequoia framework for military analysis.  The implemented extensions do not necessarily maintain the sound logic of the original model and may contradict some of the original assumptions, but allowed new components of the framework to be evaluated against the requirements.  These additional requirements included HLA-compliance, visualization capabilities, and interactions with other applications.  The government prioritized extensions involving Command and Control functionality and the perception of ground truth to ensure the key requirements would be addressed to the extent possible with this model.  The resulting application, including the modifications, is called the Proof-of-Concept (POC) application and was constructed using Sequoia in less than five months.  Monthly demonstrations of the POC application were made throughout the second half of the six-month project.Methodology of the CID ModelThe event-driven analytical model provided to TRW by the U.S. Government was developed using Microsoft Excel.  Throughout this paper, the Microsoft Excel implementation of this methodology is referred to as the CID model.  This statistical model relies on Bayes’ Theorem, a set of input probabilities, and on the definition of red and blue areas within a battlespace to perform engagement-based calculations for analysis of combat identification. Over 25 spreadsheets contain the definition of the battlespace, the probability tables and the simulation results.Each engagement begins with the random selection of a firer and a target.  Because of the random nature, fratricides (i.e., red on red or blue on blue engagements) are just as likely to occur as red on blue or blue on red.  Once the firer and target are identified, a series of calculations are performed using input probabilities for blue and red forces to determine how the firer would perceive the firing posture, orientation and movement, and whether the firer would visually or instrumentally identify the target as a friendly or an enemy.  Once these probabilities are established, an overall P(Enemy), probability of perceiving the target as an enemy, is calculated using Bayes’ Theorem.  Based on the initial rules of engagement for the firing force, the P(Enemy) is categorized as Enemy, Probably Enemy, Unknown or Friendly.  Shots are fired at enemies and a probability of kill is used to determine whether the shot hits or misses.  A logarithmic formula is used to determine how much time elapses for the engagement.The simulation runs for a predefined amount of time.  The user specifies the number of runs to perform in a single trial and how many trials to perform.  The random number seed is changed for each run and the input parameters change for each trial (e.g., the rules of engagements may be loosened).  Run results are averaged to generate trial results.  Results are presented in a combination of tables and charts and contain information regarding the numbers of hits and misses for blue on red and red on blue engagements as well as fratricides and near fratricides.The model was developed over four to six staff-months.  It has a strict set of assumptions and is difficult to modify due to the nature of the Visual Basic routines used to drive the simulation.  No clear execution order exists because all the spreadsheets can be updated with one Visual Basic command at any time.  The model is obviously not HLA-compliant and cannot be easily linked to other models.  Of course, the model does provide quick answers since multiple trials of many long runs can be executed in minutes. However, it has a significant learning curve for an analyst trying to understand the many inputs and their dependencies.Architecture of SequoiaSequoia is a component framework, which attempts to speed development by providing a set of libraries and components commonly needed for development.  Developers may add additional libraries and components.  Three integral elements provided by the Sequoia framework are the Presentation, Abstraction and Controller (PAC) agents; a dynamic objects system (DOS); and the Distributed System Infrastructure (DSI).  An additional component of the Sequoia framework is the PAC Visualizer.  Ultimately, an integrated visual development environment, called the Simulation Designer, will provide the user with the ability to dynamically interact with visual editors to modify agents and objects.  This component will speed the development process, but this project was performed without the benefit of the Simulation Designer.PAC AgentsIn Sequoia, agents have three facets: presentation, abstraction and controller; thus, they are called PAC agents [1].  The presentation facet handles the interface to the user; not all agents will exercise this facet.  The controller serves as the interface from one agent to another and maintains the state of the agent.  Finally, the abstraction performs the agent’s tasks in accordance with a finite state machine.  Agents receive events through the controller and the controller activates the abstraction.  Agents may provide behaviors for an object or perform operations on a group of objects.  The object-oriented nature of Sequoia allows the user to replace one agent with another or merely substitute one abstraction for another, e.g., to change the fidelity.  Adding agents or substituting abstractions adds functionality without requiring major changes to an application.  Many of the requirements for this project focused on evaluating the real flexibility of PAC agents [2]. Figure 1: Conceptualization of a PAC AgentA very powerful component, PAC agents may be organized into hierarchies with parent-child relationships or may be independent.  If independent agents are used, they may use an Event Manager, provided as a sub-component of the Sequoia framework, to communicate.DOSIn a nutshell, the DOS framework handles the association of objects to their attributes and methods in a flexible format.  An object may be conceptualized as a container with many drawers.  A drawer may store a single attribute, a structure or a method.  As opposed to traditional C++ structures or classes, the DOS allows addition and deletion of drawers at run-time.  The tank object used in the POC application is conceptualized in Figure 2.Figure 2: Conceptualization of Tank ObjectThe DOS framework is a complete object system that operates at run-time allowing the definition and modification of the schema of complex objects while the simulation is running. The DOS provides the functionality expected from an object system, such as:Containment of objects;Reference to other objects;Ability to share data;Creation and cloning of new objects and object types;Support for base types (integer, float, lists, string, enumerated types, etc.);Support for user-defined types;Support for methods; andSupport for notification on key events to an object or its attributes.Basically, this implementation layer provides a meta-model of objects.  Because the object model is available at runtime, operations on its elements (i.e., attributes and methods) can be detected and reported to the proper observers.  Therefore, the DSI, which will be described in the next section, can be notified automatically whenever attribute changes are published on the network.  In this application the POC team used DOS to implement the simulation object model (SOM) of our federate. In conjunction with the DSI, the DOS supports proxy instantiation of objects that are located in other federates within the federation.  This proxy mechanism frees the developers from having to decide a priori how the objects will be distributed while maintaining an optimized application regardless of whether the system is distributed over several processors.Distributed System InfrastructureThe DSI framework handles the distribution of object attributes within an application as well as between applications.  The DSI greatly simplifies the most common tasks involved in exchanging data using the HLA Run Time Infrastructure (RTI). The DSI is an object-oriented middleware layer for exchanging data between components as well as between federates.  By providing the developer with an abstraction layer, the DSI shields the developer, as much as possible, from underlying interoperability mechanisms between federates, establishing a clear separation between communication aspects and application-specific aspects.  The developer can then focus on the required functionality rather than the technical details of the communication aspects.No assumptions have been made regarding the consumer of the DSI services; PAC agents, DOS, or simple classes deriving from a basic object class may use DSI services. In the POC application, the POC team used the DSI with PAC agents for the exchange of execution control events as well as with DOS for the exchange of object attributes.PAC VisualizerThe PAC Visualizer provides the user with a view into the internal execution of an application.  As an application executes, Sequoia creates a log file containing information on the initialization of agents; the relationships between agents and other simulation execution components; and the sending, receiving and processing of events.  Once execution stops, the PAC Visualizer uses the log file to create a visual representation of these activities.  As the PAC Visualizer steps through the items in the log file, it creates circles to represent agents.  Static lines are created to represent parent-child relationships between agents or relationships between agents and other simulation execution components.  As events are passed, colored arrows dynamically appear, along with the name of the event, showing the path of the event.  As agents send or receive events, they are highlighted in yellow.  While they process a valid event and the associated tasks, agents appear in green.  If an agent considers an event invalid, the agent appears red.  Thus, the user may follow the flow of activities within a simulation by watching the replay of the simulation’s log file in the PAC Visualizer.  Appearances of red may highlight a problem to a developer using a PAC Visualizer to assist in debugging an application.ReconstructionBecause Sequoia is still under development, a TRW engineer was paired with a VPI engineer to create the POC team responsible for reconstruction of the model.  First, the POC team had to reverse engineer the CID model.  The lack of an overall spreadsheet or Visual Basic module execution order complicated this process.  An agent hierarchy was selected rather than using the Event Manager due to the cyclic nature of stepping through engagements during a run; the engagement events are not random in nature.  In addition, the time associated with the engagement was added to the simulation time and compared with the user-specified simulation time to determine when the simulation would stop.As an understanding of the model was developed, an agent hierarchy mirroring the functionality of the CID model was developed (see figure 3).  This agent hierarchy was visualized with the PAC Visualizer, which assisted in debugging and demonstration of the POC application.  While no presentation was needed for this application, the controller and abstraction components of each agent had to be defined.  The Visual Basic code was interpreted manually into pseudo-code which, in turn, was used to create the agent abstractions in C++.Figure 3: PAC Agent Hierarchy of the POC ApplicationThe use of PAC agents and the DOS simplified creation of distinct Red and Blue behaviors.  A method created to handle blue behaviors based on a Blue force object within the DOS could be duplicated and modified to use a separate Red force object.  The agent’s controller would use the incoming event and the finite state machine to determine which method in the abstraction to trigger.  Each method was tied to a specific object.  Multiple methods could be triggered if indicated by an incoming event.To mirror the original functionality of the CID model, some kind of mechanism to visualize the data was required.  The POC team selected the ModIOS Stealth for visualizing in three dimensions the battlefield and more importantly for evaluating how easy it is to integrate Sequoia with a third-party product.  Both the POC application and the ModIOS Stealth were used as distinct federates under the same federation using the RPR-FOM version 0.6 The SEDRIS Coordinate Conversion Library was used to evaluate the flexibility of Sequoia with respect to incorporation of additional service-performing libraries.  This library allowed the entities of the CID model to respect the coordinate system used by the ModIOS Stealth.  Integration and test of this SEDRIS library took two days.A third federate was built to take care of the simulation execution control.  Execution control data, such as Start, Stop, Freeze, Resume, as well as initialization data, such as the number of runs and trials, were displayed using a VCR-like interface.  This federate also used a PAC agent hierarchy, the DOS and the DSI to communicate via the RTI.  Some extensions to the RPR-FOM were made for simulation control events, since Sequoia was unable to handle these interactions at the time of the evaluation.Multiple text files containing simulation outputs of each engagement were generated and imported into Microsoft Excel.  Visual Basic macros produced bar charts and graphs based on the POC application outputs.  The intent was to represent the output data in the most efficient and natural way for the analyst’s needs.A rudimentary Command and Control structure was added to the POC application. PAC agents were used to create a distinct agent hierarchy and represent Command and Control nodes.  A three-level hierarchy was created using Gunner, Platoon Leader, and Commander.  Each Platoon Leader would receive requests for engagement from each Gunner under its jurisdiction and relay the request to its own Commander.  Based on a simple formula, the commander would decide whether the target should be engaged or whether the Gunner should move closer or retreat.  Use of the PAC Visualizer during testing of this functionality revealed extraneous event passing that, otherwise, would have been difficult to detect.Lessons LearnedAt the time the project ended, Sequoia was over six months away from a release date.  Working with a developmental product increased the learning curve since there was little documentation and the visual editors were incomplete.  However, the Sequoia framework demonstrated sufficient capabilities to prove that it makes development easier and faster when employed by a knowledgeable user.Novices have many abstract concepts to understand before implementation trade-offs may be made effectively.  Previous experience with object-oriented programming was certainly helpful, but the usage of PAC agents and the DOS will require careful study of available documentation.  Although powerful tools, newcomers may under-utilize the DOS and PAC agents until more familiarity is established.Since the legacy model had to be completely reconstructed, about a quarter of the project was devoted to reverse engineering that model to understand all the interrelationships between the spreadsheets, the inputs and outputs (which were scattered across multiple spreadsheets and intermingled with various constants), and the 60+ pages of Visual Basic code.  This time was equated to the time normally devoted to the design phase for a new system.In creating a design for the POC application, the legacy model provided little insight for implementation trade-offs since its original implementation was vastly different.  The Sequoia engineer developed the initial agent hierarchy and used PAC Visualizer to illustrate the functionality of the PAC agents.  The ability to see the hierarchy and the event passing was a significant benefit to the TRW engineer as she learned how to exploit PAC agents.  The government analysts observing the demonstrations were quickly able to understand the Command and Control functionality developed because of the PAC Visualizer.  In addition, snapshots of the agent hierarchies displayed using the PAC Visualizer clarified reports and documentation.The various extensions to the CID methodology were added with relative ease.  The object-oriented nature of the DOS and the PAC agents allowed modifications through substitution of one abstraction for another or through addition of an event to trigger a new abstraction.  Functionality created for the Blue forces was reused for the Red but allowed the objects and agents for each force to be viewed independently.HLA-compliance was achieved almost inherently because the DSI successfully isolates the Sequoia framework, and any applications developed using the DSI, from the RTI.  Simply adding publishing and subscribing calls from the model to the DSI caused the DSI to pull the appropriate data from the DOS.  Then the DSI interacted with the RTI without further intervention by the developer.  The RPR FOM was used with slight modifications.  By placing the fed file in the appropriate place, the object model contained in the fed file was immediately available for use by the POC application.This POC application clearly demonstrated that the Sequoia product, while still in development, provided the POC team with a flexible framework. Reconstruction, including reverse engineering of the CID model and adding HLA-compliance required about three staff-months.  Plug and play of the SEDRIS Coordinate Conversion Library allowed proven coordinate conversion routines to be downloaded, incorporated and tested in under two days.  It also allowed the POC team to come up with the first demonstration of the application within one month, proving the rapid prototyping capability of the product.References1.  G. Calvary, J. Coutaz, and L. Nigay: “From Single-User Architectural Design to PAC*: a Generic Software Architecture Model for CSCW” Proceedings for CHI’97 (Conference on Human Factors in Computing Systems), Association for Computing Machinery, Inc., pp.242-249, 22-27 March 1997.2. S. Vermette and J. M. Naud: “Behavior Modeling Using Multi-Agent Architecture” Proceedings and Exhibits CD-ROM for the 10th International Training and Education Conference (ITEC), 13-15 April 1999.Author BiographiesKIMBERLY NEFF has been an active member of the simulation community for seven years.  She is currently a simulation engineer within TRW’s International Defense Simulation Systems Division in Fair Lakes, VA.  Ms. Neff has a B.S. in Aerospace Engineering and a Masters of Engineering Management.  Ms. Neff has been involved with all phases of the software and simulation development life cycles on a variety of projects. During this project, she lived in Montréal in order to work on-site with VPI’s Sequoia developers.STEPHANE VERMETTE is a Senior Software Designer at Virtual Prototypes Inc. in the Simulation Software Division. He holds a bachelor degree in Engineering Physics. He has more than 11 years of experience in the fields of military simulation, system integration, and software architecture. He is currently one of the main architects of VPI’s new framework for developing interactive distributed simulation systems. EMBED Word.Picture.8   EMBED Word.Picture.8  