A Proposed Scheme for Implementing Aggregation and Disaggregation in HLAMark BiddleScience Application International Company12479 Research ParkwayOrlando, FL 32826biddlem@saic.comKeywords:Aggregation, Disaggregation, HLA, FOM, MAGTFABSTRACT: The Marine Corps Combat Development Command (MCCDC) is leading an effort to develop an HLA Federation Object Model (FOM) for the Marine Air Ground Task Force (MAGTF) training community.  The purpose of the FOM is to serve as an interoperability specification for developers of MAGTF training systems.  The FOM is generally based upon the Real-time Platform Reference (RPR) FOM, but it also implements additions obtained from other FOMs and SOMs.  Also, several custom-developed solutions are being proposed for inclusion in this FOM.  One of these is a scheme for implementing aggregation/disaggregation of objects in a synthetic battlespace.  This scheme addresses situations in which an object is best represented as a permanent component of a larger abstract, such as a an avionics subsystem of an aircraft.  It also addresses situations in which objects are to be temporarily merged with other objects in order to be represented as a single object.  This includes such instances as a weapon object being picked up by an individual combatant object or an artillery piece object being transported by a helicopter object.  Finally, the scheme also addresses situations in which an object may have multiple simultaneous representations, such as the case where a tank is represented as a single entity, but also as part of a larger aggregation, such as a platoon or a battalion.  This paper outlines the draft aggregation scheme being proposed for the MAGTF FOM development.IntroductionThe inspiration for development of a scheme to support aggregation and disaggregation of battlespace entities in a synthetic environment was prompted by considerations related to implementing a High Level Architecture (HLA) Federation Object Model (FOM) for the Marine Air Ground Task Force (MAGTF) training community.  The FOM development project requirements were initiated by the Marine Corps Combat Development Command (MCCDC).  The project is sponsored by the Office of Naval Research (ONR), with contract facilitation through the Naval Air Warfare Center Training Systems Division (NAWCTSD).  SAIC is the prime contractor for this effort, responsible for development of a conceptual model (CM), a FOM, and a Federation Agreements and Interoperability Document (FAID) for the MAGTF training community.The initial conceptual model development effort is focused on a representative MAGTF mission, with the idea being that many of the issues that need to be addressed for the CM in support of the specific representative mission will also apply across a broader spectrum of mission areas.  Aggregation and disaggregation is one of these issues.  The Marine Corps is built upon the view of the individual combatant as the basic mission execution building block.  From this perspective, aggregation and disaggregation plays a critical role regarding the synthetic battlespace.Representation of the MAGTF synthetic battlespace requires consideration of scenarios in which entities might be best represented as embedded components of larger aggregated abstracts.  Examples of this might include a radio transmitter/receiver installed in a combat vehicle, or perhaps a radar-warning receiver in a helicopter.  This is the case in which the consumed entity or entities can be viewed as being encapsulated within a container entity such that a separate representation of the encapsulated entity within the battlespace is not necessary.  This basic scenario can be further divided into categories in which entities are either permanently or temporarily aggregated or encapsulated.  For example, in a case where an avionics system, airframe, and perhaps other subsystems of an aircraft are being modeled by separate federates, the desired representation in the synthetic battlespace may be that of a single aircraft entity, into which the subsystems are permanently aggregated.  As another example, in a case where an individual combatant is carrying a specific weapon, the best representation of the two entities might be a single but temporarily aggregated representation of the individual combatant.  In this case the individual combatant could conceptually be viewed as the container.  If the combatant decides to discard the weapon, then the desired representation might at that time become a disaggregated representation of the combatant entity and the weapon entity separately.  A second type of basic scenario to be considered is the case in which a particular entity is desired to be represented as both an individual entity and as a component of one or more aggregated representations at the same time.  An example of this might include a tank being represented both as an individual platform-level battlespace entity and as a component of a specific tank platoon unit-level object, and perhaps again as a component of a battalion object.  In this example the platoon entity and the battalion entity might both be conceptualized as containers of the tank entity, but in this case the independent tank platform entity representation may need to be maintained as well.The aggregation scheme being proposed for the MAGTF FOM development effort attempts to provide a solution for effectively modeling these scenarios in an HLA federation.  The proposed scheme focuses on the Real-time Platform Reference (RPR) FOM 1.0 Draft 2 as a baseline, but it includes several modifications to the FOM which are specific to the aggregation/disaggregation scheme.  The purpose of this paper is to describe this aggregation/disaggregation scheme, as well as the rationale behind it, and to submit the concept to the Modeling and Simulation (M&S) community for review in order to expose relevant issues and to better determine its feasibility for application to the MAGTF FOM.Aggregation Scheme OverviewThe proposed aggregation/disaggregation scheme is based upon the concept of a container object, whose representation within a synthetic battlespace might encapsulate or aggregate the representation of some set of aspects of one or more other objects.  The term aspect in this case refers to object attributes and interactions.  The idea is that, upon being encapsulated within a container, there are certain aspects of the encapsulated object that no longer need to be represented in the synthetic battlespace, apart from the container object’s representation.  For the example of a radio object installed in a vehicle, when the vehicle object acts as the container for the radio, the radio need not continue to update its WorldLocation, for example.  Instead, it is understood from the federation agreements that the radio WorldLocation is identical to the WorldLocation of its container, though perhaps with a relative offset, and that the “official” representation of the aggregated WorldLocation attribute will be updated by the container, which in this case is the federate that owns the vehicle object. The aggregation model described so far assumes that it is the container that maintains the official representation of all aggregated aspects, but this is not necessarily always the case.  Consider a case where a federate is designed to model the turret subsystem object for a particular model of tank, and that a second federate exists which models the entire tank object, though with less fidelity relative to the turret.  Suppose that we want to merge the representation of the turret object with the tank object to create a combined representation.  Let us assume that the tank will become the container, and attributes such as the WorldLocation will be updated by the federate that owns the tank object.  Now assume that both the tank object and the turret object federates have the capability to represent a GunElevation attribute for the turret, but the turret object federate models this attribute with a greater degree of fidelity and accuracy with respect to integrated targeting systems.  In this case, even though the turret object representation is effectively encapsulated by the tank object, it is possibly more logical to have the turret object federate update the official representation of the GunElevation attribute. To handle this situation, the proposed aggregation scheme allows for the container to delegate authority for the official representation of combined attributes or interactions to an encapsulated object.The aggregation scheme also allows for an object to be encapsulated within an aggregated representation by a container, while simultaneously maintaining a separate and independent representation for itself. The scheme identifies three stages of federation initialization in order to set up aggregation relationships.  During initialization phase one, federates join the federation and objects are instantiated.  During  phase two, all containers issue interactions to request aggregation of other objects, and possibly to request delegation of attribute or interaction representations to contained objects.  Federates representing objects that have been petitioned by a container reply appropriately with a response interaction.  During phase three, any objects still left wanting a container will send interactions to the desired containers to request containment, and the petitioned containers will reply with an appropriate response interaction.After initialization, late joiners can send requests to either contain other objects or be contained by another object or objects, and the petitioned objects will respond accordingly.  There is a similar set of request interactions to allow either containers or contained objects to request disaggregation.  The proposed scheme includes a set of rules which dictate when and under what circumstances aggregation and disaggregation is permitted.  These rules are specified as part of the federation agreements and interoperability document (FAID), and they are supported in the FOM through the introduction of an AggregationMode enumerated data type attribute and an AggregationAssignmentType enumerated data type attribute.  The AggregationMode values include Permanent, SemiPermanent, Temorary, and Independent.  The AggregationAssignmentType values include NoAggregation, Contains, ContainedIn, and Delegates.  A description of each of the aggregation/disaggregation attributes and interactions is provided in the next section, along with the federation agreements that specify how they are to be used.RPR FOM Modifications and Federation AgreementsRPR FOM V1.0 Draft 2 partially addresses the aggregation issue with its EmbeddedSystem object class.  This object class has Designator, EmitterSystem, RadioReceiver, and RadioTransmitter subclasses.  The EmbeddedSystem object class includes HostObjectIdentifier and RelativePosition attributes.  The HostObjectIdentifier attribute indicates the effective container object for the embedded system, and the RelativePosition attribute indicates the location of the embedded system relative to its host object.  There are several issues relative to the RPR FOM implementation. First, the concept of an EmbeddedSystem object class separate and apart from the PhysicalEntity object class is effectively a workaround to avoid the need for multiple inheritance, but it allows for potentially confusing interpretations, with respect to implementation of certain types of objects.  A radio, for example can be represented as a subclass of PhysicalEntity, or it can be represented as an object of either the RadioReceiver or the RadioTransmitter subclass of EmbeddedSystem, or possibly both at the same time.  Also, there is no specific support in RPR FOM for the aggregation or disaggregation of BaseEntity objects relative to other BaseEntity objects (an individual combatant riding in a troop carrier, for example) or for organizational aggregation (platoon, battalion, etc..).As shown in figure 3-1, the proposed aggregation scheme deletes the EmbeddedSystem object class and moves the Designator and EmitterSystem subclasses to be under the PhysicalEntity object class.  It also combines the RadioReceiver and RadioTransmitter object classes and combines them with the Radio object class under PhysicalEntity.  An object class has been added to ObjectRoot, and this class is called Object.  Like ObjectRoot, Object is parent to all other object classes.  Unlike ObjectRoot, Object can contain attributes, and it contains a new added attribute called AggregationState.  Also, an attribute has been added to the BaseEntity object class, which is the AggregationRelativePosition attribute.   The AggregationState attribute is used by an object to indicate which, if any, containers it is encapsulated within.  It is also used by containers to indicate which, if any, objects it is currently encapsulating.  An AggregationState attribute update will contain one or more AggregationAssignmentType fields, as indicated in figure_3-2.Figure 3-1: RPR FOM Object Class Table Modifications for the proposed MAGTF aggregation scheme.Figure 3-2: The AggregationState attribute for the proposed MAGTF FOM aggregation scheme.In addition to object calss table changes, several interactions are added.  As shown in figure 3-3, One interaction class has been added under InteractionRoot, and it is called Interaction.  Like InteractionRoot, it is parent to all other interaction classes.  Unlike InteractionRoot, Interaction can contain parameters, and it contains an added parameter called AggregationStatus.  Two new interaction classes are added under Interaction, which are AggregationRequest and AggregationRequestResult.  The AggregationRequest interaction has several subclasses, which include AggregationReleaseRequest, AggregationContainedInRequest, AggregationContainsRequest and AggregationDelegatesRequest  as shown in figure 3-4.  The federation agreements that go along with this scheme are presented in figures 3-5 through 3-7.  A description of the various aggregation modes is presented in figure 3-8.Though not shown in tables 3-4 through 3-7, each of the interactions also includes the AggregationStatus parameter, which is inherited from the Interaction parent class and which will contain the same identical fields as the AggregationState attribute of the Object object class.  This AggregationStatus parameter will be updated with every interaction sent by every aggregated object..  Figure 3-3:  Interactions to support aggregation/disaggregation scheme          Figure 3-4: Interactions for the proposed MAGTF FOM aggregation scheme.              Figure 3-5: Federation agreements – Initialization phases.            Figure 3-6: Federation agreements – New Joiners and Disaggregation.        Figure 3-7: Federation agreements – Runtime aggregation.                         Figure 3-8: Aggregations modes.There are of course alternatives to the proposed scheme described above.  One option might be to not include the AggregationStatus interaction parameter and to not require contained objects to report an aggregation status with every update or interaction, which would cut down on network traffic to some extent.  An AggregationState attribute update would only have to be sent to late joiners or when a specific request is made.  In this case, each federate would have the additional responsibility of maintaining its own aggregation state lookup table, in order to keep track of which objects are aggregated with which.  This situation would be further complicated in the event of nested aggregation situations.  In other words, if a radio object is aggregated into a combat vehicle, and that vehicle is aggregated into some sort of larger transport vehicle, then all federates must record the radio relationship to both the combat vehicle and the transport in their respective lookup tables.  This could have a data storage and computational effect on subscribing federates.In the proposed scheme an aggregation state is reported by each aggregated object with every update or interaction, and the aggregation information is contained in either the AggregationState attribute or the AggregationStatus parameter, thus eliminating the need for lookup tables on the part of subscribing federates.  This would increase network traffic somewhat, the degree of which would depend upon the number of objects in the synthetic battlespace and the number of aggregation relationships being maintained.   Nested aggregation relationships are allowed in the proposed scheme, but it requires that each aggregated object report aggregation status for every aggregation relationship that it is involved in.  In other words, if radio object is aggregated into a combat vehicle, and that vehicle is aggregated into some sort of larger transport vehicle, then the radio object must report an aggregation relationship with both the combat vehicle and the transport vehicle with each and every update or interaction.The proposed scheme is vaguely similar to the way the RPR FOM handles EmbeddedSystem objects.  In the case of the RPR FOM, the RadioReciever object class for example inherits a HostObjectIdentifier attribute via its EmbeddedSystem parent class. RadioReceiver attribute update recipients can map the aggregated radio with its host via HostObjectIdentifier without the need for a lookup table.  While the RPR FOM EmbeddedSystem objects report aggregation in a similar fashion to the proposed MAGTF solution, the same is not true of the interactions.  In the case of the RPR FOM RadioSignal interaction, for example, there is an indicator which identifies the host radio for the signal, but not the object that hosts the radio itself.  In this case a quick lookup is required on the part of RadioSignal interaction receivers in order to match the host radio with its host object.  Another solution might be to allow for the RTI to provide an aggregated object ID service, but this would require a modification to the HLA specification and to existing RTI implementaitons.Example ScenarioFor an example scenario to illustrate the proposed aggregation scheme, consider the case in which a combat vehicle is modeled by a particular federate, and a high fidelity turret object for this vehicle is modeled by a second federate.  The turret object will be aggregated within the vehicle object representation.  Then the vehicle will be transported by a helicopter, during which time the vehicle will become aggregated with the helicopter object.  When the helicopter completes the transport of the vehicle, the vehicle disaggregates from the helicopter and joins up with a platoon, which will consist of the vehicle itself and three others like it.4.1. Turret AggregationBefore the scenario begins, assume that both the combat vehicle object and the turret object are publishing WorldLocation attributes and WeaponFire interactions.  Assume that at some point the vehicle federate issues an AggregationContainsRequest interaction with the following parameters: Container=Vehicle, Containee=Turret, AggregationMode=Permanent, AggregatedAttributesList=WorldLocation. Note the Permanent aggregation mode.  The turret federate replies with a positive AggregationRequestResponse. This establishes the link between the turret object and the vehicle container object.  The turret federate will now unpublish its WorldLocation attribute.The vehicle federate then initiates an AggregationDelegatesRequest interaction with the following parameters:  Container=Vehicle, Containee=Turret, AggregationMode=Permanent, AggregatedInteractionList= WeaponFireInteraction.  Note the Permanent aggregation mode.  The turret federate replies with a positive AggregationRequestResponse.  The vehicle federate then unpublishes its WeaponFire interaction, and the aggregation relationship is complete.  For the remainder of the federation execution, the turret federate will provide an AggregationState attribute update with every other attribute update and an AggregationStatus parameter with every interaction.It should be noted that the process of encapsulating the WorldLocation attribute representation of the turret object within the representation of the vehicle container object does not involve an HLA object ownership transfer.  Object ownership transfer would result in the vehicle object having to update two separate instances of a WorldLocation, one for the vehicle and one for the turret.  Instead, the two separate WorldLocation attributes become aggregated or merged into the WorldLocation attribute of the vehicle.  Likewise, no object ownership transfer takes place with the delegation of the WeaponFire interaction by the vehicle to the turret object. It should also be noted that this does not violate the HLA rules.4.2 Helicopter Transports VehicleInitially, assume that the helicopter object is updating WorldLocation, VelocityVector, and DamageState attributes, among others.  The combat vehicle object is updating WorldLocation, VelocityVector, and DamageState attributes as well, among others.The combat vehicle then initiates an AggregationContainedInRequest interaction, with the following parameters: Container=Helicopter, Containee=Vehicle, AggregationMode=Temporary, AggregatedAtttributesList=WorldLocation, VelocityVector. Note the Temporary aggregation mode.  The helicopter object replies with a positive AggregationRequestResponse interaction. This establishes the link between the vehicle and its container, the helicopter.  The vehicle will now unpublish its WorldLocation and VelicityVector attributes.  The combat vehicle will also include an AggregationState attribute update with every attribute update that it initiates and an AggregationStatus parameter with every interaction.  Likewise, the turret object, having overheard the combat vehicle negotiating an aggregation with the helecopter and thereby effectively aggregating the turret as well, will also include AggregationState and AggregationStatus with every update and interaction, to indicate both its aggregation with the combat vehicle and its effective aggregation with the helicopter.  Either the helicopter or the combat vehicle may update the AggregationRelativePosition attribute of the vehicle within the helicopter container.  Upon completing the transport, the vehicle will initiate an AggregationReleaseRequest interaction with the following parameters: Container=Helicopter, Containee=Vehicle, AggregationMode=Temporary, AggregatedAttributesList=WorldLocation, VelocityVector.  Note the Temporary aggregation mode.  The helicopter container object replies with a positive AggregationRequestResonse interaction.The combat vehicle then republishes its WorldLocation and VelocityVector attributes.   The turret overhears the disaggregation of the vehicle from the helicopter and discontinues reporting of its effective aggregation with the helicopter, and the disaggregation is complete.4.3 Combat Vehicle Join PlatoonThe combat vehicle initiates an AggregationContainedIn request with the following parameters:  Container=Platoon,  Containee=Vehicle, AggrgationMode=Independent, AggregatedAttributesList=null.  Not the Independent aggregation mode.  No actual attributes or parameters are aggregated, but the federation agreements state that a link is now understood to exist, that the vehicle is aggregated into the battlespace representation of the platoon object.  The turret monitors the creation of this aggregation relationship and realizes its own effect aggregation with the platoon.  The combat vehicle now issues an AggregationState attribute with every update, and an AggregationStatus parameter with every interaction, as does the turret.Summary& ConclusionsThe aggregation/disaggregation scheme described in this paper addresses issues related to representing battlespace objects as elements of other aggregate element representations.  It includes mechanisms for establishing aggregated representations on a permanent or temporary basis, and it also addresses the issue of disaggregation.  The scheme deals with situations where an object needs to be represented both individually and as part of an aggregation at the same time.  The scheme identifies modifications that can be made to the RPR FOM in order to support the concept, and it includes a description of federation agreements that need to be supported in order to facilitate the approach.  There are alternative options for implementing this scheme, such as requiring federates to keep aggregation mapping tables internally, or proposing a modification to the HLA spec to have the RTI support the concept of aggregated object IDs.  There are obvious trade-offs for each alternative relative to performance and processing load on federates. This is a draft concept, which is being tentatively proposed for inclusion in a FOM that is being developed for the MAGTF training community. It is hoped that the various issues related to the implementation of this approach can be better understood and evaluated by presenting the concept to the M&S community and inviting constructive feedback.  In addition, the evaluation of this scheme through its implementation in a proof-of-concept prototype would be very instrumental in determining its feasibility.  The decision has not been made as to whether or not this scheme is appropriate for implementation in a MAGTF FOM, and more research will be conducted before that decision is made.   References[1] HYPERLINK "obtain_doc.cfm?record_id=REF_1001080"SISO-STD-001.1-1999 (RPR FOM 1.0) Author BiographiesMARK BIDDLE is a Senior Simulation Systems Engineer for SAIC and has over five years experience in the Distributed Interactive Simulation industry.  He has performed requirements analysis, design, implementation, and testing in a team leader capacity on research projects for simulation and training technologies, with a special focus on interoperability and the High Level Architecture (HLA).  He also has over eight years of experience with In-Service-Engineering, Design, and Program Management of Navy mission critical shipboard systems.  Mr. Biddle received his Masters of Science degree in Engineering Management from Old Dominion University in Norfolk Virginia, and a Bachelor's degree in Electrical Engineering from the Pennsylvania State University.Add: AggregateRelativePosition attributeMAGTFRPRxAggregationAssignmentStruct  AggregationAssignmentStructAggregationAssignmentType: Enum0 = NoAggregationLink1 = Contains2 = ContainedInAggregatedRelativePosition: RelativePositionStruct...AggregationAssignmentStruct                 AggregationStateAggregationMode: Enum1 = Permanent2 = SemiPermanent3 = Temporary4 = IndependentTargetID: ObjectNameStructContainer  Containee  AggregationMode   AggregatedAttributeList  AggregatedInteractionListContainer  Containee AggregationMode AggregatedAttributeList  AggregatedInteractionListContainer  Containee AggregationMode AggregatedAttributeList  AggregatedInteractionListContainer  Containee AggregationMode AggregatedAttributeList  AggregatedInteractionListRequester  Container  Containee AggregationMode AggregatedAttributeList  AggregatedInteractionList   ResultINTERACTIONS 				PARAMETERS                              AggregationContainsRequestAggregationContianedInRequestAggregationDelegatesRequestAggregationReleaseRequestAggregationRequestResultAdd: "Object" object classAdd: AggregationState attributeINITIALIZATION Phase 1:  Federates Join.  Objects Instantiate. Phase 2: Containers send AggregationContainsRequest and/or AggregationDelegatesRequest interactions.Petitioned objects reply with AggregationRequestResponse interaction.Aggregated objects unpublish aggregated attributes/interactions. Phase 3:Any objects still left wanting a container send AggregationContainedInRequest interaction.Containers reply with AggregationRequestResponse interaction.Aggregated objects unpublish aggregated attributes/interactions.RUNTIME - New Joiner New object sends AggregationContainedInRequest interaction to containers it wants. Containers reply with AggregationRequestResponse interaction. Aggregated objects unpublish aggregated attributes/interactions.			OrContainer sends AggregationContainsRequest  and/or AggregationDelegatesRequest interaction to objects it wants.Objects reply with AggregationRequestResponse interaction.Aggregated object unpublish aggregated attributes/interactions.RUNTIME - Remove Entity from ContainerAnyone sends AggregationReleaseRequest interaction.Containers reply with AggregationRequestResponse interaction. Federates owning the disaggregated objects republish disaggregated attributes/interactions for those objects or manage ownership transfer of them to another federate.RUNTIME - Add Entity to ContainerObject sends AggregationContainedInRequest interaction to the container(s) it wants.Containers reply with AggregationRequestResponse interaction.Aggregated objects unpublish aggregated attributes/interactions.			ORContainer sends AggregationContainsRequest and/or AggregationDelegatesRequest to object(s) that it wants.Object(s) reply with AggregationRequestResponse interaction. Aggregated objects unpublish aggregated attributes/interactions.			OR3rd party sends AggregationContainedInRequest and/or AggregationDelegatesRequest interaction.Containers reply with AggregationRequestResponse interaction.Entities reply with AggregationRequestResponse interaction.Aggregated objects unpublish aggregated attributes/interactions.AGGREGATION MODE - All modesContainer updates aggregated attributes/interactions according to container model, except for delegated attributes/interactions.  Delegated attributes/interactions updated according to authorized object's owning federate model.All contained objects will send an AggregationState attribute or AggregationStatus parameter with every attribute update or interaction as long as it is linked to a container.Container may release contained objects’ attributes without permission from owning federates of contained objects .  Federate owners of contained objects must grant release request and must begin publishing the attributes/interactions or manage ownership transfer of them to another federate.Contained objects will not publish (and will unpublish if necessary) all aggregated attributes.Containers cannot accept aggregation requests for attributes/interactions that they do not already maintain for themselves.AggregationRelativePosition of contained objects may be updated by contained objects or by container.All aggregated objects will listen for potential aggregation/disaggregation requests by their containers and will reflect as necessary via AggregationState and AggregationStatus any nested aggregation statuses that result, as new aggregation/disaggregation of a container object recursivly affects all objects aggregated under that container.AGGREGATION MODE - PermanentContained objects will be deleted when container is deleted.Neither containers nor containees wil request disaggregation of any attribute/parameter.Contained objects will not be deleted as long as container exists.AGGREGATION MODE - SemiPermanentContainer does not necessarily have to release attributes upon request from owning federate of a contained object.AGGREGATION MODE - Temporary Container must release attributes upon request from owning federate of a contained object.AGGREGATION MODE - IndependentNo object attributes are aggregated into container, but an aggregation link is still maintained. Container must release the aggregation link upon request from owning object . AggregationRelativePosition of contained objects may be updated by objects or by container.Same parametersMAGTF