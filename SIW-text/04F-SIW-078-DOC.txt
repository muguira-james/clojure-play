APPLYING DESIGN PATTERNS TO MODELING AND SIMULATIONKenn Atkinson, P.E.Science Applications International Corporation (SAIC)1901 N. Beauregard St., Suite 500Alexandria, VA 22311703-824-3414 HYPERLINK "mailto:katkinson@dmso.mil" katkinson@dmso.milAbstract: Mature engineering disciplines have handbooks that describe successful solutions to known problems. For instance, automobile designers don't design cars using the laws of physics. Instead, they reuse standard designs with successful track records. The extra few percent of performance available by starting from scratch typically isn't worth the cost. ``Patterns'' and ``pattern languages'' describe successful solutions to common software problems. The long-term goal is to develop handbooks for software engineers. Though we are a long way from that goal, patterns have proven useful in the short term to help people reuse successful practices. Not only do patterns teach useful techniques, they help people communicate better, and they help people reason about what they do and why. In addition, patterns are a step toward handbooks for software engineers.This paper provides an overview of the patterns being written today, including object-oriented design and programming or on object-oriented modeling and patterns that focus on efficient, reliable, and scalable concurrent, parallel, and distributed programming.   This paper considers reusing these tools to provide similar benefits to the Modeling and Simulation community. Keywords :Design Patterns, pattern languages, architecture and design, composability, frameworks, componentsIntroductionMature engineering disciplines have handbooks that describe successful solutions to known problems. For instance, automobile designers don't design cars using the laws of physics. Instead, they reuse standard designs with successful track records. The extra few percent of performance available by starting from scratch typically isn't worth the cost. “Patterns``and ``pattern languages'' describe successful solutions to common software problems. The long-term goal is to develop handbooks for software engineers. Though we are a long way from that goal, patterns have proven useful in the short term to help people reuse successful practices. Not only do patterns teach useful techniques, they help people communicate better, and they help people reason about what they do and why. In addition, patterns are a step toward handbooks for software engineers.  [ HYPERLINK "http://www.acm.org/cacm" Communications of the  HYPERLINK "http://www.acm.org/" ACM, Special Issue on Patterns and Pattern Languages, Vol. 39, No. 10, October 1996.]Application developers in more complex domains (such as telecommunications, distributed medical imaging, and real-time avionics) have traditionally lacked standard ``off-the-shelf'' frameworks. As a result, developers in these domains largely build, validate, and maintain software systems from scratch. In an era of deregulation and stiff global competition, however, it has become prohibitively costly and time consuming to develop applications entirely in-house from the ground up. [ HYPERLINK "http://www.acm.org/cacm" Communications of the  HYPERLINK "http://www.acm.org" ACM, Special Issue on Object-Oriented Application Frameworks, Vol. 40, No. 10, October 1997.]They are a literary form of software engineering problem-solving discipline that has its roots in a design movement of the same name in contemporary architecture, literate programming, and the documentation of best practices and lessons learned in all vocations. One of the first things that any science or engineering discipline must have is a vocabulary for expressing its concepts and a language for relating them together. The goal of patterns within the software community is to create a body of literature to help software developers resolve common difficult problems encountered throughout all of software engineering and development. Patterns help create a shared language for communicating insight and experience about these problems and their solutions. Formally codifying these solutions and their relationships lets us successfully capture the body of knowledge which comprises our understanding of good architectures that meet the needs of their users. Forming a common pattern language for conveying the structures and mechanisms of our architectures allows us to intelligibly reason about them. The primary focus is not so much on technology as it is on creating a culture to document and support sound engineering architecture and design. One of the central tenets of design patterns is that they should encapsulate variation, i.e. they should expose that which is constant and hide that which varies. In this same vein, commonality/variability analysis can be applied to a system’s design to identify potential future variations, and to decide which generalizations with the potential to encapsulate future variation are worth implementing in the near term. Not everything that can be generalized should be. However, identifying aspects of the design that may change without having to know exactly what the changes will be can support decisions about the return on investment of developing a more general initial design. [Gustavson 2004]This paper provides an overview of the patterns being written today. The first software patterns were written by object-oriented developers, so they focused on object-oriented design and programming [GOF] or on object-oriented modeling [Coad]. A new trend is patterns that focus on efficient, reliable, and scalable concurrent, parallel, and distributed programming [PLoP2, Schmidt1, SIEMENS].  This paper considers reusing these tools to provide similar benefits to the Modeling and Simulation community. NeedThe success of modeling and simulation (M&S) as a key enabler of this transformation process will be largely dependent on increased reuse, and an improved ability to rapidly and flexibly compose new components and simulations to satisfy the specific needs of the user. [4] A recent survey of warfighter needs by the Defense Modeling and Simulation Office (DMSO) identified faster, less costly development, standardized (reusable) components and multi-resolution, composable simulation environments as critical advanced M&S techniques. [5].  The burden of developing and/or integrating models, simulations, databases, interfaces, etc. each time M&S is applied hinders the effective use of M&S capabilities.  To minimize this burden, the DoD has established a strategy to foster simulation interoperability and reuse, calling for the establishment of a common technical framework (CTF) and common services. The goal of DMSO’s Composable Mission Space Environments (CMSE) initiative, sometimes referred to as "composability," is to identify the issues related to "composability" and then target DMSO initiatives, and suggest related research from other organizations.DefinitionsComposability:  .The capability to select and assemble components in various combinations into complete, validated simulation environments to satisfy specific user requirements across a variety of application domains, levels of resolution, and time scales. [Petty and Weisel 2003]Compose: “to make or form by combining things, parts, or elements”Composition: “the act of combining parts or elements to form a whole”Composability: “The ease of forming a whole by combining parts”Webster Encyclopedic Dictionary, 1989, p. 302A composition brings into existence new emerging services of the SOS that are more than the sum of the prior services of the components..”It’s often said that patterns are discovered rather than invented”. [Fowler 1997] The best way to discover a pattern is to perform a conceptual analysis on the problem space.Pattern:  Problem/Solution pairs in a context. –Design patterns represent solutions to problems that arise when developing software within a particular contextPatterns -- Patterns represent recurring solutions to software development problems within a particular context. Patterns and frameworks both facilitate reuse by capturing successful software development strategies. The primary difference is that frameworks focus on reuse of concrete designs, algorithms, and implementations in a particular programming language. In contrast, patterns focus on reuse of abstract designs and software micro-architectures. Frameworks can be viewed as a concrete reification of families of design patterns that are targeted for a particular application-domain. Likewise, design patterns can be viewed as more abstract micro-architectural elements of frameworks that document and motivate the semantics of frameworks in an effective way. When patterns are used to structure and document frameworks, nearly every class in the framework plays a well-defined role and collaborates effectively with other classes in the framework. Frameworks: Frameworks define ``semi-complete'' applications that embody domain-specific object structures and functionality -- Components in a framework work together to provide a generic architectural skeleton for a family of related applications. Complete applications can be composed by inheriting from and/or instantiating framework components. In contrast, class libraries are less domain-specific and provide a smaller scope of reuse. For instance, class library components like classes for Strings, complex numbers, arrays, and bitsets are relatively low-level and ubiquitous across many application domains. Frameworks are active and exhibit ``inversion of control'' at run-time -- Class libraries are typically passive, i.e., they perform their processing by borrowing threads of control from self-directed application objects. In contrast, frameworks are active, i.e., they control the flow of control within an application via event dispatching patterns like Reactor and Observer. The ``inversion of control'' in the run-time architecture of a framework is often referred to as The Hollywood Principle, i.e., ``Don't call us, we'll call you.''Components -- Components are self-contained instances of abstract data types (ADTs) that can be plugged together to form complete applications. Common examples of components include VBX controls and CORBA Object Services. In terms of OO design, a component is a blackbox that defines a cohesive set of operations, which can be reused based solely upon knowledge of the syntax and semantics of its interface. Compared with frameworks, components are less tightly coupled and can support binary-level reuse. For example, applications can reuse components without having to subclass from existing base classes.TheoryThe study of patterns is well established in many other fields including architecture, anthropology, music, and sociology. Early adopters of software patterns were highly influenced by Christopher Alexander, who is a researcher at University of California, Berkeley that has written extensively on patterns found in architecture for houses, buildings, and communities.A pattern is a recurring solution to a standard problem. When related patterns are woven together they form a ``language'' that provides a process for the orderly resolution of software development problems. Pattern languages are not formal languages, but rather a collection of interrelated patterns, though they do provide a vocabulary for talking about a particular problem. Both patterns and pattern languages help developers communicate architectural knowledge, help people learn a new design paradigm or architectural style, and help new developers ignore traps and pitfalls that have traditionally been learned only by costly experience. Patterns have a context in which they apply. In addition, they must balance, or trade off, a set of opposing forces. The way we describe patterns must make all these things clear. Clarity of expression makes it easier to see when and why to use certain patterns, as well as when and why not to use these patterns. All solutions have costs, and pattern descriptions should state the costs clearly. From one point of view, there is nothing new about patterns since by definition patterns capture experience. It has long been recognized that expert programmers don't think about programs in terms of low level programming language elements, but in higher-order abstractions [Adelson and Soloway][Soloway and Erlich][Curtis][Linn and Clancy]. What is new is that people are working hard to systematically document abstractions other than algorithms and data structures. In general, most people working on patterns are not concentrating on developing formalisms for expressing patterns or tools for using them, though a few people are. Instead, they are concentrating on documenting the key patterns that successful developers use, but that relatively few developers thoroughly understand and consistently apply in their daily work. Most of the people documenting patterns are motivated by the following values: Success is more important than novelty. The longer a pattern has been used successfully, the more valuable it tends to be. In fact, novelty can be a liability, because new techniques are often untested. Finding a pattern is a matter of discovery and experience, not invention. A new technique can be documented as a pattern, but its value is known only after it has been tried. This is why most patterns describe several uses. Emphasis on writing and clarity of communication. Most pattern descriptions document recurring solutions using a standard format. We look forward to the day when we will have handbooks for software engineers. Therefore, we write our patterns in a form that is like a catalog entry. In this sense, pattern descriptions are both a literary style and technical documentation. The emphasis on clear writing stems from our collective experience developing complex software systems. In many cases, projects failed because developers were unable to communicate good software designs, architectures, and programming practices to each other. Well-written pattern descriptions improve communication by naming and concisely articulating the structure and behavior of solutions to common software problems. Qualitative validation of knowledge. Another part of our ethic is to qualitatively describe concrete solutions to software problems, instead of quantifying or theorizing about them. There is a place for theoretical and quantitative work, but we feel such activities are more appropriate in a context separate from discovering and documenting patterns. Our goal is to appreciate and reward the creative process that expert developers use to build high quality software systems. Good patterns arise from practical experience. Every experienced developer has valuable patterns that we would like them to share. We value the experience of all software developers, and do not think that a few people have the patterns, and everybody else just sits back and learns them. That is why our use of writer's workshops have been so successful at pattern conferences. In a writer's workshop, participants discuss the strengths and weaknesses of each pattern, accentuate positive aspects of the patterns, share their own experience, and suggest improvements in content and style. Writer's workshops assume that we all can learn from each other. Recognize the importance of human dimensions in software development. The purpose of patterns is not to replace developer creativity with rote application of rigid design rules. Neither are we trying to replace programmers with automated CASE tools. Instead, our intent is to recognize the importance of human factors in developing software. This recognition appears in design patterns when we discuss their effect on the complexity and understandability of software systems. In addition, this recognition shows itself in patterns on effective software process and organization. ClassificationAlthough the benefits and design principles underlying frameworks are largely independent of domain to which they are applied, we've found it useful to classify frameworks by their scope, as follows: System infrastructure frameworks -- These frameworks simplify the development of portable and efficient system infrastructure such as operating system [Campbell-Islam: 93] and communication frameworks [Schmidt: 97], and frameworks for user interfaces and language processing tools. System infrastructure frameworks are primarily used internally within a software organization and are not sold to customers directly. Middleware integration frameworks -- These frameworks are commonly used to integrate distributed applications and components. Middleware integration frameworks are designed to enhance the ability of software developers to modularize, reuse, and extend their software infrastructure to work seamlessly in a distributed environment. There is a thriving market for Middleware integration frameworks, which are rapidly becoming commodities. Common examples include ORB frameworks, message-oriented middleware, and transactional databases. Enterprise application frameworks -- These frameworks address broad application domains (such as telecommunications, avionics, manufacturing, and financial engineering [Birrer: 93]) and are the cornerstone of enterprise business activities [Fayad-Hamu: 97]. Relative to System infrastructure and Middleware integration frameworks, Enterprise frameworks are expensive to develop and/or purchase. However, Enterprise frameworks can provide a substantial return on investment since they support the development of end-user applications and products directly. In contrast, System infrastructure and Middleware integration frameworks focus largely on internal software development concerns. Although these frameworks are essential to rapidly create high quality software, they typically don't generate substantial revenue for large enterprises. As a result, it's often more cost effective to buy System infrastructure and Middleware integration frameworks rather than build them in-house [Fayad-Hmau: 97].To quote Cope once again (this time from the Patterns Definitions page), a good pattern will do the following: [Software Patterns by James O. Coplien Bell Laboratories Naperville, Illinois http://hillside.net/patterns/definition.html]It solves a problem: Patterns capture solutions, not just abstract principles or strategies. It is a proven concept: Patterns capture solutions with a track record, not theories or speculation. The solution isn't obvious: Many problem-solving techniques (such as software design paradigms or methods) try to derive solutions from first principles. The best patterns generate a solution to a problem indirectly -- a necessary approach for the most difficult problems of design. It describes a relationship: Patterns don't just describe modules, but describe deeper system structures and mechanisms. The pattern has a significant human component .... All software serves human comfort or quality of life; the best patterns explicitly appeal to aesthetics and utility.BenefitsThe primary benefits of OO application frameworks stem from the modularity, reusability, extensibility, and inversion of control they provide to developers, as described below:Modularity -- Frameworks enhance modularity by encapsulating volatile implementation details behind stable interfaces. Framework modularity helps improve software quality by localizing the impact of design and implementation changes. This localization reduces the effort required to understand and maintain existing software.Reusability -- The stable interfaces provided by frameworks enhance reusability by defining generic components that can be reapplied to create new applications. Framework reusability leverages the domain knowledge and prior effort of experienced developers in order to avoid re-creating and re-validating common solutions to recurring application requirements and software design challenges. Reuse of framework components can yield substantial improvements in programmer productivity, as well as enhance the quality, performance, reliability and interoperability of software. Extensibility -- A framework enhances extensibility by providing explicit hook methods [Pree: 94] that allow applications to extend its stable interfaces. Hook methods systematically decouple the stable interfaces and behaviors of an application domain from the variations required by instantiations of an application in a particular context. Framework extensibility is essential to ensure timely customization of new application services and features. Inversion of control -- The run-time architecture of a framework is characterized by an ``inversion of control.'' This architecture enables canonical application processing steps to be customized by event handler objects that are invoked via the framework's reactive dispatching mechanism. When events occur, the framework's dispatcher reacts by invoking hook methods on pre-registered handler objects, which perform application-specific processing on the events. Inversion of control allows the framework (rather than each application) to determine which set of application-specific methods to invoke in response to external events (such as window messages arriving from end-users or packets arriving on communication ports).ChallengesWhen used in conjunction with patterns, class libraries, and components, OO application frameworks can significantly increase software quality and reduce development effort. However, a number of challenges must be addressed in order to employ frameworks effectively. Companies attempting to build or use large-scale reusable framework often fail unless they recognize and resolve challenges such as development effort, learning curve, integratability, maintainability, validation and defect removal, efficiency, and lack of standards, which are outlined below: Development effort -- While developing complex software is hard enough, developing high quality, extensible, and reusable frameworks for complex application domains is even harder. The skills required to produce frameworks successfully often remain locked in the heads of expert developers. One of the goals of this theme issue is to demystify the software process and design principles associated with developing and using frameworks. Learning curve -- Learning to use an OO application framework effectively requires considerable investment of effort. For instance, it often takes 6-12 months become highly productive with a GUI framework like MFC or MacApp, depending on the experience of developers. Typically, hands-on mentoring and training courses are required to teach application developers how to use the framework effectively. Unless the effort required to learn the framework can be amortized over many projects, this investment may not be cost effective. Moreover, the suitability of a framework for a particular application may not be apparent until the learning curve has flattened. Integratability -- Application development will be increasingly based on the integration of multiple frameworks (e.g. GUIs, communication systems, databases, etc.) together with class libraries, legacy systems, and existing components. However, many earlier generation frameworks were designed for internal extension rather than for integration with other frameworks developed externally. Integration problems arise at several levels of abstraction, ranging from documentation issues [Fayad-Hamu 97], to the concurrency/distribution architecture, to the event-dispatching model. For instance, while inversion of control is an essential feature of a framework, integrating frameworks whose event loops are not designed to interoperate with other frameworks is hard. Maintainability -- Application requirements change frequently. Therefore, the requirements of frameworks often change, as well. As frameworks invariably evolve, the applications that use them must evolve with them.Framework maintenance activities include modification and adaptation of the framework. Both modification and adaptation may occur on the functional level (i.e., certain framework functionality does not fully meet developers' requirements), as well as on the non-functional level (which includes more qualitative aspects such as portability or reusability). Framework maintenance may take different forms, such as adding functionality, removing functionality, and generalization. A deep understanding of the framework components and their interrelationships is essential to perform this task successfully. In some cases, the application developers and/or the end-users must rely entirely on framework developers to maintain the framework. Validation and defect removal -- Although a well-designed, modular framework can localize the impact of software defects, validating and debugging applications built using frameworks can be tricky for the following reasons: Generic components are harder to validate in the abstract -- A well-designed framework component typically abstracts away from application-specific details, which are provided via subclassing, object composition, or template parameterization. While this improves the flexibility and extensibility of the framework, it greatly complicates module testing since the components cannot be validated in isolation from their specific instantiations. Moreover, it is usually hard to distinguish bugs in the framework from bugs in application code. As with any software development, bugs are introduced into a framework from many possible sources, such as failure to understand the requirements, overly coupled design, or an incorrect implementation. When customizing the components in framework to a particular application, the number of possible error sources will increase.Inversion of control and lack of explicit control flow -- Applications written with frameworks can be hard to debug since the framework's ``inverted'' flow of control oscillates between the application-independent framework infrastructure and the application-specific method callbacks. This increases the difficulty of ``single-stepping'' through the run-time behavior of a framework within a debugger since the control flow of the application is driven implicitly by callbacks and developers may not understand or have access to the framework code. This is similar to the problems encountered trying to debug a compiler lexical analyzer and parser written with LEX and YACC. In these applications, debugging is straightforward when the thread of control is in the user-defined action routines. Once the thread of control returns to the generated DFA skeleton, however, it is hard to trace the program's logic. Efficiency -- Frameworks enhance extensibility by employing additional levels of indirection. For instance, dynamic binding is commonly used to allow developers to subclass and customize existing interfaces. However, the resulting generality and flexibility often reduce efficiency. For instance, in languages like C++ and Java, the use of dynamic binding makes it impractical to support Concrete Data Types (CDTs), which are often required for time-critical software. The lack of CDTs yields (1) an increase in storage layout (e.g., due to embedded pointers to virtual tables), (2) performance degradation (e.g. due to the additional overhead of invoking a dynamically bound method and the inability to inline small methods), and (3) a lack of flexibility (e.g., due to the inability to place objects in shared memory). Lack of standards -- Currently, there are no widely accepted standards for designing, implementing, documenting, and adapting frameworks. Moreover, emerging industry standard frameworks (such as CORBA, DCOM, and Java RMI) currently lack the semantics, features, and interoperability to be truly effective across multiple application domains. Often, vendors use industry standards to sell proprietary software under the guise of open systems. Therefore, it's essential for companies and developers to work with standards organizations and middleware vendors to ensure the emerging specifications support true interoperability and define features that meet their software needs. Key PrinciplesSuccessful patterns and frameworks can be boiled down to a few key principles:1. Separate interface from implementation2. Determine what is common and what is variable with an interface and an implementation  – Common == stable3. Allow substitution of variable implementations via a common interfaceDividing commonality from variability should be goal-oriented rather than exhaustive\Benefits of Design PatternsDesign patterns enable large-scale reuse of software architectures.– They also help document systems to enhance understanding.Patterns explicitly capture expert knowledge and design tradeoffs, and make this expertise more widely available.Patterns help improve developer communication.– Pattern names form a vocabularyPatterns help ease the transition to object-oriented technology.Drawbacks to Design PatternsPatterns do not lead to direct code reuse.Patterns are deceptively simple.Teams may suffer from pattern overload.Patterns are validated by experience and discussion rather than by automated testing.Integrating patterns into a software development process is a human-intensive activity. [Introduction to Patterns and Frameworks, Dr. David L. Levine and Douglas C. Schmidt Department of Computer Science Washington University, St. Louis flevine,schmidtg@cs.wustl.edu http://classes.cec.wustl.edu/cs342/]Anti-patternsIf a pattern represents a "best practice", then an anti-pattern represents a "lesson learned". Initially proposed by Andrew Koenig (a respected C++ pioneer at Bell Labs), anti-patterns come in two varieties: Those that describe a bad solution to a problem which resulted in a bad situation. Those that describe how to get out of a bad situation and how to proceed from there to a good solution. Anti-patterns are valuable because it is often just as important to see and understand bad solutions as it is to see and understand good ones. Cope writes (in the AntiPatterns page at the WikiWiki Web): The study of anti-patterns is an important research activity. The presence of "good" patterns in a successful system is not enough; you also must show that those patterns are absent in unsuccessful systems. Likewise, it is useful to show the presence of certain patterns (anti-patterns) in unsuccessful systems, and their absence in successful systems.CatalogsThe authors of [POSA] have classified different kinds of pattern collections that possess varying degrees of structure and interaction into pattern catalogs, systems, and languages: Pattern Catalogs A pattern catalog is a collection of related patterns (perhaps only loosely or informally related). It typically subdivides the patterns into at least a small number of broad categories and may include some amount of cross referencing between patterns. Pattern Systems A pattern system is a cohesive set of related patterns which work together to support the construction and evolution of whole architectures. Not only is it organized into related groups and subgroups at multiple levels of granularity, it describes the many interrelationships between the patterns and their groupings and how they may be combined and composed to solve more complex problems. The patterns in a pattern system should all be described in a consistent and uniform style and need to cover a sufficiently broad base of problems and solutions to enable significant portions of complete architectures to be built.Process DevelopmentArchitecture reconstruction is an iterative and interactive process, comprising four phases. The first phase is the extraction, from implementation artifacts (including source code and dynamic information such as event traces), of a set of extracted views that represent the system's fundamental structural and behavioral elements. The second phase is fusion of the extracted views to create fused views that augment or improve the extracted views. During the third phase, the analyst iteratively and interactively develops and applies patterns to the fused views to reconstruct architecture-level derived views. Patterns provide the medium for an analyst to express their understanding of a system’s architecture as structural and attribute-based relationships among its components. Finally, the derived views may be explored for the purposes of evaluating architectural conformance, identifying targets for reengineering or reuse and analyzing the architecture's qualities.FutureOver the next few years, we expect the following aspects of patterns will receive considerable attention [Schmidt2]. Integration of design patterns together with frameworks. Some of the most useful patterns describe frameworks. Such patterns can be viewed as abstract descriptions of frameworks that facilitate widespread reuse of software architecture. Similarly, frameworks can be viewed as concrete realizations of patterns that facilitate direct reuse of design and code. One difference between patterns and frameworks is that patterns are described in language-independent manner, whereas frameworks are generally implemented in a particular language. However, patterns and frameworks are highly synergistic concepts, with neither subordinate to the other. The next generation of object-oriented frameworks will explicitly embody many patterns and patterns will be widely used to document the form and contents of frameworks. Integration of design patterns to form pattern languages. Much of the existing literature on patterns is organized as design pattern catalogs [GoF,Siemens]. These catalogs present a collection of relatively independent solutions to common design problems. As more experience is gained using these patterns, developers and authors will increasingly integrate groups of related patterns to form pattern languages. These pattern languages will encompass a family of related patterns that cover particular domains and disciplines ranging from concurrency, distribution, organizational design, software reuse, real-time systems, business and electronic commerce, and human interface design. In the same sense that comprehensive application frameworks support larger-scale reuse of design and code than do stand-alone functions and class libraries, pattern languages will support larger-scale reuse of software architecture and design than individual patterns. Developing comprehensive pattern languages is challenging and time consuming, but will provide the greatest payoff for pattern-based software development during the next few years. Integration with current software development methods and software process models. Patterns help to alleviate software complexity at several phases in the software lifecycle. Although patterns are not a software development method or process, they complement existing methods and processes. For instance, patterns help to bridge the abstractions in the domain analysis and architectural design phases with the concrete realizations of these abstractions in the implementation and maintenance phases. In the analysis and design phases, patterns help to guide developers in selecting from software architectures that have proven to be successful. In the implementation and maintenance phases, they help document the strategic properties of software systems at a level higher than source code and models of individual software modules. SummaryThe use of patterns and pattern languages is an abstraction techniques which has been quite successful in other disciplines.  The M&S community can practically apply the reuse principle by adapting the use patterns and pattern languages.  This does not mean pick up the software design pattern catalog and directly apply those patterns, but that the technique of using the pattern abstraction technique can be applied to simulation design and create an M&S pattern catalog which can successfully capture the demonstrated benefits for this community.References [Adelson and Soloway 1989] B. Adelson and E. Soloway. The Role of Domain Experience in Software Design. IEEE Trans. on Software Engineering, V SE-11, N 11, 1985, pp. 1351-1360. [Alexander 1979] Alexander, C., et al, The Timeless Way of Building, Oxford University Press, 1979.[Arlow and Neustadt 2002] Arlow, J. and Neustadt, I., UML and the Unified Process: Practical Object-Oriented Analysis & Design, Addison Wesley, 2002. [Birrer: 1993] Eggenschwiler T. Birrer "Frameworks in the Financial Engineering Domain: An Experience Report" ECOOP '93 Proceedings, Lecture Notes in Computer Science nr. 707, Springer-Verlag, 1993. [Campbell-Islam: 93] Roy H. Campbell and Nayeem Islam "A Technique for Documenting the Framework of an Object-Oriented System", Computing Systems, Vol. 6, No. 4, Fall 1993 [Coad 1992] P. Coad, Object-Oriented Patterns. Communications of the ACM, V 35 N 9, Sept 1992, pp. 152-159. [Coplien 1992] J. O. Coplien, J. Vlissides, and N. Kerth, eds., Pattern Languages of Program Design, Vol 2. Reading, MA: Addison-Wesley, 1996. [Curtis 1989] B. Curtis, Cognitive Issues in Reusing Software Artifacts. In Software Reusability, V II. ed. T. Biggerstaff and A. Perlis, Addison Wesley 1989, pp. 269-287. [Fayad-Hamu: 1997] Mohamed E. Fayad and David S. Hamu "Object-Oriented Enterprise Frameworks: Make vs. Buy Decisions and Guidelines for Selection", The Communications of ACM, 1997[Fowler 1997] Fowler, M., Analysis Patterns. Reusable Object Models, Addison Wesley, 1997.[Gamma 1995] Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides, "Design Patterns: Elements of Reusable Software Architecture", Addison-Wesley, 1995.[Gustavson 2004] Paul Gustavson, Katherine L. Morse, Robert Lutz, Steve Reichenthal, Applying Design Patterns for Enabling Simulation Interoperability, 2004 Spring Interoperability Workshop 04S-SIW-111.[Hamu-Fayad: 97] David S. Hamu and Mohamed E. Fayad, "Achieve Bottom-Line Improvements with Enterprise Frameworks," The Communications of ACM, October 1997. [Johnson: 88] Ralph Johnson and Brian Foote. ``Designing Reusable Classes.'' Journal of Object-Oriented Programming. SIGS, 1, 5 (June/July. 1988), 22-35. [Johnson: 95] Herman Hueni and Ralph Johnson and Robert Engel, ``A Framework for Network Protocol Software,'' Proceedings of OOPSLA, Austin, Texas, October 1995.[Linn and Clancy, 1992] M. Linn and M. Clancy, The Case for Case Studies of Programming Problems. Communications of the ACM V 35 N 3, March 1992, pp. 121-132. [Lutz 1997] Lutz R, "A Comparison of HLA Object Modeling Principles with Traditional Object-Oriented Modeling Concepts", Simulation Interoperability Standards Organization, 97F-SIW-025, September 1997.[Petty and Weisel 2003] M. D. Petty and E. W. Weisel, .A Composability Lexicon., Proceedings of the Spring 2003Simulation Interoperability Workshop, Orlando FL, March 30-April 4 2003, 03S-SIW-023. [Pree: 94] Wolfgang Pree, Design Patterns for Object-Oriented Software Development, Addison-Wesley, Reading, MA, 1994.  [Schmidt 1996] D. C. Schmidt, A Family of Design Patterns for Application-Level Gateways, Theory and Practice of Object Systems, Wiley and Sons, to appear 1996. [Schmidt 1995] Schmidt, Douglas, Using Design Patterns to Develop Reusable Object-Oriented Communication Software, CACM, (Special Issue on Object-Oriented Experiences, Mohamed Fayad and W.T. Tsai Eds.), 38, 10, October 1995. [Schmidt: 1997] Douglas C. Schmidt, ``Applying Design Patterns and Frameworks to Develop Object-Oriented Communication Software,'' Handbook of Programming Languages}, Volume I, edited by Peter Salus, MacMillan Computer Publishing, 1997.  [Shalloway 2002] Shalloway, Trott, Design Patterns Explained. A New Perspective on Object-Oriented Design, Addison Wesley, 2002 [Siemens 1996] F. Buschmann, R. Meunier, H. Rohnert, P. Sommerlad, and M. Stal, Pattern-Oriented Software Architecture - A System of Patterns. Wiley and Sons, 1996. [Soloway and Ehrlich 1984] E. Soloway and K. Ehrlich, Empirical Studies of Programming Knowledge, IEEE Transactions on Software Engineering V SE-10, N 5, September 1984.  [W3C 2002].SRML - Simulation Reference Markup Language. W3C Note, Dec. 18, 2002. <http://www.w3.org/TR/SRML/>Authors:Kenn Atkinson is a Scientist for Science Applications International Corporation, assigned to the Support Staff for the Defense Modeling and Simulation Office. He has 23 years experience in software development and RF measurement systems.  Mr. Atkinson is a Registered Professional Engineer, received a Masters in Engineering Administration from the University of Utah and a Bachelors in Physics from the Brigham Young University.