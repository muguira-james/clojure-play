OneSAF: Indexing and Searching XML DocumentsRobin OutarScience Applications International Corporation12901 Science DriveOrlando, FL 32826-3014407-235-7660routar@saic.com Boaventura DaCostaDynamics Research Corporation3505 Lake Lynda Drive, Suite 100Orlando, FL 32817407-380-1200bdacosta@drc.comKeywords:Modeling and Simulation, M&S, One Semi-Automated Forces Objective System, OneSAF, OOS, eXtensible Markup Language, XML, Indexing, SearchingABSTRACT: The One Semi-Automated Forces (OneSAF) Objective System (OOS) is a next-generation Computer Generated Forces (CGF) simulation that can represent a full range operations, systems, and control processes from individual combatant level and platform level to fully automated BLUFOR battalion level and fully automated OPFOR brigade level. OneSAF is a data-driven simulation. Data is stored, managed, and interchanged using eXtensible Markup Language (XML). As a result, OneSAF has taken on the challenge of working with data and meta-data stored within file-based repositories. Considering the magnitude of files that can potentially be housed and accessed with a fielded OOS system, a vehicle was needed to easily track and search on all data housed within the repositories. As a result, a simple, yet powerful indexing mechanism was developed, allowing OneSAF to easily and effectively store meta-data about all XML data and search on these values. This paper discusses the mechanics of this indexing approach. In particular, this paper discuses the OneSAF Data Repositories, the types of information stored in these repositories, how data is accessed, how XML documents can be indexed and easily searched upon, and lessons learned along the way.1.0 IntroductionThe One Semi-Automated Forces (OneSAF) Objective System (OOS) is a next-generation Computer Generated Forces (CGF) simulation that can represent a full range operations, systems, and control processes from individual combatant level and platform level to fully automated BLUFOR battalion level and fully automated OPFOR brigade level [1]. OneSAF is a data-driven simulation. Data is stored, managed, and interchanged using eXtensible Markup Language (XML). As a result, OneSAF took on the challenge of working with data and meta-data stored within file-based repositories. Considering the magnitude of files that can potentially be housed and accessed with a fielded OOS system, a mechanism was needed to manage and search the data housed within these repositories.The result is a robust indexing engine allowing OneSAF to effectively catalog meta-data about XML documents and binary files. This engine also provides OneSAF with search capabilities, allowing data to be easily found through searching the index for specific meta-data.  This paper discusses the mechanics of this indexing approach. In particular, this paper discusses the OneSAF Data Repositories themselves, the types of information stored in these repositories, how information is accessed, how XML documents can be indexed and easily searched through, and lessons learned along the way.2.0 OneSAF Data ArchitectureXML is an integral part of the OneSAF Data Architecture, in that it is used to define the grammar of most of the data stored in the different OneSAF Data Repositories. The OneSAF Repositories Framework has been developed to support the data architecture providing System Repository Services (SRS). These SRS provide access to all data and meta-data housed in the repositories regardless of the data format. The SRS provide both XML-centric services as well as services independent of data format. These SRS provide a uniform vehicle to create and manage data across all of OneSAF.OneSAF data is stored in a number of data repositories. These are file-based systems, organizing information and data into logical areas. Data is not stored in models, but in files. All data files are stored in these repositories. OneSAF has seven repositories: Software Repository (SWR) (also referred to as the Concurrent Versioning System (CVS)), Knowledge Acquisition/Knowledge Engineering (KA/KE) Repository, System Composition Repository (SCR), Military Scenario Repository (MSR), Environment Repository (ER), Parametric and Initialization Repository (PAIR), and the Simulation Output Repository (SOR).  The SWR and KA/KE Repository have special constraints on developmental use within OneSAF. These are not data repositories and are not accessible via the SRS. The remaining repositories are considered data repositories and are treated uniformly, accessible only via the SRS.These SRS are the only valid means to access data. They act as an Application Programming Interface (API) to the data repositories. Clients wishing to access information must use these services. The SRS provide both domain-neutral core services and value-added data services. Core services provide clients with primitive data services (read, write, copy, and delete). Value-added services provide domain-specific APIs to particular types of data, such as consistent access to common data products. Access to Simulation Scenario data provided through the Simulation Scenario Design Language (SSDL) API is such an example. This service only provides access to simulation scenario data, but utilizes the primitive core services to read and write [2].3.0 Indexing and SearchingConsidering the magnitude of information that can potentially be housed in the data repositories, a vehicle is needed to catalog the data so that it can be programmatically managed and searched. OneSAF decided on an indexing solution simply because it would speed up data retrieval based on certain search conditions. An index solution, much like secondary access path indexes, would not affect the physical placement of the data, but instead would provide an alternative search path for efficiently locating data. The alternative would be a recursive file search of the entire repository system searching for specific data. From a performance standpoint, this was unacceptable.For an indexing solution to be useful, however, it needs to meet the following requirements:First, a querying language, such as SQL, (Structured Querying Language), found with most Relational Database Management Systems (RDBMS), is needed. SQL provides clients with an industry-standard way to search for data.Second, speed (performance) is a factor. A large amount of data may have to be indexed in short periods of time. Third, a distributed environment must be supported; multiple files across multiple computers need to be managed uniformly.Fourth, multiple file types must be indexed and searched, including XML documents.With these requirements in mind, indexing solutions were examined. When OneSAF started, very little was available in open-source solutions for XML indexing and searching. In addition, what was available at the time was either in its beta stages or required a monetary cost. As a result, OneSAF initially implemented its own indexing solution using XML until industry standard, open-source tools became available.3.1 Using XML to Index XMLInstead of creating a complex data structure such as B+-Tree, which some RDBMS use to index data, a simplified solution was implemented. This solution entailed the use of XML documents that would store attributes as well as keywords for each document housed in the repositories. Since OneSAF Repositories are file structures organized by directories, an index XML document would be stored in each directory, keeping track of all other documents within that location.  REF _Ref43872246 \h  \* MERGEFORMAT Figure 1 shows a fragment of a OneSAF XML Index Document.<?xml version="1.0" encoding="UTF-8"?><INDEX xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="index.xsd">    <FILEENTRY filename="M1A1.xml" classification="U" releasability="US Gov only" Last_Modified="2000-01-15T12:00:00" Format="xml" lock="false" status="complete" test="false"/>        <KEYWORDS key="vehicletype" value="tank"/>        <KEYWORDS key="tank" value="M1A1"/>        <KEYWORDS key="chassis" value="tracked"/></INDEX>Figure  SEQ Figure \* ARABIC 1: OneSAF XML Index Document FragmentEach document within a directory had a FILEENTRY element composed of a fixed set of attributes describing that document. These attributes provided data such as classification information and whether the document was locked for write by another client. In addition, each document could have more than one KEYWORDS element associated with it, providing additional meta-data about the document. These KEYWORDS proved helpful in searching for documents. For example, a client needing to know about all documents containing information about M1A1 tanks, could do so by posing a query looking for all documents with the key=”tank” and value=”M1A1”. This approach was very flexible and met the early needs of the program. As the program matured, however, and the number of XML documents increased, so did the demand for a more robust indexing approach. The largest concern with this solution was that the index files themselves were XML. Each and every time the document was accessed for reading and writing, it needed to be parsed. Reading was not as much of a problem, since the Simple API for XML (SAX) could be used, which is a fast parser for XML documents. Writing to the document, was another matter, however. The Document Object Model (DOM) was used for writing new document entries to the index. As the documents grew, so did the amount of memory required to parse the index. A one-megabyte XML document could easily require up to ten megabytes to be represented in memory [3]. Inevitably, the XML documents would become too large to be parsed.The other concern was keeping the index documents up-to-date with the current state of the repositories. SRS were provided which allowed developers to programmatically add and remove document references from the index. These services would be integrated with OneSAF composer, editors, and tools. As end-users created, modified, and removed data from the repositories, the composer, editor, or tool in question would correctly update the index document. All of this would occur seamlessly. During development and testing, however, these index documents had to be updated manually. While most developers were diligent in updating the indexes, some were not, which lead to orphan XML documents and/or document references within the indexes. 3.2 Finding a Robust, Open-Source SolutionAs the need for a new indexing solution grew for OneSAF so had it for the XML community. A number of open-source solutions were now available.Team OneSAF researched a number of solutions as a replacement for the in-house index approach. One solution was XQEngine, a text-based search engine for XML documents. Using technology, much like those of web search engines, such as Google and Yahoo, XQEngine provides users with the ability to search on word-content, something the index document mechanism did not support. In addition, users could search on attributes and element hierarchies. XQEngine uses the XQuery language for searching. (XQuery is a query language that poses queries against XML data.)Even though XQEngine showed promise (claiming it could index 70,000 words a second), there were two drawbacks. First, at the time, XQEngine had a 32,000-document limit. Second, it could only index XML documents. Since the OneSAF Repositories could easily surpass 32,000 documents and house data stored in binary formats, it did not meet the scalability needs of the program [4]. After careful consideration, the Jakarta Indexing Engine was selected. Jakarta Lucene is a high-performance, full-featured text search engine written entirely in Java available through the Apache Jakarta group. It is suitable for applications that require text search, and cross-platform support. Lucene boasts scalable, high-performance indexing; powerful, accurate and efficient search algorithms; simple Application Programmer Interfaces (API); and has cross-platform capabilities [5].3.3 The Lucene Indexing Engine Lucene creates an index, which is represented as a series of files that are optimized for fast lookup of data, much like that of an index for an RDBMS. This index is housed in the local file system. Documents can be freely added and removed from the index. The index can be “re-indexed” as needed. Lucene allows clients to specify the data and how to index it.  Attributes, such as filename and file path, can be stored in the index. Once these attributes are stored, they can be used as search keys. Results from queries are returned based on relevancy as determined by the querying engine. Queries can span multiple fields and have operators such as AND, OR, or NOT.  Queries can also include ‘wild cards” [6].Lucene creates an internal representation of a physical file; this representation is a document object. Document objects have fields associated with them. These fields are used to inform the Lucene indexing engine of how to store the data, whether the data should be indexed, tokenized. Once these fields are attached to the document object, this object is passed on to an index writer, which writes the document object to the index. The index writer uses an analyzer, to format the text being stored in the index (see  REF _Ref43872230 \h Figure 2). Lucene uses the same analyzer to query the fields of the index and produce query results [5]. INCLUDEPICTURE "http://www.sys-con.com/java/archives3/0712/walls/fig1.jpg" \* MERGEFORMATINET Figure  SEQ Figure \* ARABIC 2: Lucene Analyzer [5]Early benchmarking of the Lucene Indexing Engine showed favorable results. OneSAF was able to index the entire PAIR in less than ten seconds. Memory consumption was considerably less than the current in-house index approach, and performance increased dramatically. The OneSAF in-house index approach uses XML parsers to parse and retrieve data from the XML index document located in each directory. The Lucene Indexing Engine memory consumption was significantly less because Lucene only requires a one-megabyte heap size for the Java Virtual Machine. Further performance benefits resulted from the method in which Lucene optimizes the data stored in its indexes. The organization of the data by Lucene allowed for fast querying of the index.  REF _Ref43872209 \h  \* MERGEFORMAT Table 1 shows the average search times using the OneSAF in-house indexing approach and the Lucene Indexing Engine.Indexing MethodAverage Search Time (seconds)OneSAF In-house Indexing Approach.0632Lucene Indexing Engine.0027Table  SEQ Table \* ARABIC 1: Indexing Search ResultsLucene indexes are approximately 30% of the size of the text it has indexed. According to Lucene, data can be indexed at a rate of 200 megabytes an hour (on a Pentium 266 MHZ computer). Additional features include ranked searching (best result returned first), Boolean and phrase queries, and date related queries [7]. Based on the analysis, OneSAF chose to use the Lucene Engine.3.4 Integrating the Lucene Indexing EngineWhile Lucene is an excellent indexing and search engine, it has one major flaw. It was not designed for a distributed environment. Since OneSAF is being designed to operate on both a single node and multiple nodes, this posed a problem. It also meant that Lucene did not meet OneSAF’s third requirement for an indexing solution.In order to simplify the design a single node version was implemented before tackling the distributed version of this new index solution. To improve performance one index would exists per repository.   This approach would be more efficient in terms of querying and allow for greater flexibility. The performance increase resulted from searching a smaller index since there is no reason to search one large master index if the data is known to reside in a specific repository. Added flexibility came from the fact that if a repository had to be added or deleted, the master index would not have to be re-indexed or altered in any way. Additional flexibility is given from the fact that OneSAF is composable. For example, for a given composition, it could be possible that only the PAIR is needed, so that index would be used. (This will become clearer when distributed indexing is discussed.) Lucene does not support multiple indexes on multiple nodes. There is no way to synchronize indexes using Lucene. At the time of this writing Lucene also does not support networked queries. This flaw was seen in the initial testing of the product but was deemed acceptable because of its performance and features. In order to allow all OneSAF composers, editors, and tools running on multiple nodes to have a consistent view of the index, the decision was made to have one copy of the index set running on a server. This meant that the indexes (one for each repository) would reside on the server. A basic client-server approach was adopted.  Since Lucene does not have network support built in, an Indexer SRS was developed to enable Lucene to operate in a distributed environment. This Indexer SRS is simply a daemon that listens for requests from clients, processes the requests, and sends back a response. This Indexer SRS is also capable of arbitration to ensure it is the only Indexer SRS running in the distributed system. Since OneSAF can run on a single node, it is possible for more than one instance of the Indexer SRS to be running. The challenge was to ensure that distributed clients pointed to the “master” index while single node clients pointed to their local copy of the index. To address this challenge, an environment variable was introduced that would indicate whether the given client was running on a single node or distributed. Based on this variable the Indexer SRS would either point to the local copy of the index or the server that housed the distributed version of the index.With the advent of this Indexer SRS, Lucene now became a networked search engine. The server on which the SRS ran would have all the repositories and corresponding indexes. Since the indexes were on a different node, absolute file paths could not be returned as search results (as they would be based on specific system the index was residing on). Instead, repository abstractions are returned. These repository abstractions are a system independent way of representing files in the various repositories. The distributed version of the Indexer SRS simply reuses the standalone implementation with the Indexer SRS to allow for distributed querying. A sequence diagram of OneSAF distributed indexing is provided  REF _Ref47866193 \h  \* MERGEFORMAT Figure 3. EMBED PBrush  Figure  SEQ Figure \* ARABIC 3: OneSAF Distributed Indexing Sequence DiagramClients use a repository file object to pose queries against the index. The appropriate search method is invoked from the repository file. The repository file then creates a request object and passes the object to the Indexer SRS. The Indexer SRS finds an instance of the service running and sends the request to the searcher class. The searcher class processes the request object, creates a response object with the results of the query, and hands that to the Indexer SRS, which in turn hands the response object to repository file. The repository file then processes the response and presents the client with the results in the form of a string array. Standalone querying works the same way except the Indexer SRS is forced to use the local node.3.5 OneSAF Index Meta-dataThe index houses two categories of meta-data, required attributes and client-defined name-value pairs. Each file reference in the index automatically inherits a set of required attributes. These attributes along with a description are provided in  REF _Ref45351600 \h  \* MERGEFORMAT Table 2.Required AttributeDescriptionNameThe name of the repository, directory, or file.FileTypeThe type of file. This attribute also specifies if type is of repository or directory.ClassificationThe classification value of the repository, directory, or file.ReleasabilityThe releasability value of the repository, directory, or file.StatusDoes not apply to repositories or directories. Files can be designated as Complete or Draft. Complete files are considered executable by the system.LockDoes not apply to repositories or directories. Identifies a file as being locked for write by a client. All other clients can only read the file until the locking client releases the file.LastModifiedThe creation date of the repository or directory. Can be the creation date or last modified date for files.Table  SEQ Table \* ARABIC 2:  Required Index File AttributesWhen a file reference is added to the index, the attributes found in  REF _Ref45351600 \h  \* MERGEFORMAT Table 2 are automatically associated with the file. Default values are used if the client supplies no other values. Clients can later modify the values for these attributes if they so desire. As the OneSAF program matures, additional required attributes may be added as necessary.Name-value pairs are simply client-defined attributes assigned to desired file references within the index. These name-value pairs are not automatically added to the index. Clients have two ways which to add this name-value pair to the index. The first approach makes use of XML Processing Instructions (PIs). These PIs are placed in the XML document after the XML declaration, but before the starting element as shown in  REF _Ref45344994 \h  \* MERGEFORMAT Figure 4. <?xml version="1.0" encoding="UTF-8"?><?INDEX keyword = "vehicletype" value = "tank"?><?INDEX keyword = "tank" value = "M1A1"?><?INDEX keyword = "chassis" value = "tracked"?><ELEMENT...Figure  SEQ Figure \* ARABIC 4: OneSAF Index Processing InstructionsIndex PIs found after the start element are ignored. This was done for performance reasons. This avoids the Indexer Engine from having to parse the entire XML document. The Index PI is composed of a name-value pair. Clients can add any number of keywords to the index. ( REF _Ref45344994 \h  \* MERGEFORMAT Figure 4 shows three name-value pairs, but more could be added.) This approach using PIs only works with XML documents. Other file types must use the second approach. The second approach, allows OneSAF composers, editors, and tools to add name-value pairs to the index document object using the SRS. There can be a one-to-many relationship or a many-to-many relationship for the name-value pairs. This allows indexing of any file regardless of type.  To prevent duplicates, there are SRS to check if a name-value pair has already been assigned to the file.  Once name-value pairs have been added, they can then be easily searched.There are SRS to add and remove file references from the index.  There are also SRS to manage the name-value pairs associated with a given document.  These SRS provide many simplified interfaces to the Lucene package, making use of the index quite simple.  Clients of these SRS are not required to have any knowledge of Lucene. All the complexity of the Lucene Index Engine has been abstracted.In addition to these SRS, OneSAF Tools, such as the Data Management Tool and the Information Meta-data Tool, provide graphical interfaces to display the required attributes and name-value pairs to end-users. These tools provide additional features to graphically modify required attribute values and add, modify, and remove name-value pair meta-data.3.6 Searching the IndexOnce a file reference has been added to the index, a Find SRS provides the capability to search the index along with retrieving specific data form an indexed file. Operations are provided that allow for the fetching of value(s) based on a key along with an operation that allows for SQL like queries. Querying capabilities are inherited from Lucene, which defines a strict grammar for querying. This language allows nested queries using the operators AND, OR, NOT or ‘phrase’ relations. This allows the client to pose complex queries against the files that have been indexed. For example,(filename:\"M1A1.xml\" AND   classification:\"U\"");will return all XML documents that have a filename of “M1A1.xml” and a classification equal to ‘U’ (i.e. Unclassified). Clients have the flexibility to create canned searches that can be used with the OneSAF composers, editors, and tools. In addition, the OneSAF Data Management Tool provides a graphical interface search (see  REF _Ref45432478 \h  \* MERGEFORMAT Figure 5) allowing users to search across all the data repositories directly for virtually any XML document, other file type, or specific data within the documents themselves. EMBED PBrush  Figure  SEQ Figure \* ARABIC 5: Data Management Tool Search Window4.0 ConclusionThis paper discusses the challenge of implementing an indexing engine capable of tracking potentially thousands of XML documents and other file types across multiple repositories represented as file-based systems. Initial efforts entailed the development of an in-house, custom solution for OneSAF, using XML as the vehicle to index XML and other file types. As the XML community matured, open-source solutions became available, allowing OneSAF to benefit from reuse, while at the same time providing a reliable means of tracking and searching data across the system. The result is a robust, scalable index engine supporting sophisticated querying capabilities.5.0 ReferencesOneSAF Architecture and Integration (A&I) Task Order. (2003). OneSAF Product Line Architecture Specification (PLAS) – Volume I: Architecture Overview. Retrieved July 7, 2003, from OneSAF Web site: https://www.onesaf.net/Architecture_and_Integration/SystemsEngineering/SystemArchitecture/PLAS/OneSAF_PLAS_Volume_I.docOneSAF Architecture and Integration (A&I) Task Order. (2003). OneSAF Repository Component Layer. Retrieved May 24, 2003, from OneSAF Web site: https://www.onesaf.net/Architecture_and_Integrati on/SystemsEngineering/SystemArchitecture/PLAF/EPLAF/RepositoryLayer/repository_component_layer.htmlDaCosta, B., & Outar, R. (2003). OneSAF: XML Performance in Simulation. 2003 SIW Conference. Orlando, FL.XQEngine. Retrieved March 9, 2003, from http://www.fatdog.comWalls, Craig. (2002). Search-Enable Your Application With Lucene. Java Developers Journal. 7 (12).  Lucene Frequently Asked Questions. Retrieved March 23, 2003, from http://lucene.sourceforge.net/cgi-bin/faq/faqmanager.cgiJakarta Lucene. Retrieved March 23, 2003, from  HYPERLINK "http://jakarta.apache.org/lucene/docs/index.html" http://jakarta.apache.org/lucene/docs/index.htmlAuthor BiographiesROBIN OUTAR is a Software Engineer with Science Applications International Corporation in Orlando, FL. He is currently involved in the development of the XML and Repository aspects of the OneSAF Objective System. He received a B.S. in Computer Science from the University of Central Florida.BOAVENTURA DACOSTA is a Senior Software Engineer with Dynamics Research Corporation in Orlando, FL. He is leading the data engineering efforts for the OneSAF Object System as the Data Architect and Repository Lead. He received an M.A. in Instructional Systems and B.S in Computer Science from the University of Central Florida.