Approaches to Multicast Group Allocation in HLA Data Distribution ManagementBerrached, M. Beheshti, O. Sirisaengtaksin, A. deKorvinDepartment of Computer and Mathematical SciencesUniversity of Houston-DowntownHouston, Texas 77002 HYPERLINK mailto:Arached@dt.uh.edu Arached@dt.uh.eduKeywords:  DDM, HLA, Multicast, ClusteringAbstractData Distribution Management (DDM) is one of the six service categories defined in the HLA Interface Specification.  Its purpose is to reduce the amount of data exchanged among HLA federates by allowing each federate to declare regions, in a routing space, in which they are interested in either receiving or sending data.  At the core of DDM relevance filtering problem is how federates, or more specifically objects within federates, of similar interests (subscription/publishing) are clustered into multicasting groups.  The traditional approach to this problem is the fixed grid-based approach used in the RTI-STOW.  Fixed grid filtering, however, has several shortcomings.  This paper describes three alternative approaches: an object clustering-based approach that groups objects based on proximity of their interest/publication regions, a multi-level grid-based approach that takes advantage of the underlying network architecture, and a hybrid approach that combines features from the grid-based and clustering-based approaches.  Those approaches are evaluated and compared in terms of their filtering effectiveness and computational overhead in the specific context of the HLA data distribution.Introduction1.1  BackgroundThe objective of the Data Distribution Management in the High-level Architecture is to reduce the amount of irrelevant data updates that are exchanged among HLA federates.  The main concept to support data distribution is based on the so called, routing spaces [VanHook96, Morse97].  A routing space is a multidimensional coordinate system in which federates express their interest for either sending or receiving data.  The axes of a routing space define the domains of the simulation data, such as object attributes or interactions, that federates intend to exchange during simulation.  The need for DDM stems from the fact that, in general, a simulation object is interested in receiving a data update only if the data value is within a certain range of its domain.  Federates express their interests to send or receive data by posting their update or subscription regions to the RTI.  A subscription region defines a subset of a routing space in which a federate wishes to receive data updates.  An update region defines a subset of the routing space in which a federate offers to publish data updates.  When an update region and a subscription region overlap, a connection is established by the RTI and data updates are routed from the publisher of the data update to the subscriber to the data update.  The data distribution services, therefore, provide a mechanism for federates to send attribute and interaction updates only to those federates that have expressed interest in the updates being published.  Detailed information on various aspects of DDM can be found in any of [DMSO97, VanHook96, Morse97].Problem DefinitionCurrent implementations of DDM are based on using the multicast services provided by the underlying network to route data from a publisher to the group of federates that expressed interest in receiving the data [VanHook96,VanHook94].  Multicast addressing makes it easier for a sender process to send a message to multiple recipients.  It does this by shifting the burden from the sender application process to the lower layers of the underlying network architecture which take the responsibility of creating and maintaining the multicast groups, determining the various multicast routes, updating the routing tables across the network as group memberships change etc.  The overhead associated with multicasting is effected by three main factors: (1) number of multicast groups in use, (2) rate at which members join and leave multicast groups and (3) the size and structure of the network (e.g. LAN or WAN).  A straightforward approach to using multicast addressing  in the context of DDM is to associate a multicast group with each update region and join all the federates whose subscription regions overlap the update region. This straightforward approach, however, is only adequate for small simulations of few hundred entities (at best).  For larger applications, say of the order of hundred of thousands entities, the number of multicast groups required would be very large and the overhead associated with membership changes and other multicast maintenance operations would be tremendous.  As noted in [VanHook94], the number of multicast groups and the rate at which membership changes can be supported are a limited resource whose utilization has implications on the performance of the system. The purpose of this paper is to investigate different approaches to multicast group allocation.  The remainder of the paper is organized as follows: the next section gives an overview of the grid-based filtering approach.  Section 3, describes a multi-level grid-based approach.  Section 4 overviews the main issues involved in the clustering approach and section 5 introduce a hybrid approach that combines elements from the fixed-grid and clustering approaches.  Fixed grid-based APPROACHAn implemented approach to the multicast allocation problem for data distribution is the fixed grid-based approach [VanHook96, VanHook94, DMSO97].  In the fixed grid-based approach, each routing space is subdivided into a predefined array of fixed size cells.  Each grid cell is assigned a multicast group.  A federate joins those multicast groups whose associated grid cells overlap the federate subscription regions.  When a federate whishes to send a data update, the update is delivered only to those multicast groups whose associated grid cells overlap the federate update region.  The idea here is that if an update region and a subscription region intersect, they must both overlap at least one grid cell in common.  The multicast group(s) associated with the overlapped cell(s) serve to route the data updates from publishing to subscribing federates.  The fixed grid approach is relatively simple to implement and incurs little overhead.   Its main feature is that no interaction between federates is needed to determine the required connectivity between senders and receivers.  This is due to the fact that the grid is predefined and the regions occupied by the grid cells are regular (i.e. d-dimensional rectangles) and remain unchanged at run time.  Matching of subscription and update regions to grid cells is therefore done by each federate locally.Despite those features, the fixed grid-based approach suffers from a number of shortcomings.  First, it does not filter out all irrelevant data.  Irrelevant data can be delivered if a subscription and update regions overlap the same grid cell but do not themselves intersect.  This situation is illustrated in Figure 1.  The figure depicts a 2-dimensional routing space subdivided into a 4 by 4 grid and two regions ,S and U, which represent the subscription and update regions of federates F1 and F2, respectively.  Note that S and U do not intersect and therefore data update from the F2 should not be delivered to F1.  However, because both regions overlap cell 9, any data update from F2 will be delivered to any subscriber to the multicast group associated with cell 9, including F1.    F1    F2Figure 1: Irrelevant data is delivered from F2 to F1 even though S and U do not intersect.Irrelevant data delivery can be reduced by reducing the size of the grid cells.  However, this would increase the number of multicast group usage and its associated overhead.The second drawback of fixed grid-based filtering is that no information about the dynamic state of the publishing or subscribing federates is used to optimize multicast group usage.  Multicast groups are pre-allocated evenly to cells across the routing space and remain unchanged through out  the simulation regardless of the needs of the federates. This results in inefficient utilization of multicast groups: low utilization of multicast groups in sparsely “populated” regions of the routing space and insufficient multicast groups in the more heavily populated regions.  For a more comprehensive analysis of fixed-grid based filtering see [VanHook96].A multi-level grid-based approachThe limit on the number of multicast groups and their associated maintenance overhead is most critical at the wide area network level.  At the local area network level, multicasting is much more efficient.  In effect, multi-access local area networks (e.g. Ethernet or token bus based LANs) provide hardware support for multicasting and though multicast group membership maintenance incurs some overhead, it is not nearly as significant as in the case of wide area networks.  This property can be used to provide a hierarchy of grid-based filters with increasing level of granularity at successive levels of the underlying network.Figure 2:  Schematic diagram of a Two-level Grid-Based filterFigure 2 shows a two-level filter in a network configuration with three local networks.  A finer grid is used at the local network level and the coarse grid at the wide area network level.  Filtering agents [Calvin94] are used at the gateways to implement filtering at the wide area network level.  Each gateway filtering agent keeps a record of the subscription regions of all the federates in its site.  The subscription region of a gateway, in a routing space, is the union of the subscription regions of the federates in its site.  At the wide area network level, each higher-level grid cell is assigned a wide-area network multicast group (each of which consists of a group of site gateway addresses).  A gateway joins those WAN multicast groups whose associated higher-level grid cells overlap its subscription region.   At the local level, federates are only aware of the lower-level (finer) grid.  A federate joins those local multicast groups whose associated lower-level grid cells overlap its subscription regions.  An attribute/interaction update is sent to those multicast groups whose associated lower-level grid cells overlap with the update region of the publishing federate.  In addition, a copy of the update and the update region is also forwarded to the local site gateway filtering agent which would then forward it to the WAN multicast groups whose associated higher-level cells overlap with the update region of the publishing federate.When an update is received from a remote site, the local gateway filtering agent matches the update with the lower-level grid to find out those local federates that are interested in the update.  The update is delivered to those federates that are members of the multicast groups associated with the lower-level cells that overlap the update region.It is clear from the above description that the lower-level grid provides a mechanism to filter out irrelevant data that pass through the higher-level grid.  The advantage of this scheme is that it allows more effective filtering without increasing the number of multicast groups at the wide area network level. The effect is that it spreads the overhead associated with multicast addressing over the different levels of the network. It also inherits the simplicity of the fixed-grid approach in that federates do not have to interact to determine the required connectivity.Like the fixed grid approach, multicast groups are allocated statically which results in sub-optimal group utilization.Clustering approachesCluster based filtering is based on grouping objects that have similar subscription regions and/or update regions.  Ideally, objects that are subscribing to the same update region are grouped in the same cluster and assigned a multicast group.  Updates would then be routed only to the subscribers of the update region through the multicast group.  If the number of objects in the simulation is small, this method would be sufficient.  For large distributed simulations, however, this simple approach would require a large number of multicast groups. Further clustering can be done based on the proximity of the update regions in the routing space.  The idea here is that update regions that are close to each other in the routing space are likely to share common subscribers.  The problem can therefore be stated as follows: given N update regions and M multicast groups, group update regions in M clusters in such a way that update regions belonging to a cluster are closer to each other (in a given routing space) than update regions belonging to different clusters.  The problem of clustering as stated above has been studied extensively for different applications and numerous methods have been proposed, ranging from the square-error clustering methods to the use of back-propagation neural networks.  The suitability of these methods in the context of DDM depends on how and at what stage clustering is to be done.  Specifically, these methods are most suitable for static clustering, where groups are built at initialization time (i.e. before simulation run time).  Static clustering by itself, though it incurs little run time overhead, does not produce effective filtering because the clusters are not updated at run time to adapt to the dynamic changes of the update regions.  Applying those methods dynamically to continuously re-build the cluster database as update regions change, though it has the potential of producing near optimal filtering, is computationally impractical. A hybrid clustering approachOur hybrid approach combines elements from clustering and fixed grid approaches, and uses clustering statically and dynamically...Clustering is done in two phases.  The first phase takes place statically, at initialization time.  At this stage, objects in a routing space are represented with their initial update regions in the routing space.  Update regions are grouped based on their proximity to each other (i.e. the proximity of their centers).  As mentioned in the previous section, numerous methods can be used at this stage since their computational overhead, though still important, is not very critical .  The square-error clustering method, for instance, groups N data values in M clusters in such a way that the deviation of the data items from their cluster centroids (i.e. their mean vectors, also called centers of gravity) is minimized.  The algorithm attempts to generate a set of clusters that are as compact and separate as possible [Jain88].  Several programs have been developed based on this method and have proven to produce good results [Blashfield82].  Regardless of the method used, the outcome of this phase is a set of clusters, with each cluster consisting of a set of update regions.The second phase takes place during simulation run time.  Its objective is to maintain the compactness of the clusters as the objects states change and their corresponding update regions “move” in the routing space.  This entails that whenever an update region is changed, a decision is made as to whether it should be kept in the its current cluster or assigned to another cluster.  A straightforward approach is to compute the distances from the center of the region to all cluster centroids  and add the new region to the cluster with the closest centroid.  Once the new region is joined to a cluster, the new centroids of the modified clusters are recomputed and the clusters are re-built (i.e. every update region is joined to the closest newly computed centroid).  The first difficulty with the above approach is the computational overhead incurred by rebuilding the whole cluster database dynamically.  A more suitable approach would be to update only the clusters that have been directly effected by the change; i.e. the cluster that gained the new update region and the one that lost it.  The second difficulty, is that the cluster update mechanism is triggered every time an update region is changed.  For a large number of update regions, the overhead incurred would simply be prohibitive.Our approach is as follows: We take the set of clusters generated from phase 1, where each cluster consists of a set of publishers’ update regions, and map them onto a grid of fixed-size cells (e.g. the lower-level grid of section 2).  Each update region is mapped onto the grid by registering a publisher in each cell it overlaps.  The result is a collection of clusters, where each cluster consists of a set of cells containing one or more publishers from the original cluster.  Each cell is characterized by the number of publishers it contains.  Grid cells that are empty do not belong to any cluster and each occupied cell belongs to one and only one cluster.  The mapping of the clusters onto a fixed-grid of cells is in many respects analogous to digitizing an image onto a fixed-grid of pixels.  The benefits are also similar, it reduces the computational complexity of processing the clusters.  Instead of dealing with continuous points (i.e. update regions) in space, we only have to deal with a finite set of cells, of which only the occupied ones are of interest.  In particular, cluster updates are triggered only when an occupied cell becomes empty (i.e. its number of publishers goes to zero) or when an empty cell becomes occupied.  The two main operations needed for cluster updates are the leave and join operations.  For the leave operation, which occurs when the number of publishers in a cell goes to zero, the cell is simply deleted from the cluster and the centroid of the cluster is recomputed.  For the join operation, which occurs when an empty cell becomes occupied, the new cell is added to its closest cluster.  This can be accomplished by adding the new cell to the cluster with the closest centroid.  Another alternative, is to add the new cell to the cluster of its closest neighboring cell.  The first approach has the potential of keeping the clusters more compact while the second approach incurs less overhead, especially if the clusters are represented using tree data structure (e.g. bintrees or octrees [VanHook96, Samet90]).  To limit clusters spread, a split operation can be employed, which splits a cluster if its cell count exceeds a certain threshold.  Of course, splitting should not be done unless there are unused multicast groups available.  A dual merge operation can be used to merge clusters whose centroids get sufficiently close to one another. Filtering is achieved by matching subscription regions and update regions that overlap the same clusters.  A multicast group is associated with each cluster.  Each federate subscribes to the multicast groups whose associated clusters overlap the federate subscription regions.   Attribute updates and interaction are sent only to those multicast groups whose associated clusters overlap the update region of the publishing object.  Summary In this paper, we described approaches to the problem of multicast allocation for data distribution.  The traditional fixed grid-based approach is the simplest to implement and incurs the least run time overhead.  Its performance depends to a great extent on the granularity of the grid (i.e. the maximum number of multicast groups that can be used at a time).  Its major drawbacks stem from the fact that multicast groups are allocated statically to regions of a routing space which can result in inefficient utilization of multicast groups.  A multi-level grid-based approach was proposed.  Its main feature is that it provides a hierarchy of grid-based filters with increasing levels of granularity at successive levels of the network hierarchy.  Cluster-based approaches have the potential of providing better filtering with fewer multicast groups.  However, they can be computationally intensive.  A hybrid approach that combines features from the grid-based and clustering approaches was also described.  References[Blashfield82]	Blashfield R. K., Aldenderfer M. S., and Morey L. C., “Cluster Analysis Software,” In Handbook of Statistics Vol. 2, North-Holland Publishing Company, Amsterdam, 1982. [Calvin94]	Calvin J. O. and VanHook D. J., “Agents: An Architectural Construct to Support Distributed Simulation,”  Proceedings of the 11th Workshop on Standards for the Interoperability of Distributed Simulation, September 1994.[DMSO97] 	Defense Modeling and Simulation Office, “HLA Data Distribution Management: Design Document Version 0.5,” February 1997.  Available at URL: http://www.dmso.mil/projects/hla/ [Jain88]	Jain A. K. and Dubes R. C., “Algorithms for clustering Data,” Prentice-Hall 1988.[Mose97]	Morse K. L., Steinman J. S., “Data Distribution Management in the HLA: Multidimensional Regions and Physically Correct Filtering,” Proceeding of the Simulation Interoperability Workshop, Spring 1997.[Samet90] Samet H., “Applications of Spatial Data Structures,” Addison-Wesley Publishing Company, 1990.[VanHook94]	Van Hook D. J., Rak S. j., Calvin J. O., “Approaches to Relevance Filtering,”  Proceedings of the 11th  Workshop on Standards for the Interoperability of Distributed Simulations, September 1994. [VanHook96]	Van Hook D. J., Rak S. j., Calvin J. O., “Approaches to RTI Implementation of HLA Data Distribution Management Services,” Proceedings of the 15th Workshop on Standards for the Interoperability of Distributed Simulations, September 1996. PAGE  1PAGE  6           0	         1	         2	        3 		           4	           5                6             7           9		         10           11   						                                    11              12	         13           14US   9Site GatewayWANLocal NetworkLocal NetworkAgentHigh-level GridLow-level GridLocal Network