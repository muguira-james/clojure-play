Design of the HPC-RTI for the High-Level ArchitectureDr. Jeffrey S. Steinmansteinman@ca.metsci.comGuy Berliner, Gary E. Blank, James S. Brutocao, Jacob Burckhardt, Mitch Peckham,Scott Shupe, Kurt Stadsklev, Tuan Tran, Dr. Ron Van Iwaarden, Lois YuMetron Incorporated512 Via De La Valle, Suite 301Solana Beach, CA  92075(619) 792-8904AbstractThis paper describes a new Run-Time Infrastructure (RTI) for the High-Level Architecture (HLA) that executes on massively parallel high-performance computers. Currently under development, this new RTI uses the Synchronous Parallel Environment for Emulation and Discrete-Event Simulation (SPEEDES) framework to coordinate all HLA services between legacy simulations and native SPEEDES simulations.First, this paper provides an overview of the SPEEDES architecture, including topics such as communications, event management, time management, and the SPEEDES Modeling Framework. This paper then shows how SPEEDES supports HLA on high-performance computers.Three primary HLA tasks are discussed: (1) development of an HLA “gateway” that allows SPEEDES simulations to interoperate with HLA federations, (2) development of RTI interfaces between SPEEDES and external simulations executing in a networked environment, and (3) development of an RTI for simulations running on high-performance computers. In tasks (2) and (3), SPEEDES functions as both a simulation engine and an RTI. Using the various SPEEDES-HLA interfaces, all combinations of SPEEDES simulations, HLA federations, and HLA federates can interoperate in a single conglomerate execution.IntroductionIn the early 1990’s, several Department of Defense (DoD) simulation infrastructure projects began to explore how to provide interoperability between multiple simulations executing on different computing platforms [12,13,17,26]. SPEEDES was one of those projects [23]. Its primary goal was to provide interoperability between objects distributed across large numbers of processors using a common simulation engine. One of the key features of SPEEDES is its ability to preserve causally correct event processing in a repeatable manner without sacrificing parallel performance or imposing constraints regarding how simulated objects may interact. The SPEEDES work resulted in more than thirty publications and a number of government patents [18].In the mid-1990s, the DoD officially acknowledged the importance of providing interoperability between its simulations. The Defense Modeling Simulation Office (DMSO) [6] began to explore the idea of defining a High-Level Architecture (HLA) that would provide the necessary means to achieve interoperability between disparate simulations [4,5,7,22,33]. In 1996, members of the Architecture Management Group (AMG) unanimously voted to adopt the HLA. All DoD simulations are now mandated to conform to the HLA standard. Interoperability has moved to the forefront of the DoD simulation world.The Simulation Interoperability Standards Organization (SISO) is now coordinating with IEEE and OMG to finalize the HLA standard. Twice a year, SISO sponsors the Simulation Interoperability Workshop (SIW) to focus on HLA-related simulation topics.While the HLA standard was being formed, several mainstream DoD projects began looking at SPEEDES to combine interoperability and high-performance by using a common simulation engine. SPEEDES applications can combine to form larger, more capable simulations. The SPEEDES modeling framework is currently being extended to provide interoperability with:HLA federations through a gateway that can “talk to” any RTI meeting the HLA standardExternal HLA federates operating in a computer network environmentHLA federates represented as SPEEDES nodes that execute on high-performance computersAll of the above combinations are interoperable with each other. The rest of this paper highlights the SPEEDES Modeling Framework (SMF) and how it supports HLA.Technical BackgroundThis section gives a high-level overview of the SPEEDES architecture and its modeling framework. It then discusses how the SPEEDES Modeling Framework has been extended to provide further distributed simulation capabilities and full interoperability with HLA.The SPEEDES Architecture REF _Ref443383943 \h  \* MERGEFORMAT Figure 1 shows the fundamental architecture for SPEEDES. The layered approach provides a well-encapsulated strategy for isolating critical functionality and extending capability through higher abstractions.Figure  SEQ Figure \* ARABIC 1: The SPEEDES Architecture.Two internal communication libraries provide the foundation for efficiently supporting distributed simulation in a portable manner. The SPEEDES Communications Library achieves interoperability between different operating systems, networks, and inter-process communication mechanisms through a common interface that we have been able to implement and optimize across all the major types of parallel and distributed computing environments. Such environments include shared memory multiprocessor machines, networks of computers, and/or large-scale message-passing super-computers. The basic services in the SPEEDES Communications library are summarized in  REF _Ref443391279 \h  \* MERGEFORMAT Table 1.Table  SEQ Table \* ARABIC 1: The SPEEDES Communications LibraryService CategoryCommunication ServicesMiscellaneous(1) Start up communications, (2) get number of nodes, and (3) get node idBarriers(1) Enter barrier, (2) enter fuzzy barrier, and (3) exit fuzzy barrierGlobal Reductions(1) Global sums, (2) global minimums, and (3) global maximumsAsynchronous Messages(1) Send a message to either: a single node, a list of destinations, or to all nodes, (2) poll the network for incoming messages and queue them up, (3) return a queued message of a particular type, and (4) poll the network for a message of a particular typeCoordinated Messages(1) Send a message to either: a single node, a list of destinations, or to all nodes, and (2) receive a message, returning NULL when there are no more messages to receiveThe current shared memory implementation does not require the use of operating-system-dependant semaphores. All reads and writes to shared memory are logically coordinated to ensure correctness without requiring non-portable locking mechanisms provided by semaphores. Other than the system calls to (1) create a shared memory segment, (2) to attach a pointer to the shared memory, and (3) to delete the shared memory when it is no longer needed, the rest of the SPEEDES shared memory implementation is ordinary (and portable) C++ code.SPEEDES also provides a second communications infrastructure that facilitates message passing with external modules. SPEEDES decouples its internal message-passing infrastructure from its external message passing system in order to optimize the implementation of each separately. Internal communication is accomplished by sending messages through shared memory, local high-speed networks (or both); external communications are transmitted through distributed network environments. Separating external and internal communication systems enables external modules to join and leave SPEEDES simulations without disrupting internal synchronization mechanisms. Figure 2 shows a SPEEDES simulation operating on two multiprocessor machines with several external modules.All messages in SPEEDES use network-safe versions of integers and doubles to perform heterogeneous data conversions between big endian and little endian machines. Two C++ classes, NET_INT and NET_DOUBLE, overload assignment and accessor operators to effect such conversions transparently. When accessed, these data types convert the data they represent to the right form, if necessary. This strategy allows SPEEDES to define network-safe messages composed solely of NET_INTs and NET_DOUBLEs, thus eliminating the need for the framework to encode and decode messages sent between heterogeneous machines. Users can set preprocessor flags during compilation to define NET_INTs and NET_DOUBLEs as normal integers and doubles when running in a homogeneous environment.Figure  SEQ Figure \* ARABIC 2: SPEEDES network connectivity example. Here, two machines, each with four processors, support the internal SPEEDES simulation using both shared memory and TCP/IP inter-process communication services. External modules are connected through the Host Router to provide visualization, analysis, and interoperability with other HLA simulations.SPEEDES provides an optimistic, rollback-based, event-management layer that can be used to support multiple time management schemes [8]. Disabling the rollback mechanism at run time permits conservative time management algorithms to synchronize event processing. Currently, lookahead-based conservative time management is available.SPEEDES uses incremental state saving techniques to support rollbacks. Users substitute atomic data types such as integers, doubles, and strings with C++ objects that capture state changes with overloaded assignment operators. Their default conversion operators allow them to be used as normal data types in equations, etc. Examples of rollbackable data types are RB_int, RB_double, and RB_string.SPEEDES provides a library of rollbackable container classes. Examples are RB_SpList, RB_SpBinaryTree, RB_SpHashTree, and RB_SpDynPtrArray. These classes support rollbackable operations by reversing the operation when rollbacks occur. For example, SPEEDES rolls back the insertion of an element into a tree by removing that element from the tree. Because the tree may undergo several rotations during the insert and remove operations, SPEEDES does not guarantee that the shape of the tree after a rollback is the same as it was before the original operation occurred. However, SPEEDES does preserve element order and thus functional correctness.SPEEDES also supports rollbackable dynamic memory allocations when users employ the RB_DEFINE_CLASS(T) macro, where T is a user class name. This macro generates several functions and rollbackable pointer classes to support dynamic memory allocations with rollbacks. For example, the macro generates a function called RB_NEW_T() that users may invoke to create a new instance of class T. If the event that created the instance gets rolled back, SPEEDES automatically deletes the instance, thereby preventing a memory leak.SPEEDES currently supports lazy cancellation in a manual mode where users can write virtual methods that determine whether events are permitted to roll forward following a rollback. In the future, SPEEDES will automate lazy cancellation through a built-in touch-depend system that tracks the dependencies between events and state variables. A rolled back event can later be rolled forward if the straggler that induced the rollback does not touch any of the state variables that the event depends on. All rollbackable operations in SPEEDES are rollforwardable [19,27,28] and thereby support lazy cancellation.SPEEDES supports transparent persistence, the ability to save the state of a simulation to disk. Whenever a SPEEDES simulation dynamically creates a rollbackable object, SPEEDES records its address and block size in a default persistent database that it manages directly in high-speed memory. Similarly, whenever the simulation sets a rollbackable pointer, SPEEDES records the linkage between memory blocks in the database.By transparently providing persistence in the rollback mechanism, SPEEDES simulations can automatically participate in checkpoint/restarts. During a checkpoint, SPEEDES packs all objects on each node into a compressed buffer and then writes the buffer to disk. Each node writes to its own file. SPEEDES can later read these files during a restart to reconstruct the entire simulation from the point where the checkpoint was originally made. This capability provides further fault tolerance for SPEEDES applications.Figure  SEQ Figure \* ARABIC 3: Distributed time management.Guaranteeing logically correct time management in a distributed computing environment involves many challenges. Each simulated object must process its events in ascending time order to maintain repeatability and causality. The challenge is to allow any object to schedule events for any other object at any logical time in the present or future.Without lookahead, conservative time management algorithms can only permit the object with the smallest time tag to process its next event. This is because all other objects must wait just in case their actual next event is scheduled by the current event. This fact prohibits concurrent event processing, thereby serializing the simulation.Lookahead provides some processing concurrency by limiting how tightly in time objects can interact. If the earliest unprocessed event time in the simulation is T, and the lookahead value is L, then a simulation engine can process events while maintaining causality up to time T+L. Of course, this limitation makes it difficult to support tight interactions between objects and offers a poor solution to the time management problem.The most capable solution to the time management problem is to allow objects to process their events optimistically, but then roll them back when receiving straggler events (an event whose time tag is in the past). Since events can change state variables and schedule new events, rollbacks must restore state variables and retract events generated during the rolled-back simulated time interval. When a simulation engine schedules events for different nodes, it sends event-scheduling messages. Rollbacks must therefore retract those sent messages by further sending antimessages. When another simulation node receives an antimessage, it may have already processed the retracted event. This requires further rollbacks, which likely generates further antimessages, etc. Cascading rollbacks may cause instabilities for simulations with poor load-balancing characteristics. The most popular optimistic algorithm is called Time Warp [11].SPEEDES supports the optimistic approach with an algorithm called Breathing Time Warp (BTW) [21,23]. This algorithm provides the flow control necessary to ensure stable simulation execution. BTW achieves such flow control by releasing event messages only when they are likely to be valid. Events that have a high probability of being rolled back hold onto their messages initially. This strategy significantly reduces antimessage traffic, which in turn further reduces rollbacks.The SPEEDES Modeling FrameworkThis section describes the SPEEDES modeling framework, which includes (1) fundamental abstractions, (2) components & event handlers, and (3) events as methods & processes.Fundamental AbstractionsThere are four fundamental abstractions in the SPEEDES Modeling Framework that act as building blocks for the rest of the framework. These abstractions are (1) object managers, (2) simulation objects, (3) events, and (4) messages [23].  REF _Ref443911925 \h Figure 4 shows an extended Unified Modeling Language (UML) class diagram [15] representing these four fundamental abstractions.One object manager instance for each kind of simulation object resides on each node. Object Managers group different kinds of simulation objects together into subsets in a distributed manner. An object manager decomposes its simulation objects to SPEEDES nodes and remembers their locations when responding to requests for simulation object handles.Figure  SEQ Figure \* ARABIC 4: UML diagram of the fundamental classes in the SPEEDES Modeling Framework.SPEEDES provides two common decomposition strategies, block-decomposition and scatter-decomposition, through built-in macros that automate the decomposition process. With these macros, SPEEDES relieves users from writing their own object managers. Simulation object lookups are computed by modular arithmetic rather than by table lookups which would require more memory and do not scale as well. Static and dynamic load balancing techniques will likely become available in the future [32].Simulation objects represent the simulated entities. Their state variables must be comprised of rollbackable data types. All event management responsibilities for individual entities reside in the base class simulation object where SPEEDES maintains pending unprocessed events as well as uncommitted processed events. A SPEEDES scheduler, residing on each node, continually determines which simulation object processes its next event. Processed events are committed when their time tags are less than the time tag of the earliest unprocessed event in the simulation [8,11,21]. REF _Ref443911925 Figure 4 shows that object managers are also simulation objects. This supports logically correct dynamic object creation during a simulation execution. Applications may schedule simulation object creations on any node at any present or future simulated time. This requires object managers to support event-processing capabilities. Thus, object managers must inherit from the simulation object base class. By necessity, the dynamic object creation and deletion mechanism supports rolling back object creation and object deletion events.Time-tagged events are C++ objects that are managed by simulation objects. Unprocessed events with future time tags are stored in a pending event queue. Processed events with time tags in the past are stored in an uncommitted event queue until SPEEDES commits them. When processing an event, SPEEDES stores state variable changes in the event object. This allows SPEEDES to roll back uncommitted events when necessary. An event may associate with only one simulation object at a time because (1) simulation objects may be on different nodes, (2) simulation objects may be at different logical times, and (3) rollback dependencies are coordinated by simulation objects.A special C++ class called SpSimTime represents the logical time of events. This class contains five values that represent the physical event time and a series of tie-breaking fields. A double precision variable represents the physical time. Users can set two integer priority fields to break ties between events with the same physical time. Priorities can take on negative values. SPEEDES automatically sets two more integer fields, ensuring that all internally scheduled events have unique time tags, even when their physical times and priority fields are the same. Because of this, there is no ambiguity in the ordering of events, thus ensuring repeatable executions.Messages facilitate scheduling events. Each message begins with a header that contains information including (1) the logical time of the event, (2) the event type, and (3) the object handle of the simulation object the event will act on. Following the header is an arbitrary number of fixed-length parameters that are passed as user-settable data for the event. Finally, optional user-provided variable-length data may follow at the message’s end.Scheduling an event always involves sending a message, even when the event is for an object on the same node. SPEEDES coordinates event messages internally when users schedule their events. Applications never directly send messages themselves. When a node receives a message, SPEEDES (1) creates an event object, (2) stores the message in the event object, and then (3) inserts the event object into the pending event queue for the appropriate simulation object. If necessary, SPEEDES then rolls back any processed, but uncommitted, events. Users can retract all events with “cancel” events. Users specify the event to retract with a cancel handle returned by the routine that scheduled it. Like all other events, SPEEDES rolls back cancel events when necessary.Components & Event HandlersBuilding on these fundamental abstractions, SPEEDES provides a higher-level component-based set of modeling tools to promote expressive and clear semantics, reusability, and maintainability. Components encapsulate an abstraction, such as a piece of equipment, that can be dynamically added or removed from a simulation object. Examples include sensors, trackers, weapon systems, communications, command & control, position, cargo, etc. Components usually contain one or more application-level models that are controlled by processes and event handlers. Models do not require inheritance. By keeping model associations one-way (i.e., models are only used by other objects within the component), SPEEDES preserves maximum reusability.  REF _Ref443966095 \h Figure 5 shows a UML class diagram for components.Figure  SEQ Figure \* ARABIC 5: Components in SPEEDES.Figure  SEQ Figure \* ARABIC 6: Event handlers in SPEEDES.Event handlers [29] can be associated with either components or with simulation objects directly (see  REF _Ref443984114 \h Figure 6). Event handlers differ from normal events in that they are registered and unregistered dynamically during run time.When registering (or unregistering) a component in a simulation object, SPEEDES registers (or unregisters) all of its event handlers as well. The object that schedules an event to invoke event handlers of a given string name may not know which event handlers corresponding to that string name are currently registered. This provides an abstraction barrier that further promotes software encapsulation and reuse. SPEEDES supports event handler invocations that are either directed (scheduled for an individual simulation object) or undirected (scheduled for all simulation objects that subscribe to the event handler string name).As an example, components may employ event handlers to react to a bomb detonation. Various pieces of equipment, each of which is modeled in a component, might register detonation event handlers to assess damage when detonation events occur. The detonation scheduler does not know which components, if any, process the detonation event.Events as Methods & ProcessesSPEEDES provides another way to schedule and process events. Users can define methods in their simulation objects to be invoked as events. Applications can schedule these event methods using a type-checked event-scheduling interface provided by SPEEDES. The macro, DEFINE_EVENT_METHOD, generates this specialized event-scheduling function in addition to an event object and a message. This macro relieves users from the necessity of writing event objects and messages.SPEEDES also provides support for process model constructs [31] inside event methods with a few simple macros. Processes are event methods that can pass simulated time without exiting. The WAIT statement is the simplest process model construct. Processes can wait specified time periods and then “wake up,” continuing where they left off. Local stack variables in the process remain valid when waking up. A WAIT resembles a UNIX sleep command, except it coordinates logical time rather than real time.SPEEDES provides semaphore constructs that allow processes to wait indefinitely, or with a timeout, until a condition occurs. Specifically, processes can:Wait for a logical semaphore to be set. The semaphore acts like a flag that triggers the process to wake up.Wait for a resource to become available. Resource semaphores hold integer or double values representing the resource amount. Processes can request and return resources. When requesting an amount, such as 10, that exceeds the current amount available, such as 6, the process blocks until another process returns enough resources to fulfill the request.Wait for a counter to be non-zero. This construct coordinates work done by a process that depends on a list of items, but has no work to do when the list is empty. For instance, a sensor that should go to sleep when there are no targets within its field of view could wait on a counter representing viewable targets.All semaphore waits can optionally provide a timeout argument to wake up after a specified amount of time if the semaphore condition is not satisfied. This provides a rudimentary capability to support interrupts. A process can wait on a semaphore using a timeout to represent normal wait logic, but then wake up early when an unexpected condition occurs that sets the semaphore. REF _Ref444047988 \h Figure 7 exemplifies semaphore waits. In this example, a radar sensor component has one radar sensor model, two types of processes, three event handlers, and two kinds of semaphores. An entity, such as a ship or an aircraft, can simply plug in this component to have a radar sensor onboard.Figure  SEQ Figure \* ARABIC 7: Example of a radar sensor component.When the radar discovers a target, SPEEDES activates the Radar Discover Object event handler, creating a Remote Proxy Semaphore and launching a new Radar Precomputation Process. The precomputation process predicts when the target enters and exits the radar’s detection range, and waits on the proxy semaphore using the predicted time as the timeout. If the target changes its motion before the timeout occurs, SPEEDES activates the Radar Reflect Attributes event handler, which sets the semaphore that interrupts the target’s precomputation process. When that happens, the precomputation process recalculates when the target enters its sensor range. In a similar manner, if the sensor changes its own motion, SPEEDES activates the Radar Update Attributes event handler, which sets all of the component’s proxy semaphores, thereby interrupting all of its precomputation processes.If a precomputation process reaches its timeout, it adds the target proxy to the Detectable Proxy List and increments the Remote Proxy Counter Semaphore. When the counter semaphore becomes non-zero, it wakes up the Radar Scan Process, which now begins forming detections by feeding position information from the detectable proxies into the Radar Model. The precomputation process also computes when each target exits the radar’s detection range. In a similar manner, the precomputation process removes the target’s proxy from the list and decrements the counter semaphore when the target exits the sensor’s detection range. If the counter semaphore ever returns to zero, the scan process goes back to sleep.Another process model feature is the ASK construct. This construct allows processes to invoke two-way remote method calls on other objects in logical time. To the programmer, it looks and feels as if the process invokes a method on a remote object with returned arguments provided by the remote object. SPEEDES actually invokes ASKs asynchronously in logical time, thus prohibiting deadlocks. SPEEDES first schedules an event method for the remote object, which when completed returns data back to the process through another event. Like WAIT statements, SPEEDES restores local stack variables and the process continues where it left off. Macros hide this implementation so that the code simply looks like a remote method call. ASKs can be nested.SPEEDES is targeting its process model capabilities to transform the IMPORT simulation language and compiler [30] to execute IMPORT programs in parallel. IMPORT extends the MODSIM programming language [2] in several ways. It provides advanced object-oriented mechanisms to describe reusable object associations. It also embeds declarative programming semantics within the simulation language to support artificial intelligence. When mature, IMPORT will comprise a 5th generation simulation language and development environment. A beta version of the Parallel IMPORT compiler has been delivered with SPEEDES Version 0.7. It currently supports some simple demos.Internal HLA Functionality in SPEEDESSPEEDES provides another internal layer of capability in its modeling framework that addresses functionality required by the DoD to support HLA interoperability. Users acquire this capability when their entities inherit from a special kind of simulation object base class called S_SpHLA. This class provides all of the critical HLA management functionality necessary for interoperability and scalable performance (see  REF _Ref444053586 \h Figure 8).Figure  SEQ Figure \* ARABIC 8: Object proxies.This layer does not provide HLA interfaces to SPEEDES users. Rather, its goals are three-fold:Provide advanced capability for SPEEDES simulationsAutomate interoperability with HLAProvide the foundation for a SPEEDES-based RTILater in this paper, we will discuss how SPEEDES wraps this layer with standard HLA interfaces.Internal Object Management & Object ProxiesThe S_SpHLA base class coordinates all object management services through the use of object proxies [24]. Object proxies allow entities to identify (1) exportable attributes implemented as special C++ objects and (2) exportable methods extended to the proxy through inheritance. Class-based subscription mechanisms, value-based subscription mechanisms, or both establish proxy distribution lists that are coordinated inside the S_SpHLA class.Exportable attributes and methods are combined into a proxy that can be distributed to other nodes or to the outside world. Object proxies support a number of object-oriented concepts including encapsulation, inheritance, dynamic binding, aggregation, and containment. The exportable attribute types currently provided by SPEEDES are shown in  REF _Ref444056702 \h Figure 9. When updating exportable attributes, operator overloading automatically reflects the updates across the network to subscribers in logical time.Figure  SEQ Figure \* ARABIC 9: Object proxy attribute types.Special kinds of attributes, called Dynamic Attributes, compute values as a function of time. Dynamic attributes find use, for example, in disseminating an entity’s position. Instead of periodically sending out position updates to the rest of the world, a formula locally calculates entity positions in each proxy. Dynamic attributes can significantly reduce message traffic and improve simulation fidelity.Dynamic attributes are implemented as a list of Dynamic Items, each of which represents the changing attribute over a subinterval of time. The extensibility of the dynamic attribute framework allows users to add new items to the library without requiring modifications to the general infrastructure. Dynamic items contain a start time and an end time and are stored within the attribute in a list ordered by ascending interval: i.e. {[t0, t1], [t1, t2], [t2, t3], ...}. To obtain a dynamic attribute value at a given logical time, the dynamic attribute class first searches through its list to find the dynamic item containing the correct time interval. Then the dynamic attribute invokes a virtual function that the inherited dynamic item provides to compute its value. The dynamic item list need not be homogeneous. This permits linking together different types of equations, providing a fully general mechanism for computing predicted values.Internal Interaction HandlersThe event handler framework provides support for HLA interactions. SPEEDES passes parameters into interaction handlers using the SpParmSet class. Because interaction handlers are event handlers, users can schedule both directed and undirected interactions. Entities subscribe to undirected interactions by string name. SPEEDES implements undirected interactions efficiently by only sending interaction messages to nodes that have at least one subscribing entity. Then, SPEEDES locally schedules the interaction for each subscribed entity on the node.Internal Ownership Management & Two-Way ProxiesIn the near future, a two-way proxy interface will provide ownership management functionality. SPEEDES will permit subscribers to modify remote proxy attributes through a standard set-method call on the remote proxy. The two-way proxy mechanism will automatically send new attribute values back to the original proxy owner, who will redistribute them to the remaining subscribers in logical time.Internal Declaration ManagementDeclaration management supports object proxy distribution based on class type. Each object proxy automatically publishes itself in a distributed manner during construction. Users may specify subscriptions through an input file or through method calls. SPEEDES supports hierarchical subscriptions.SPEEDES establishes distribution lists within each S_SpHLA object that track all the entities subscribing to its proxy. SPEEDES further reduces entity distribution lists into node lists to reduce message traffic. SPEEDES efficiently delivers attribute update messages to each node first before distributing them locally.Internal Data Distribution ManagementData Distribution Management (DDM) provides the key to scalability in large simulations. SPEEDES multidimensional routing spaces [3,9,14,25] provide value-based filtering. Publishers define publication regions and subscribers define subscription regions in routing spaces. An entity can register more than one publication region, subscription region, or both. If a subscription region overlaps a publication region, then the subscriber will receive the publisher’s object proxy.  REF _Ref444078720 \h Figure 10 shows this conceptually.Figure  SEQ Figure \* ARABIC 10: An example of a simple 2-dimensional routing space. This figure identifies two subscription regions and one publication region for three different objects. In this example, Object A will receive the proxy of Object C.SPEEDES provides four different kinds of routing space dimensions:Normal Dimensions – double precision values bounded by a minimum and a maximum. Users provide a low and high value to define a region.Theaters – bounded spatial regions using <latitude, longitude, altitude>. Users provide a position and a range to define spherical regions.Categories – integer-based values bounded by 0 and the number of categories - 1 for that dimension. Users specify a set of integer values to define categorical regions.Enumerations – an enumerated list of string elements that users can employ for filtering. Specifying elements in the enumeration identifies multiple regions.Users bin each dimension according to specified resolutions to form cells. SPEEDES then distributes each cell using a scatter decomposition algorithm. By distributing routing spaces in this manner, region overlap computations are processed in parallel. Further binning on dimensions permits SPEEDES to manage regions with higher resolution within a grid-cell. A hierarchical grid data structure represents each cell’s sub-dimensions, if any.SPEEDES does not require using every dimension in a routing space when specifying a region. Don’t care dimensions are equivalent to specifying the entire dimension. In other words, SPEEDES does not provide filtering on that dimension since the region really does not care about that dimension. For efficiency, SPEEDES does not subdivide don’t care dimensions into multiple bins for distribution. However, users can specify whether SPEEDES will subdivide don’t care dimensions within a hierarchical grid-cell, on a dimension-by-dimension basis.Users commonly employ DDM to support range-based filtering [20]. The theater dimension automatically determines region overlaps. To do so, it uses each entity’s maximum sensor range and each entity’s maximum velocity to determine (1) region sizes and (2) how often regions require updating. Users can specify multiple theaters to support multiple conflict zones around the world. Theaters work differently from the other dimension types in that the union of all theaters automatically forms a logical dimension. A spatial region that does not intersect any of the geographical regions results in a NULL routing space region.SPEEDES & HLASPEEDES supports interoperability with HLA in three ways. First, SPEEDES provides an HLA gateway [16] to allow SPEEDES simulations to interoperate with federations that use any standard HLA Run-Time Infrastructure [1] (see  REF _Ref444335630 \h Figure 11). This is currently being used by the Wargame 2000 project at the Joint National Test Facility (JNTF).Figure  SEQ Figure \* ARABIC 11: HLA Gateway. In this example, a SPEEDES-based simulation and/or federation can interoperate with an HLA federation that uses any standard HLA Run-Time Infrastructure.Second, SPEEDES is providing HLA interfaces for federates across local and/or wide area networks. This will permit remote federates to interoperate with SPEEDES-based simulations and federations. In this case, remote federates will talk directly to SPEEDES through HLA interfaces (see  REF _Ref444335646 \h  \* MERGEFORMAT Figure 12). The High-Performance Computing Office (HPCMO) under the Common HPC Software Support Initiative (CHSSI) is currently sponsoring this ongoing work.Third, SPEEDES is providing direct HLA interfaces to allow federates to execute in parallel on high-performance computers as SPEEDES nodes. This will permit federates to interoperate through high-speed communication mechanisms, such as shared memory. In this manner, a federation can comprise multiple federates operating on high-performance supercomputers (see  REF _Ref444335664 \h Figure 13). Direct federates can interoperate with native SPEEDES simulations through the clustering capabilities that currently allow multiple SPEEDES simulations to interoperate. This work is also being sponsored by HPCMO/CHSSI.Figure  SEQ Figure \* ARABIC 12: External module interfaces for HLA federates. In this example, a SPEEDES-based simulation and/or federation interoperates with a federate through a network-based interface to SPEEDES.Figure  SEQ Figure \* ARABIC 13: Direct HLA interfaces will support HLA federations on high-performance computers.All three of these approaches share a common SpFedStateMgr base class that generalizes the common interface while allowing for specialized implementations. The SpFedStateMgr is a programmable simulation engine in its own right. As a primary responsibility, it coordinates object proxy state data with logical time. Users can program the SpFedStateMgr to convert data from one format to another. For example, a SPEEDES simulation may use dynamic position attributes to represent great circle motion between specified waypoints. However, the FOM may require periodic position updates in Earth Central Inertial (ECI) coordinates. Users can program the SpFedStateMgr to schedule periodic update events that convert dynamic positions into ECI positions as the FOM specifies. This programmable middleware tool can convert SOMs to FOMs and vice-versa, allowing a SPEEDES simulation to interoperate with multiple federations without changing its internal SOM.The entire SPEEDES modeling framework promotes HLA interoperability. Object Proxies and Interactions support the HLA-required Object Management services. The internal Declaration Management and Data Distribution Management services in SPEEDES support their counterparts in HLA. The two-way Object Proxy mechanism, which is still under development, will provide the foundation for Ownership Management.SPEEDES uses its intrinsic Time Management capabilities to coordinate HLA services with the SpFedStateMgr. SPEEDES automatically assigns logical time stamps to real-time messages, coordinating all events in logical time. This strategy unifies the entire time management infrastructure and provides full interoperability between real-time and logical-time federates.Coordinating Time with Object ManagementThis section provides an example showing how the SpFedStateMgr coordinates logical time with Declaration Management and Object Management services. REF _Ref444341322 \h Figure 14 shows a sequence diagram with an SpFedStateMgr (1) connecting to SPEEDES, (2) subscribing to an object class, and then (3) coordinating Discover Object and Reflect Attribute messages in logical time. The SpFedStateMgr first sends a message to one of the nodes in SPEEDES to create an S_SpFedGhost simulation object. This simulation object represents a federate inside SPEEDES. All subscription messages from the federate, and all messages to the federate flow through the S_SpFedGhost object.In its constructor, the S_SpFedGhost object (1) registers two event handlers, SubscribeObject and DiscoverObject, (2) launches the CoordinateTime process, and then (3) returns the local ID and start time back to the SpFedStateMgr.The SpFedStateMgr then subscribes to one or more object classes. The SubscribeObject event handler processes this request, using internal SPEEDES Declaration Management services to subscribe to the object class by string name. When the S_SpFedGhost discovers a new object proxy, SPEEDES automatically invokes the DiscoverObject event handler, which passes the discovery message to the SpFedStateMgr where it is reconstructed. It also sets a Message Semaphore that is used by the CoordinateTime process to facilitate Next Event Requests [10]. SPEEDES handles reflect attribute messages similarly through a ReflectAttributes event handler (not shown) that passes modified attributes to the SpFedStateMgr.The CoordinateTime process maintains a barrier in SPEEDES that prevents Global Virtual Time (GVT) from advancing beyond the time advanced to the SpFedStateMgr plus lookahead. The SpFedStateMgr never passes a message into SPEEDES with a time tag less than its granted time plus lookahead.Figure  SEQ Figure \* ARABIC 14: Sequence diagram showing an SpFedStateMgr connecting to SPEEDES, subscribing to a class, and then coordinating object discovery and other messages in logical time. REF _Ref444391737 \h Figure 15 shows how the Next Event Request (NER) cycle is supported when there are no outgoing messages with time tags less than the requested time.Figure  SEQ Figure \* ARABIC 15: Next Event Request (NER) cycle when there are no outgoing messages for the SpFedStateMgr.The SpFedStateMgr sends a NER message to the S_SpFedGhost that causes the NextEventRequest event handler (not shown) to set the NER semaphore. This causes the CoordinateTime process to wake up and service the request. If GVT is greater than the requested time, the process simply grants the requested time to the SpFedStateMgr. However, if GVT is less than the NER time, the CoordinateTime process cannot grant the time yet, since a message with an earlier time tag may still arrive. In this case, the CoordinateTime process waits with a timeout on the message semaphore until the requested time expires. If the timeout expires, meaning there are no messages with earlier time tags than the requested time, the CoordinateTime process wakes up, grants the time, and then goes back to sleep until another NER message arrives. REF _Ref444392530 \h  \* MERGEFORMAT Figure 16 shows the case when there is an outgoing message for the SpFedStateMgr with an earlier time tag than the requested time. In this case, rather than the timeout expiring, the CoordinateTime process is interrupted while waiting on the message semaphore. The outgoing message is sent to the SpFedStateMgr and then SPEEDES grants the time using the time-tag of the message instead of the time value requested.Figure  SEQ Figure \* ARABIC 16: Next Event Request (NER) cycle when there is a message with an earlier time-tag than the NER time.By coordinating all messages from the S_SpFedGhost to the SpFedStateMgr using the CoordinateTime process with outgoing message semaphores and GVT barriers, SPEEDES guarantees logically correct time management for all outgoing messages. Combining this with the rule that all messages from the SpFedStateMgr must have time tags greater than or equal to the granted time plus lookahead ensures that the framework correctly coordinates all message flow between SPEEDES and the SpFedStateMgr in logical time.Full support for time management extends into the Ownership Management, Declaration Management, and Data Distribution Management services. Large-scale analytic federations that require repeatability and scalability must have these capabilities.Progress Report On The HPC-RTI ProjectDespite being only several months into this task, we have already made a good deal of headway towards the objective of building a fully functional HLA RTI in SPEEDES. Some of the RTI services are already completed, while many others have the essential functionality, requiring only the final interface and/or some refinement. Much of this work will be included in the SPEEDES 0.8 release due out at the end of August 1999.In a subsequent release of SPEEDES in October, 1999, we intend to have all the “basic HLA functionality” implemented. By this, we mean the following capabilities: create, destroy, or join a federation; publish/subscribe to object and interaction classes; register/discover object instances; update/reflect object attributes; send/receive interactions; modify/query lookahead; next event request and time advance request; name-to-handle and handle-to-name mapping services; and tick.Summary & ConclusionsThis paper shows how SPEEDES supports interoperability between native SPEEDES simulations, federates, and federations. SPEEDES employs its entire Modeling Framework to provide this capability. The HPC-RTI project started in late 1998 and will complete its first phase in October 1999.This project aims to provide an HLA-compliant parallel RTI that coordinates all HLA services optimistically in logical time. Moreover, it aims to provide such a system with many powerful, concise constructs that can be easily applied in a scalable manner. By providing an RTI that solves all of the critical problems that have plagued the parallel DoD simulation community, SPEEDES promotes the development of complex, interoperable DoD simulations on geographically dispersed, high-performance parallel computers.AcknowledgementsThe High-Performance Computing Modernization Office (HPCMO) sponsored this work through the Common HPC Software Support Initiative (CHSSI) project. The Space and Naval Warfare (SPAWAR) center and the Naval Research Laboratory (NRL) under the CHSSI Force Modeling & Simulation Computational Technical Area provided overall management.The SPEEDES software development team gives special thanks to Wargame 2000 and the Joint National Test Facility for sponsoring many of the features in SPEEDES Modeling Framework. The SPEEDES team also gives thanks to DMSO for their guidance and technical support.SPEEDES is a government-owned software system, managed by Metron Inc., and licensed by NASA. It currently supports several large DoD simulation projects including Wargame 2000, JSIMS, Parallel NSS, and EADTB. The government has recently formed The PDES User's Group to coordinate further SPEEDES development. Current membership includes (1) the JNTF, (2) SPAWAR, and (3) the JSIMS Enterprise. Metron provides expert technical support for the PDES User’s Group during configuration board meetings.BiographyDr. Jeffrey S. Steinman, Senior Analyst with Metron Inc., received his Ph.D. in High-Energy Physics from UCLA in 1988. From 1988-1995, Dr. Steinman worked at the Jet Propulsion Laboratory where he developed the SPEEDES operating system. This work resulted in more than 30 publications in the area of high-performance simulation and several patent awards. He is currently providing technical support for several large-scale DoD projects including Wargame 2000, JSIMS, JWARS, NSS, and EADTB. Dr. Steinman was the principle developer of the NSS HLA-Integration framework and was the lead integrator of NSS with the HLA Run-Time Infrastructure for the JTFp (Joint Training Federation Prototype) project. He is also a regular participant in the HLA technical exchanges for Time Management and Data Distribution Management.References[1]	Bachinsky S., Tarbox G., Mellon L., Fujimoto R. 1998, “RTI 2.0 Architecture.” 1998 Spring Simulation Interoperability Workshop, No. 98S-SIW-150.[2]	CACI Products Company 1990, “MODSIM II: The Language for Object-Oriented Simulation, Reference Manual.”[3]	Cohen D., Kemkes A. 1998, “User Level Measurement of DDM Scenarios.” 1998 Spring Simulation Interoperability Workshop, No. 98S-SIW-072.[4]	Dahmann J., Kuhl F., Weatherly R. 1998, “Standards for Simulation: As Simple As Possible, But Not Simpler – The High Level Architecture For Simulation.” Simulation, Vol. 71, No. 6, Dec. 1998, Pages 378-387.[5]	Dahmann J., Lutz R. 1998, “Persistent Federations.” 1998 Spring Simulation Interoperability Workshop, No. 98S-SIW-059.[6]	Defense Modeling and Simulation Office (DMSO) website, http://hla.dmso.mil.[7]	Defense Modeling and Simulation Office, “HLA Interface Specification,” Version 1.3, www.dmso.mil/projects/hla.[8]	Fujimoto R. 1990, “Parallel Discrete Event Simulation.” Communications of the ACM, Vol. 33, No. 10, Pages 30-53.[9]	Fujimoto R., Tacic I. 1997, “Synchronized Data Distribution in Distributed Simulations,” 1997 Spring Simulation Interoperability Workshop, No. 97S-SIW-045. [10]	Fujimoto R. 1998, “Time Management in The High Level Architecture.” Simulation, Vol. 71, No. 6, Dec. 1998, Pages 388-400.[11]	Jefferson D. 1985, “Virtual Time.” ACM Transactions on Programming Languages and Systems, Vol. 7, No. 3, pages 404-425.[12]	Kanarick C. 1991, “A Technical Overview and History of the SIMNET Project.” In Proceedings of the 1991 Advances in Parallel And Distributed Simulation Conference, Pages 104-111.[13]	Loral Systems Company 1992, “Strawman Distributed Interactive Simulation Architecture Description Document.” Prepared for Program manager – Training Devices Naval Training Systems Center, Orlando, FL, ADST/WDL/TR-92003010, Vols. 1 and 2.[14]	Morse K., Steinman J. 1997, “Data Distribution Management in the HLA: Multidimensional Regions and Physically Correct Filtering.” Spring Simulation Interoperability Workshop, No. 97S-SIW-052.[15]	Muller P. 1997, “Instant UML.” Wrox Press Ltd. 30 Lincoln Road, Olton, Birmingham, B27 6PA.[16]	Paterson D., et. al. 1998, “An Approach to HLA Gateway/Middleware Development.” 1998 Spring Simulation Interoperability Workshop, No. 98S-SIW-005.[17]	Reynolds P., 1994, “Disorientation.” ELECSIM 94.[18]	SPEEDES website,  HYPERLINK http://www.ca.metsci.com/speedes/ www.ca.metsci.com/speedes/.[19]	Steinman J. 1993, “Incremental State Saving in SPEEDES Using C++.” In Proceedings of the 1993 Winter Simulation Conference, Pages 687-696.[20]	Steinman J., Wieland F. 1994, “Parallel Proximity Detection and the Distribution List Algorithm.” In Proceedings of the 1994 Parallel And Distributed Simulation Conference (PADS’94), Pages 3-11.[21]	Steinman J., et. al. 1995, “Global Virtual Time and Distributed Synchronization.” In Proceedings of the 1995 Parallel And Distributed Simulation Conference, Pages 139-148.[22]	Steinman J. 1997, “The NSS HLA-Integration Framework.” 1997 Spring Simulation Interoperability Workshop, No. 97S-SIW-071.[23]	Steinman J. 1998, “Scalable Distributed Military Simulations Using the SPEEDES Object-Oriented Simulation Framework.” In Proceedings of the Object Oriented Simulation Conference (OOS'98), Pages 3-23.[24]	Steinman J. 1998, “Time Managed Object Proxies in SPEEDES.” In Proceedings of the Object Oriented Simulation Conference (OOS'98), Pages 59-65.[25]	Van Hook D., Calvin J. 1998, “Data Distribution Management in RTI 1.1.” 1998 Spring Simulation Interoperability Workshop, No. 98S-SIW-206.[26]	Weatherly R., Wilson A., Griffin S. 1993, “ALSP – Theory, Experience, and Future Directions.” In Proceedings of the 1993 Winter Simulation Conf4erence, Pages 1068-1072.[27]	West D. 1988, “Optimizing Time Warp: Lazy Rollback and Lazy Re-evaluation.” Master’s Thesis, University of Calgary, January 1988.[28]	West D., Panesar K., 1996, “Automatic Incremental State Saving.” In Proceedings of the 1996 Parallel And Distributed Simulation Conference (PADS’96), Pages 78-85.[29]	West D., Ng H. 1998, “Event Distribution and State Sharing in the Thema Parallel Discrete Event Simulation Modeling Framework.” In Proceedings of the Object Oriented Simulation Conference (OOS'98), Pages 24-29.[30]	Whitehurst A., Wallace J. 1997, “Using IMPORT to Implement Complex Behaviors in Simulations.” In Proceedings of the 1997 Object-Oriented Simulation Conference, Pages 16-21.[31]	Whitehurst A., Brutocao, J. 1998, “Parallel Execution of Process-Based Simulation Models.” In Proceedings of the Object Oriented Simulation Conference (OOS'98), Pages 115-120.[32]	Wilson L., Nicol D. 1996, “Experiments in Automated Load Balancing.” In Proceedings of the 1996 Parallel and Distributed Simulation Conference (PADS’96), Pages 4-11.[33]	Yu L., Steinman J., Blank G., 1998, “Adapting Your Simulation For HLA.” Simulation, Vol. 71, No. 6, Dec. 1998, Pages 410-420.	The Aggregate-Level Simulation Protocol (ALSP) was developed by MITRE to link disjoint simulations together through a common run-time interface. The Distributed Interactive Simulation (DIS) protocol evolved from the Army’s SIMNET project and was used to simulate virtual-world training environments by allowing participants to exchange standardized messages called Protocol Data Units (PDUs).	NASA developed SPEEDES in 1990 at the Jet Propulsion Laboratory under DoD contracts from Strategic Defense, Air Defense, and Ballistic Missile Defense.	AMG membership includes representatives from the largest mainstream DoD simulation projects.	SPEEDES projects include the Joint Simulation System (JSIMS), Wargame 2000 (WG2K), the Extended Air Defense Test Bed (EADTB), and Parallel NSS.	SPEEDES supports shared memory under both UNIX and Windows NT operating systems, TCP/IP in network environments, and MPI on large-scale message-passing supercomputers.	Lookahead means that all events scheduled between objects on different nodes must advance logical time by at least L units, where L is the lookahead value. When running conservatively, SPEEDES automatically adds L to events if necessary.	Lazy cancellation can occur whenever a processed event is unaffected by a straggler-induced roll back. In this case, lazy cancellation saves the framework from reprocessing the event by rolling it forward. This reduces redundant event processing and can dramatically reduce message and antimessage traffic.	Breathing Time Warp (BTW) gets its name from merging two time management algorithms: Breathing Time Buckets (BTB) and Time Warp (TW). In BTB, events never release their messages until they know they will not be rolled back. In this sense, BTB is said to be risk-free. TW, on the other hand, has maximum message-sending risk because it releases its messages immediately. BTW offers the best of both worlds by holding back messages that are likely to be retracted by antimessages.	Simulation objects are referenced by the integer triplet, <Node, MgrType, LocalId>.	Using a block decomposition strategy, ten objects would be decomposed to two nodes with the following Ids: Node 0 = {0,1,2,3,4}, and Node 1 = {5,6,7,8,9}. Using a scatter-decomposition strategy, ten objects would be decomposed to two nodes as: Node 0 = {0,2,4,6,8}, and Node 1 = {1,3,5,7,9}.	This value is sometimes referred to as Global Virtual Time (GVT). SPEEDES periodically updates its estimate of GVT to commit events.	When a straggler message arrives on a node, it normally only rolls back its corresponding simulation object, not the entire node. If a rolled-back event scheduled other events, SPEEDES cancels those events in a recursive manner.	SPEEDES sets two special time fields in the SpSimTime object for each scheduled event to assure repeatability: (1) a counter and (2) the unique Id of the simulation object that scheduled the event. To break ties when the physical time is the same, each simulation object maintains a counter field that continually increases each time it schedules an event and stores it in the SpSimTime object to represent the time for that scheduled event with the formula: counter = max(current event counter, counter) + 1. Incrementing the maximum of the current event counter and the simulation object’s counter guards against going backwards in time when the current event’s counter came from a simulation object with a higher counter value. The counter guarantees that each simulation object itself generates unique time tags. The unique Id guarantees that different simulation objects never schedule events with the same time tag. Together, the counter and unique Id fields guarantee that all scheduled events within the simulation have repeatable unique time tags.	In the near future, SPEEDES will support events as methods for any object associated with a simulation object, including components.	The WAIT construct first saves local stack variables and then reschedules the same event. When re-entering the event, SPEEDES restores local stack variables and jumps to the next line of code following the wait statement. SPEEDES uses macros to make this capability transparent to the user.	Critical HLA services include: (1) Object Management, (2) Declaration Management, (3) Data Distribution Management, and (4) Ownership Management. SPEEDES already provides the two other HLA services: Time Management and Federation Management.	SPEEDES currently supports a wide variety of dynamic attributes including step functions, polynomials, splines, and complex exponential functions. SPEEDES also provides a library of motion types including great circles, rhumline, circular orbits, loiter motion, extrapolated motion, polynomials, and splines. SPEEDES further provides coordinate transformations between Earth Central Inertial (x,y,z), Earth Central Rotating (x,y,z), and Earth Coordinates (latitude, longitude, altitude). All dynamic attributes provide first and second derivatives.	The SpParmSet automatically handles integer and floating point data type conversions between big endian and little endian machine types.	This capability was partially developed in 1998 for integer attributes. It will be completed in late 1999.	Assume that the ship proxy class and the aircraft proxy class both inherit from the moving entity proxy class, which in turn inherits from the entity proxy class. When creating a ship, SPEEDES publishes it as a ship, a moving entity, and as an entity. If another entity subscribes to moving entity proxies, SPEEDES will send it all ship and aircraft proxies. If the entity only subscribes to ships, then SPEEDES will not send it aircraft proxies.	It is often the case that a node may have many entities that subscribe to a particular proxy. Proxy updates are delivered to each node in a single message. Then the update is disseminated to the rest of the subscribers.	In HLA terminology, publication regions in routing spaces are also referred to as update regions.	For example, suppose there are three dimensions in a routing space, R = {0 ( x < 100, 50 ( y < 80, 20 ( z < 80}. If the bin sizes for the three dimensions are 10, 5, and 20 respectively, then there will be 10 x 6 x 3 = 180 cells in the routing space that can be distributed to different nodes.	The Gateway and the External Module use the Host Router for communicating with SPEEDES, while the Direct Interface communicates with SPEEDES through function calls. Also, the Gateway interfaces with another RTI while the External Module and Direct Interface provide HLA interfaces to a federate. These differences can be organized and implemented efficiently by specializing the SpFedStateMgr class through inheritance.	All messages exchanged between SPEEDES and the SpFedStateMgr are coordinated in logical time. However, the SpFedStateMgr primarily focuses on coordinating object proxy data.	Notice that the Connect to SPEEDES event associates with the O_SpFedGhost object manager since object managers are responsible for creating simulation objects. SPEEDES can ghost more than one federate per node.	While only two event handlers are shown here, the S_SpFedGhost actually registers a number of event handlers during its construction.	In the future, the CoordinateTime process will support Time Advance Requests as well.	The HLA specification does not require coordinated time management for Ownership Management, Declaration Management, and Data Distribution Management services. The SPEEDES-based RTI provides this benefit automatically.PAGE  12