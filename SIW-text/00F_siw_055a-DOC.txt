Converting SEDRIS Data to the CTDB FormatVictor J. SkowronskiTom StanzioneTASC55 Walkers Brook DriveReading, MA 01867-3297 HYPERLINK mailto:Vjskowronski@tasc.com vjskowronski@tasc.com, tstanzione@tasc.comKeywords:Synthetic Environment, Compact Terrain Database, CTDB, SEDRISAbstract: As part of the Synthetic Environment Data Representation Interchange Specification (SEDRIS) project, a compiler has been written to convert terrain data into the Compact Terrain Database (CTDB). The compiler uses the SEDRIS Application Programmer’s Interface (API) to access the terrain data in a representation that conforms to the SEDRIS Data Representation Model (DRM). Since the last paper on this compiler (98F-SIW-006) was presented at the SIW, a number of improvements have been made to the SEDRIS to CTDB compiler. These improvements primarily affect the way in which model (3D icons)s are compiled. Buildings, with perimeters that are more complex than rectangles, can be compiled using new algorithms that have been developed for the compiler. In addition, Multiple Elevation Structures can also be compiled. This paper discusses the changes that were made to the compiler design in order to implement these new capabilities.IntroductionSEDRIS provides a common interface to a variety of sources of environmental data. This paper describes how SEDRIS has been used in the creation of a compiler to convert SEDRIS data to the CTDB format used by the ModSAF (MODular Semi-Automated Forces) Computer Generated Forces (CGF) program.The next section,  REF _Ref485634676 \h Background, provides an overview of the CTDB format, SEDRIS, and the SEDRIS to CTDB compiler. Following the overview, enhancements to the compiler that have been made since Reference  REF _Ref485634808 \r \h [4] are discussed. Finally, some results from tests of compiler operation and performance are presented.BackgroundThis section discusses aspects of the CTDB format and SEDRIS Data Representation Model (DRM) that are relevant to the SEDRIS to CTDB compiler. An overview of the CTDB is given first. This overview describes the CTDB in general terms. More specific information about particular data structures of the CTDB is given when the creation of these data structures is discussed later in the paper. Similarly, the overview of SEDRIS provides a broad description of the SEDRIS DRM. Specific data structures needed by the compiler for proper conversion are not discussed in this paper, but will be documented in a SEDRIS to CTDB content specification document.Overview of CTDBThe Compact Terrain Database (CTDB) is a terrain runtime format that has been optimized for the types of data queries needed for simulations of Computer Generated Forces (CGF). The most frequently used queries in CGF applications are elevation lookups and line of sight calculations (LOS). The CTDB is designed to support the process of these queries as rapidly as possible. The CTDB is also designed to support queries for vehicle movement and route planning.The CTDB contains two main data structures, an elevation grid and a list of physical feature data. The elevation grid contains a grid of regularly spaced elevation data and mobility values that cover the entire database. The list of physical feature data is organized spatially, with the smallest spatial unit called a patch. The physical features in a patch can be buildings, trees or tree lines, forest canopies, roads, or rivers. Patches may also store terrain data, as Triangular Irregular Networks (TIN).The CTDB contains additional data structures whose purpose is to store data referenced by the soil grid or the patches. The data in these structures is typically common to many grid posts or features, so storing it in a common structure reduces the overall size of the CTDB. Examples of these structures are the Polygon Attribute Table (PAT) and the model library. Other data structures, the abstract feature and road network data, store information from the elevation grid and patch data in a form that is more useful for terrain reasoning.More information on the structure of the CTDB can be found in References  REF _Ref489870334 \r \h [1] and  REF _Ref489870236 \r \h [2].Overview of SEDRISThis section provides a brief overview of those features of the SEDRIS that are important to the operation of the compiler. For a more complete description of SEDRIS, see References  REF _Ref485546948 \r \h [6] and  REF _Ref486129165 \r \h [7]. At the time that this paper was written, the latest version of SEDRIS was version 2.5.2a. The overview is based on this version of SEDRIS.A SEDRIS database, usually called a transmittal, is organized as a hierarchical tree of objects. The terms used in describing the hierarchical relationships between objects are illustrated in  REF _Ref485624174 \h Figure 1. Object A is the aggregate of Object B. The only object with no aggregate is the root object. Object B is the aggregate of Objects D and E. Objects D and E are components of Object B. Object B is also related by association to Object C. Associations allow connections between objects that do not fit within the concept of aggregate or component. For example, a model is connected to its instance through the association relationship. EMBED Word.Picture.8  Figure  SEQ Figure \* ARABIC 1 SEDRIS Hierarchy RelationshipsAt the top, or root, of a transmittal is the Synthetic Environment object (see  REF _Ref485979486 \h Figure 2). The objects immediately beneath the Synthetic Environment object are called its components. The most important components of the Synthetic Environment object for the compiler are the Model Library and the Environment Root. The Model Library contains models that are referenced by objects beneath the Environment Root object. The Environment Root object contains the feature and geometry objects that define the synthetic environment. EMBED Word.Picture.8  Figure  SEQ Figure \* ARABIC 2 SEDRIS Transmittal HierarchyThe Environment Root contains a Spatial Domain object, and two hierarchies, one for geometry and one for features. The Spatial Domain object is used by the compiler to compute the extents of the CTDB that will be created. The compiler uses the objects in the geometry and feature hierarchies to create objects in the CTDB.The SEDRIS objects that are of primary interest to the compiler are the Primitive Geometry and Primitive Feature objects. These objects will be converted into equivalent objects within the CTDB. The only Primitive Geometry object currently supported by the compiler is the Polygon object. Primitive Feature objects, that are supported by the compiler, are Point, Line, and Areal Features. Geometry Model Instance objects (considered a type of Geometry Hierarchy object) are also recognized by the compiler.CTDB features, such as roads, buildings, and terrain polygons, map to the primitive objects of SEDRIS, shown at the bottom of the tree in  REF _Ref485979486 \h Figure 2 (roads to linear features, buildings to geometry model instances and terrain polygons to polygons). The primitive objects contain part of the information needed to compile a CTDB feature. The rest of the needed information is found in other objects that are components of the Primitive objects. These other objects are not shown in  REF _Ref485979486 \h Figure 2.Overview of Compiler OperationThe compiler is designed to operate in three phases. In each of the first two phases, the SEDRIS transmittal is scanned. In the third phase, the data from the first two phases is At the end of each phase, the results of that phase are written to one or more temporary files. These files remain available on disk after the compiler finishes execution. The persistence of these temporary files supports incremental compilation. The compiler can be directed to skip over those phases that were successfully completed previously.The three phases of compiler operation are as follows.The compiler scans the transmittal for metadata that is used to construct the CTDB header and the Polygon Attribute Table. Data from this phase is written to a temporary file. The data is also used to establish grid post spacing and patch size, which are needed for the second phase.The compiler traverses the transmittal and extracts all features of interest. The features are converted to an internal format and written to one or more temporary files according to the feature’s spatial location. Two additional files are also written. One file contains all the data that will be converted to abstract features in the CTDB. The second file stores model data.The data in the temporary files are read, sorted, and passed to the back end of the compiler where it is converted to the CTDB format. REF _Ref485702385 \h Figure 3 shows how data flows between the compiler and its inputs and outputs.  EMBED Word.Picture.8  Figure  SEQ Figure \* ARABIC 3 Compiler OperationThe spatial organization of the data written to the temporary files is illustrated in  REF _Ref485779781 \h Figure 4. Each temporary file covers a strip that extends across the entire extent of the CTDB (east to west). Storing data in strips allows the strips to be read and processed separately. The data is sorted along the east/west axis after it has been read so that it can be accessed more efficiently. Storing by strip and then sorting after reading the data places objects that will be compiled into the same patch near each other.The figure also shows that the height of a strip is large enough to contain more than one patch of the CTDB. A strip height of one patch produces an excessive number of temporary files for databases with large areas. Increasing the height of the strip reduces the number of temporary files at the expense of additional processing. Objects read from a temporary file must be sorted first along the north/south axis before they can be sorted along the east/west axis. Objects that overlap one or more strips are written to all the strips that they touch. This results in some duplication of data. However, only one strip is resident in memory at any one time, so the duplicate data does not create duplicate objects in memory. Objects that overlap patches within a strip are handled by resorting the data after each patch row is processed. A flag in the object data is set by the compiler when an object is no longer needed. Objects flagged as no longer needed are moved to the end of the data array by the sorting operation. This allows the processing of each patch row to start at the beginning of the data buffer and avoids long searches through objects that have already been compiled. EMBED Word.Picture.8  Figure  SEQ Figure \* ARABIC 4 Spatial Organization of Temporary FilesThe features file that is shown in  REF _Ref485702385 \h Figure 3 is used to identify classification and attribute codes from the SEDRIS transmittal. SEDRIS objects can have, as a component, a Classification Data object (see Reference  REF _Ref486129105 \r \h [8]). This object contains an Environment Classification Code (ECC), which describes the real world object that the SEDRIS object represents, a building, a terrain area, etc. A SEDRIS object may also have Property Data Value objects as components. These objects contain Environment Attribute Codes (EAC), which describe properties of the SEDRIS object, such as its height, or soil type.Since different data producers may use different ECCs or EACs, the actual code values are not included in the compiler source code. Instead, the features file is used to provide a list of codes for each type of object that the compiler converts. The file is a text file formatted as a reader file so that it can be easily modified.A sample entry for the features file is shown in  REF _Ref486129946 \h Figure 5. The first entry is an ASCII label that will be recognized by the compiler code. Following the label is a list of ECCs that belong to this group (buildings). Following the ECC list are lists of EACs. Each EAC list is preceded by a label that identifies the list to the compiler code.(building (AL015 AL240)(height (HGT_))(length (LEN_))(width (WID_ WD1_))(angle (AOO_)))Figure  SEQ Figure \* ARABIC 5 Sample features file entryCompiler EnhancementsThe enhancements that have been made to the compiler since the report given in Reference  REF _Ref485634808 \r \h [4] have been mostly in the area of the compilation of models. The compilation of buildings has been improved to accept complex geometry in building models. The capability of creating aggregate models and Multiple Elevation Structures (MES) has also been added.The primary change to the compilation of models was to compile them as they were encountered in the traversal of the Environment Root in Phase 2. Previously, models had been compiled directly from the Model Library of the SEDRIS transmittal. With the addition of the capability to create buildings from Point and Areal Features, compiling from the Model Library was no longer adequate. Point and Areal Features have no association with the Model Library, so they had to be compiled as they were encountered during the traversal.Because model data is now collected during the traversal of the Environment Root, it was also necessary to write the model data into a temporary file. When model data was only extracted from the SEDRIS Model Library, it could be efficiently recompiled from the Model Library if the compiler was restarted directly in Phase 3. With model data being extracted from anywhere within the SEDRIS transmittal, however, extracting model data during a restart will retraverse the entire transmittal. Writing the model data to a temporary file for use during Phase 3 avoids the need to retraverse the SEDRIS transmittal.The enhancements to the compilations of models are discussed in the following sections. The first enhancements discussed are to the implicit grid detection algorithm. The development of new terrain databases with more closely packed elevation data required changes to the algorithm used to determine the spacing of elevation grid posts.Enhancements to Implicit Grid DetectionThe compiler computes the spacing that will be used for the elevation grid during Phase 1 of the compilation. The algorithm used was described in Reference  REF _Ref485719813 \r \h [5]. The algorithm computes a Fourier Transform of the terrain elevations in the SEDRIS transmittal to find any underlying periodicity in the elevation data.The algorithm was intended to create CTDBs with spacing between the elevation grid posts in the range of 75 to 150 meters. This is the spacing for CTDBs compiled from S1000 data. Other terrain databases are now being converted to CTDBs with significantly different spacing. The spacing in the new databases can be much smaller, sometimes only a single meter. The smaller spacing made it necessary to revise the algorithm.The first modification made to the grid algorithm was to reduce the lower limit for grid post spacing. Permissible values can now be as low as 1 meter. In order to avoid using a shorter spacing than the actual grid (a harmonic in the FFT corresponds to a shorter period or spacing), the algorithm chooses the highest possible grid spacing that meets its selection criteria.The actions taken when no grid is found have also been modified. Instead of using a default value of 125 meters, the compiler calculates a value for the spacing based on the total number of SEDRIS location objects found in the geometry hierarchy. The number of locations is divided by the area of the CTDB being created. The resulting average density of elevation readings per unit area is used to set the spacing such that the average number of terrain polygons in a patch of the CTDB will be between 10 and 50. This is about the number of virtual polygons in a gridded patch, 32. (The patch size is determined by the post spacing and is typically four times the post spacing.)Compilation of Aggregate ModelsIn a CTDB, an aggregate model is a container for a collection of models. Each model within the aggregate model is stored as a location relative to the origin of the aggregate model and a reference to either a linear or volume model. Aggregate models allow the CTDB to reuse typical collections of trees and buildings.  In the Format 7 CTDB, however, only linear models, used to represent trees, are supported within aggregate models.The compiler supports the conversion of SEDRIS Feature Models to CTDB aggregate models. The Feature Model must consist solely of Point Features. The Point Features represent the individual trees that will be represented in the aggregate model and only trees are supported by Format 7 of the CTDB.When a Feature Model Instance is encountered by the compiler, data is written to two separate arrays. A data object is created and written to the appropriate temporary files. An entry is also made in an array of static model data. The static model data stores the references to the point features that will be compiled as individual trees in the CTDB.Compilation of Complex Building ModelsBuildings, or volume models, are represented in a CTDB as a set of vertices. The vertices form edges that define the roofline of the building. For line of sight calculations, the building is considered to block visibility if the light ray passes underneath one of the roofline edges.The building models of the previous compiler were limited to four corners. This restriction was adequate for the simulations in open country, but it is too restrictive for urban environments. In an urban environment, individual entities can hide in alleys and other irregularities in a building’s perimeter.Compilations of S1000 models assumed that a building model was organized as a set of boxes (a parallelepiped with right angles at all the corners). These boxes were stored as components of the building model. When the CTDB volume model was created, the vertices from all the boxes were collected and sorted into a counterclockwise list of vertices. The sorting process used the centroid of the collection of the vertices to determine their order. This can cause problems for oddly shaped buildings, like the U-shaped building in  REF _Ref486132205 \h Figure 6. The interior corners of the building were assigned to the wrong side of the building by the sorting algorithm because they were on the opposite side of the centroid from the vertices to which they should have been joined. EMBED Word.Picture.8  Figure  SEQ Figure \* ARABIC 6 Sorting corner vertices of an irregularly shaped buildingIn addition to the problem of irregularly shaped buildings, the assumption that the input data would be organized as boxes or something similar is not generally valid. SEDRIS allows data producers to use many different types of organizational constructs for their data. A common one for visual data is organization along separating planes. The principle is that polygons on one side of the separating plane will not be visible to observers on the other side. Having a separating plane allows image generators to avoid spending time processing data that will not be displayed.If the polygons of a building model are organized using separating planes, then they cannot be assembled into the “boxes” assumed by the S1000-based code. A new algorithm is needed to create a building model in the CTDB.The algorithm that was developed for the compiler constructs the building perimeter directly from the polygons of the building model. The steps of the algorithm are as follows.Collect all the polygons for the building model.Identify the polygons that model walls. Polygons that are vertical or nearly so are considered to be part of a wall.Extract the top edges of all the wall polygons.Starting with the edge vertex that has the smallest X-value (with larger Z-value used as a tie-breaker), connect edges until a complete perimeter has been constructed. Starting with a vertex having the smallest X-value insures that the perimeter will be the outside wall, rather than the wall of an interior courtyard.It is possible during the perimeter construction phase to find more than one edge that connects to the current edge. If the edges are not co-linear in the XY-plane, the edge that will create the most extensive perimeter is chosen. If the two edges are co-linear, then the edge with the greatest slope is used.Figure  SEQ Figure \* ARABIC 7 Complex building outlines REF _Ref485800083 \h Figure 7 shows an example of several complex building perimeters that have been compiled from a database of downtown Philadelphia.  The building perimeters have been divided into convex perimeters so that the “point in polygon” algorithms of libctdb (see Reference  REF _Ref489870236 \r \h [2]) will operate properly. Each building is further broken up by the compiler back-end into smaller segments that fit within a patch, as required by libctdb. The compiler back-end will also break up a building perimeter that contains more than 15 vertices, although no example of this is shown in  REF _Ref485800083 \h Figure 7. All these divisions of the original building outlines are necessary in order to provide a usable representation for libctdb.Figure  SEQ Figure \* ARABIC 8 Building from Bellevue CTDBA three dimensional view of a simple building from the Bellevue database is shown in  REF _Ref485802287 \h Figure 8. The peaks in the roof show the effect of using the edge with the highest slope whenever two edges connect to an edge of the roof. The two corner points at the end of the building are connected to each other and to the vertex at the peak. Since the slope of the edge to the peak is greater than the slope of the edge to the other corner, the edge to the peak is used and the vertex at the peak is included in the perimeter.The algorithm that has been developed to construct building perimeters has some limitations. Buildings with non-vertical walls cannot be compiled. If the walls are not vertical within the tolerance of the compiler (about 15 degrees), they will be ignored in the construction of the perimeter. Models with disjoint components (separate structures with no connecting walls) will also not compile properly. The compiler will select one of the disjoint components and construct its perimeter as the building model.The algorithm described above is used for buildings represented as geometry models. The compiler can also create building models from point or areal features. For a point feature, a box is created. The dimensions of the box are read from Property Value objects that are components of the point feature. Property values, with attributes of length, width, and height are used for the corresponding dimensions of the building (see  REF _Ref485887279 \h Figure 9). In addition, an attribute of orientation is used to determine the angle of the length axis with respect to true north. For an areal feature, the building perimeter is compiled from the vertices of the feature’s face. Height may be encoded as an attribute or provided as the Z-value of each vertex. EMBED Word.Picture.8  Figure  SEQ Figure \* ARABIC 9 Attributes for building derived from a point featureCompilation of Multiple Elevation StructuresA Multiple Elevation Structure (MES) uses a more complex data structure in the CTDB than the volume models that were described in the previous section (see Reference  REF _Ref489870266 \r \h [3]). Like the volume model, a MES has an outline stored in the physical feature data of the patches and a reference roofline stored as part of the volume model library. The MES also has two additional data structures. An MES volume stores the MES roofline, floorline, transformation matrix, and origin. An MES template stores information about rooms within the MES, called enclosures, and information about the doors and windows of the MES, called apertures. The MES template also contains information about the connections between apertures and enclosures, the topology of the MES. (Note that this is a different sense of the term topology as used in solid modeling and in the SEDRIS representation of geometry topology.)Previous CTDB compilers required the data supplier to include information about the topology of the MES. This avoided the need for an algorithm in the compiler that would determine the geometry of the enclosures and the apertures from the polygons of the building model. The algorithm would need to be able to group polygons by enclosure without any prior information about the number and extents of the enclosures. Such an algorithm would be extremely complex and prone to error. EMBED Word.Picture.8  Figure  SEQ Figure \* ARABIC 10 MES data organization in SEDRISTo avoid the need for a complex analysis of building models, the SEDRIS data structure for MESs shown in  REF _Ref485884421 \h Figure 10 is proposed. Code to compile the proposed structure has been implemented in the compiler.In the structure shown in  REF _Ref485884421 \h Figure 10, each enclosure is represented by a single Union of Primitive Geometry. The union contains all the polygons that define the boundary of the enclosure. Apertures are also represented by a Union of Primitive Geometry. The union for apertures contains the polygons that define the aperture, but it also contains a Classification Data object with a classification code that identifies the union as an aperture. The ECC coding standard already contains an ECC for Exit/Entrance and it is assumed that this code or a similar one can be used to identify apertures. Finally, the topology of the MES is encoded through associations between enclosure unions and aperture unions. When an aperture is connected to an enclosure, the corresponding unions have an association.This structure for encoding an MES in a SEDRIS transmittal provides all the information necessary for the compiler to construct an MES. Furthermore, the structure avoids adding SEDRIS objects whose function is to provide connectivity between other objects rather than to store internal information about the MES.Performance ResultsThe performance of the compiler is shown in  REF _Ref485890833 \h Table 1 and  REF _Ref485890848 \h Figure 11. The original format column indicates the source of the data in the SEDRIS transmittal. The other columns of  REF _Ref485890833 \h Table 1 compare the amount of input data processed to the compilation time and the size of the resulting CTDB.  REF _Ref485890848 \h Figure 11 graphs the compilation time as a function of the input database size.There does not appear to be a clear correlation between the size of the CTDB and the size of the input database. This is likely due to differences in the original sources. Each source stores some data that is not needed for a CTDB. The amount and type of the unused data changes the fraction of data in each transmittal that will be converted to a CTDB. The difference in the fraction of data processed probably accounts for the different size ratios between input and output databases seen in the table.The correlation between the size of the input database and the compilation time is more pronounced than between input and output database sizes. This is possibly because the compilation time is dominated by the time it takes to traverse the SERIS transmittal. In a transmittal traversal, even unused objects require some processing time. Larger databases should therefore take longer to traverse even if the amount of data actually used is the same or less than the data extracted from a smaller database.ConclusionThe enhancements, which have been made to the SEDRIS to CTDB compiler since the last report in Reference  REF _Ref485634808 \r \h [4], provide the capability to create any data structure in the CTDB. Additional work is required to refine these capabilities so that additional SEDRIS data representations can be used for each CTDB data structure.Work on the SEDRIS to CTDB compiler is continuing. In particular, additional development is being conducted to accommodate different organizational constructs. This will insure flexibility and robustness in the conversion of SEDRIS environmental data to the CTDB format.Database NameOriginal FormatDatabase Extents (km x km)Input File Size (Mbytes)Compilation Time (Hours)Output File Size (Mbytes)BellevueLM S100010 x 104.50.090.3MOBALM S100024 x 241587.649.9FtpolkGeoTIFF/VPF11.5 x 7.75.70.088.7PhillyTerrasim2 x 1500.903.7P1 i9E&S GDF7.7 x 7.711710.040.8P2 a13E&S GDF108 x 1544049.7415.4Table  SEQ Table \* ARABIC 1 Compiler performance data EMBED MSGraph.Chart.8 \s Figure  SEQ Figure \* ARABIC 11 Compilation time versus database sizeReferencesG.Lukes, P.Birkel: “Synthetic Environments, Final Technical Report”, sponsored by Defense Advanced Research Projects Agency, September 1998 (Document #98-5-3100)J. Smith: “LibCTDB User Manual and Report”T. Stanzione, A. Evans: “Multiple Elevation Structures in the Improved Computer Generated Forces Terrain Database”, Proceedings of the Sixth Conference on Computer Generated Forces and Behavioral Representation, July 1996V. J. Skowronski: “Producing Terrain Databases for Computer Generated Forces using SEDRIS”, Proceedings of the Fall 1998 Simulation Interoperability Workshop, September 1998V.J. Skowronski: “Detecting Implicit Grids in Terrain Databases using a Fast Fourier Transform”, Proceedings of the Fall 1998 Simulation Interoperability Workshop, September 1998 HYPERLINK http://www.sedris.org http://www.sedris.org, SEDRIS Web SiteM. Worley: “SEDRIS: an Object-Oriented Data Model in a Procedural World”, Proceedings of the Spring 2000 Simulation Interoperability Workshop, March 2000P. Birkel: “SNE Forum – Introduction; CRM Overview; EDCS Overview”, Proceedings of the Spring 2000 Simulation Interoperability Workshop, March 2000Author BiographiesDR. VICTOR SKOWRONSKI is a Senior Member of the Technical Staff at TASC, where he investigates terrain representation for CGF systems.  Prior to joining TASC in 1996, he did research in solid modeling at Rensselaer Polytechnic Institute, where he also earned a PhD in Computer Engineering. Victor earned a M.E. and a B.E. in Electrical Engineering from Stevens Institute of Technology. He is a licensed Professional Engineer in New York and Massachusetts.THOMAS STANZIONE is the manager of the Simulation Technology Section at TASC. His interests include data representation for terrain reasoning and terrain database generation for simulation applications.  Mr. Stanzione has a Masters of Science Degree in Photographic Science from the Rochester Institute of Technology.  