Military Modeling Framework (MMF): A Framework Supporting Composability and Multi-Resolution Modeling	Khang Cat	Karl Gardner	Tom Gryder	SAIC	Raytheon	MITRE Corporation		12479 Research Parkway	528 Boston Post Road	202 Burlington Road	Orlando, FL 32826	Sudbury, MA 01776	Bedford, MA 01803	(407) 207-2731	(978) 440-1437	(781) 377-9006	 HYPERLINK mailto:khang.v.cat@cpmx.saic.com khang.v.cat@cpmx.saic.com	 HYPERLINK mailto:fkg@ed.ray.com fkg@ed.ray.com	 HYPERLINK mailto:twg@mitre.org twg@mitre.org Keywords: JSIMS, Military Modeling Framework (MMF), composability, multi-resolution modeling (MRM)ABSTRACT: As a modeling framework for the Joint Simulation System (JSIMS), the Military Modeling Framework (MMF) provides the means for composability and multi-resolution modeling.  The goal of the MMF is to establish a foundation for development of Mission Space Objects (MSOs), which can be composed in a robust and flexible fashion.  Spanning all military services, these MSOs not only have to interoperate, but are also envisioned to be composed from reusable and dynamically re-configurable components, assuring a common interpretation of the synthetic battlespace.  Accurate representation of military power is key to Joint Training exercises.  In JSIMS, this will be achieved by having each service develop models for which they are domain experts, and placing these models into a repository that can then be used by all services and joint organizations to compose an exercise. The MMF is being developed by an Enterprise-wide Tiger Team, with members from the Air Force, Army, Navy, Joint, and other JSIMS Development Agents (DAs).  The MMF will help achieve dynamic object composition and isolation of the details of the Discrete Event Simulation Engine from the MSO developer. The MMF supports composition of MSOs from Submodels and dynamic reconfiguration of those Submodels, including “pseudo” aggregation and deaggregation.  This paper describes the technical details of the MMF, including how it provides composability and multi-resolution modeling in support of MSO development.IntroductionDisclaimerThe Military Modeling Framework (MMF) is still undergoing development within the Joint Simulation System (JSIMS) Enterprise as of the writing of this paper.  As such, this paper does not necessarily represent the current and/or official position of the JSIMS Enterprise.Introduction to JSIMS and the EnterpriseJSIMS defines a single, distributed, interactive and seamlessly integrated simulation environment for training of the Commanders in Chief (CINC) and Joint Task Force (JTF).  JSIMS provides the simulation system necessary to support multiple training, planning and analysis, rehearsal, education and doctrine development events.  As such, JSIMS can be composed into various configurations to meet service specific training requirements.The JSIMS Enterprise members include: JSIMS Integration and Developer (I&D), Land Development Agent (DA) (i.e., WARSIM 2000), Air & Space DA (i.e., National Air & Space Model (NASM)), Maritime DA, and the Intelligence DAs (i.e., Warfighter’s Intelligence Module (WIM), National Simulation (NATSIM), and JSIMS Signals Simulation (J-SIGSIM)), and a number of Executive Agents (EAs).JSIMS Software ArchitecturePrior to a detailed discussion of the MMF, a brief introduction to the JSIMS architecture is provided.  The JSIMS layered software architecture diagram is shown in  REF _Ref423682670 \h Figure 1.  The relevant components of the architecture are discussed in turn.  The following description of the JSIMS architecture is based on reference [1] and on-going discussions with the JSIMS Chief Architect.Infrastructure ComponentsThe JSIMS Infrastructure components consist of the JSIMS Object Services (JOS), Military Modeling Framework (MMF), and Common Services.  The JOS and MMF are discussed in more detailed below.Figure  SEQ Figure \* ARABIC 1. JSIMS Layered Software ArchitectureJSIMS Object Services (JOS)The JSIMS simulation infrastructure is known as the JOS.  The JOS provides the parallel discrete event simulation (PDES) engine (i.e., SPEEDES), provides state updates using data distribution management (DDM), and provides a mechanism for interest management.  Additionally, the JOS supports object initialization and persistence via the Common Data Infrastructure (CDI).  The Object Management Framework (OMF) portion of the JOS provides access to all JOS services.The JSIMS architecture is HLA compliant and supports interoperability with other HLA federates using an HLA compliant RTI.Federation Objects (FOs) represent the “public face” of a battlespace entity (e.g., F-15 aircraft, M1A1 tank).  As such, the FO contains the public states of the model as observable attributes in the synthetic battlespace.  The FOs are real software objects in that they have attributes and methods.  The superset of all FO classes makes up the JSIMS Federation Object Model (JFOM).  As an object model, the JFOM contains the hierarchy of FOs.  Furthermore, the FOs are intelligently partitioned to optimize system performance (i.e. CPU cycles and network traffic) and support the JSIMS security architecture [3].  The JFOM is the primary mechanism for supporting model-to-model communications within JSIMS.  Each model “publishes” and updates a set of partitioned FOs.  When a model requires data from other models, it “subscribes” to the other models’ FOs by registering its expressions of interest via a MMF method inherited from the OMF.Predictive contracts are explicit in persistent FOs and describe the FO attributes over a specified time duration.  When a model “updates” its persistent FOs, it updates the predictive contract for the attributes.  The FO update causes the infrastructure to distribute or reflect the information of the FO update to hosts that need it.  When another model accesses a FO attribute of that 1st model, it invokes the appropriate “get” method with the current simulation time to obtain the current value of the 1st model’s attribute (i.e., by evaluating the predictive contract for the simulated time).  When the predictive contract of a FO’s attribute expires, the owning model receives a callback (i.e., thread of control) to update the predictive contract of that attribute.While a FO may only be owned (i.e., published) by one model at a given time, its ownership may be transferred to another model.  The model that owns the FO is capable of updating the attributes of that FO.  Note that FO ownership transfer applies to individual, partitioned FOs (i.e., not per FO attribute).FOs are similar in concept to the High Level Architecture (HLA) Simulation Object Model (SOM) and Federation Object Model (FOM) concepts, but are fundamentally different.  Although the JFOM is a collection of software classes with attributes and methods, it is conceptually equivalent to the HLA SOM.Interest Management provides a mechanism for models to express their interest in other models’ FOs.  JSIMS interest management is two-tiered.  The first tier, Interest Management Language (IML), allows models to state what FOs should be distributed on its local host, as expressed by the FO class, collection, and tag (e.g., the IML triple).  The second tier, FO Query Language (FQL) allows models to specify queries on specific FO attributes.  If a FO matches a model’s interest expression in both IML and FQL, then the OMF fires a trigger view, giving the model thread of control (e.g., to update its states).MMFThe MMF plays two major roles.  First, the MMF allows a set of military domain base classes from which model developers will specialize to build their models.  The MMF insures that these models would be built in a consistent fashion and provides a means for software reuse across modeling domains.  Second, the MMF provides a framework to isolate model developers from the details of the simulation infrastructure (e.g., PDES engine), support dynamic creation of new models, and support dynamic reconfiguration of a model’s components.  As a framework, the MMF inherits from the OMF to gain access to various simulation infrastructure capabilities, e.g., the FO publication and subscription mechanisms. This paper focuses on the framework aspects of the MMF, particularly as it supports composability and multi-resolution modeling (MRM).Mission Space Objects (MSOs) MSOs are the models that simulate the game pieces in the synthetic battlespace, e.g., aircraft, tanks, ships, and simulated command units.  As a minimum, MSOs must inherit from MMF base classes (e.g., Model and Submodel classes) in order to gain access to the OMF, JOS, and Common Services.  In order to interact with other MSOs, an MSO is required to either: (1) publish and update FOs, as its “public face” interface; and/or (2) express interest in FOs published by other MSOs.  Consequently, an MSO may get a thread of control in one of two ways: (1) via a callback for FO attribute expiration (of its predictive contract), or (2) via a trigger view when some FOs met its interest expression.Two fundamental capabilities provided by the MMF to the MSOs are (1) the ability to compose MSOs from smaller components, and (2) the ability to implement multi-resolution models (MRM).  These two capabilities are the focus of Sections  REF _Ref423686594 \r \h 4 and  REF _Ref424922242 \r \h 5, respectively.Given the defined game pieces, or battlefield entities, in the simulation environment, MSO developers have a number of options in which to implement these battlefield entities:A.	One MSO simulates a number of battlefield entities.  An example is a “flight of four” MSO simulating four F-15 fighter aircraft entities.B.	One MSO simulates one battlefield entity.  An example is an F-15 MSO representing one F-15 fighter aircraft entity.C.	A number of MSOs simulate one battlefield entity.  As an example, an F-15 entity can be simulated by a aircraft platform MSO (models the kinematics of the aircraft, and publishes the position and velocity state information), a radar MSO (models the sensing capabilities, and publishes the illumination state information), and a damage MSO (computes damage state and publishes that damage state)Life Cycle Applications (LCAs)LCAs consist of applications to support the life cycle of the simulation, including pre-exercise, exercise execution, and post exercise support functions.  In pre-exercise mode, LCAs provide scenario generation (e.g., force lay down), including operational and physical composition and evaluation, and initialization during start of exercise.  During the exercise execution, LCAs provide simulation control, including start/stop, pause/resume, checkpoint/re-start, and time management controls; magic moves; and continuous review (CR).  In post exercise, LCAs support after action review (AAR).  In addition, LCAs support plan view displays (PVDs) and graphical user interface (GUI) operator interfaces, and access to the JSIMS repository.JSIMS Modeling and Simulation Resource Repository (JMSRR)The JMSRR is a distributed database containing metadata and pointers to MSOs, parametric data, initial state data, exercise compositions, exercise scenarios, and results from previous exercises.  The JMSRR provides metadata and indexing into these data repositories and supports queries.  It also supports the exercise composition process, as described in Section  REF _Ref423686594 \r \h 4.MMF DevelopmentDevelopment Team and ProcessThe MMF is developed by an empowered Tiger Team with representatives from across the JSIMS Enterprise including Land DA, Air & Space DA, Maritime DA, Joint DA, and Intelligence DAs (NATSIM and WIM). The process consists of requirements analysis, System Object Oriented Analysis/Design (OOA/D), Software OOA/D and OO Programming.  The team is given full authority to make design decisions and to represent their respective DAs.Requirements AnalysisThe requirements analysis phase consisted primarily of reviewing the JSIMS requirements document [2] and individual DA source requirement documents to identify overall driving requirements from which to derive detailed requirements for the MMF.  The overall system level requirement used to derive the MMF requirements was “JSIMS shall provide common software services ranging from low-level system utilities to higher-level applications such as database management, tools and reusable shared software components.”  Armed with this system level requirement and an understanding of the vision of JSIMS to be a flexible and composable system, approximately 15 derived requirements were defined.  Three of these requirements are considered driving requirements and are described below.Driving RequirementsOne of the major goals of JSIMS is to deliver a composable modeling environment with maximum potential for reuse.  This leads to our first driving requirement: “The MMF shall enable MSO creation in a uniform, consistent, composable fashion.”  Another goal which is key, particularly to the Air & Space DA, is support for Multi-Resolution Modeling (MRM), for which there are two additional driving requirements.  The first is for model reconfiguration: “The MMF shall provide support for dynamic swap of MSO Submodels.”  The second is for pseudo aggregation and deaggregation: “The MMF shall provide support for pseudo aggregation and deaggregation of MSOs.”  The concepts of pseudo aggregation and deaggregation are explained in Section  REF _Ref423933108 \r \h 5.2.MMF Use CasesThe MMF development defined the following use cases, grouped by areas of driving requirements:In support of Dynamic Composition:MMF Supports Initialization of MSOs by LCA: This Use Case supports initialization of MSOs when created by LCAs.MMF Supports Initialization of MSOs by Spawning New MSOs: This Use Case supports spawning and initialization of new MSO(s) when created by another MSO.In support of Model Reconfiguration:MMF Supports Swap of Submodels: This Use Case provides a framework for swapping of an MSO’s Submodel (e.g., swap a fixed-wing kinematics Submodel for a rotary-wing kinematics model when a tilt-wing V-22 Osprey changes its flight behavior from forward to hover flight).In support of Pseudo Aggregation and Deaggregation transitions:MMF Supports Pseudo Deaggregation: This Use Case provides a framework for pseudo deaggregation (e.g., a tank platoon MSO pseudo deaggregates into 4 individual tank MSOs).MMF Supports Pseudo Aggregation which provides a framework for pseudo aggregation (e.g., aircrafts pseudo aggregating into a package).Design PhilosophyThe MMF design philosophy is to meet JSIMS Initial Operating Capability (IOC) requirements for a modeling framework, while maintaining the Full Operational Capability (FOC) vision.  While the MMF design is constrained by the over-arching JSIMS architecture (as defined by reference [1]), the Tiger Team retained as much flexibility as possible in the MMF.The MMF Design REF _Ref423926132 \h Figure 2 shows the object model diagram for the classes comprising the MMF, namely Model, Submodel, SubmodelFactory classes.  Each is discussed in more detail in the following subsections.Figure  SEQ Figure \* ARABIC 2. MMF Object Model DiagramIn order to support component-level composability (see Section  REF _Ref423926600 \r \h 4) and maximize software reuse, the MMF design specifies a framework of Submodels from which leaf-node Submodel classes will be aggregated to compose an MSO.  For example, a fighter aircraft MSO can be composed by aggregating: (1) a fixed-wing aircraft kinematics Submodel, (2) an airborne fire control radar Submodel, and (3) a fighter mission behaviors Submodel.  The Submodel inheritance tree will allow for specialized Submodels to be built with reuse via inheritance of parent classes.  The aggregation of Submodels into an MSO allows the same Submodel classes to be reused in the composition of various MSOs.  Finally, the fighter aircraft Model and Submodel classes may be instantiated with specific parametric data to represent a specific entity, say an F-15C.  In summary, the MMF supports software reuse using inheritance, aggregation, and parameterization mechanisms.Model ClassAs stated in Section  REF _Ref423928814 \r \h 1.3.1.2, the MMF, as a framework, inherits from the OMF.  Specifically, the Model class inherits from the OMF’s SimulationObject class.  This inheritance provides the methods (see  REF _Ref423926132 \h Figure 2) to create and delete FOs, change FO ownership, register callbacks for FO attribute expiration, create and delete interest expressions, and support various initialization methods.  It also provides the Model class a list of owned FOs and list of interest expressions, as attributes.The Model class introduces additional methods to coordinate the creation and initialization of the instances of Model and Submodel classes, coordinate the swapping between Submodels, establish links among the Submodel instances, spawn new MSOs, perform pseudo aggregation and deaggregation (see Section  REF _Ref423933108 \r \h  \* MERGEFORMAT 5.2), and access parametric and initial state data from the CDI.  The Model class also contains the model composition data which defines the allowable Submodel configurations (see Sections  REF _Ref423933366 \r \h  \* MERGEFORMAT 4.2 and  REF _Ref423933350 \r \h  \* MERGEFORMAT 5.1), the valid transitions between these Submodel configurations, and a list of FOs that represents that MSO’s interface.An instance of the Model class is created for each MSO.  The MSO must also include at least one object from the Submodel class hierarchy.  In the current design, the Model class is a concrete class, and therefore its attributes and methods cannot be overridden.  As such, it is generic to all MSOs and is purely data driven.Submodel ClassThe Submodel class performs Submodel-specific actions in support of the Model class creating and initializing instances of its Submodel class, linking its Submodel object to other required Submodel objects, and transferring FO control.  While MSOs must use the FO publication and subscription mechanism to communicate, Submodels within an MSO can communicate using direct method invocation (i.e., one Submodel invokes a method of another Submodel).The Submodel class is the root class for a rich Submodel inheritance tree.  The MMF Tiger Team identified and designed a number of Submodel child classes, see  REF _Ref423929664 \h Figure 3 for a subset of these Submodel classes.  Detailed discussion of these child classes is beyond the scope of this paper.  Furthermore, this Submodel hierarchy is still currently in development and is subject to change.Figure  SEQ Figure \* ARABIC 3. Example of Submodel Class HierarchyA Submodel instance can either be aggregated into a Model or another Submodel (e.g., nested Submodel structure), but it cannot be aggregated into both at the same time.  However, the same Submodel class could be instantiated in one case to be a part of a Model, and in another case to be a part of a parent Submodel.  A Submodel has required services (referred to as links) that need to be satisfied for proper operation.  Therefore, the linking of Submodels matches up the provided and required services of all Submodels.SubmodelFactory ClassThe SubmodelFactory class assists in the creation of Submodel instances and will not be further described in this paper.ComposabilityConcept of ComposabilityThe JSIMS Composability Task Force (CTF) defined composability as “the ability to rapidly configure, initialize, and test an exercise by logically assembling a simulation from a pool of reusable elements” [4].  There are three methods of composability: assembly, extension, and parameterization.  The CTF defined these as [4]:Assembly: A method of achieving composability by  instantiating and connecting components which interoperate through a common infrastructure which may also be a component.  Extension: A method of achieving composability by extending the functionality of components in an existing logical structure through direct (function override) or indirect (selective feature activation) means.Parameterization: A method of achieving composability by altering parameter sets which control the operation of data-driven elements in an existing logical structure.Given these methods of composability, the focus of this paper is the assembly method of composability, although the MMF supports the other two methods as well.Levels of ComposabilityFocusing on the assembly method of composability, JSIMS defined three levels of composition (with varying levels of granularity): simulation, package, and component.   REF _Ref423682829 \h Figure 4 depicts the levels of composition ranging from the simulation level of a complete ready to run exercise to the component level, which builds off of atomic level components.  Between the simulation and component levels is the range of small to large packages which represent logical groupings of models to form complete logical collections.  Each DA is free to choose the level and method of composition that is most appropriate for satisfying their particular requirements.  For example, Air & Space DA intends to initially provide small packages (e.g., F-15C MSO) as the basic building block for scenario generation.  Other DAs plan on delivering more complete large packages (e.g., ground combat package for ground forces training).Figure  SEQ Figure \* ARABIC 4. Composability Levels and MetadataComposability MetadataThe compositions are controlled with metadata that describe how components and packages can be combined to form simulation systems.  This is not intended to be an exhaustive list of how every object can (or cannot) be composed with every other object.  Rather it specifies explicitly those compositions that are allowed.  Finally at the top level of a simulation, metadata is developed by exercise developers to define what packages are needed to achieve their training objectives.The information needed to produce the required metadata should be a natural fallout from Software OOA/OOD.  By intelligently employing a composition hierarchy of components and packages, the amount of required metadata can be reduced. REF _Ref423682829 \h Figure 4 shows conceptually how entities at different levels of granularity can be combined to form the desired composition under the constraints of metadata.  Packages can be augmented with components to form new packages or with other packages to form larger packages.  Similarly, components and packages can be combined to form a simulation system for use in exercises, such as Unified Endeavor (UE).Metadata and VV&AOne of the goals is to define a flexible system that readily accepts changes to model compositions, while supplying a mechanism to assure that only Verified Validated and Accredited (VV&A) configurations are used in training exercises.  This is achieved with the “metadata” about the compositions that are explicitly allowed.  The use of specific metadata prevents the exercise analyst from arbitrarily combining models.  Given that this composition is controlled largely by metadata, it is possible to quickly change the metadata to create new compositions.  However, this new metadata must be created and verified, validated, and accredited by the SMEs.  The advantage of using metadata comes in the level of control and the visibility of changes to verified, validated, and accredited Submodel configurations. The use of metadata can actually help VV&A because it limits what possibilities need to be tested within the supplied realm of the metadata.  If the metadata is changed, functional VV&A must be performed.  However minimal software V&V would be required.  If metadata is not supplied, and software is modified instead, then the software V&V needs to be redone.The goal is to use objects at different levels of granularity to achieve a robust and flexible simulation composition capability.  The ultimate goal is to allow scenario analysts to simply use a Life Cycle Application to compose an exercise by selecting components, packages or complete simulations.Composability in MMFWith the above understanding of composability, the MMF Tiger Team has developed an approach to achieve composability within the JSIMS architectural constraints, while minimizing the impact on MSO developers. REF _Ref423682951 \h Figure 5 illustrates the process of developing an exercise composition using the component-level “assembly” process during scenario generation.  Initially, a MSO developer designs a set of Submodels which are intended to work together to implement various battlespace entities.  Each geometric shape in  REF _Ref423682951 \h Figure 5 represents an inter-changeable Submodel.  Metadata is supplied to explicitly constrain the allowed combinations.  For example, triangles represent radar Submodels and we have selected only airborne radar Submodels from the full set of radar Submodels.  Circles represent kinematics Submodels for different types of vehicles at different levels of fidelity, while squares represent behavior Submodels for different missions.  By putting this information into the JMSRR, the MSO developer has possibly reused existing models (e.g., radar Submodels) and defined restrictions on what kinematics Submodels (e.g., fixed wing) for behavior can be used.Figure  SEQ Figure \* ARABIC 5. Component-Level Composability ProcessThe next step is for a scenario analyst to use an LCA to selectively define (i.e., further constrain) what is used in a specific exercise and to set an initial configuration.  Continuing with the example, the scenario analyst may limit selected Submodels to a smaller set of airborne radar Submodels, a specific set of fixed wing kinematics Submodels (e.g., high, medium, low fidelity) and a set of mission behavior Submodels.  This information is distributed to a JSIMS node where it can be executed and stored in that local CDI.  At this point, the MMF takes over by dynamically creating an MSO of the type specified by the LCA.Model Composition DataIn order to achieve the goal of dynamic composition of models, a data structure implemented as a C++ class was developed.   REF _Ref423945600 \h Figure 6 notionally depicts some of the major data components (i.e., class attributes).  Note that the methods for this class are largely for internal manipulation and query, hence they are not presented here.Figure  SEQ Figure \* ARABIC 6. Model Composition DataBasically an MSO (or model) is composed of a collection of Submodels that intercommunicate by direct method invocations, and communicate to other MSOs via publication and subscription of FOs.  The ModelCompositionData is information pertinent to the complete collection of Submodels that form the model which primarily consist of a list of all Submodels (active or inactive) and a list of which are currently active.The SubmodelCompositionData (basically a table with entries for each Submodel) for each Submodel indicates what FOs the Submodel will be publishing (as provided services), what Submodels it will intra-model communicate, and other Submodel data.  These structures are then referenced through a basic tree structure to form a model composition hierarchy.  Part of the information for each entry in the model tree is the current configuration of its children nodes and a table of valid transitions between alternate configurations.  This data is used to create MSOs, to spawn new MSOs, and to reconfigure their Submodels.The next section will elaborate on how this data is used.  In the initial composition process, the MMF reads this data to create automatically instances of the needed Submodels, create the published FOs (for each Submodel that is active), and link Submodels (by passing pointers between the Submodels) to allow them to communicate directly using direct method invocation.  The bottom portion of  REF _Ref423945600 \h Figure 6 shows how this data will be used dynamically to reconfigure the model between alternate Submodel configurations.Multi-Resolution Modeling (MRM)MRM is the ability for a model (e.g., MSO) to change its algorithm dynamically to simulate the same battlefield entities at a different level of resolution (which usually implies a change in level of fidelity), as the needs of the exercise changes.  The motivation for multi-resolution models is to conserve CPU cycles whenever possible and re-allocate these computing resources to resolve more critical interactions, as they occur during the exercise.While the resolution or complexity of the MRM model changes, its “public face” or interface, as described by its FOs, remains at the same level of resolution.  Therefore other models still interact with the multi-resolution model (that has changed resolution and fidelity) using the same interface.  This is a key feature and benefit in separating the implementation (MSOs) from the interface (JFOM).  This approach allows models with varying levels of resolution and fidelities to interoperate, while still supporting a consistent battlespace.To support higher resolution models, the partitioned FO concept allows for extended FOs to be published and updated by these higher resolution models.  For example, low resolution models (e.g., 3-DOF (degree of freedom) motion model) publish a Dynamics FO for its position and velocity state information.  Orientation and attitude angles (e.g., heading, pitch, yaw, and roll) are normally not represented or published by these low resolution models.  However, when an MRM model changes to its high resolution mode (e.g., 6-DOF motion model), it may publish the Orientation FO (an extended FO) for its orientation and attitude angles, in addition to the Dynamics FO.  Other high resolution models that are capable of using these states would have already expressed interest in these Orientation FOs.The MMF fully supports the ability to implement multi-resolution models.  It does so by providing a mechanism to swap Submodels dynamically, and a framework to perform pseudo aggregation and pseudo deaggregation (as explained in Section  REF _Ref423933108 \r \h 5.2).It should be noted that these early MRM design approaches were explored in the MRM prototyping efforts as part of the NASM program, and were incorporated into the current MMF design.Swap of SubmodelsAs discussed in Section  REF _Ref423964791 \r \h 3.1, an MSO is composed of a Model object and a number (one or more) of Submodel objects.  Because most of an MSO’s unique behaviors are implemented in the Submodel objects, it would be desirable to change the various Submodel objects dynamically during run-time to change the behavior of the MSO.  For example, it may be deemed necessary that a fighter aircraft MSO needs to change from a 3-DOF kinematics Submodel to a 6-DOF kinematics Submodel in order to simulate effectively the effects of aerial combat maneuvers (ACM), i.e., airborne dogfight, because of the desired level of fidelity.The MMF supports the ability to swap out a Submodel configuration, in place of another Submodel configuration, as shown in  REF _Ref423772158 \h Figure 7.  When a lower resolution Submodel is swapped out for a higher resolution Submodel, the latter may need to synthesize additional states for its algorithms.Figure  SEQ Figure \* ARABIC 7. Swap of Submodel ConfigurationAs an example of the development products,  REF _Ref423795767 \h Figure 8 shows the interaction diagram (i.e., event trace) for the “MMF Supports Swap of Submodels” Use Case.  The key points are:Once an MSO decides to swap its Submodels, it invokes the Model.SwapSubmodelConfiguration method.  This method instantiates the new Submodels for the new configuration, and initializes these new Submodels.The FOs references are transferred from the old to the new Submodels, so the new Submodels can now update those FOs.The state data is transferred between the old and new Submodels, and new states are synthesized by the new Submodels (as necessary).The new Submodels register their interest expressions.The old Submodels are deleted.The Model class links all the Submodels together, ensuring that all of its Submodels can communicate amongst themselves.Figure  SEQ Figure \* ARABIC 8. Interaction Diagram for Swap Submodel “Pseudo” Aggregation and DeaggregationTraditionally, when models aggregated and deaggregated, the interface to these models as well as the behavior of the models changed.  In JSIMS, it is required that the interface of the battlespace entities remain at the same level of resolution, even as the underlying model changes the resolution of its internal algorithms.At this point, it is key to understanding that battlespace entities may be implemented in three distinct MSO compositions, as illustrated in  REF _Ref423798996 \h Figure 9:(i)	One MSO simulating multiple battlefield entities (pseudo aggregation mode).(ii)	One MSO simulating one battlefield entity (deaggregation mode).(iii)	Several MSOs simulating one battlefield entity.In each of the three MSO compositions, the battlefield entity and its FO representation does not change level of resolution.  A battlefield entity’s public face, represented by its FOs, hides the implementation (i.e., MSO) from other entities.  As such, the other battlefield entities are not aware when an entity has undergone pseudo aggregation or deaggregation.Figure  SEQ Figure \* ARABIC 9. Battlespace Entities and MSOsThe term “pseudo” is used in conjunction with aggregation and deaggregation to emphasize that the resolution of battlefield entity’s “public face” does not change as a result of the aggregation or deaggregation process.  Therefore, a sensor can still observe the individual fighter aircraft after they have pseudo aggregated into a single “flight of four” MSO, since the FOs for each fighter aircraft are still updated by the “flight of four” MSO.Next, there are basically three levels of aggregation and deaggregation states, as depicted in  REF _Ref423799625 \h Figure 10:(A)	Aggregated State: An aggregate-level MSO publishes and updates aggregate-level FOs, e.g., a tank company MSO publishes FOs representing aggregate-level tank company state information (aggregate position).(B)	Pseudo Deaggregated State: One MSO is modeling an entire tank platoon, publishing both aggregate-level state information in a Collection FO (as needed) and entity-level state information in Dynamics FOs.(C)	Deaggregated State: A number of MSOs exist for the purpose of modeling the individual battlespace entities.  These MSOs publish both aggregate-level state information in a Collection FO (as needed), and entity-level state information in Dynamics FOs.Figure  SEQ Figure \* ARABIC 10. Three Levels of Aggregation/Deaggregation StatesBecause JSIMS does not allow the level of resolution of the interface to change as models undergo pseudo aggregation and deaggregation, transitions between states (A) and (B), and states (A) and (C) are not allowed.  Transitions are allowed between the deaggregated states (B) and (C) because their interfaces remain at the same level of resolution.  As shown in  REF _Ref423799625 \h Figure 10, these transitions are referred to as pseudo aggregation and deaggregation, and are discussed in the next two subsections. Pseudo AggregationPseudo aggregation is the process whereby an MSO undergoes the transition from the deaggregated state to the pseudo deaggregated state, reference  REF _Ref423799625 \h Figure 10.  An example is 4 individual fighter aircraft MSOs pseudo aggregating into a single “flight of four” MSO.  MSO developers may choose to design an MSO such that it performs in pseudo aggregation mode when the simulation does not require the higher resolution MSOs (e.g., the “flight of four” MSO is sufficient to simulate the behavior of the 4 individual aircraft until they become engage in a battle.)A key assumption in pseudo aggregation is that the “flight of four” MSO is capable of simulating the behaviors of the individual MSOs being pseudo aggregated.   REF _Ref423847310 \h Figure 11 shows the interaction diagram for pseudo aggregation.  The key points are:Once the Pseudo Deaggregate MSO decides to pseudo aggregate, it uses the ChangeAggState FO to regain thread of control at the proper entry point (since its Submodel may be swapped).The PseudoDeaggregate FO is used to inform the Deaggregate MSOs of the impending pseudo aggregation.The FOs (representing the battlefield entity undergoing pseudo aggregation) are transferred to the Pseudo Deaggregate MSO (for updating).Initialization FOs are used to transfer private state data (e.g., fuel level) to the Pseudo Deaggregate MSO.The Deaggregated MSOs are deleted.Figure  SEQ Figure \* ARABIC 11. Pseudo Aggregation Interaction DiagramRecovery of Battlefield Entities. The concept of pseudo aggregation may be extended to support recovery of battlefield entities.  As an example, an F-18 fighter aircraft MSO lands on an aircraft carrier MSO, and the MSO developer wants to subsume the F-18 fighter aircraft entity into the aircraft carrier entity.  Depending on the needs of the exercise, modelers can implement this a number of ways.  For sake of discussion, assume that prior to landing the F-18 is a separate entity, has its own set of FOs, and has an MSO to update those FOs.Scenario 1: Suppose the F-18 still needs to be represented as a separate battlefield entity, because it is still on the flight deck and can be observed by various sensors.  This requires the F-18’s FOs to be updated, because it still needs to be recognized as a separate entity.Option A. Keep the F-18 MSO alive to publish its FOs, and use the containment interaction (i.e., Contain FO), to capture the containment relationship between the F-18 MSO and the aircraft carrier MSO.Option B. Transfer ownership of the F-18's FOs to the carrier MSO and delete the F-18 MSO.  If the modeler wants to do this, the carrier MSO must be capable of publishing the F-18's FOs, as a pre-condition.  This process is covered by "pseudo aggregation" interaction.Scenario 2: Suppose the F-18 is moved into the aircraft carrier's hangar bay (under the flight deck) and can no longer be observed or detected.  Since the F-18 is no longer represented as a separate battlefield entity, its FOs no longer need to "exist" (i.e., its FOs can go into a dormant state).Option C. Delete the F-18 MSO and place its FOs in a dormant state.  Before deleting itself, the F-18 MSO publishes a State Change FO to the aircraft carrier MSO, indicating to the aircraft carrier to increment its count of F-18s by one.  The carrier MSO now represents the F-18 as another piece of on-board cargo.  Should the carrier take damage, it has to know how many of its F-18s are damaged and to what extend. Pseudo DeaggregationPseudo deaggregation is the process whereby an MSO undergoes the transition from the pseudo deaggregated state to the deaggregated state, reference  REF _Ref423799625 \h Figure 10.  An example is a single “flight of four” MSO pseudo deaggregating into 4 individual fighter aircraft MSOs.  MSO developers may choose to design an MSO such that it performs in pseudo deaggregation mode when the simulation requires higher resolution MSOs (e.g., 4 individual aircraft MSOs are required to simulate the complex behaviors required for tactical engagements.)   REF _Ref423850839 \h Figure 12 shows the interaction diagram for pseudo deaggregation.  The key points are:Once the pseudo deaggregate MSO decides to pseudo deaggregate, it kicks off the spawn MSO use case, which creates a new MSOs to represent the deaggregated entities.The FOs (representing the battlefield entity subject to pseudo deaggregation) are transferred to the Deaggregate MSO (for updating).Initialization FOs are used to transfer private state data (e.g., fuel level) to the Deaggregate MSO.Figure  SEQ Figure \* ARABIC 12. Pseudo Deaggregation Interaction DiagramPseudo deaggregation is generally used when the simulation requires high fidelity behaviors to accurately capture the detailed behaviors of individual battlefield entities.Launch of Battlefield Entities. The concept of pseudo deaggregation may be extended to support the launch of new battlefield entities.  Examples include: launch of aircraft from an aircraft carrier, launch of Marines landing crafts from a Navy ship, and launch of explicitly modeled weapons (e.g., cruise missiles, ICBMs, etc.).SummaryA JSIMS Enterprise-wide Tiger Team was established to design and develop the MMF.  As a framework for model development, the MMF provides an approach for building consistent models, defines the means for initialization and spawning of new models, provides access to the FO publication and subscription mechanisms, and isolates the details of the simulation infrastructure.  Additionally, the MMF is built as a framework that supports component level composability and MRM (including re-configuration of Submodels, and pseudo aggregation and deaggregation).During the design effort, the MMF Tiger Team fleshed out some necessary details of the JSIMS architecture.  Lessons from the NASM program’s MRM prototyping efforts were incorporated into the current MMF design.  This MMF implementation is in the process of being tested for its composability and MRM capabilities at the time of this writing.  The JSIMS MMF will continue to evolve over the life cycle of the spiral software development effort.References[1]	System Segment Design Description (SSDD) for the Joint Simulation System (JSIMS), Version 2.0, 15 May 1998.[2]	JSIMS System Segment Specification (SSS), Version 2.1, 1 December 1997.[3]	Valle, Tony. “Security Features of the JSIMS Design”, paper 98S-SIW-091, Spring 1998 Simulation Interoperability Workshop, SISO, 9-13 March 1998.[4]	JSIMS Composability Task Force, “JSIMS Composability Task Force Final Report”, 30 September 1997.AcknowledgementsThe authors wish to acknowledge that the MMF development was performed by a JSIMS Enterprise-wide Tiger Team.  The authors would like to extend their appreciation to each member of the Tiger Team, and to those who participated in the MMF Peer Reviews for sharing their constructive comments and criticisms.Dr. Ben Wise led the NASM MRM prototyping effort that spearheaded the composability and MRM technologies.  For this, the authors are grateful for his significant technical contributions.Author BiographiesKHANG CAT is a Senior Systems Engineer at SAIC, and is the System Architect for the NASM program.  He has over nine years of experience in systems and software engineering in the modeling and simulation industry.  Mr. Cat received a B.S. degree in Mechanical and Aeronautical Engineering from the University of California, Davis in 1989, and a M.S. degree in Electrical Engineering from the University of Southern California in 1992.KARL GARDNER has a M.S. degree in Computer Science from University of Dayton.  He worked 5 years in software process, 10 years in tool development, and the previous 2 years in Modeling and Simulation.  Mr. Gardner is currently working for Raytheon Electronic Systems supporting the NASM program as Air & Space DAC Architecture Group Lead.TOM GRYDER is a Lead Simulation and Modeling Engineer for MITRE Corporation.  As part of the NASM Program Office, Mr. Gryder is the DA NASM/A&S Architecture Lead.  He has worked 14  years as a System/Performance Engineer with 5 years specifically oriented to modeling and simulation.  Mr. Gryder has a M.S. degree in Computer Science and Artificial Intelligence from the University of Pennsylvania.			