Hard Real-Time Simulation using HLAThom McLean College of ComputingGeorgia Institute of TechnologyAtlanta, GA, 30332 thom@cc.gatech.eduKeywords:Real-Time, HLA, RTIABSTRACT: Most real-time distributed simulations do not use HLA time management services.  The federates rely on wall-clock time for dead-reckoning, and sometimes, receiver side ordering of messages.  This presents particular problems in preventing causal and temporal anomalies, making many real-time simulations unsuitable for environments where correctness must be guaranteed (as in simulation based acquisition.)  This paper shows how time management can be used in real-time federates, and presents an approach for creating deterministic execution in real-time simulations.  The paper presents results of the R-RTI implementation, which was based on the Georgia Tech FDK.  The paper illustrates one method for equating HLA message timestamps to real-time processing deadlines, and describes other techniques currently being studied.IntroductionThe High Level Architecture (HLA) has become the standard technical architecture for modeling and simulation in the U.S. Department of Defense.  One component of the HLA, the Interface Specification (IFSpec) REF _Ref395702650 \r \h [1], defines the set of services that are used by individual simulations to interact with each other.  HLA simulations use runtime infrastructure (RTI) software to provide services to support interconnecting simulations as well as to manage the distributed simulation execution.  Using the IFSpec, composing federations of autonomous simulators or simulation components has become an accepted paradigm to realize distributed simulation systems, especially for real-time interactive simulation systems.  In such heterogeneous systems, typically, a simulation application or federate will not use time management services, preferring to synchronize to local, or wall-clock time (WCT).  Thus, we commonly say that the federate executes in real-time, although the RTI does not provide any real-time facilities.  Ignoring most of the RTI functionality, real-time federation developers typically focus on ways to minimize the amount of overhead imposed by the RTI.  In many situations, this approach has led to a hasty conclusion that HLA does not adequately serve the needs of real-time simulation developers.Distributed interactive simulations have been pressed into service for a variety of new uses.  Beginning with the US Army’s SimNET, sets of previously stand-alone simulators have been used in larger scale simulation systems.  Typically, these simulators have synchronization models that are designed to meet real-time human-in-the-loop response requirements.  The lack of a general mechanism for synchronization for real-time simulators led to the development of protocols that do not rely on timestamps to order the delivery of messages.  Recently, similar techniques have been used in on-line gaming environments, where communication latency may be large, and a strict timestamp order protocol is infeasible.  Reliance on ROOne way we minimize RTI overhead is to deliver messages to a federate with no ordering guarantees, or in receive order (RO).    RO delivery services avoid costly distributed synchronization operations normally associated with time-management and time-stamp ordered (TSO) messages.  However, RO message delivery is generally not repeatable, and can cause causal and temporal anomalies, as discussed in  REF _Ref395699059 \r \h [3] and elsewhere.  Except for certain types of hardware-in-the-loop (HWITL) simulation systems executing in a real-time operating system, most real-time simulations use RO delivery. Much of the rationale for RO message processing is based on experiences with DIS and early HLA implementations.  While the experiences were useful in understanding the nature of RT problems, the lessons learned do not always apply to current technology.  The HLA IFSpec does not specify timeliness criteria for RTI services or, specifically, message delivery. The lack of timeliness requirements, or any additional guidance, is a critical limitation in supporting real-time simulation systems where the amount and predictability of RTI overhead is an important design factor.  The inability to specify or guarantee message delay, for example, is one factor that has precluded acceptance of HLA in HWITL simulations and testbeds.  Analytical Shortcomings of ROIn addition to the obvious difficulties with respect to HWITL integration, the lack of timeliness criteria in HLA contributes to the difficulty in simulation analysis.  For example, causal relationships between RO events are difficult to detect.  Because the messages are delivered unordered and without timestamps or message delay information, no causal relationships can be inferred except for trivially implied causality within a single federate.  It is common practice for real-time federations to add an additional time attribute to a message for the purpose of dead-reckoning and detecting causal anomalies.  The difficulty in analyzing and validating real-time simulation data is a frequent topic in VV&A forums.  This is an important problem when trying to use simulation results to support acquisition decisions or course-of-action analysis. Recognizing these problems, we are investigating ways to add real-time functionality to the RTI.  In suggesting real-time features, we are not simply facilitating federate execution in real-time, rather, we propose modifications to the RTI to allow more discriminate analysis and management of federation execution.  Moreover, with a more complete understanding of distributed deadlines for execution, we may be able to develop better ways of specifying requirements for RTI performance for a desired model of real-time execution. Specifically, we are proposing changes that specify real-time deadlines for RTI functions, thereby enabling hard real-time federation execution.OrganizationThe remainder of the paper is organized as follows. Related work is presented in Section 2.  Section 3 illustrates common models for real-time execution.  In section 4 and 5 we explain research results leading toward hard real-time HLA federation execution. Section 6 speaks to the need for changes to the RTI IFSpec.  Section 7 discusses some potential benefits of this approach and is followed by a conclusion in section 9.Related WorkHistorically, much of the motivation for Distributed Interactive Simulation (DIS) was the appeal of linking real-time training simulators.  The original DIS protocol made no assumptions about message delay or infrastructure overhead.  Messages included a sender timestamp, which the receiver could use for dead-reckoning or reordering messages (although reordering was beyond the scope of the protocol.)  Unordered delivery limited the applicability of the DIS protocol.  Causal and temporal anomalies were common, especially in executions across wide area networks.  Some early DARPA programs, such as WarBreaker, may have overestimated the analytic value of DIS-based simulation.  However, these early programs, and more recent initiatives such as simulation-based acquisition (SBA), have established the US Department of Defense and wider interest in using real-time simulation for credible RDT&E.    To date, most work on HLA RTI software has focused on networked workstations using well-established communication protocols such as UDP and/or TCP.  While such implementations are sufficient for large portions of the M&S community, some applications require higher communication performance.  Shared memory multiprocessors and cluster computing platforms offer high performance alternatives.  A few systems have been adapted for use in high performance computing platforms as in  REF _Ref395702876 \r \h [2] and  REF _Ref395702925 \r \h [5].  A few other hard real-time HLA and HLA-like RTI implementations, primarily for HWITL testing, have been presented at simulation workshops.  However, these efforts have, for the most part, provided non-real-time HLA interfaces to a real-time environment.  Additionally, some commercial products claim hard real-time execution (see  HYPERLINK "http://www.opal-rt.com" http://www.opal-rt.com) by providing an RTOS simulation execution environment. Models of RT ExecutionMost commonly, the distributed simulation community uses local wall-clock time (WCT) as the reference for real-time, ignoring any variance between local clocks.  Such variance can be accounted for, if required, as in  REF _Ref395702951 \r \h [6].  We frequently say that a simulation is executing in real-time when it maintains a constant relationship between local simulation time and WCT.Common Models in Non-Real-Time EnvironmentsIn a conventional (non-real-time) operating system, the simulation cannot obtain guarantees for task completion deadlines.  A “real-time” simulation in this environment is typically a synchronized to wall-clock-time.  In order to ensure that a simulation remains synchronized with the WCT, it must execute in one of two manners.  A simulation may execute at an explicit time step, in which case it will suspend execution (wait) until the expiration of the time step interval.  Alternatively, a simulation may request the wall clock time at the end of a time step and, based upon the return value, vary the time step interval accordingly.   These methods are explained below.Time-stepped execution is the predominant model for “DIS” style applications.  The simulation is executed as a series of discrete intervals of length ∆t. In each interval, the application must 1) retrieve incoming messages, 2) compute the new internal state, and 3) send appropriate messages to other logical processes.  At the end of this processing cycle, internal time is incremented by ∆t, and the application suspends execution until that time is reached.  Timestamps, if present, are not used to order delivery of the messages.  All messages are delivered RO and are assumed to be relevant for NOW (the current wall-clock time). This method of execution has the benefit of providing regular, periodic state updates.  Such a method is appropriate for a visualization routine, where each cycle yields a new frame in the animation.  There are a few drawbacks to this approach, however.  In order to ensure that a queue of incoming events does not grow, the application must normally flush the incoming event (message) queue in each cycle.  Since the intervals are fixed at ∆t length, all processing must be completed in ∆t time.  However, variance in the number of incoming messages and other factors in the computation may increase the time spent in each processing cycle.  Therefore, ∆t must be at least as large as the longest total time that can be spent processing.  The difference between ∆t and the actual time spent during a cycle is called the slack time.  This is shown in Figure 1.  The existence of positive slack time in each cycle ensures that the simulation time is able to stay correctly synchronized with wall clock time.  If the cycle takes longer than ∆t, then simulation time will lag wall-clock time.  The no-wait, or time-sampled model is designed to post updates as quickly as possible.  It may be appropriate when response time of the system to any input is the most important factor in the design.  It permits synchronization to WCT without the requirement for slack time.  We can find examples of this type of system in human-in-the-loop simulators.  For this model, the processing cycle may include the same basic functions as in time stepped.  The difference is how simulation time is advanced.  In the no-wait model, the current value of wall-clock time is sampled to determine the new simulation time. Messages are again processed in receive order, and are assumed to be relevant for NOW.  Notice that in this model there is no need for slack time, because variance in processing time is accounted for each time the wall-clock time is sampled.Real-Time Scheduled ExecutionScheduled execution of processes is available in operating systems with real-time features.  Outside the distributed simulation community, distributed real-time computing commonly involves scheduling remote and local events with real-time execution constraints.   In this model, all processing is scheduled to be completed by a specified deadline.  In a simulation system, a logical process (LP) can schedule processing for itself or for another LP.  Messages to remote LPs are simply one class of remotely scheduled processing.  Most current simulation systems do not employ such a methodology, but it is this paradigm that offers the most significant change to the state of the art in real-time distributed simulation. Note that both the time-stepped and time-sampled execution models are easily implemented in a scheduled execution environment.  For time-stepped behavior, a process would simply schedule itself for periodic execution.  For a time-sampled execution model, the process would re-schedule itself for immediate execution upon completion of the current computation.A scheduled execution model in a distributed simulation implies deadlines for message delivery and places restrictions on the processing of RTI services. We could additionally place real-time requirements on the entire federation execution.  This would effectively require that federate and RTI processes be scheduled independently, ensuring federate, RTI, and federation deadlines were all met.   Hard Real-Time Federation ExecutionHard real-time execution implies that meeting a deadline is an absolute requirement for correctness in the simulation system. For a hard real-time federate, this constraint could be applied to any one of the execution models above.  A hard real-time federation, on the other hand, must also meet execution deadlines for federation-level, distributed processes.  This new model for federation execution necessitates that RTI processes execute in real-time.Most real-time simulation systems consider the network or simulation infrastructure to be a system boundary.  This design is certainly the simplest way to connect real-time simulators, but many other paradigms are possible.   If we extend the real-time model to include the RTI, we can develop additional temporal constraints for the RTI, permitting greater control over the entire execution.  We can easily understand how we might develop service timing bounds similar to those currently available in the tick() call to regulate RTI overhead. We can also easily understand how we might take advantage of bounds to message delivery delay, even in RO processing.  But we also may wish to place other real-time constraints on RTI services, or even make the RTI operate asynchronously, acting as a distributed real-time scheduler.  Prerequisites for HRT ExecutionTo develop hard real-time federation level concepts, we must place some restrictions on the larger execution environment.  For this paper, we assume two key conditions.  First, we assume a network quality-of-service (QoS) guaranteed latency bound.  Secondly, we assume a single ubiquitous WCT, observable to within some bounded skew in any part of the system.  We intuitively observe that any notion of distributed deadlines is predicated on both conditions holding.In order to meet hard real-time execution requirements, the execution environment must be able to guarantee an upper bound to communication latency.  This requirement is obvious when we consider that, in order to schedule a remote process with a hard real-time deadline, the message that conveys the processing request must be received by some earlier deadline. Thus, the network must provide a system-wide latency guarantee or be capable of negotiating latency QoS between communicating processors.  In practice, most commodity networks do not provide QoS.  An exception is ATM, which does provide some level of control over latency.  However, cluster-computing environments can allow for bounded latencies when utilized somewhat below their bandwidth limits.  For near-term HRT RTI research, we expect to used closed, cluster-computing resources to ensure communication latency bounds.In order to make processing deadlines apply to the federation globally, we must assume that processes share a common notion of real-time.   This “common clock” is not an absolute system requirement for all federates; some processors may elect to execute as-fast-as-possible (AFAP).  As long as the AFAP federates are capable of executing faster than real-time, a global relationship between federation simulation time and WCT can be maintained, and the federation can be said to execute in real-time.  However, for simplicity in this paper, we assume that all processes are executing using some RT model, and therefore are individually managing a relationship between federate simulation time, and (local) WCT.  Therefore, in order to provide real-time (HRT) deadlines in such a distributed simulation environment, a common notion of WCT is necessary to ensure that deadlines are meaningful throughout the distributed execution. When both the notion of ubiquitous wall-clock time and QoS are available, then a HRT distributed simulation environment may be realized.  Addressing Limitations of RT-DS ExecutionWhen addressing the problem of real-time distributed execution, one immediately becomes aware of the limitations of the communications network.  Because of network latency, and the tendency of RT simulators to send messages that are relevant “NOW” (with so-called “zero lookahead”), we find that the recipients of the messages must therefore always be receiving late information.  The amount of latency encountered determines the lateness of the message.  This differs from traditional time-managed simulations, where the correctness of the simulation execution is dependent upon processing a message when simulation time equals the message time-stamp (hence the notion of being “granted” to a specific simulation time).  Existing Work in Dead-Reckoning The lateness problem has been partially addressed in the determination of various algorithms for dead-reckoning.  The problem is exacerbated when closely coupled interactions occur between entities where the physical (network) latency is much greater than the modeled time-line for interaction.  A canonical example of a closely coupled interaction is a missile intercept.  As the missile moves ever closer to the target, the interaction between the missile guidance system and the target must occur at a faster rate.  The required interaction rate will eventually exceed the limits of the network. Dead-reckoning and smoothing techniques are not always able to produce an acceptable representation of the modeled system.  Transfer of ControlIn cases where mathematical techniques cannot mitigate message lateness, it is important to understand the limits of the physical system and factor them into the design simulation execution model.  In the case of the missile intercept, it may be necessary, for example, to transfer control of the missile end-game to a computer which is physically closer to the host of the target federate.   This allows the modeled entities to interact over a shorter physical distance, (possibly) reducing the latency. Although we must deal with the limitations of the communications network in any simulation system, they do not, as one might infer, preclude a real time approach.  In particular, we may define a constant relationship between a message delivery time and WCT, such that a message will be delivered by a certain deadline.  In this situation, we actually may be able to execute in real-time, using a time-managed approach.  This approach was used very successfully in previous research to induce repeatability in RT simulations  REF _Ref395699059 \r \h [3].  One of the by-products of this research was an observation that in many LAN-based situations, Real-Time Time-Management was entirely plausible. Using Virtual Timestamps In the afore mentioned research, message ordering in RT is accomplished by choosing a deadline sufficiently far in the future so as to ensure message arrival at the recipient prior to the expiration.  This deadline is specified by a timestamp, TS, for the message.  In choosing a timestamp for each message, we might intuitively assign the sending federates’ simulation time.  However, we observed from the time-stepped model of execution that it is likely that most messages will not be delivered until the expiration of a time step.  If we define a reasonably long time-step, (say 3 to 5 milliseconds) then we can ensure message delays have no detectable impact on simulation execution.The additional delay gives the RTI time to order the packets for delivery.  We thus define virtual latency to be the interval, on a virtual time scale, between the transmission of a message by some federate and its earliest delivery at some other federate.  Conceptually, this artificial latency corresponds to virtual lookahead for the simulation.  The timestamp for each message can be simply assigned the sum of the virtual latency and current local virtual time of the sender.TSn = VLij + LVTiIf this assignment and ordering is done in the RTI, federates can continue to operate as if the messages are sent and received in receive order.  This approach was shown to work in  REF _Ref395699059 \r \h [3] even without the benefit of a QoS network.  The RTI was able to induce a real-time, repeatable execution using this virtual time management technique, and maintain a constant relationship between wall-clock time and virtual time.RT  RTInfrastructure A system of software for repeatable real-time executions, referred to as the Repeatable RTI  (RRTI) was developed to exploit the virtual time management concepts, above.  The implementation is based on the Georgia Tech Federation Developers Kit (FDK) and produces real-time, repeatable executions in LAN and cluster environments.  Subsequent to profiling the federation, an application programmer uses the RRTI in the same manner that one would use an RTI for RO (DIS-style) processing.  Use of the RRTI does not require extensive code modifications to existing RT federates.  Basic calls to the HLA RTI such as join(), publish(), sendInteraction(), UpdateObjectAttributes() and tick() behave identically in the RRTI compared to the original RTI.  The repeatability work showed the viability of a real-time execution, even in time-managed federations.  Moreover, because of the constant relationship between simulation time and WCT, the execution confirmed that hard real-time deadlines could be met.  These somewhat unexpected results led us to broaden and generalize the application of hard real-time constraints to HLA simulation.Towards Hard Real-Time In on-going research, the PADS group (directed by Dr. Richard Fujimoto) at Georgia Tech has begun redesigning the communications layer of RTI-Kit in order to realize the first iteration of a hard real-time HLA RTI.  Our work so far involves moving from synchronous to asynchronous message delivery and developing techniques for real-time time management.Asynchronous CommunicationIn previous versions of RTI-Kit, network communication occurred synchronously; messages were received directly from the communications hardware (the wire) at the request of higher layers (usually during the tick() call).  However, this method requires the federate to pass control to RTI in order to service the wire, which makes message delivery time, and RTI response time, inherently unpredictable.   Asynchronous communication provides the RTI with the ability to execute without interaction between it and the federate.  The RTI-Kit MCAST module is responsible for providing subscription-based group communication.  In recent work by Brad Fitzgibbons, a graduate student and member of the PADS group, MCAST has been redesigned to work with ECho, a more flexible and powerful communications library developed by other researchers at Georgia Tech. ECho is a collection of libraries that provides interfaces for network messaging and group communication  REF _Ref395698961 \r \h [9].  It currently supports communication over TCP but is being extended to support additional transports (e.g., ATM and Reliable UDP) and QoS guarantees.  ECho executes on multiple platforms including Linux, many other UNIX-based systems, and Microsoft Windows.  Echo has powerful utilities to mitigate architectural differences in communication between any of the supported platforms.As the RT implementation evolves, additional RTI services will register message handlers with MCAST to transition from deferred message handling to completely asynchronous execution of RTI processes.  Other RTI-Kit libraries such as the TM-Kit will be able to process messages without requiring the federate to give control to the RTI. As additional transports and QoS negotiation features are added to ECho we will extend the MCAST implementation and the RTI services to exploit the enhancements.  HRT Impact on Message Delay Even without QoS or modifications to communications services, message delays (the effective latency) are not significantly increased if time management services are used carefully.  As explained above, message delay is the amount of wall-clock time that elapses between the time a message is sent and when it is delivered to the LP.  In a time-stepped execution model, a message will not be delivered until the WCT reaches the next step and flushes the incoming message list.  This is illustrated in Figure 3, above.  Since the message may be queued, waiting to be delivered, the best comparison metric is not a measurement of network latency, but rather a more practical latency-to-delivery.  Figure 4 compares the real-time and receive order message delay results for a (quiet) TCP LAN.  The results show the effect of decreasing delta-t on average message delay.  We can also see the effect that virtual latency has on the message delay.  As we reduce delta-t for the receive-order runs (RO) we see a corresponding reduction in message delay.  For the real-time runs, when delta-t is large compared to virtual latency, the reductions in delta-t also have a corresponding effect on message delay.  However, as delta-t decreases, message delay is bound from below by the value of virtual latency.  The high-level interpretation of these results is that an embedded, hard real-time delivery service will have a negligible effect on the message delay, while providing the benefits of regular, predictable execution.Overhead of Time Management in the RRTIIn time-stepped execution model, the simulation application assumes that all processing and OS overhead for each cycle will not take longer than delta t.  This defines the “bounds of imposable load” due to RT message delivery.  If after imposing a load, the simulation can execute at the desired rate (no missed deadlines), the solution is appropriate.  Else, the "wait" period must be increased, which implies that the time step interval will need to be increased.   The dominant source of overhead in the RRTI implementation is the time required for LBTS computation and TSO message delivery.  This is accounted for in the RRTI tick() method. When we examine RRTI overhead as a percentage of delta-t, (Figure 5) we can see that for this simulation, the  time management overhead for delta-t less than 5ms will produce missed deadlines on every cycle (TCP).  This means that the execution will slow down to accommodate the time management, and will not be able to run in real-time.  However, for Myrinet, a delta t of 2.5 ms was found to be acceptable, causing relatively few missed deadlines.Broadly, this means that we were able to execute using synchronized, real-time time-steps equating to greater than 100 Hz for TCP and 400 Hz using Myrinet.  During the execution, the message delivery deadlines were met, and execution (in this case) was repeatable.  These results were quite unexpected to some colleagues who presumed HLA overhead to be too great for efficient distributed time-management. RT-LBTS workAnother area which we are actively exploring is the possibility of managing simulation time in real-time.  The work is motivated by previous research in real-time repeatable simulation in  REF _Ref395699059 \r \h [3].  The repeatability research showed the viability of managing a virtual time clock, but the results were dependent on accurate measurements of the amount of time required to execute various tasks (code blocks). The most unpredictable RTI service (in terms of timeliness) is the tick() call. Current RTI implementations use the tick() call as a catch-all for managing internal RTI state.  Apart from administrative functions, the most significant source of overhead in tick() is simulation time management.  The central computation in time management is a distributed reduction operation to determine a lower-bound timestamp (LBTS), also known as global virtual time.  The process of computing LBTS is a distributed reduction that cannot generally be guaranteed to complete within a bounded time because of two factors: 1) it depends on the participation of all other federates in the execution, 2) transient messages cause an LBTS computation to be aborted. Current research in RT-LBTS is exploring how to compute LBTS in bounded time with a level of computational overhead that is appropriate for a RT execution.  Secondarily, this research is exploring ways to ensure that LBTS will always permit delivery of messages in real-time, thereby meeting our HRT goal.  Using our previously stated assumptions, we have modified an LBTS reduction algorithm to exploit the latency bound and preclude transient messages.  Notice that a transient message cannot occur if it is sent with a delivery guarantee prior to the beginning of an LBTS computation.  Also, since our RTI is executing asynchronously, we can use the real-time clock to schedule LBTS computations at a common time.  Thus, each of the Local RTI Components (LRCs) participating in an LBTS computation can rendezvous in real-time, reliably and efficiently completing the reduction.Preliminary results from performance tests indicate, as we would expect, that synchronized LBTS computations are significantly more efficient than an unsynchronized LBTS computation.  Figure 6 shows execution results for an experiment conducted using a test federate with synchronized, and unsynchronized LBTS computations.  For this experiment the federation was run for 30 seconds of simulation time in a very coarsely synchronized cluster of Linux workstations, using TCP over gigabit Ethernet.  The LBTS overhead factor is a ratio of real-time spent in the computation of LBTS to total simulation execution time. The apparent advantages of synchronized LBTS computations, even in this rough experimental configuration, encourage us to explore the possibility that HRT Time Management Services could be a better way to meet difficult real-time integration challenges such as HWITL simulations or live test-ranges. Need for Real-Time Extensions to HLAThe potential benefits of a HRT RTI cannot be fully realized if we are limited to the existing IFSpec.  Additional RTI configuration data or vendor-supplied specifications are needed for designing and executing in a HRT environment.  The HLA does not include an execution model for real-time simulation.  The HLA IFSpec does not provide sufficient detail to construct a real-time synchronization model.  The communications transport and ordering parameters are not sufficient for mapping federation requirements into RTI performance requirements.  Depending on federation goals, several types of extensions might be appropriate to address issues including: Extending RTI delivery specification to support QoS requestsFor real-time delivery assurances, the RTI should be able to determine a QoS requirement prior to sending updates or interactions.  Using the current IFSpec, the RTI could use federate lookahead as a starting point.  However, this quantity applies to any outgoing message.  A better mechanism would allow the RTI to determine a range of QoS requirements based upon publisher-subscriber (producer-consumer) pairs.  This would allow the RTI to manage delivery requirements across individual links, optimizing network utilization.    Specifying timeliness requirements for RTI and Federate Ambassador callsAs mentioned earlier, except for tick() (or invokeCallbacks(), in the IEEE 1516) the RTI IFSpec is silent regarding the requirements for RTI responsiveness.  Even the minimum and maximum time values for tick() are labeled as approximations (specifiable to at least 1 millisecond) with no absolute assurances.  Practically, this makes it difficult or impossible to schedule RTI service calls to meet real-time deadlines.  An alternative to specifying timeliness for RTI Ambassador calls might be to have each federate specify timeliness data for the Federate Ambassador calls.  Using this configuration data a HRT RTI could act as a scheduler for federate processes. Providing real-time synchronization requirements for RTI Service processingIt is interesting to note that many RTI services are not synchronized with the management of simulation time as noted in  REF _Ref395702540 \r \h [8].  This can result in non-deterministic execution even for non-real-time, conservative, time-managed federations!   By stipulating RTI service requirements relative to the progress of simulation time, a HRT federation is able to deduce HRT RTI processing deadlines as well.  Specifying RTI behavior in this way could be extremely valuable for test and evaluation or other environments where reproducibility of an execution is an important requirement.Specifying real-time simulation execution modelsAfter many years of integrating real-time and interactive distributed simulation systems, the distributed simulation community has not mastered basic problems of interoperability.  By developing general and well-understood models for real-time simulation execution, we can begin to formally specify correctness criteria for real-time federations.  Specifying real-time simulation execution models for HLA may allow the next generation of RTIs to resolve integration difficulties we face today.Benefits of Hard Real-TimeA hard real-time HLA RTI will provide time-bounded services, and those bounds will be well-known to the simulation developer.  This provides the developer with additional control over simulation behavior.  It will also facilitate the design of more credible virtual environments in which relationships between real-time events are deterministic.A HRT RTI will promote HLA use in test and evaluation.  Precise specification of simulation behavior and execution requirements can allow repeatable simulation execution, a first step in providing credible simulation execution environments for testing.  Hard real-time execution can provide more realistic virtual environments.  By specifying correct real-time behavior temporal anomalies can be avoided.  Causal anomalies can be predicted or mitigated explicitly, because they are detectable if not avoidable.  Accounting for temporal and causal anomalies can make simulation based training much more effective than in current, non time-managed environments.Finally, specification of HRT execution can permit more effective use of communication and processing resources. As illustrated in the simple RT-LBTS experiment, a HRT simulation execution environment can reduce overall RTI overhead.  Efficiencies in RTI may translate to greater scalability or fidelity in HRT environments.Conclusion and Future WorkIn this paper we suggest a more robust paradigm for hard real-time HLA-based simulation.  Using the RTI-Kit, a modular RTI construction set, we presented results on repeatability in real-time simulations, and preliminary work on RTI enhancements to support hard real-time federation execution.  Current work has focused on implementation of asynchronous communications and real-time LBTS computations.  We expect that these RTI enhancements will provide significant benefits in designing real-time HLA federations. Future work will extend the communications module to manage QoS guarantees for the federation.  Using communications assurances, and some facilities of real-time operating systems, we expect to make progress toward a HRT RTI.This research will raise additional questions regarding paradigms for real-time simulation systems.  We expect to confront significant challenges in finding efficient scheduling algorithms for communication and processing that best meet simulation execution requirements.  We also expect to uncover additional complexities in managing HRT execution.  For example, in allowing federation specification of latency bounds, the RTI may have to account for federation execution requirements that violate the physical constraints of the system (e.g., the requested latency is not physically possible). We expect the area of hard real-time simulation to provide a rich set of research topics.  By developing and exploring new paradigms for hard real-time execution, we see real-time simulation as an increasingly important and credible tool for training, engineering, and research. ReferencesDefense Modeling and Simulation Office, High Level Architecture Interface Specification, Version 1.3. 1998: Washington D.C.Fujimoto, R. et al, Design of High-performance RTI software, in Proceedings of Distributed Simulations and Real-time Applications, August 2000 (DIS-RT-2000)McLean, T. and R. Fujimoto, Repeatability in Real-Time Distributed Simulation Executions, in Proceedings of the 14th Workshop on Parallel and Distributed Simulation, 2000.Fujimoto, R.M. and P. Hoare, HLA RTI Performance in High Speed LAN Environments, in Proceedings of the Fall Simulation Interoperability Workshop. 1998: Orlando, FL.Ferenci, S. and R.M. Fujimoto, RTI Performance on Shared Memory and Message Passing Architectures, in Proceedings of the 1999 Spring Simulation Interoperability Workshop. 1999: Orlando, FL.Lamport, L., Time, Clocks, and the Ordering of Events in a Distributed System, Communications of the ACM, 21, 7, pgs. 558-565, July 1978.Dorsch, M., and V.  Skowronski, Modifying the RTI for Active Networks, in Proceedings of the Spring Simulation Interoperability Workshop. 2001: Orlando, FL. p. Paper 01S-SIW-007.Tacic, I. and R.M. Fujimoto, Synchronized Data Distribution Management in Distributed Simulations, in Proceedings of the 12th Workshop on Parallel and Distributed Simulation. 1998.Eisenhauer, G., The ECho Event Delivery System, http://www.cc.gatech.edu/systems/projects/ECho, 2000ReferencesShen, K. and S. Gregory, "Instant Replay Debugging of Concurrent Logic  Programs," New Generation Computing, 14(1), pp. 79-107, January 1996.. Fujimoto, R. M.  "Parallel Discrete Event Simulation," Communications of the ACM, vol. 33, pp. October 1990, 1990.LeBlanc T. J. and J. M. Mellor-Crummey, "Debugging Parallel Programs with Instant Replay," IEEE Transactions on Computers, vol. C-36, pp. 471-481, 1987.Reinhardt, S. K., M. D. Hill, J. R. Laurus, A. R. Lebeck, J. C. Lewis, and D. A. Wood, "The Wisconsin Wind Tunnel: Virtual Prototyping of Parallel Computers," ACM Sigmetric, 1993.Fujimoto, R. M., "Zero Lookahead and Repeatability in the High Level Architecture," .Author BiographiesDr. ANGUS L. M. THOM McLEAN is a Senior Research Scientist at the Georgia Tech Research Institute.  He has several years experience in Naval Aviation, Simulation and Training, and Distributed Simulation Systems.  He is currently pursuing research interests in large-scale real-time distributed simulation, splitting his time between the Parallel and Distributed Simulation (PADS) research group in the College of Computing, and the Distributed Simulation Systems (DSS) group in GTRI.  He has authored several papers for SIW and other Simulation fora.    There is one exception:  The tick() call takes optional parameters to specify the minimum and maximum time that the RTI should spend before returning from tick().  This is a soft requirement, however, and the reference clock for the parameter is not specified.Figure  SEQ Figure \* ARABIC 1 - Time-Stepped ExecutionFigure  SEQ Figure \* ARABIC 6 - RT-LBTS Overhead ResultsFigure  SEQ Figure \* ARABIC 2 - MCAST ModificationsFigure  SEQ Figure \* ARABIC 3Figure  SEQ Figure \* ARABIC 5Figure  SEQ Figure \* ARABIC 4 - Delivering Messages