HLA/RTI Integration with a Smalltalk Discrete Event SimulationDavid P. CedelDr. Ron PainterCACI, Inc1600 Wilson Blvd, Ste 1300Arlington, VA  22209703-558-0xxx, 703-558-0xxx HYPERLINK mailto:dcedel@caci.com dcedel@caci.com,  HYPERLINK mailto:rpainter@caci.com rpainter@caci.comKeywords:High Level Architecture, Run-Time InfrastructureABSTRACT: The Prophet Simulation Test Bed provides a scaleable and extensible simulation foundation to support Simulation Based Acquisition (SBA) for the Division Tactical Unmanned Aerial Vehicle (TUAV) Signals Intelligence (SIGINT) Payload (DTSP). Written almost entirely in Smalltalk using the JWARS architectural framework and intended from the start to be distributed using HLA/RTI, the PROPHET simulation has had to address multiple architectural and performance challenges. This paper is a brief discussion of these challenges and our solutions. Topics covered include: the interface of Smalltalk to the RTI, the higher level integration of a purely object oriented system with the RTI object/interaction management layer, and the integration of a discrete event based simulation with the RTI time management facilities.    In particular, the Smalltalk programming language provides a purely object oriented environment that facilitates discrete event simulation development. Unfortunately, the integration of this rigorously composition and interaction based environment with the data publishing environment provided by the HLA/RTI requires the resolution of a substantial impedance mismatch. This paper describes how the powerful meta-programming facilities present in Smalltalk were used to associate RTI classes and structures with abstractions native to the Smalltalk environment, integrate RTI time management into the local discrete event simulation framework, and mesh RTI events with local simulation events.1. IntroductionThe Prophet Simulation Test Bed (PSimTB) is an engineering level signals-intelligence simulation built on the Smalltalk discrete event simulation framework utilized by JWARS. The JWARS framework provides common discrete event simulation artifacts, but does not address one of the primary architectural directives of the PSimTB simulation: distribution using the HLA/RTI. The PSimTB ‘s contribution to the JWARS framework, which will be reincorporated and made available to other simulations using the framework, is the integration of the framework with the Smalltalk HLA/RTI binding (SHRB) in what we call the Smalltalk HLA/RTI layer (SHRL). This work was performed under contract to the U.S. Army CERDEC Intelligence and Information Warfare Directorate.2. Architecture OverviewA general overview of the resulting architecture is shown in Figure 2.1. The SHRL will be the focus of this discussion. It provides JWARS framework layer functionality with simple object oriented HLA/RTI abstractions by encapsulating HLA/RTI federation, time, declaration, object, and ownership management functionality in ways natural to the Smalltalk environment. These abstractions carry out direct communications with RTI services through the Smalltalk HLA/RTI binding (SHRB). EMBED Word.Picture.8  Figure 2.1 - General Architecture2.1 JWARS FrameworkThe standard services required by discrete event simulations are included in the basic JWARS framework. These services include: an event manager and event queue combination allowing the scheduling and execution of simulation events, two different classes of simulation events with accompanying trigger and execution functionality and optional persistence abstractions allowing communication with relational and flat file databases.2.2 Smalltalk HLA/RTI BindingThe SHRB serves the same purpose for Smalltalk that the DMSO supported Java binding does for Java. Using Smalltalk’s built-in cross-language communication classes (allow translation between Smalltalk structures and C or C++ structures, maintenance of operating system pointers in Smalltalk, invocation of native C or C++ functions, etc.) the SHRB exposes the standard RTI interface available in C++ to Smalltalk.3. Smalltalk HLA/RTI LayerThe SHRL is distinct from the SHRB in its integration of the basic RTI services into the JWARS framework and is best explained by describing how it exposes those services (Federation, Time, Declaration, Object, Ownership, and Data Distribution Management) in the context of the JWARS framework. 3.1 Federation ManagementEach simulation in the JWARS framework inherits from a common simulation system class, which is essentially a collection of high-level simulation objects. The system initializes, prepares and launches the simulation objects (which comprise the simulation itself). The system also cleans up, terminates and kills the simulation objects. Figures 3.1 and 3.2 demonstrate the two levels of JWARS framework simulation system that the SHRL modifies: Basic and Discrete Event. An instance of the RTI ambassador class provided by the SHRB is added by the SHRL to the simulation system (See Figure 3.3). The creation and joining of a federation are carried out by the RTI ambassador instance during its launch sequence. After joining the federation, the RTI ambassador instance blocks for synchronization on an initial synch point. During this hold, each simulation system is told to create its initial object class instances and enable its time management (the exact mechanism is described later). When the initial synchronization point is announced and all simulation systems synchronize, simulation execution continues.Figure 3.1 - Basic SHRL Simulation SystemFigure 3.2 – Discrete Event SHRL Simulation SystemFigure 3.3 - RTI Ambassador Hierarchy and CompositionAn instance of a SHRL implementation of the abstract federate ambassador class provided by the SHRB is also included in the simulation system (See Figure 3.4). While not specific to federation management in particular, it is during initialization, preparation and launching that this instance is first referenced. This subclass encapsulates callback and callback content specific semaphores and exposes an interface for blocking simulation process on expected RTI callbacks. Even SHRL code is relieved of its federate ambassador callback flag-based loops (See Figure 3.5).Figure 3.4 – Federate Ambassador Hierarchy and CompositionFigure 3.5 – Initial Synch Using Federate Ambassador Semaphores3.2 Time ManagementThe event execution loop in the JWARS framework operates in an instance of the event manager class as follows:While events are in the event queue:Get the next event.Update the executing time to the time of the next event.Execute the next event.Events are ordered and executed by time stamp, with events of the same time stamp being executed based first on internal priority and finally on order of schedule.The SHRL modifies the event manager to request time advances from the RTI using the next event request protocol and interleave incoming timed HLA/RTI events as local events in the local event queue. The event loop then operates as follows:While events are in the event queue:Is the time of the next event equal to my RTI time?Yes.Get the next event.Update the executing time to the time of the next event.Execute the event.No.Execute a next event request for the time of the next event.This loop has the effect of pushing the RTI time forward to the time of the next event. When the RTI time is equal to the time of the next event, no other RTI events will arrive at or before that time, and the next event is executed. Note that the execution of a next event request may result in a grant to (and events at) a time earlier than the requested time.3.3 Declaration ManagementIn the JWARS framework simulation objects are created simply as Smalltalk objects. The introduction of a system like the HLA/RTI requires that events like the internal creation of a new instance or the external modification of an existing instance be captured and passed explicitly to or from the RTI. Rather than put the burden of HLA/RTI awareness into the domain code, the SHRL provides a framework for declaring publication and subscription intent and Smalltalk object class to HLA/RTI construct mappings.3.3.1 Interaction ClassesInside of SHRL, each HLA/RTI interaction has a corresponding Smalltalk class in a hierarchy under an abstract Smalltalk interaction class (See Figure 3.6). This super class provides a class instance side protocol that each subclass must override to define: RTI name, RTI parameters and RTI parameter definitions. The super class also provides class instance side variables for maintaining RTI run-time information such as RTI handle. Note that because the class side structures used to maintain Smalltalk to RTI mapping information are class instance based, Smalltalk interaction classes can exist in hierarchies just as they do in the HLA/RTI object model. Figure 3.6 – Interaction Class Hierarchy and CompositionA sample mapping definition would appear as follows:initializeRtiParameters	super initializeRtiParameters.	self 		addRtiParameter: 'EmitterId'			forInstanceVariable: 'emitterId'			valueClass: String;		addRtiParameter: 'TrueAzimuth'			forInstanceVariable: 'trueAzimuth'			valueClass: OSFloat32;		addRtiParameter: 'AdjustedSignalToNoise'			forInstanceVariable:				 'adjustedSignalToNoise'			valueClass: OSFloat64Once defined, SHRL requires that each simulation system register the Smalltalk interaction classes it will publish and subscribe by overriding special methods it inherits from its parent simulation system class. These methods are called at launch time by an instance of a Smalltalk interaction handler class (See Figure 3.7), which notifies the specified Smalltalk interaction classes to register themselves and their parameters and maintains references to them for later publishing or receipt of HLA/RTI interactions. A sample subscription method would appear as follows:subscribeInteractionClassNames	^super subscribeInteractionClassNames		add: SignalReport;		yourselfFFigure 3.7 – Interaction Handler Hierarchy and Composition3.3.2 Object ClassesObject classes are treated much like interactions by the SHRL. Like interaction classes, each HLA/RTI object class also has a corresponding Smalltalk class in a hierarchy under an abstract Smalltalk object super class (See Figure 3.8), and this super class also provides a class instance side protocol for defining Smalltalk to HLA/RTI mapping information. Unlike HLA/RTI interaction classes, federates may subscribe to just a subset of available HLA/RTI object attributes. To accommodate this, it has become customary to define a single SHRL Smalltalk object class including mappings for all available attributes. Simulation systems needing only a subset of the available attributes define Smalltalk subclasses that remove unneeded attributes from the super class’s list. Figure 3.8 - Object Class Hierarchy and CompositionA sample mapping definition for a Smalltalk object class would appear as follows:initializeRtiAttributes	super initializeRtiAttributes.	self		addRtiAttribute: 'UnitId'			forInstanceVariable: 'unitId'			valueClass: String;		addRtiAttribute: 'EmitterStatus'			forInstanceVariable: '		emitterStatus'			valueClass: String;		addRtiAttribute: 'TotalAltitude'			forInstanceVariable: 		'totalAltitude'			valueClass: OSFloat64;		addRtiAttribute: 'AssignedFrequency'			forInstanceVariable: 			'assignedFrequency' 			valueClass: OSFloat32 EMBED Word.Picture.8  Figure 3.9 – Object Handler Hierarchy and CompositionLike interaction classes, the SHRL also requires that each simulation system register the Smalltalk object classes it will publish and subscribe, along with which attributes it intends to use. Again, an instance of a Smalltalk handler class (See Figure 3.9) calls the subscription and publication methods, notifies the Smalltalk classes to register themselves and their attributes, makes the actual publish and subscribe HLA/RTI calls, and maintains references to the Smalltalk object classes for later use (See Figures 3.10 and 3.11). Figure 3.10 – Object Handler Class PublicationFigure 3.11– Object Handler Class SubscriptionA sample publication method would appear as follows:publishObjectsClassNames	^super publishObjectClassNames		add: Receiver;		add: Antenna;		add: ReceiverFrequencyBand;		yourself3.4 Object ManagementOnce established, the subscription and publication intent and Smalltalk interaction and object classes mappings are combined with Smalltalk’s inherent reflective capabilities to allow the SHRL to carry all of the HLA/RTI operations necessary without the involvement of domain code. In the JWARS framework, instances are created and modified as usual. At the Smalltalk meta-language level, notification of these changes is passed transparently to and from the HLA/RTI by the SHRL.3.4.1 Interaction ClassesThe creation and publication of an HLA/RTI interaction through the SHRL is as simple as creating a Smalltalk object. Each HLA/RTI interaction class has a corresponding Smalltalk class which is instantiated, populated as any other object and sent the message ‘send.’ Class side functionality the Smalltalk class inherits from the abstract Smalltalk interaction super class captures the creation of the instance, translates the instance’s relevant state into serialized byte arrays, builds HLA/RTI specific collections and publishes the interaction though the current simulation system’s RTI ambassador instance (See Figure 3.12). The creation of an interaction would appear in domain code as follows:SignalReport new	signalToNoise: 0.36;	emitterType: $B;	azimuth: 32;	sendFigure 3.12 – Interaction Instance PublicationThe receipt of a published interaction begins in the current JWARS framework simulation system’s federate ambassador instance, which passes the incoming information to the interaction handler instance. The interaction handler passes the information on the interaction to the Smalltalk class corresponding to the incoming interaction, which instantiates the interaction, populates the new instance and invokes the ‘receive’ method on the new instance (See Figure 3.13). It is in the ‘receive’ method that references to domain functionality associated with the receipt of the interaction are included. Varying reactions to the same interaction by different federates can be accommodated using extensions or specializations of the Smalltalk interaction class. Figure 3.13 – Interaction Instance ReceiptThe SHRL also provides two subclasses of the abstract Smalltalk interaction class that combine to form a two-way communication. Using a request registration mechanism in the invocation handler, sending a request and waiting for a response can be handled cleanly, using future objects and the semaphore mechanism provided by the SHRL federate ambassador, outside of domain code. The publication of a request would appear in the sending domain code as follows:^(GLOSBetweenObjectsRequest new	sourceLocation: aSourceLocation;	targetLocation: aTargetLocation;	send)		value losStatus3.4.2 Object ClassesThe creation and updating of HLAR/RTI objects using the SHRL is also as simple as creating and working with Smalltalk domain objects. When any subclass of the abstract Smalltalk object class is instantiated, it is assigned a unique identifier, added to a table in the object handler and registered with the RTI. Consecutive updates to any HLA/RTI relevant attributes on that instance are captured, and later notification to publish causes these attributes to translated into serialized byte arrays, added to HLA/RTI specific collections and published through the current JWARS framework simulation system’s RTI ambassador instance (See Figure 3.14). Figure 3.14 – Object Instance UpdateThe combined creation and publication of an object would appear in domain code as follows:Antenna new	antennaId: #'A1';	platformId: #'P1';	length: 3;	updateFurther updates to this object would only require sending it additional ‘update’ messages, although the SHRL does include additional methods in the abstract Smalltalk object class’s instance side update protocol that allow the forced (modified or not) update of any subset of attributes. The receipt of a new HLA/RTI instance in the SHRL is initiated in the current JWARS framework simulation system’s federate ambassador instance. The new instance is registered under RTI handle and RTI id in its corresponding Smalltalk object class through the object handler. The update of an existing instance also begins in the federate ambassador. The object handler receives the incoming information and passes it on to the corresponding Smalltalk object class.  The Smalltalk object class then un-serializes the update content and applies it to the identified instance (See Figure 3.15). However, the receipt of instance creations and updates requires more than just the behind-the-scenes mechanics of the SHRL; the domain functionality must have notification, or callbacks, of these events. In the SHRL, the creation of a callback requires only the override of the necessary class side abstract Smalltalk object class method with needed domain behavior.Figure 3.15 – Object Instance Update ReceiptAn instance creation, or discover instance, callback might appear as follows:receiveNewWithRtiHandle: objectHandle named: aString	| emitter |	emitter :=		super			receiveNewWithRtiHandle: objectHandle				named: aString.	self addEmitter: emitter.	^instanceThe call to the same method in the abstract Smalltalk object super class returns a reference to the newly instantiated object. The domain code can then carry out whatever domain specific initializations and actions are necessary.An instance update, or attribute update, callback might appear as follows:receiveUpdateForObjectNamed: aString withAttributes: aLookupTable	| emitter |	emitter :=		super	receiveUpdateForObjectNamed: aString		withAttributes: aLookupTable.	self insertInstrumentForObject: emitter.	^instanceThe call to the same method in the abstract Smalltalk object super class also returns a reference to the identified object instance. In combination with the collection of updated attributes and values, the domain code has complete information about this update and can again carry out any necessary domain specific operations.3.5 Ownership ManagementOwnership management is accomplished predominantly in the SHRL on the instance side. Each instance of a subclass of the abstract Smalltalk object super class inherits both a modification and ownership table. The modification table maintains a Boolean indicating modification status for every attribute. The ownership table maintains a Boolean indicating ownership status for every attribute. The state of these two tables is used to automate the construction of an update: when told to update, an instance will construct and send an update composed of those attributes contained in the intersection of the modified attributes table and the owned attributes table. Note that, as in the HLA/RTI, initial ownership of an attribute lies squarely with the creating simulation system, or federate.Changes of ownership require ‘request ownership’ message sends to object instances. These calls are similar to update calls and appear as follows:anEmitter requestOwnership: (Array with: 'emitterStatus')The default SHRL handling of ownership requests is passive: any request for ownership will be met with an ownership grant. The process consists of looking up the identified instance, updating the instance’s ownership table and issuing an ownership grant through the current simulation system’s RTI ambassador instance. As a consequence of the passive nature of the SHRL’s ownership scheme, the receipt and processing of an ownership request can be carried out without the direct involvement of the domain code. However, any ownership behavior beyond the default can be accomplished through the domain code override of the default abstract Smalltalk object super class’s ownership methods. 3.6 Data Distribution ManagementData distribution management is not currently included in the SHRL. Simulation systems that require data filtering currently provide it themselves in SHRL system overrides.4.0 Recent Changes to SHRLInitially, all federates built with the SHRL were written in Smalltalk under the JWARS framework and used non-standard serializing routines to pass native Smalltalk objects through the RTI. To allow for communication with other HLA/RTI federates, standard base type, complex data type and enumerated data type serializing routines have been added.The default behavior in the SHRL event manager moves forward its HLA/RTI time using the next event request method. A new, optimized SHRL event manager allows a federate participating in a federation where it is receiving many interactions or updates but does not need to take any HLA/RTI specific actions based on them to employ the time advance request method instead. Because no HLA/RTI messages will result from the processing of the interactions or object updates, they can effectively be grouped and processed based purely on the federate’s local event progression. 5.0 Plans for the FuturePlans for improvement to the SHRL include:Layer specific exception definition and handling. Currently, certain RTI level exceptions bubble up through the SHRL code into domain code. It would be helpful to provide a clean set of SHRL exceptions to the domain level functionality.Data distribution management integration. A mechanism for the definition of DDM ranges in the SHRL would allow filtering code currently resident in the domain level functionality to be re-positioned to the SHRL.Class attribute integration. Currently, no functionality in the SHRL provides domain level functionality access to object class attributes. Predictably, their positioning in the framework will be on the class side of the Smalltalk object classes, with access being granted through message sends to the class.Removal of HLA/RTI mappings from the SHRL Smalltalk object and interaction subclasses. To free these subclasses to make use of other domain specific inheritance hierarchies (and other architectural mechanisms like a generalized persistence framework), the mapping information now included in the SHRL subclasses could be moved into extensions or separate mapping objects which would be used by the handlers to convert to and from the HLA/RTI. 6.0 ConclusionThe SHRL provides HLA/RTI functionality to the JWARS discrete event system framework by negotiating the boundary between the HLA/RTI specific SHRB and the Smalltalk based JWARS framework. Making extensive use of Smalltalk’s reflective capabilities, the SHRL is able to bridge this boundary in a straightforward, object-oriented and domain transparent way, integrating HLA/RTI federation, time, declaration, object and ownership services seamlessly into the JWARS framework.Author BiographiesDAVID CEDEL is a Senior Software Engineer for CACI, Inc.  He has participated in the design and implementation of the JWARS and Prophet Simulation Testbed simulation architectures. He is the designer and implementer of the Smalltalk HLA/RTI Layer.RON PAINTER is Chief Scientist for Modeling and Simulation for CACI, Inc. He is the technical lead for the JWARS project responsible for the architectural design and implementation of JWARS. He is the developer of the architecture for the Coast Guard Search and Rescue Simulation (SARSIM) and provided technical guidance in both the domain expertise and simulation artifacts for the Prophet Simulation Testbed. Dr. Painter developed a generalized simulation architecture and system, SimMaster(, in SIMSCRIPT II.5( which has been used to develop a wide range of military simulations. Dr. Painter has a PhD in Theoretical Solid State Physics.