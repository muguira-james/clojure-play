From FOMs to BOMs and Back AgainTram ChasePaul Gustavson Lawrence M. RootSimVentions11903 Bowman Drive, Suite 102Fredericksburg, VA 22408(540) 372-7727 HYPERLINK "mailto:tchase@simventions.com" tchase@simventions.com HYPERLINK "mailto:pgustavson@simventions.com" pgustavson@simventions.com HYPERLINK "mailto:lroot@simventions.com" lroot@simventions.comKeywords:Components, Composability, Interoperability, Computability, Base Object Models (BOMs), Reuse, FOM, HLAABSTRACT: With the advent of the High Level Architecture (HLA) and the Federation Object Model (FOM), simulations have made great strides in becoming more interoperable. However, there are shortcomings that still make building simulations more cumbersome and tedious than is necessary. Maintaining, customizing, and reusing FOMs are just some of the challenges that simulation developers face today.The Base Object Model (BOM) attempts to solve some of these issues. By breaking a FOM into the smaller more manageable BOMs, the once monolithic FOM becomes easier to manipulate. For example, the simulation designer can tinker with any of the individual BOMs while not breaking elements in the other BOMs. A user may also have different BOMs that represent various levels of functionality and these BOMs could be swapped in and out depending upon the simulation requirements.These BOMs can be combined into what is called a BOM Assembly, which is a BOM containing references to the original BOMs. Finally, the BOM Assembly can be transformed into agile FOMs. While this process may seem intimidating, the use of tools such as BOMworks, has helped simplify this task. This paper describes the progression required for breaking down a FOM into independent BOMs and then assembling them back again.1. IntroductionSimulations have become increasingly more complex due in large part to a growing desire for truer realism and an increased need to model a greater number of entities and events that are representative of a joint warfare environment. The capability to support these needs is often expected to be easily met because we are witness to the constant proliferation of improved computational resources (e.g., processing power, network speed) and we have followed the evolution of interoperability standards, such as eXtensible Markup Language (XML) and the High Level Architecture (HLA). However, despite our advancements in the areas of computability and interoperability, it is often our ability to develop, integrate, and deliver models and the simulations that use such models that is impaired and encumbered. This is referred to as composability.Composability is defined within the Department of Defense (DoD) Modeling and Simulation (M&S) Master Plan as “the ability to rapidly select and assemble components to construct meaningful simulation systems to satisfy specific user requirements. Composability includes the framework, body of knowledge, tools, techniques, and standards necessary to enable effective integration, interoperability, and reuse.”While we may understand what composability is supposed to be, history has shown that we have not adequately achieved composability across the M&S community. Arguably, this composability deficiency has limited our ability to effectively compute and interoperate. However, if we can improve upon the aspect of composability, then the aspects of computability and interoperability become even less encumbered and likely even greater enablers in supporting our M&S needs.  1.1 The Encumbered Interoperability of the HLAWithin the HLA framework, syntactic interoperability among simulations is achieved through the use of the Runtime Infrastructure (RTI) and Federation Object Models (FOMs). The RTI handles the exchange of data between simulations based on each simulation’s publicized capabilities, which are documented in the FOM. The FOM identifies the object classes and interaction classes that have been agreed to be shared among the simulations and serves as the semantic interface for interoperability among HLA simulations.While the FOM approach allows simulation engineers to be precise in defining the model information to be exchanged among simulations and systems, there are many shortcomings to the FOM approach. For example, if one federate requires even a small change in the FOM, all of the other federates must then adapt and apply the updated FOM. Likewise, adding a new simulation with new capabilities to the federation will require either a new FOM to be built, or a new capability to be added to an existing FOM. The result is that users are forced to maintain either a multitude of different FOMs for their simulation, or must manage one overloaded FOM, which only gets more arduous and complex when new capabilities are added. Certainly our FOM development and management efforts have proven to help reach and maintain a level of interoperability, but at a high cost and with limited success. Aspects of the high cost factor include the time and effort in building and managing FOMs; the time and effort in coordinating, communicating, and compromising with other simulation engineers and the time and effort it takes to configure and adapt simulation to various FOMs. These hurdles can take their toll among individuals and organizations causing discouragement, perhaps frustration, and may often lead to failed success at achieving interoperability. However, these hurdles could be reduced significantly if FOMs were more easily composable, and simulations themselves could be configured and extended by the supporting components that were assembled to formulate the composed FOM. In fact, theoretically, interoperability could be even more attainable if composability was a key attribute of the HLA.  1.2 Composability in PracticeThis concept of composability, which is desired for M&S, has been solved in several other markets and domains including the software development community. Instead of developing applications from scratch and rewriting code that has already been written, developers use components with well understood interfaces to build and compose applications. For instance, programmers can grab a button from a tool palette and drag it onto a form canvas representing the graphical user interface (GUI) of their application. The action of clicking on that button can be assigned to invoke functionality that may be contained in a Dynamic Link Library (DLL). Now suppose a new DLL is found, with the same interface that improves upon the previous functionality, the developer simply assigns the button to invoke the new DLL method. Both the button and DLL are software components in this example.  What is common is the interface between the button and the DLL.Now take this approach of being able to update and extend an application through the use of components and apply it to the HLA -- specifically the FOM. Consider that if a FOM could be broken into parts that are more manageable and interchangeable, users could build simulation representations in the same way developers build applications. This is the idea behind the Base Object Model (BOM).2. BOM BasicsBefore diving into how BOMs can support composability for HLA, it is important to understand BOM basics.  A BOM is defined as “a piece part of a conceptual model, simulation object model, or federation object model, which can be used as a building block in the development and/or extension of a simulation or federation.”Essentially, a BOM piece part serves to represent a component. Within M&S, the concept of components has been defined as follows:Reusable building blocks which have a known set of inputs and provide expected output behavior, but the implementation details may be hidden.  Such components are useful for constructing simulations and/or providing functionality for simulation systems.In the case of BOMs, the focus is on describing the interface for a component, not the implementation details. It is essentially the responsibility of the simulation to provide the implementation or behavior that is described by the interface. This behavior can be captured internally, by its own code, or by component implementations, such as a Windows DLL, a Unix Object, or in other ways such as the Simulation Reference Markup Language (SRML). Thus, a BOM reflects a language-neutral interface that identifies the essential elements provided by a component or piece part.This separation of interface from implementation allows BOMs to serve as building blocks for supporting composability. This includes the composition of HLA object models, federate capabilities, and/or federation agreements regardless of the hardware platform, operating system, or programming language required of a participating federate. The basic components of a BOM, which provide the framework to support this type of composition, are identified in Figure 2.1.Figure 2.1 – BOM ElementsOne of the benefits of BOMs is the ability to capture a pattern of interplay among conceptual entities. This is accomplished in the Pattern of Interplay portion of the BOM. The Pattern of Interplay is composed of a collection of actions that describe the events that transpire among the conceptual entities being modeled. These events are messages or triggers that have been included in the Event Types section of the BOM; likewise the conceptual entities are captured in the Entity Types. The Pattern of Interplay actions also contain a sender and receiver property that allows the BOM user to denote which conceptual entities the event occurs between. Another advantage of the BOM is the ability to capture the states of the conceptual entities, which is done in the State Machine section. The events that initiate a transition from state to state are also noted in the state machine.The BOM elements that have been explained thus far have been used to describe the conceptual model. Like the FOM, the BOM contains an object model definition. The elements are leveraged from the HLA Object Model Template (OMT); this includes the object classes and attributes, interaction classes and parameters, and data types. While the OMT elements are used, not all fields in the tables may be applicable to a BOM as the BOM was built to be HLA friendly but not dependent on the use of HLA.Finally, the Model Mapping elements provide a bridge between the conceptual model information and the object model definition. Users can map entities and events to the classes that will fulfill the behavior needs described in the Pattern of Interplay. If a BOM exists that describes an interface to a model, whether it be an object class, pattern of interplay, or state machine, and that model appears to support the required objectives for the federate or federation, it would be sensible to use that existing model instead of repeating the development process; that is recreating it. Furthermore, such a BOM could provide use history and other related metadata that would assist in the selection process.3. FOM to BOMThe process of decomposing an existing FOM starts with a functional analysis to determine how to break up the FOM. This may be considered the most difficult part of the process. Typically someone familiar with the simulation and FOM is required. For this paper, the Real-Time Platform Reference (RPR) FOM will be used as an example due to its widespread use. There are two aspects of the RPR FOM that can be separated, the object classes and the interaction classes. 3.1 Object RepresentationIn the case of the RPR FOM, breaking up the object classes is somewhat intuitive. The class names do a good job of representing the associated functional area. For instance, there are eight classes at the root listed below.ActiveSonarBeamBaseEntityEmbeddedSystemEmitterBeamEnvironmentObjectEnvironmentProcessGriddedDataMinefieldWith some analysis, it makes sense to group these classes as follows.ActiveSonarBeamEmbeddedSystemEmitterBeam---------------------------------------BaseEntity---------------------------------------EnvironmentObjectEnvironmentProcessGriddedData---------------------------------------MinefieldThe result of our analysis produces four groupings, that can be supported by a BOM:Entity ObjectsBaseEntitySignal ObjectsEmbeddedSystemActiveSonarBeamEmitterBeamEnvironment ObjectsEnvironmentObjectEnvironmentProcessGriddedDataMinefieldMinefieldNote that this is only one way of grouping the object classes. They could be broken down further to help isolate areas that are constantly changing for easier maintenance. For example, the BaseEntity classes could be further broken down based upon domain such as land, sea, or air. Once the groups have been decided upon, BOMs must be created that contain the classes, associated attributes, data types, and notes as represented in Figure 3.1. Figure 3.1 – Object Class BOMWith the help of a tool, this process can be automated to allow drag/drop or cut/copy/paste of classes from a FOM (1.3 or 1516) to a BOM. The tool would automatically populate the BOM with the needed attributes, data types, and notes.The object class table is shown in Figure 3.2 along with the current breakdown of the object classes into our four groupings: Entity Objects, Signal Objects, Environment Objects, and Minefield Objects.  Figure 3.2 – RPR FOM Object Class TableEach of the groupings illustrated can be supported by a BOM. 3.2 Behavior RepresentationThe interaction classes of the RPR FOM, provide insight into understanding the Behavior Representation. However, breaking down the interaction classes into a set of behavior representations takes a little more work than breaking down object classes into a set of object representations. Instead of creating general groups, the interactions are grouped by event sequences. As stated earlier, familiarity with the simulation and FOM is necessary. In the case of the RPR FOM, there is a guidance document, the GRIM[4], which helps to explain the functions of the classes. It also helps that the RPR FOM is based on the Distributed Interactive Simulation (DIS) standards[5] which can be used to understand the sequences of events and states supported by the interaction classes. The DIS standards provide a clear presentation of various protocol data unit (PDU) families. This presentation, identified in the list below, provides a clear context for identifying the Behavior Representations for our RPR BOMs.Entity State UpdateWeapons EffectsCollisionSimulation Management (SIMAN)Radio CommunicationMinefieldSynthetic EnvironmentBy examining the GRIM reference, it is learned that a Weapons Effects is carried out through the use of two interaction classes, WeaponsFire and MunitionDetonation. A pattern of interplay is developed between two generic conceptual entities, which can be visually depicted in the following sequence diagram, Figure 3.3. Figure 3.3 - Weapons FireNote that the states of the conceptual entities have also been annotated in the diagram; these can also be captured in the BOM. Unlike the object class BOM described previously, the interaction class BOM contains more than just classes. This is where we document the conceptual model, starting with a pattern of interplay that describes the events that occur, in this case a WeaponsFire pattern. It also contains conceptual entities (Firing Entity and Target Entity) and their states. The necessary interaction classes (WeaponFire and MunitionDetonation) and the associated parameters, data types, and notes are placed in the object model definition elements. The DamageStateUpdate is handled by an EntityStateUpdate and actually is described in another BOM and referenced in this BOM. Since the EntityStateUpdate BOM is used often, it makes sense to create it as a standalone BOM and reference it when needed. The model mapping section is populated as well; it contains references to the object classes that will fulfill the behavior needed by the Firing Entity and Target Entity and maps the events to interaction classes contained in the BOM. In this case, it would contain a reference to the EntityObjects BOM that was created earlier. Thus, the populated elements of the interaction class BOM are illustrated in Figure 3.4.Figure 3.4 – Interaction Class BOMAfter grouping the objects and interactions, a BOM-based RPR FOM can be represented by 12 RPR BOMs. The 12 RPR BOMs are identified in the dark blue box illustrated in Figure 3.5.  SHAPE  \* MERGEFORMAT Figure 3.5 – RPR BOMsNote that a BOM could contain multiple patterns of interplay, for instance, the SIMAN BOM in the figure contains six patterns of interplay. In our case, it made sense to group them in one BOM. The result, however, is that BOMs can now be managed individually. If a federate participates in multiple federations that use different WeaponsFire scenarios, only different WeaponsEffect BOMs need to be maintained and swapped in and out as necessary.4. BOM to FOMWhile BOMs may be used to maintain independent object models, there still may be a need to use a FOM for the simulations of a federation. This can be accomplished by combining the BOMs that support what needs to be represented into what is called a BOM Assembly. A BOM Assembly is a BOM that contains references to other BOMs, as shown in Figure 4.1. In our case, an RPR BOM Assembly would contain references to all of the BOMs we just created. These references are located in the Pattern of Interplay element of the BOM Assembly. These references point to the patterns of interplay in the RPR BOMs.Once a BOM Assembly has been constructed it can be exported to a FOM. This would be a time consuming task by hand but with the help of Extensible Stylesheet Language Transformations (XSLT) and tools such as BOMworks, it is possible to export a BOM Assembly to either 1.3 or 1516 FOMs with a few mouse clicks. The key is to follow all the references and populate a FOM with theFigure 4.1 – BOM Assemblyreferenced object classes, interaction classes, attributes, parameters, and data types. Once built, the referenced BOMs (Interaction or Object) can be changed but the BOM Assembly can be left alone re-exported resulting in a new FOM including any changes. Adding or removing BOMs would cause the BOM Assembly to be modified while having no effect on the other BOMs.There are two notable side effects of this process. The first is that when a FOM is broken down into BOMs, you may be able to eliminate unnecessary elements that were just carried along to avoid creating a new FOM. Likewise, building the BOM Assembly and exporting it back into a FOM with the use of automation will cause only the needed data types and notes to be exported into the FOM. This is a way of “cleaning” a FOM. The second side effect is dependent upon the tool capabilities but the process could be used to convert between different versions of FOMs. For example, a user could break a 1.3 FOM down into BOMs, create a BOM Assembly, and then export a 1516 FOM. Note that this process would have the same shortcomings as any automatic conversion between FOM standards such as entries that don’t exist in one or the other version.5. SummaryWe have identified the importance of composability within the M&S community. We have stated that interoperability and computability can be more easily achieved through composability. The end result is the reduction of time and effort it takes to develop, integrate and deliver models and functional simulations. We’ve shown how BOMs can serve as a viable composability commodity, which support the HLA framework. This exploration of M&S composability has included the process of decomposing a FOM into more manageable BOMs, and rapidly assembling those BOMs back into a FOM. We have described how this resulting BOM-based FOM can be more easily extended, modified, and integrated by simulations that must use it.  At the Fall 2005 Simulation Interoperability Workshop (SIW), an attendee of a BOM tutorial, which was titled “Achieving Composability with Base Object models (BOMs)” summed it up best by stating after the tutorial, “what BOMs provide is a capability that we haven’t seen since DIS in that it allows manageable pieces of simulation interoperability to be developed, integrated, and tested independently, much like the DIS PDUs, and provides a context for understanding how it all connects together.”  In summary, the clear benefits from this BOM approach include the following:Supporting composability by allowing BOMs to be combined to represent federates and federationsProviding extensibility of FOMs through the application and integration of new BOMsSupporting the exchangeability of one BOM for anotherFacilitating better manageability of BOMs by enabling team development through distribution of responsibilities, and providing a mechanism needed for configuration management and unit testingProviding a means of “cleaning” a FOM by breaking it down and then rebuilding it, only necessary classes and data types will be carried forwardProviding an indirect way of transforming between different OMT specification versions (1.3 and 1516)Additional InformationAdditional information and downloadable material on BOMS can be found on the Base Object Model Specification Information website at  HYPERLINK "http://www.boms.info" www.boms.info.References[1]	IEEE 1516.2-2000, “High Level Architecture (HLA) Object Model Template (OMT) Specification.”[2]	SISO, “BOM Template Specification – Volume I, Version 0.12 (draft),” October 2005.[3]	Gustavson, Chase, “RPR BOM Initiative: Providing a Set of Applicable BOMs to the M&S Community,” 05S-SIW-088.[4]	SISO, “Guidance, Rationale, and Interoperability Modalities for the Real-time Platform Reference Federation Object Model (FOM) – Version 1.0,” 10 September 1999.[5]	IEEE 1278.1A-1998, “Standard for Distributed Interactive Simulation - Application Protocols.”Author BiographiesTRAM CHASE is a software engineer at SimVentions, Inc. (http://www.simventions.com) and is focused on the development and integration of technology for creating innovative and engaging experiences and solutions. He has recently worked on the development of a BOM tool called BOMworks™ which performs much of the automation discussed in this paper. Tram is a graduate of Virginia Tech, with a B.S. in Mathematics (1994), and has supported a wide variety of M&S and system engineering efforts within the DoD. Tram lives in Virginia with his wife and son.PAUL GUSTAVSON is a co-founder and Chief Technology Officer of SimVentions, Inc. (http://www.simventions.com) and is focused on the development and integration of technology for creating innovative and engaging experiences and solutions. Paul is a graduate of Old Dominion University, with a B.S. in Computer Engineering (1989), and has supported a wide variety of M&S, system engineering, web technology and mobile computing efforts within the DoD and software development communities. He is a principal author of “C++ Builder 6 Developer’s Guide,” and contributor to other books and articles. He has presented at numerous conferences. He is also a long-time advocate and pioneer of the Base Object Model (BOM) concept for enabling simulation composability, interoperability and reuse. Paul lives in Virginia with his wife and two boys.LAWRENCE M. ROOT is co-founder of SimVentions, Inc. (http://www.simventions.com) and has been involved in the broader M&S community since the onset of HLA. Larry has over 20 years of real-time tactical software and system engineering experience supporting Navy C4I combat systems and related analysis. Most recently he has been involved in assisting the Navy in shifting its tactical combat system development paradigm from the current platform-centric approach to a battleforce-centric approach that supports and encourages the development of composable components that span missions and platforms. As such, he supports the Navy’s contributions to Single Integrated Air Picture (SIAP), Force System Engineering Council (FSEC), and Open Architecture (OA). He has published several papers within SISO and is currently the Chair for SISO’s BOM Product Development Group (PDG).