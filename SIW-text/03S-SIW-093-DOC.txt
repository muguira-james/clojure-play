OneSAF Repository Framework: Defining, Storing and Interchanging XML DataBoaventura DaCostaDynamics Research Corporation3505 Lake Lynda Drive, Suite 100Orlando, FL 32817407-380-1200bdacosta@drc.comTim Lucas, Robin OutarScience Applications International Corporation12901 Science DriveOrlando, FL 32826-3014407-235-7637, 407-235-7660 tlucas@ideorlando.org, routar@ideorlando.orgDoug HeltonLockheed Martin Corporation12506 East Lake Underhill RoadOrlando, FL 32825407-235-7728dhelton@ideorlando.orgKeywords:Modeling and Simulation, M&S, One Semi-Automated Forces Objective System, OneSAF, OOS, eXtensible Markup Language, XML, Configuration Management, CM, distribution, synchronization, notificationABSTRACT: The One Semi-Automated Forces (OneSAF) Objective System (OOS) Data Architecture has embraced eXtensible Markup Language (XML) as its data interchange format. As a result, XML is being used as the language to define, store, and interchange data and meta-data both within OneSAF and between simulations. This paper describes the Repositories Framework, which provides a mechanism in which to manage both XML and binary files in a distributed manner across multiple hosts that support simulations. The OneSAF Repository Services will be discussed, including the configuration management, distribution, and notification mechanisms being employed.1. IntroductionSince its release by the World Wide Web Consortium (W3C) in 1998, eXtensible Markup Language (XML) has grown into a universal vehicle in which to structure documents and data via the Web.  Today, a number of commercial XML-enabled and XML-native products have been marketed providing everything from databases, to text-based repository search engines. Some of these products have even been made available as open-source and royalty-free.Today, simulations are taking advantage of XML. The One Semi-Automated Forces (OneSAF) Objective System (OOS) has embraced XML as its data interchange format. The OneSAF Data Architecture utilizes XML as its vehicle to define, store, and interchange data and meta-data both internally and between simulations.This paper describes the OneSAF Data Architecture. In particular, if focuses on the Repositories Framework, which provides a mechanism in which to manage a number of different file formats, including XML, gifs, pngs, text files, property files, and proprietary binary files in a distributed manner across multiple hosts that support simulations. The System Repository Services will be discussed including the configuration management, distribution, and notification mechanisms that are employed.This paper attempts to discuss as much of the Repositories Framework as possible. In some instances features of the framework such as how data files are indexed, how searching is performed, and how the tagging of data for classification and release-ability occurs could only briefly be touched upon. 2.0 OneSAF Repositories FrameworkOneSAF is a next-generation Computer Generated Forces (CGF) simulation that can represent a full range of operations, systems, and control processes from individual combatant level and platform level to fully automated BLUFOR battalion level and fully automated OPFOR brigade level. OneSAF is composed of a set of products as opposed to a single system or application. Each of these products consists of a set of interacting components, composers, and tools. These components provide overlapping functionality, which meet the various OOS system compositions [1].  REF _Ref29449676 \h  \* MERGEFORMAT Figure 1 shows version 16 of the OneSAF Product Line Architecture Framework (PLAF). INCLUDEPICTURE "https://www.onesaf.net/Architecture_and_Integration/SystemsEngineering/SystemArchitecture/PLAF/EPLAF/Graphics/plaf.jpg" \* MERGEFORMATINET Figure  SEQ Figure \* ARABIC 1: OneSAF Product Line Architecture Framework (PLAF) Version 16 [2]The PLAF is a mechanism to organize, categorize, and define the layered software structure to incrementally meet the OneSAF requirements. From the PLAF, a static view of the System Compositions, Products, and Components that compromise the OneSAF Architecture can be seen. For example, the Repository Manager is a OneSAF product that is composed of two components, the Data Management Tool (DMT) and the Information Security Utility (ISU). In addition, the PLAF identifies functionally, particularly the software components that can be used as building blocks for higher-level functionality [2]. Once fielded, OneSAF will be utilized across the three Army modeling and simulation domains of Advanced Concepts and Requirements (ACR), Training, Exercises, and Military Operations (TEMO), and Research, Development, and Acquisition (RDA) [3].XML is an intricate part of the OneSAF Data Architecture. It is used predominately as a data interchange format (DIF) so that data and meta-data can be defined, stored, exchanged, and shared both within OneSAF and between other simulations. The Repositories Framework, part of the OneSAF Component Support Layer (seen in the PLAF as the System Repository Services), was conceived to support the OneSAF Data Architecture and to provide services in which to manage XML, binary, and the other data file formats supported by OneSAF in a distributed manner.The OneSAF Repositories Framework is composed of System Repository Services (SRS), which provide a uniform mechanism to create and manage both local and remote repository data and meta-data across all OneSAF Products and Components. These SRS are accessible by OneSAF Products and Components in order to work with data stored in the OneSAF Repositories.  REF _Ref30834404 \h Figure 2 depicts this. INCLUDEPICTURE "https://www.onesaf.net/Architecture_and_Integration/SystemsEngineering/SystemArchitecture/PLAF/EPLAF/SupportLayer/system_repository_services_context.jpg" \* MERGEFORMATINET Figure  SEQ Figure \* ARABIC 2: OneSAF System Repository Services [4]The data services provided by the SRS act as an Application Programming interface (API) to the OneSAF Repositories. Products and components that want to access data and meta-data housed in the OneSAF Repositories must do so through these data services. A number of services are available, including security data services. (The Security Data Services provide mechanisms to search and sort on data and meta-data based on classification and release-ability tags. These can also filter data and meta-data based on user access privileges.)The SRS can be decomposed into two types, domain-neutral core services and value-added data services. Core services provide primitive data services and access to data and meta-data. Examples of core services are reading and writing of XML, binary, and the other data file formats mentioned in this paper. Value-added data services on the other hand provide domain-specific APIs to particular data representations, such as the consistent access to common data produced and used by several components. For example, common access to Simulation Scenario data stored as XML data files is provided by a Simulation Scenario Development Language (SSDL) API. This API provides a common interface to this information and relies on underlying core services to access and store XML data [4].OneSAF data and meta-data are stored in repositories. These repositories are electronic storage mechanisms that keep all the information, data, and meta-data for one logical area pertaining to OneSAF. The OneSAF Repositories utilize a file-based system. Data is stored in XML, binary, and other data file formats. There are seven (7) logical areas. These are the Software Repository (CVS), Knowledge Acquisition/Knowledge Engineering (KA/KE) Repository, System Composition Repository (SCR), Military Scenario Repository (MSR), Environment Repository (ER), Parametric and Initialization Repository (PAIR), and the Simulation Output Repository (SOR). (The Software Repository is referenced to in OneSAF documentation as CVS. As it will be discussed later in this paper, CVS is also an application used to configuration manage data and meta-data both during OneSAF development and as part of the fielded OOS. To avoid confusion, the term “CVS” will be used only to reference the CVS application. When referring to the repository, the term “Software Repository” will be used.) Each of these repositories houses a specific-kind of data. The following is a brief description of each:The Software Repository contains all the data and meta-data created during the OneSAF Software Development Phase. This includes all analysis, design, code and test, configuration management, and version control information. All the Software Models and Infrastructure source code is housed here [5].The KA/KE Repository contains all the data and meta-data captured during the Knowledge Acquisition and Knowledge Engineering phases. This includes all descriptions of doctrinal behaviors, units, entities, and equipment characteristic and performance data [6]. The System Composition Repository contains all data and meta-data associated with the many OneSAF System Compositions. This repository also houses independent executables and meta-data specific to versioned releases of OneSAF configuration products [7].The Military Scenario Repository houses all data and meta-data associated with Military Scenarios, including data and meta-data for the military units involved [8]. The Environment Repository houses all OneSAF data and meta-data associated with the synthetic natural environment, including source data necessary to construct OneSAF environment runtime databases as well as the compiled runtime environment databases themselves [9]. The PAIR stores all non-environment data and meta-data required by the OneSAF simulation during runtime, including all data and meta-data associated with the units, entities, behavior models, compositions of these items, and simulation scenarios to support the Military Scenario requirements. In addition, the PAIR includes local Characteristics and Performance Documents, User Accounts and Privileges, Unit Primitive List, Physical Model Primitive List, Platform Primitive List, Behavior Primitive List, Unit Template, Platform Template, Behavior Template, and the Simulation Scenario with Data-Collection Specification documents [10].The Simulation Output Repository contains all data and meta-data associated with the output of an OneSAF execution. This repository houses the Data Log, System Assessment, Checkpoint, Replay Visualization Files, and Analysis Product documents [11].  The Software and KA/KE Repository have special constraints based on developmental use within the OneSAF program. The remaining repositories are considered data repositories and are treated uniformly, accessible only via the SRS. Data and meta-data housed in these data repositories is predominately XML. The data repositories are managed so that they remain consistent and valid for use within OneSAF. Each repository is defined in terms of what information it can contain, when it is accessed during the OneSAF simulation lifecycle, which OneSAF Products access the repository, and which user roles require access [12].The following sections provide a deeper understanding of the OneSAF Repositories Framework, specifically, the SRS.2.1 Abstracting the OneSAF Data Repositories Before delving into the SRS, some basic functionality of the Repository Framework should be discussed. The following sections cover the Repository Abstraction Layer and Repository File API. Both perform vital functions of the Repository Framework, supporting not only the various SRS, but also the most important capabilities of the framework, which are configuration management, synchronization, and notification. In addition, throughout the remainder of this paper, a number of terms are used extensively. For example, the term “client” is used very heavily. A client in this paper refers to OneSAF Products and Components, which interact with the Repositories Framework. This could be components, such as the DMT and ISU. A client is not an end-user interacting with the product or component, but the product and component itself.  In a OneSAF distributed environment, a single computer could be running multiple products and components. A computer in this paper is referred to as a “node”. A node is a single processor or multiple processor computer that may or may not be on a network (depending on whether OneSAF is operating in a distributed or stand-alone manner). Therefore, a single node could be running multiple clients. Also, users of these products and components are referred to as ‘end-users’, and so, an end-user on a node could be accessing or running multiple clients.Lastly, this paper makes an attempt to distinguish between OneSAF Repositories and OneSAF Data Repositories. As discussed earlier in this paper, there is a difference. “OneSAF Data Repositories“ and “data repositories” refers to all repositories excluding the Software and KA/KE Repositories, while “OneSAF Repositories” and “repositories” refers to all the repositories. 2.1.1 Repository Abstraction Layer Each of the OneSAF Data Repositories is physically represented using the Concurrent Versioning System (CVS). Each data repository may be implemented as a single CVS module, maximizing the compose-ability of OneSAF or may be represented in a single CVS module. (See section 3.1 for additional information on the use of CVS.) Each of the data repositories is defined using a file-based structure with directories. To simplify the complexity of each data repository to clients of the framework, a Repository Abstraction Layer has been developed composed of services that support the notion of “sand boxing” or abstracting the physical implementation of the OneSAF Data Repositories. This Repository Abstract Layer shelters clients from having to know the physical paths of the data files in the data repositories. This includes the location of the data repositories themselves. An XML-based property file maps the data repository abstract names to their physical locations and names in the file system. An API is available allowing clients to obtain the physical locations and associated attributes of any OneSAF Repository (data repository or otherwise), simply by specifying the repository name. For example, a client may use the API to find the physical location of the Parametric and Initialization Repository by simply passing in the repository name “PAIR”.    The Repository Abstraction Layer and the associated properties file work in conjunction with the Repositories Framework Configuration Management capabilities (see the section 3.1 for details), and such, the entire file system can be specified as being rooted in a particular CVS module. This provides real value-added services to OneSAF, which has emphasized using the open source model for all software development.  The notion of sub-repositories has also been encapsulated in the framework’s design, which accommodates “virtual” data repositories. As the name implies, sub-repositories exist within the larger data repository sand box. These sub-repositories benefit clients by providing a sandbox view into the parent data repository allow the client to specify if a sub-repository should be configuration-managed. This allows the client to specify sections of a data repository to be referenced as abstractions as well as specify whether or not they should be configuration managed via CVS. They also provide a mechanism to sand box end-users of OneSAF products and components into managing data files in a dedicated location in the data repositories. For example, the Entity Composer component (part of the Model Composer product) could have a special child directory in the PAIR identified in the properties file. This would indicate where all OneSAF Entity related data is stored. The Entity Composer component can then set this location as the root of all entity data, sand boxing end-users into that location forcing them to create, manage, and store entity related data within that sub-directory structure. The File Open, Save, and Save As File menu options would always default to this location as the root of the entity data. End-users would not be able to go outside this directory in the data repository. 2.1.2 Repository File API The processing of data files in the data repositories is performed using the Repository File API. This API extends the Java File (java.io.File) API supplied as part of the Java SDK. The Repository File API performs a number of vital operations all dealing with accessibility to the data and meta-data housed in the data repositories.  First, this API provides support for the Repository Framework integrated Security SRS. These capabilities provide methods to associate data with classification and release-ability meta-data. Individual data files, directories, and entire data repositories can be associated with classifications and release-ability values.  The Repository File API can also tag data files with any meta-data defined by clients of the framework. This meta-data can be anything and any number. This information is stored to be used later by clients, as they desire. This includes the meta-data being used as search criteria in order to locate data at a later date. This API also provides a data file locking mechanism. This mechanism provides clients with a means to lock a data file that has been accessed for write purposes. This locking mechanism was conceived to deal with the complexity of merging multiple XML data files and the problems with later validation (see section 3.1.1 for details). On OneSAF merging is not used to resolve data file collisions. Instead, this data file locking mechanism has been provided, allowing clients to lock data files they have open for write. Only when the client (who originally locked the data file) has released it, can other clients access the data file for write, beginning the process again by locking the data file as well. (This data file locking mechanism has been modeled on how SSH works, by utilizing keys that clients provide. Clients that wish to obtain an exclusive lock on a Repository File have to pass in a key to the lock method; this key can be any string they wish.  This lock is then distributed to other nodes to prevent others clients from editing this data file. To unlock the data file, the same key has to be passed in to the unlock method.  This ensures that the client who locked the data file is also the client who unlocks the data file.) In addition the Repository File API provides interested clients the ability to register themselves to receive notifications of particular events by subscribing to event types. (Section 3.2 discusses this further.)  This registration allows clients to receive messages of changes to data they have vested interest in, providing them with a vehicle in which to take the appropriate actions based on these changes.  Lastly, the biggest value-added services supported by this API are the configuration management of data, synchronization of data across distributed clients and nodes, and the notification of data repository changes. These services are discussed in detail later in this paper. But first, the SRS are discussed. 2.2 System Repository ServicesAs mentioned, the Repositories Framework is composed of services (SRS) providing a uniform mechanism to manage data in the OneSAF Data Repositories. These services exist in the form of APIs.  In particular, these domain-neutral core services provide a means to read, write, copy, and delete all data in the data repositories regardless of file format. Support is provided to handle data stored as XML, binary, and the other data file formats mentioned thus far. The current version of the Repositories Framework provides two (2) ways to read, write, and validate XML data. These are achieved through the Document Object Model (DOM) and the Simple API for XML (SAX). Both are achieved using Xerces version 1.4.3 with current efforts moving towards Xerces 2 [13]. Xerces is an XML parser developed by the Apache Software Foundation. It complies with XML Schema and provides support for DOM level 2 (partial support for level 3) and also supports SAX 2. 2.2.1 Document Object Model System Repository ServiceDOM is the more sophisticated of the two XML data access methods available. DOM provides clients of the framework with a means to update content data, structure, and style of any XML data file.  In addition, it abstracts clients from having to understand and integrate 3rd party parsers. Methods are available to clients providing all functionality for reading, retrieving, and validating Document Object Models. Data retrieval (read) methods have been created to further abstract DOM from the client. A DOM created from parsing an XML data file can be queried by using these data retrieval methods. These methods provide the ability to open, parse, and search an XML data file through the use of search parameters. Clients may also use XPath expressions if they so desire.Once a DOM is retrieved, traversed, and manipulated, it can be easily checked for well-formedness and validity through validation services provided by the framework. Current efforts are moving towards using DOM level 3 for validation, however, since level 3 is still in it’s beta stage, validation is currently performed utilizing SAX. Validation can be performed through the serialization of a DOM and the creation of an input source that the SAX parser interprets. A default SAX handler has been developed to catch and compile errors, returning all validation errors to the client. In addition to these built-in read and validate DOM services, write capabilities have been provided. Clients using DOM can write XML data permanently to disk. Creating a buffered file output stream, which is then passed to an XML Serializer.  Before using the XML Serializer to write out the DOM, however, the format of the output is set so that indentions, comments, and XML declarations can be maintained. Clients simply need to supply the DOM and the full path of the data file in question.2.2.2 Simple API for XML System Repository ServiceSAX has been provided as an alternative to DOM. Not as sophisticated as DOM, the SAX service provides static methods to parse (read) XML data files. There are two methods that are available. One method accepts a path to a data file while the other accepts an input source. SAX uses call back methods when parsing XML data files. To take advantage of this, clients must create content handlers provided through the SAX API. Clients of the framework must extend/implement this class to handle callbacks.Clients may also use the SAX service to validate data files. Methods have been provided for the validation of single data files, directories, and entire data repositories. As for error handling, clients have the option to manage their own, by creating custom error handlers, or may use the default handler provided with the API. Unfortunately, the SAX API does not support the writing of XML data. SAX was intended as a fast means to parse XML data and meta-data. So, the SAX service provided through the Repositories Framework is read-only. This is not a limitation of the framework, but the intended design of the SAX parser itself. 2.2.3 Non-XML System Repository ServicesNot all SRS are XML-centric. The Repositories Framework provides a number of services other than DOM and SAX. These services provide the reading, writing, tagging, and searching of other file types. Examples include the searching for a checkpoint file, which is a binary file and the searching for icon files, by using meta-data associated with the fileThe framework provides the vehicle to access and write data to the data repositories. Examples include the reading, management, and writing of icon images, such as CGD files, or other proprietary binary files such as Microsoft Word documents. These data files are accessed and written in very much the same way as the XML data. These data files are read by creating a Repository File, which returns an abstract pathname to the data file in question. An input stream can then be created to access the data. Since Repository File extends Java File, clients can use the data file to obtain an input stream of any type. Writing this data to the data repositories is also straightforward. The client uses the Repository File to obtain an output stream of any type. Finally, as mentioned, there are services available to search for data files in the data repositories. These data files do not have to be XML in nature, but any data file type.  The search can take different forms. A client can search based on the name of the data file using a defined grammar similar to regular expressions. Clients can also search based on meta-data associated with these data files (as mentioned with the searching of icon files). 3.0 Configuration Management, Notification, and DistributionThis paper has thus far concentrated on the domain-neutral and value-added data services provided as part of the Repositories Framework. Another important aspect of this framework is the seamless configuration management of the data housed in the data repositories and the means in which the framework synchronizes the data in a distributed environment. These services not only keeps all data repositories (possibly housed on multiple nodes) synchronized, but also provides an automated broadcasting service, which notifies all clients and nodes of the changes occurring to both the data and data repository structure. These services are vital to the usability and integrity of the data housed in the OneSAF Data Repositories. Figure 3 depicts how data is configuration managed, synchronized across distributed nodes, and how clients are notified of changes. The subsequent sections discuss these services in greater detail. EMBED PBrush  Figure 3: Repository Framework Configuration Management, Synchronization, and NotificationA client on a node creates an instance of the Repository File API. This API represents a data file or directory in the OneSAF Data Repositories. (This client must have access to a local copy of the OneSAF Data Repositories and must be running a local instance of the Repository Framework) Meanwhile, another client (noted as the remote client in Figure 3) on another node (or quite possibly, the same node) creates and instance of the same data file. (This client must also have access to a local copy of the OneSAF Data Repositories and must be running a local instance of the Repository Framework)The client registers itself with the listener asking to be notified of changes to the data file or directory in question.Meanwhile, the remote client also registers itself with the listener to be notified of changes to the same data file or directory. So, now both clients on either different nodes or possibly the same node have indicated their interest in receiving notifications of changes to the same data file or directory.  The client modifies the data file or directory in some way. The modified data file or directory is then saved to the appropriate local data repository and location. Once this happens, the client invokes the commit change method available via the Repository File API. This action is the starting point for the configuration management and distribution of the modified data file or directory to all remote clients.The Repositories Framework attempts to commit the local change to the CVS Server (which more than likely for performance reasons will be on a separate node). This will only occur if configuration management is enabled for the directory or data file that has been changed. (Keep in mind that the Repository Abstraction Layer provides clients with a means to indicate whether they want data repositories or sub-repositories to be configuration managed.)If the local change is committed successfully to the CVS Server, details of the change are then passed to the distribution services.The distribution services create an event and hands it off to the Broadcast Event Service.The Broadcast Event Service then broadcasts the event to all of its registered listeners. (Step 8 also shows this)If the client that receives the event is also the client who invoked the event, then it will notify all other clients on that node that have registered interest in the data file or directory change. Otherwise, no other action is taken.The broadcast event service distributes the event to all remote listeners as well.Since the remote listener is not the source of the event, it invokes the appropriate CVS command to synchronize its local data repository with the latest changes to the data file or directory. For example, if a data file was updated, then a CVS update command is invoked to get the latest version of the data file from the CVS Server.If the local data repository synchronization is successful, that remote client notifies all the other clients on that node that are interested in the data file or directory change as well.3.1 Configuration Management of DataThe OneSAF Data Repositories store all data and meta-data for the system. Scenario files, configuration information, initialization data, and even source code is stored in these data repositories. Since OneSAF is a data-driven system, loss of a single data file or an invalid edit of any data could prove very costly. As a result, the Repositories Framework employs the capabilities to configuration manage data housed in the data repositories. Configuration management is one of the most important capabilities provided. The Repository Framework utilizes the CVS application as its configuration management solution. CVS is an open-source network-transparent version control application. CVS operates in a client-server environment allowing data to be accessed from any source utilizing an Internet connection. CVS incorporates an unreserved checkout model to version control. In the process, it avoids the artificial conflicts common with exclusive checkout models [14].CVS was chosen as the configuration management system to be incorporated with the OneSAF Data Architecture for a number of reasons. First, CVS stores version information about all data and meta-data it manages, allowing data to be tagged if necessary for later use.  Second, CVS is an open-source solution, allowing OneSAF to make modifications as necessary so that it can fully meet the program’s needs. CVS also allows customization and extension with standard scripts, instead of proprietary, tool-specific languages. Not to mention, it is the dominant Open Source Configuration Management Tool available on the market today. Third, CVS is supported on all major platforms, including all platforms that OneSAF supports.  Fourth, CVS scales well in regards to the volume of changes that may occur against data. This may mean many file changes, many changes within a file and many users changing files. Fifth, CVS does not require special kernel patches or specialized versions of OS tools. Lastly, CVS supports distributed development.Since CVS operates in a client-server mode, end-users wishing to configuration management their data in the OneSAF Data Repositories seamlessly, must operate in this mode as well. In a distributed environment, the Repository Framework requires that there be a centralized CVS Server with each distributed remote client on a node acting as a CVS Client. In this mode of operation, the computer acting as the CVS Server houses the master version of the OneSAF Data Repositories, while each node houses a local checked-out version of the same data repositories. These checked out versions are acquired once a computer has been setup and configured as an OneSAF CVS Client node. (The Data Management Tool (see  REF _Ref29449676 \h Figure 1) is used to gain a local version of the data repositories. It can also be used if a node has been offline for any extended period of time or has suffered from a system crash to re-synchronize itself with the latest data repositories found on the CVS Server.)   The Repositories Framework provides a CVS client class, which encapsulates all the network and file, transfer protocols that CVS uses. This means that each OneSAF client node, must not only act as a CVS client, but must also have the Repositories Framework running on the same node. This includes a checked out version of the master data repositories found on the CVS Server. Since the CVS client class encapsulates all the necessary CVS network and file transfer protocols, configuration management of OneSAF data in the data repositories is completely abstracted away from end-users. The OneSAF Products and Components (see  REF _Ref29449676 \h Figure 1) utilizing the Repositories Framework to manage data simply commit their changes to the data repositories (by invoking the commit method found within Repository File). The Repositories Framework CVS client class performs the configuration management steps necessary.The Repositories Framework uses the jCVS API to handle configuration management. jCVS provides a complete CVS client-server protocol package that allows any Java program to implement the complete suite of CVS operations. jCVS also provides a Swing based client that provides a GUI client for CVS. In addition, jCVS provides a Servlet that allows any Servlet enabled web server to present any CVS repository on the Internet for browsing and download [15]. Version 5.3.2 of the jCVS API is currently in use.All data and meta-data housed in the OneSAF Data Repositories may be configuration managed. Not all data, however, can be configuration managed using the integrated CVS capabilities discussed so far. Most data and meta-data managed in the OneSAF Data Repositories is configuration managed using CVS. However, data such as checkpoint information, simulation output data utilized by After Action Review (AAR) systems, and Environment data such as terrain databases is not. Different rationale has been given to each as to why. In some instances, such as checkpoint information, data that is local to a client computer and is not distributed is not configuration managed. In other instances such as environment, these terrain database are simply too large in size to be adequately configuration managed using the CVS services described. However, all this data can be configuration managed through third-party COTS if end-users so desire. They are not seamlessly performed through the framework, however.To this point, the client-server mode of operation has been discussed. The other mode should be mentioned. OneSAF is capable of operating as a stand-alone simulation as well. Meaning, it can operate on a single node. In this case, the data and meta-data can still be configuration managed. However, both the CVS Server software and CVS client software must be installed and operate on a single node. 3.1.1 Configuration Management of XML DataMost of the data that will be configuration managed will be stored in XML data files. Since XML data files are text-based, committing these data files to configuration management using the CVS client has not been a problem. Updating each nodes local data repository has been, however. This is largely due to the merging processes used by CVS. CVS implements a line-by-line merge when an update command is executed on the local data file. If a single line is added, even if just a hard return, CVS attempts to merge the new line. If a significant update is made, with multiple changes, CVS attempts to merge the entire section. This can be troublesome when dealing with XML, since all XML data files on OneSAF are required to either conform to a DTD (with legacy systems) or XML Schema. In other words, CVS does not understand that the data conforms to a grammar and must validate against a schema. Depending on the merge, the XML data file may be invalid and possibly unparsable using the DOM and SAX services discussed earlier in this paper. In addition, CVS utilizes the greater than character ‘<’ when a merge is questionable. Instead of simply overwriting the data during a merge, CVS will add a line of ‘<’ characters to indicate where the merger occurred. This presents a problem when using XML. (XML uses the ‘<’ to represent the beginning of an open and end tag, such as in the examples <SIW> and </SIW>.) A new line of ‘<’ in an XML data file simple leaves the data invalid and unparsable. Earlier versions of the Repository Framework attempted to correct this merging problem by looking at the output from the CVS Server to determine if a merge error had occurred. Even though it was possible to detect merge errors, it was nearly impossible to correctly fix the XML data file. As a result, the current version of the Repositories Framework avoids this pitfall by first deleting the local copy of the data file and then performing an update against the CVS Server for the latest data file. This ensures each client has the most recent version of the updated data file. In the case where the data file is open for read only, an event is dispatched and the client is notified of the change. (Notification is discussed in the next section.) It would then be the responsibility of any remote clients to acquire the latest data file through a CVS update and reload it for editing.3.2 Synchronization of Distributed DataSynchronization is a by-product of distribution. When data files are distributed to other nodes, the local data repositories on those nodes are now in accord with the CVS Server master data repository. Each client on these nodes is expected to commit their changes to configuration management via method calls in the Repositories Framework. This method commits the data file to configuration management and then initiates a broadcast event. Each instantiation of the Repository Framework on the each node listens for this event. Once the framework receives this broadcasted event, it is checked to see if it was the source of the event. If it was, it will in turn notify the other clients of the change. If it was not the source, it then invokes the appropriate CVS commands to update the local data repository with the one on the CVS Server.3.2 Notification of Repository Data ModificationsOneSAF must be able to operate in both a stand-alone fashion and distributed. In order to keep the various OneSAF nodes local data repositories synchronized with the master CVS Server; the data must be properly distributed. This requires that clients must be notified of changes to data files and or directories so they can act and request the latest information from the CVS Server.OneSAF uses Java’s native event/listener interface for local event notifications. For distributed clients, events are broadcasted over the network. Client who are interested in receiving such events simply have to subscribe to the event type. (The Common Component Layer provides the broadcast event services (see  REF _Ref29449676 \h Figure 1)).In order to abstract broadcast events from the OneSAF clients, the Repositories Framework defines a class that listens for broadcast events. Likewise there is a repository class that generates these events. When data, which is configuration management, is modified and saved to the data repositories, a broadcast event is sent out. When the repository class receives this event, this class invokes the local notification services.This notification mechanism allows clients to be informed when data files are added, edited, copied, or deleted from the OneSAF Data Repositories. This mechanism, very simply, allows client to deal with changes to the data effectively. Without this mechanism, data could be updated at any given instance and clients on possibly remote nodes would have no means to be kept informed of these changes. The result could possibly be multiple client on different nodes each possible housing inconsistent out-of-sync data repositories. This notification mechanism simply informs the client of data changes they have requested to receive. It is then the responsibility of the client to interpret the notification message (change against the data repository) and act accordingly. (Keep in mind that clients will only receive notifications for events they have subscribed to. If they haven’t subscribed to any event types, they will not receive any notifications.)  There are two types of notifications, local and distributed.  The local event is only sent out when local configuration management operations are successful.  This same event is then distributed to other clients, and if those clients are able to bring their local checked out version of the data repositories in sync with the CVS Server version, their clients on the same node are notified.  This approach avoids invalid notifications to client.  If data repositories become seriously out of sync with the master version on the CVS Server due to system failure, an update or new checkout can be performed against an entire data repository to bring the clients on the node up-to-date.Once a client receives a notification, the Repository Framework has already successfully distributed and synchronized the data file or directory in question. Distribution and synchronization occur before notification; else the notification could be invalid. Should an error occur during distribution indicating that the local copy of the data file or directory being synchronized was not updated properly, the notification will not be sent.4.0 Summary	The OneSAF Repositories Framework provides a vehicle for all OneSAF Products and Components to access data and meta-data housed in the OneSAF Data Repositories. In addition to the domain-neutral core and value-added data services provided through the SRS, the framework’s largest contribution is its ability to seamlessly configure manage, synchronize, and notify clients on multiple nodes in a distributed environment. These services provide clients of the framework the ability to manage different types of data and formats (with the most predominant format being XML). Future efforts are focused on the further enhancements of existing services and the development of new value-added services to access and manage data both represented as XML and in binary. GUI OneSAF components and utilities are also scheduled for development providing a graphical interface to the data repository structure allowing clients further flexibility in the access and management of data. In addition, a number of XML performance efforts are underway in an attempt to maximize the use of XML on OneSAF.6.0 References[1]	OneSAF Architecture and Integration (A&I) Task Order. ONESAF product Line Architecture Specification (PLAS) – Volume I: Architecture Overview. Science Applications International Corporation (SAIC), Orlando, FL, September 2002. (Available at https://www.onesaf.net/Architecture_and_Integration/SystemsEngineering/SystemArchitecture/PLAS/OneSAF_PLAS_Volume_I.doc)[2]	OneSAF Architecture and Integration (A&I) Task Order. OneSAF Product Line Architecture Framework (PLAF). OneSAF.net Web site: https://www.onesaf.net/Architecture_and_Integration/SystemsEngineering/SystemArchitecture/PLAF/EPLAF/PLAF.html[3]	Courtemanche, A., and R. Wittmann. OneSAF: A Product Line Approach for a Next-Generation CGF. 11TH-CGF-079, 11th Computer Generated Forces and Behavioral Representation Conference, Orlando, FL, May 2002. (Available at https://www.onesaf.net/Architecture_and_Integration/SystemsEngineering/SystemArchitecture/PLAS/11TH-CGF-079.doc)[4]	OneSAF Architecture and Integration (A&I) Task Order. OneSAF Component Support Layer: System Repository Services. OneSAF.net Web site: https://www.onesaf.net/Architecture_and_Integration/SystemsEngineering/SystemArchitecture/PLAF/EPLAF/SupportLayer/repository_services.jsp[5]	OneSAF Architecture and Integration (A&I) Task Order. OneSAF Repository Component Layer: Software (CVS) Repository. OneSAF.net Web site: https://www.onesaf.net/Architecture_and_Integration/SystemsEngineering/SystemArchitecture/PLAF/EPLAF/RepositoryLayer/sw_repository.html 	[6]	OneSAF Architecture and Integration (A&I) Task Order. OneSAF Repository Component Layer: KA/KE Repository. OneSAF.net Web site: https://www.onesaf.net/Architecture_and_Integration/SystemsEngineering/SystemArchitecture/PLAF/EPLAF/RepositoryLayer/ka_ke_repository.html[7] 	OneSAF Architecture and Integration (A&I) Task Order. OneSAF Repository Component Layer: System Composition Repository. OneSAF.net Web site: https://www.onesaf.net/Architecture_and_Integration/SystemsEngineering/SystemArchitecture/PLAF/EPLAF/RepositoryLayer/system_composition_repository.html[8]	OneSAF Architecture and Integration (A&I) Task Order. OneSAF Repository Component Layer: Military Scenario Repository. OneSAF.net Web site: https://www.onesaf.net/Architecture_and_Integration/SystemsEngineering/SystemArchitecture/PLAF/EPLAF/RepositoryLayer/military_scenario_repository.html[9]	OneSAF Architecture and Integration (A&I) Task Order. OneSAF Repository Component Layer: Environment Repository. OneSAF.net Web site:  https://www.onesaf.net/Architecture_and_Integration/SystemsEngineering/SystemArchitecture/PLAF/EPLAF/RepositoryLayer/environment_repository.html[10]	OneSAF Architecture and Integration (A&I) Task Order. OneSAF Repository Component Layer: Parametric and Initialization Repository. OneSAF.net Web site:  https://www.onesaf.net/Architecture_and_Integration/SystemsEngineering/SystemArchitecture/PLAF/EPLAF/RepositoryLayer/pair_repository.html[11]	OneSAF Architecture and Integration (A&I) Task Order. OneSAF Repository Component Layer: Simulation Output Repository. OneSAF.net Web site:  https://www.onesaf.net/Architecture_and_Integration/SystemsEngineering/SystemArchitecture/PLAF/EPLAF/RepositoryLayer/sim_output_repository.html[12] OneSAF Architecture and Integration (A&I) Task Order. OneSAF PLAF: OneSAF Repository Component Layer. OneSAF.net Web site:  https://www.onesaf.net/Architecture_and_Integration/SystemsEngineering/SystemArchitecture/PLAF/EPLAF/RepositoryLayer/repository_component_layer.html[13]	DaCosta, B., and R. Outar. OneSAF: XML Performance in Simulation. To appear as 03S-SIW-093, 2003 Spring Simulation Interoperability Workshop, Orlando, FL, March 2003.[14] Concurrent Versioning System: The open standard for version control. Concurrent Versioning System Web site:  http://www.cvshome.org/[15] jCVS: Welcome to jCVS.org. jCVS Web site:  http://www.jcvs.org/Author BiographiesBOAVENTURA DACOSTA is a Senior Software Engineer with Dynamics Research Corporation in Orlando, FL. He is leading the data engineering efforts for the OneSAF Object System as the Data Architect and Repository Lead. He received an M.A. in Instructional Systems and B.S in Computer Science from the University of Central Florida.TIMOTHY LUCAS is a Software Engineer with Science Applications International Corporation in Orlando, FL. He has worked in various areas of Software Engineering including data fusion, artificial intelligence, and constructive simulation. He is currently working on XML-based solutions as part of the Repositories team on the OneSAF Objective System. He received a M.S. in Computer and Information Science from the University of Florida and a B.S. in Computer Science from Rensselaer Polytechnic Institute.ROBIN OUTAR is a Software Engineer with Science Applications International Corporation in Orlando, FL.  He has worked on the OneSAF Objective System for two years concentrating most of his efforts on the Configuration Management, Distribution, and Notification mechanisms, which are part of the Repositories Framework.  Additionally, he is involved in the development of the XML related services for the OneSAF Objective System. He received a B.S. in Computer Science from the University of Central Florida.DOUG HELTON is a Software Engineer with Lockheed Martin in Orlando, FL. He is currently involved in the development of the XML and Repository aspects of the OneSAF Objective System. He received a B.S. in Computer Engineering from the University of Central Florida.