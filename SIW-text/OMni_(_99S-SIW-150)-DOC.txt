OMni TM: A FOM and Language Independent Interface toThe RTIKen HuntJay GrahamAEgis Research Corporation6703 Odyssey DriveHuntsville, AL 35806256-922-0802khunt@aegisrc.com, jgraham@aegisrc.com Keywords:HLA, FOM Agile, FOM Independent, Middleware,type-safety, HLA Lab WorksABSTRACT: A variety of approaches for interfacing simulations with the High Level Architecture (HLA) Runtime Infrastructure (RTI) have been developed and demonstrated. While gateway approaches have proven viable for legacy applications with a limited future, the most interesting approaches for new development include; a.) Accessing the RTI application-programming interface (API) directly from the simulation code, b.) Migrating legacy DIS middleware layers to HLA, and c.) Developing new HLA-specific middleware layers as integration frameworks. Each of these approaches offers significant advantages and lessons learned, but unfortunately the current implementations of these approaches display serious deficiencies.This paper describes a new interface technology developed under private funding specifically for HLA. This technology, called OMni(TM), incorporates the positive salient aspects of each of the aforementioned approaches, while avoiding their shortcomings. The OMni name is derived from the concept of an “object model-neutral interface”, with the emphasis on the exploitation of the HLA object model denoted by the variant capitalization. OMni combines current industry best practices with a clear vision for delivering the HLA promise of an open and extensible architecture. Key aspects of OMni, such as custom-generated APIs, language layers, type safe interfaces, HLA foundational classes, and FOM mapping are discussed, with contrasts to existing alternatives made to illuminate this new technology’s superior characteristics.  IntroductionAs the transition to HLA has proceeded throughout the DoD simulation community, a variety of approaches for interfacing simulations with the RTI have been discussed and prototyped. One of the earliest approaches demonstrated was that of the DIS gateway. Since there was an existing community of real-time, platform level simulations in existence that conformed to the DIS protocol, this was a logical first step toward interfacing legacy simulations with the RTI. This approach places an intermediary application (known as a gateway) on the DIS network, which translates information back and forth between the DIS network and an HLA federation. The next logical step was for existing middleware that supported the DIS protocol to be adapted to interfacing with the RTI via a Federation Object Model (FOM) that closely resembles the DIS protocol data units (PDUs). This modified middleware alleviates the need for a gateway by directly interfacing simulations to the RTI. Other RTI interface strategies have chosen to ignore the past and instead focus on issues particular to HLA. The first such strategy was to access the RTI API directly from the simulation. More recently, strategies involving HLA-specific middleware designs attempt to address code-intensive issues that virtually all HLA-based simulations must address. This latter category includes OMni, a new HLA interface technology developed under private funding.To formulate a design for our own HLA-specific middleware, we first looked at prior RTI interface strategies and evaluated their strengths and weaknesses. We also attempted to categorize the potential users of each of the solutions. Table 1-1 summarizes our assessments:Table 1-1. RTI Interface Strategies prior to the availability of HLA-specific middleware solutionsInterface StrategyPros/ConsLikely UsersDIS GatewayProsNo code modifications required for legacy DIS simulations.Entire systems of DIS simulations can be immediately integrated into an HLA federation through a single Gateway. Legacy DIS simulations and tools needing a quick, low-cost interface to an HLA federation as an interim solution until a more robust HLA interface can be achieved. Legacy DIS simulations on the verge of retirement.ConsIncur additional latency of interfacing through an external application.HLA interface assumes RPR FOM. Support of federations other than RPR FOM requires code modifications to the Gateway.Added system complexity. Modified DIS MiddlewareProsLittle-to-no modifications required for simulations using the DIS version.Most offer flexibility of both HLA and DIS support.Comfort zone of using name-branded components.Simulations that previously used the DIS version of the middleware who aren’t concerned with being locked into the RPR FOM (or its minor derivatives).ConsAPI designed around DIS PDUs. Simulations that don’t fit the coarse DIS platform level of fidelity are out of luck.Simulations that don’t care about DIS are carrying around excess baggage of DIS-specific functionality.HLA interface assumes RPR FOM. Support for federations using other FOM will require modifying the middleware. Native RTI APIProsNo dependency on third-party components.Flexibility to support any conceivable object model.HLA experimental development.Simulations that have no DIS history and are not concerned about being dependent on a single FOM.ConsNo compile-time type safety.Simulation is hard-coded to a specific object model (unless a custom “middleware” layer is reinvented.) Supporting different FOMs requires code modifications.While they are only summarized briefly in the previous table, the cons listed for each of the approaches are significant. All of these strategies suffer from dependency on a single FOM. The first two strategies will tie you to one particular object model, which in our opinion violates the concept of an open architecture as promised by HLA. And while coding to the native RTI API does allow you to customize your HLA interface to any conceivable object model, unless you are willing to reinvent what OMni (and other FOM-independent solutions) provide, you will still be tied to a single object model. This certainly confounds the hope of near universal interoperability. While use of the native RTI API does offer flexibility in terms of the supported object model, it also has what we consider to be a serious pitfall in the lack of a type-safe interface. Irrespective of the HLA compliance guidelines, without compile-time type checking, the only way to verify that a simulation works as intended is to perform an exhaustive test of every attribute and parameter value that the simulation can input or output. This would require updating every possible attribute and sending every possible interaction to a previously validated simulation or tool that operates with the same object model and checking that correct data is being received. This process would then have to be reversed to insure that the simulation will interpret reflected attributes and received interactions correctly. Consider the difficulty of defining a test scenario that would cause a simulation of even moderate complexity to exercise each and every attribute. Few, if any, simulations offer a built-in interface test mode. And while some federations may be able to tolerate the discovery of type mismatches during execution, for very large-scale exercises such a discovery could be extremely costly. In the DIS world, middleware offers APIs that expect specific datatypes as inputs, allowing the compiler to perform a level of checking that is typically never performed for an HLA federate coded to the native RTI API. What this means is that when a variable is passed to a DIS middleware function that expects a float, the compiler has already insured that the value passed is indeed being interpreted in the simulation as a float. Thus, the simulations that receive that value are not usually concerned with the possibility of type mismatches. However, in HLA, the flexibility of the API to support different object models prohibits the compiler from performing these rudimentary checks. Unfortunately, the RTI does no enforcement of datatypes, so it is up to the federates to insure that they are strictly adhering to the datatype specification contained in the HLA object model. Even simple type promotions usually taken for granted, such as float to double, have to be deliberately and consistently implemented when interfacing with the RTI. Such type promotions (or rather the assumption of them) are particularly troublesome in HLA, since most programmers are in the habit of relying on smart compilers to take care of such mundane issues. OMni BasicsOMni (for Object Model-neutral interface) is a set of related software components and applications that together provide a simulation with the means of establishing a FOM-independent interface to the RTI.  In addition, it offers a type-safe interface that will tremendously impact the testing and integration process of HLA migration as well as HLA federation development.  To accomplish this, OMni is based on the assumption of a slow-changing SOM. As shown in Figure 2-1, the OMni Runtime Layer has two primary interfaces. Its first interface is with the OMni-based simulation and is derived from the simulation’s SOM. It is important to emphasize that with OMni, it is beneficial for the SOM to actually be indicative of what the simulation is doing internally. With DIS middleware and gateway approaches the SOM is more an artifact of DIS than of the simulation’s modeling capabilities. But because DIS-based simulation developers are used to thinking in terms of the DIS PDUs which they know how to translate their internal data into, they typically have no problem accepting the RPR FOM (of a subset of it) as their own SOM. With OMni, the more realistically the SOM reflects the internal structure of the simulation the easier it is to integrate the simulation with OMni. Since OMni offers (as an option) a custom API derived from the SOM, the first criticism typically levied toward OMni is that code changes and recompilation will be required whenever the SOM is modified. However, as we just described, the SOM should be a reflection of the simulation’s internal structure. If the simulation itself is well defined and stable, then its SOM (and therefore the simulation’s interface to OMni) will be stable as well. Thus, we encourage OMni users to develop a comprehensive SOM that describes the full capabilities of the simulation, using a class hierarchy and attribute nomenclature that resembles the actual implementation of the simulation. By developing the SOM in this way, it should only need modification as often as the simulation’s capabilities itself are modified, resulting in a “slow changing” SOM as a stable interface. (In our opinion, such an object model is more in line with the HLA concept of a SOM [1]. What has unfortunately become standard practice is to package the subset of the RPR FOM that the simulation custodian feels he can offer the most federations and call it the SOM). The OMni Runtime Layer’s other primary interface is with the RTI. This interface is continually adapting to different FOMs in order to allow the simulation to support different federations. OMni’s interface to the RTI is derived from the FOM of the federation being adapted to (referred to as the “target FOM”), and a mapping definition read by OMni during an initialization step. As shown in Figure 2-1, the mapping definition is created by an application called the FOM Mapper. The FOM Mapper reads the simulation’s SOM and the target FOM, and allows the user to specify how the classes, attributes, interactions and parameters of one model are manifest in the other. The FOM Mapper allows the user to designate Translator Modules to perform simple operations such as unit conversions, or more complex operations such as buffering attributes from multiple objects in the SOM domain that correspond to a single object in the FOM domain.  EMBED Visio.Drawing.5  Figure 2-1. User’s view of OMniThe following sections elaborate on key aspects of OMni, including the OMni APIs (plural since there are multiple ways for a simulation to interface with OMni) and on the mapping of the SOM to the target FOM. OMni APIsAs was previously mentioned, a custom API (derived from the simulation’s SOM) is only one option for interfacing with OMni. OMni also offers a stable native API. Sections 3.1 and 3.2 describe the different APIs offered by the OMni Runtime Layer. 3.1 OMni Native APIOMni’s native API is virtually identical to the RTI’s. The OMni Runtime Layer makes use of the Decorator Pattern. As described by Gamma, a decorator class “conforms to the interface of the component it decorates so that its presence is transparent to the component’s clients” [2]. The decorator forwards requests to the component, and performs whatever actions (such as transformations) before or after forwarding. In the case of OMni, the RTI Ambassador and Federate Ambassador classes are decorated with OMni Runtime Layer classes. The result of this approach is that any simulation currently using the native RTI API can be “OMni-enabled” simply by changing the declarations of two classes and relinking with the OMni Runtime Layer. We took this approach not only to make it easy for existing HLA federates to experiment with OMni, but also because we needed an interface that could support the needs of any HLA federate. Since such an interface has already been designed, refined and well documented by the RTI developers, we chose to leverage off of their work. 3.2 OMni Custom APIsWhile coding to the native OMni RTI achieves the highly desirable goal of FOM independence, it still does not solve the type safety problem. As described earlier, OMni addresses this issue by offering custom APIs derived from the simulation’s SOM. These APIs are generated by OMDT Pro, another application developed under private funding by AEgis Research. OMDT Pro, which is an advanced HLA object-modeling tool, can produce a custom OMni API for any valid HLA object model. It offers a variety of target languages, including C, C++, Java, Fortran and Ada. For C++ and Java, the generated API includes classes with type-safe methods. For languages other than C++ and Java, OMDT Pro creates functions (i.e. subroutines) with descriptive names and type-safe interfaces. For example, to update an attribute named “Speed” of type float in a class called “Vehicle”, OMDT Pro will generate a C function with the following declaration:OMRC OMniUpdateVehicle_Speed (OMID objectID, float newVal);The use of code generation in the context of the simulation’s object model offers all of these benefits:Compile-time type checking can be performed.An API that closely matches the federate’s internal modeling syntax can be provided.The bridge between the RTI and languages such as FORTRAN and Ada doesn’t have to be invented by the federate. OMDT Pro will generate APIs that implement the conversions to the RTI’s native C++ interface.For C++ and Java, custom APIs can offer sophisticated foundational classes that hide the work of interfacing with the RTI from the model developers.The use of code generation brings the datatype specification, as contained in the HLA object model, into the simulation’s interface in an automated fashion, further allowing automation (i.e. the compiler) to verify that the specification is adhered to. We are not aware of any other interface strategy capable of providing this level of assurance to the simulation developer that they are adhering to their object model specification.As you might have guessed, the generated code from OMDT Pro accesses OMni’s native API. An added advantage of making the OMni native API virtually identical to the RTI’s API is that the OMDT Pro code-generation modules can also generate type-safe, language-specific interfaces to the RTI’s native API. While we can’t imagine a simulation that wouldn’t want to take advantage of OMni’s FOM independence, there is likely an exceptional case that can only work in the context of a single FOM, and wouldn’t benefit from the OMni runtime layer. For these cases, our approach insures language layers and type-safety are still available. Object Model MappingSince the primary function of OMni is to allow OMni-based simulations to adapt to the FOMs of various federations, there must be a means for the user to establish the mapping between the simulation’s SOM and the target FOM. With OMni, this is done be creating an object model mapping specification using the FOM Mapper. The FOM Mapper allows the user to specify how every attribute and parameter in the SOM appears in the target FOM. The mapping is supported by a set of user-extensible Translator Modules as mentioned earlier. These modules are bi-directional components responsible for translating data from the context of one object model domain to another. Each of the Translator Modules that are delivered with OMni are focussed on single, low-level tasks such as coordinate conversion, attribute-to-class mapping and data buffering for classes that correspond to multiple classes in the other domain. The FOM Mapper allows the user to chain Translator Modules together to achieve more elaborate mappings. The component model of the Translator Modules is also documented so that end users can create translations that are as elaborate as needed for their application. The FOM Mapper exploits the component model to incorporate new Translator Modules into its user interface for establishing Object Model Mappings. Figure 4-1 illustrates the concept of a Translator Module with two simple samples. The first translator performs a simple scale operation. The FOM Mapper would provide the user with access to the properties of the Scale Module, which would in this case consist of the scale factor. By entering the appropriate scale factor, the user could use the Scale Module to convert between units of measure, such as feet to meters. EMBED Visio.Drawing.5  Figure 4-1: Sample Translator ModulesThe second Translator Module performs the more elaborate translation from a Latitude/Longitude coordinate system to an Earth Centered Rotational coordinate system. In this case, the LLtoECR Module expects very specific information to be provided as inputs. The properties of modules with multiple inputs or outputs such as the LLtoECR Module would include information about when to trigger an update. For instance, the Translator Module could be set to calculate new output values whenever any of the inputs change, or only when all of the inputs have been modified. In addition to Translator Module properties, the FOM Mapper also allows the user to designate constant values (defaults) for object model elements that have no correlation in the other object model domain, and to explicitly flag object model elements that have no meaning in the other object model domain. The FOM Mapper consistency checker insures that all object model elements in both the SOM and the target FOM have been accounted for either by establishing their mapping, supplying a constant, or by flagging the element as a no-op. Status and Future DirectionsOMni is still a work in progress. At the time of this writing, it has not yet been made available to the general public. Custom API generation will be limited to a narrow scope of languages for the initial release, with other languages added throughout the year. OMni is intended to become part of the HLA Lab Works suite of applications, joining OMDT Pro, FedProxy and FedDirector (which are several versions into their lifecycle.) Other directions for OMni that we expect to investigate in the near future include an OMni-enabled DIS Gateway and an OMni Bridge Federate. It is expected to be a trivial matter to create an OMni-enabled DIS Gateway from any of the existing DIS Gateways by simply changing the declarations for the RTI Ambassador and Federate Ambassador objects and then relinking with the OMni library. AEgis Research is involved in negotiations with custodians of such DIS applications to expedite this effort. As for the Bridge Federate, conceptual designs have been developed that indicate OMni can perform much of the work expected of a Bridge Federate with very little additional software needed. In this situation, the FOM of one federation is used instead of a SOM, and the FOM of the second federation is used as the target FOM. A means of distributing OMni has been identified to address the hurdles of joining more than one federation. ConclusionWhile the concept of a FOM-independent interface to the RTI was unheard of when we began formulating our concepts for OMni, by the time that this paper was written the need for such a technology has obviously become appreciated and is being investigated by other organizations. In particular, we have noted the efforts of Lockheed Martin Information Systems in the development of their Agile FOM Framework. From their published work [3], it is obvious that we have wrestled with many of the same issues in parallel over the last year or so. We believe our approach of exploiting the SOM by generating custom APIs is superior to any other middleware approach we have observed. Only by using automation to incorporate the object model specification into the interface can developers have confidence that their simulation is safe to use in a federation. Insuring type safety is a tedious job that should be relegated to the compiler. However, the nature of the RTI API prohibits such type checking. OMni establishes a bridge between the datatype information in the object model and the simulation code needed to enable compile-time type checking for HLA. As others who have worked toward FOM independence have noted, there is no guarantee that a given simulation can support every FOM. For example, everyone would agree that there is no mapping between a platform level military simulation (with classes such as Tank and F15) and a federation of electronics manufacturing simulations (with classes such as Conveyor, Queue, and Breadboard). Even in cases where syntactical mappings can be made, federation designers must still take responsibility for considering the more subtle issues of semantics and fidelity and their impact on federation results. References[1] Defense Modeling and Simulation Office, “HLA Object Model Template, Version 1.30,” 5 February 	1998.[2] E Gamma, et al, “Design Patterns: Elements of Reusable Object-Oriented Software”, Addison-Wesley, 1995.[3] D Macannuco, B Dufault, L Ingraham: “An Agile FOM Framework,” Simulation Interoperability Workshop, 98F_SIW_025, September 1998.Author BiographiesKEN HUNT is the Technology Group Leader for Software Development at AEgis Research Corporation.  In this role, he has oversight of all corporate software development activity, including the HLA Lab Works™ tool suite and DMSO’s OMDT. Since receiving a bachelor’s degree in Electrical Engineering from Auburn University, he has accumulated over 14 years of experience in software and simulation development.  His simulation experience includes designing discrete event simulation frameworks for DoD, finite element applications for NASA, and manufacturing simulations for the automotive industry.JAY GRAHAM is a Software Developer and Techinical Lead at AEgis. He has been involved in the development of Modeling and Simulation Software and Tools for the HLA. In particular, he is an experienced developer of simulation software frameworks. Mr. Graham has a BS degree in Computer Science, minor in Mathematics. His research interests are in Distributed Object Technologies and Software Framework Design.