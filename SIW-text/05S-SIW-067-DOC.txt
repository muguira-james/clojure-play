1.  IntroductionDead reckoning is a method of deductively estimating the position of an object in motion based upon known attributes, such as velocity and acceleration.  Initially conceived as a navigational technique for ships at sea, dead reckoning is of interest to simulations as a way to estimate the movement of a remotely simulated object between state updates.  This creates the illusion of smooth movement, allowing for more accurate collision checking with remote objects, better visualization for human users, and easier tracking for both human and simulated observers.  Another benefit of dead reckoning is that it can be used to reduce the frequency of updates required in distributed simulations.  This reduces the amount of bandwidth consumed by a simulation and saves the processing time associated with transmitting and receiving those updates.  Within the IEEE 1278 Distributed Interactive Simulation (DIS) standard, remote entities are given three positional thresholds and three rotational thresholds.  Information on an entity's position is only transmitted when the local simulator calculates that the entity's actual position or rotation relative to the dead reckoned position or rotation has broken these thresholds.  In DARPA's Distributed Simulation Networking (SIMNET) program, such a scheme reduced network traffic by 83%. [1]Commonly, a dead reckoning algorithm will use knowledge of an object's velocity to predict the movement of the object over time using a simple Newtonian formula; position equals initial position plus velocity multiplied by time.   This is a first-order dead reckoning algorithm, and is especially useful for objects that are likely to maintain a constant velocity.  Second-order algorithms take this calculation a step further and consider the acceleration of the object being reckoned.Additional complexities that may be commonly included in a dead reckoning algorithm include rotation, rotational acceleration, and limitations on behavior such as an inability to pass through solid objects.  In addition, some dead reckoning algorithms include a method of correcting errors when a new update is received that does not coincide with the dead reckoned position and heading.  This is done by interpolating the predicted and actual movement of the object so that the path is corrected without causing the object to teleport into place.  This interpolation is very useful in environments where a human viewer is present and could find a teleporting object confusing, annoying and difficult to track.Urban environments pose additional difficulties to the dead reckoning of vehicles.  Intersections are extremely frequent on city roads.  When a vehicle reaches an intersection it often will need to stop or turn, violating the assumption of constant velocity and acceleration in first or second order dead reckoning.  The paths of vehicles also often cross at intersections, producing apparent collisions if the dead reckoning incorrectly predicts movement.Furthermore, the density of traffic causes vehicles traveling in a city to frequently stop for vehicles in their path; stop-and-go traffic.  The net result is that vehicles in a city rarely travel with a constant velocity or acceleration for any significant length of time.  These problems can be alleviated by increasing the frequency of entity state updates, but at the cost of additional bandwidth consumption and use of system resources.This paper details an alternate method of dead reckoning the movement of vehicles traveling along roads, designed to overcome the problems posed by the road travel in an urban environment.  While more limited than a traditional dead reckoning algorithm, requiring both knowledge of the road system and knowledge of the vehicles' paths for the immediate future, this method provides superior fidelity while reducing bandwidth consumption.2.  BackgroundIn support of USJFCOM's Urban Resolve 2004  Experiment an application called ClutterSim (henceforth referred to as “Clutter”) was developed.  Clutter is a specialized simulation application, created to inexpensively simulate large quantities of vehicles.  The intent of Clutter was to provide a large amount of sensor noise (also known as “clutter”) to represent the many people and vehicles that populate a city.  This noise would provide concealment for hostile forces such as armed insurgents to blend in with, adding to the difficulty of identifying and locating them, as well as appropriately overwhelming simulated sensor systems that may be unable to handle the noise and large quantity of information.While the sheer volume of entities overwhelmed the original simulation software, Clutter reduced both the computational requirements and network bandwidth consumption for the vehicles it was simulating.  Clutter increased the quantity of traffic that could be simulated by several orders of magnitude, ultimately supporting more than one million individually simulated vehicles.  Accomplishing these objectives, however, required many optimizations including making Clutter vehicles unaware of both the surrounding terrain and the state of vehicles.  In addition, Clutter vehicles did not subscribe to remote entity states, instead relying on deterministic calculations to produce the same vehicle movements based upon a single message when vehicles enter a road.  [2] With the large quantity of urban vehicles, some anomalies in vehicle movement became especially apparent.  The simulation took place across many machines in different locations, and as a consequence latency was nontrivial.  At turns or intersections vehicles would continue to be dead reckoned in a straight line until an entity update made them turn or stop, teleporting them back into their proper place.  In addition to being unattractive, this effect could be misleading to human observers; a vehicle driving through an intersection might appear to be going straight through the intersection, only to teleport down a side road shortly thereafter.  For the same reason as the intersection problems, vehicles would also sometimes briefly pass through the vehicle ahead of them and then teleport back when the next update was received. To combat these predictive errors, the first-order dead reckoning the Clutter vehicles used was replaced with a road-based dead reckoning system.  This system uses a knowledge of the road networks, the Clutter vehicles' planned paths, and the distance along thoes paths that the vehicles are permitted to travel to allow Clutter vehicles to conform to bends in the road, turn at intersections, and stop when needed without requiring multiple updates.3.  Design Philosophy3.1  Less is moreBecause one of the key attributes of Clutter is quantity, any design must be as efficient as possible to avoid overwhelming limited resources.  Limited bandwidth is a major problem, especially in conjunction with the density of urban traffic and powerful sensor systems; one paper on Clutter, Simulating Urban Traffic in Support of the Joint Urban Operations Experiment, comments, “The inclusion of long-range sensors and high-level views in joint experiments prohibits the use of some simple short-cut strategies to reduce network bandwidth requirements (such as divide-and-conquer).”  [2]  The dense traffic and frequent intersections of an urban environment also make deviations from a dead-reckoned path more frequent, increasing the number of updates significantly and further consuming bandwidth.  [3]As a consequence, our design must try to minimize the network traffic it requires.  The solution should use no more bandwidth than the current first-order dead reckoning, and preferably less.Fortunately, Clutter vehicles provide us with an excellent means to trim bandwidth consumption: they follow predefined roads and determine their path in advance, making them eminently predictable.  As another paper on dead reckoning, The Applicability of Distributed Simulation Techniques to High Performance Aircraft, observed, “'Predictability' is the key to successfully reducing DIS network traffic... The position and orientation of 'predictable' vehicles can be extrapolated long enough into the future to significantly reduce network entity state update requirements.”  [1]  Our solution should leverage Clutter vehicles' predictability to keep the frequency of updates to a minimum.3.2  Lag happensTo support the number of vehicles Clutter is expected to produce for dense urban traffic, a distributed approach is necessitated.  Furthermore, there is no assurance that the distributed simulators will be geographically co-located, so the latency associated with communication between simulators may often be non-trivial.  During Urban Resolve 2004, for example, the machines involved in the simulation were located in Hawaii, Ohio, and multiple sites in Virginia.  [3]  This potential distance adds additional network complications.  Latency over the network and dropped packets delay updates to vehicle states.  This results in remote vehicles not stopping or starting movement simultaneously with their local instances, and sometimes missing intermediate states altogether.  This creates infidelities such as vehicles running off of roads, through each other, or through intersections.  [2]  Correcting these errors in the past required teleporting the vehicle into place, which is yet another infidelity.In addition to latency, another potential difficulty posed on a distributed system is the loss of a simulator.  When this occurs, moving vehicles will continue to drive in a straight line until they are removed when the loss of the simulator  is detected.  Having a large number of vehicles driving in a straight line through buildings, other vehicles, or large bodies of water is extremely visible to human operators and should be avoided if possible.The new method of dead reckoning should be able to deal with latency, missed packets, and the loss of simulators gracefully.  Any discrepancies between local and remote machines must be corrected in as subtle a fashion as possible to avoid creating visual anomalies that will disturb human users, but without allowing the simulations to become significantly desynchronized.4.   Dead Reckoning4.1  How it worksOur road-based dead reckoning is extremely simple in concept.  Using knowledge of each vehicles' speed, travel time, and permitted travel distance, we can calculate where the vehicle is located.Each vehicle is dead reckoned on a road topography that every simulator can access.  In the case of Clutter, every simulator loads its own copy of the same terrain database.  The simulators locally simulating clutter vehicles publish the current road, target road, speed of travel, time of entry, permitted travel distance, and time spent immobile for each of their vehicles.  With this information, any the vehicle’s position can be calculated.  To determine position, a vehicle’s distance along the road it is travelling on is calculated by multiplying the time it has been in motion by its travel speed.  This road distance is capped by the stopping distance provided.  Once the road distance has been calculated, it can then be converted to XYZ world coordinates using the road topography.  This process is summarized below in figure 4.1.While this process is more costly than standard first order dead reckoning, the calculation only must be performed when the position is fetched.  Once calculated, the position can be cached to save resources if it is fetched repeatedly within a short period of time. Each road in the topography is assigned to a simulator, which we call a “road master”.  The road master is in charge of monitoring traffic on that road.  Road masters watch entity states for vehicles entering their road, and then tell the vehicle simulators when the vehicle may progress further down the road.  The vehicle sim recieves this update and changes the vehicle's state appropriately.It is possible to have multiple road masters, in which case each road master takes a subset of the roads in the terrain database.  This allows scalability as the number or roads and vehicles using the roads increases.To the right, the communications between the various simulators is diagrammed in figure 4.2.  On the next page, figure 4.3 illustrates an example of a vehicle travelling down  a road using road-based dead reckoning.This method provides many benefits.  Vehicles will not pass through each other or drive through intersections due to delayed updates because the distance at which they must stop is transmitted in advance.  Vehicles will also no longer drive off the road when the road bends, because each simulator is aware of the road network and the fact that the vehicle is moving along this road network.However, latency still produces one complication.  Because remote simulators do not receive updates immediately or with a consistent delay their timing data will vary from the local simulator's.  When a simulator learns that a remote vehicle is given permission to move further, on the local machine that vehicle has already been moving for whatever length of time the update was delayed by.  At intersections it is even possible that the remote simulators may briefly calclulate a vehicle’s position one road behind where it is on its local simulator.This delay means that if the position of a vehicle is calculated using the timing data in an update, it will teleport slightly forwards in correction because the new times indicate it was given permission to go further in the past.  This is analogous to the short backwards teleportation whenever a vehicle was ordered to halt under the old system, but erring in the opposite direction.  If latency is small enough this distance may be imperceptible but as already noted such network conditions cannot be assumed.To overcome this, simulators only take the timing information for a vehicle when they first learn of the vehicle.  This usually occurs when a simulator joins the simulation after it has already been created or if the simulator is filtering out updates geographically.  The published enter and wait time for a vehicle let simulators learning about a vehicle mid-road place it in the appropriate place on the road.After the initial placement, each simulator keeps its own copy of the published state of the vehicle and tracks the time of road entry and time spent waiting at stop distances independently.When a stopping distance update is received, the update’s road is compared to the road we have calculated the vehicle as being on using our cached data.  If it is, we update the travel distance, but use the time the update was received rather than the published time in the update as the moment at which the vehicle was permitted to travel further.  This allows us to avoid teleporting the vehicle forward along its path.  If the travel distance update is not for the road the receiving simulator calculates the vehicle is on, it is stored but not used.  When the vehicle moves onto that road, the stored distance is then used as our initial stopping distance on that road.  This allows us to handle the boundary case where a remote vehicle is briefly one road behind as it transitions between roads.In addition to travel distance permissions, updates are also sent out when the vehicle advances to a new road, indicating the new current road and what road the vehicle is going to next.  This is done instead of publishing the whole route in advance because doing so allows us to replan the route while the vehicle is moving in response to traffic or other events, without having to send the whole path every replan.If the received road update matches the vehicle's current road, the next road information is copied over.  If the update's road is the vehicle’s next road, we are in the boundary case just mentioned and ignore it.  Once the vehicle transitions on our simulation, we will then use the update to fill in our next road.  If neither of these cases is true, something unexpected has occurred.  Network problems such as severe latency or packet loss could cause this to happen.  We remove the vehicle and re-place it as if we had just initially discovered it.  This will correct the vehicle's location if the vehicle falls more than a single road behind its actual state.4.2  Meeting design goalsAs discussed in “Design Philosophy”, there were two major goals of these changes to the Clutter vehicle dead reckoning.  The first is the reduction of  network traffic required by the simulation of our vehicles.  The second is to improve the approximation of remote vehicle movement under less than perfect networking environments.  Better approximation would enhance both visual (2d and 3d) displays and sensor modeling.  The system detailed above accomplishes both of these goals.4.2.1  BandwidthThe road-based dead reckoning reduces network traffic by reducing both the frequency of updates and the average size of the update.  Under the old system, an update to the dead reckoning information needed to be sent out every time a vehicle changed velocity.  Starting a vehicle, moving it down a straight road, then stopping it when a vehicle or intersection is reached would require two updates- one to get the vehicle moving and one to stop it again.  Our system only requires a single update for this, since updates also include the stopping distance.  Roads that are not perfectly straight would require additional updates every time the road curves, whereas under our system no updates are required because the remote machines are aware of the structure of the road.  Under our implementation, the initial road update is comparable in size to the standard first-order dead reckoning update.  Instead of position and velocity, we send a pair of road indexes, travel speed, and enter and exit data.  The average update size, however, is reduced because most of our updates only need to tell the vehicle it may go further.  These updates are very small, consisting only of the new allowed distance and the time the vehicle has spent immobile on the current road. Excluding overhead, the initial road and distance update sent by our road-based dead reckoning is in total 72 bytes.  The distance updates, sent alone after road entry, are only 16 bytes.  The data contained in these updates is summarized above in figure 4.4.  First order dead reckoning updates, in comparison, consist of a position, velocity, and rotation.  Using the RPR FOM (Real-time Platform Federation Object Model) 1.0 standard, the position is transmitted as an array of three 8-byte floating point floating point values, and the velocity and rotation each as an array of three 4-byte floating point values.  This produces a total size of 48 bytes.A perfectly straight road with no traffic is the situation where the standard first order dead reckoning would be the most competitive against this new system.  Standard dead reckoning would require three updates to do this if the vehicle drives straight at the intersection; one to place and start the vehicle, one to stop it at the intersection, and one to tell it to move through the intersection.  This is a total size of 144 bytes in three updates, disregarding overhead.  By comparison, road-based dead reckoning would require one full road and distance to place the vehicle and one distance update to tell it to move through the intersection and off the road.  This is a total of 88 bytes in two updates; about 60% as large, although the smaller number of updates may also further help by reducing overhead.As the traffic increases, this ratio increases.  For every stop and start, first order dead reckoning would require two updates; 96 bytes over two updates.  Road-based dead reckoning would only require a single 16 byte update.  On a reasonably short city road that produces an average of three stops before the intersection, for example, 432 bytes in nine updates versus 136 bytes in five updates for road-based dead reckoning.Any turning, either due to bends in roads or because a vehicle is making a turn at an intersection, would also require one or more additional update for first order dead reckoning and none for road-based dead reckoning.  This further shifts the bandwidth advantage in favor of the road-based method.4.2.2  FidelityAs discussed in “How it works”, we overcome the barriers to smooth movement posed by latency in two ways.  First, simulators know when vehicles must stop and when and where they must turn at intersections or to follow roads.  No update is required to make a vehicle halt or turn, so latency no longer causes vehicles to go too far.  Even in the extreme case of a simulator dying, vehicles remain on the road and immobile instead of continuing in a linear path.  This prevents situations such as vehicles driving through each other, off the road, through buildings, or over bodies of water- all highly visible unrealistic behavior.The second advantage of this method is that the time a vehicle spends stopped provides automatic compensation for latency.  If a vehicle receives a state update late, it will remain at its stopping distance on the road until the update is received.  Locally, the vehicle will have resumed movement and be further down the road than the remote vehicle.  When the vehicle reaches its next stopping point on the local machine, however, the remote machine will still consider the vehicle in motion because of the delayed start.  As long as the stopping times are large relative to the latency, small positional errors due to delayed updates will correct themselves when the vehicle stops.  These errors will not accumulate, so teleportation to correct the vehicle's position will not be necessary except in extreme delays or dropped packets.  In the implemented system, the vehicles will teleport to compensate for lag only if they fall more than a single street apart from each other.  This could easily be made more restrictive by comparing the position calculated from an update's timing data with the position calculated from the cached data and adjusting the position should the two become too divergent.One other benefit reaped from the changes to a road-based dead reckoning system is that it makes small enhancements to the simulated movement such as smooth turning and acceleration easier to accomplish.  These behaviors can be included in the road dead-reckoning logic, instead of requiring a constant stream of first order dead reckoning updates.Because of stop-and-go traffic and speed limits, supporting vehicle acceleration in an urban environment with second order dead reckoning would require at least twice as many updates as first order dead reckoning and with no acceleration.  In addition to the normal updates when a vehicle starts and stops, an update would be needed when the vehicle is done accelerating and has reached the desired travel speed, and a second to begin deceleration as it approaches its stop distance.  The inclusion of acceleration in the updates would further increase the size of the update.  The extra information known by road-based dead reckoning- the stop distance and desired travel speed- allow acceleration and deceleration to be calculated on each simulator locally without any additional network traffic.  One way this could be implemented is to assume vehicles accelerate constantly up to the listed travel speed, then travel at the speed until beginning deceleration a certain distance from their stopping point.Using knowledge of the road networks, any turns a vehicle makes can also similarly be turned into a smooth turn instead of requiring a constant stream of updates or being a sudden change in heading as it would be otherwise.  Our system implements this by smoothing the final segments of movement from the known stop line at the end of a road to the start line of the next road of travel.4.3  Future developmentSeveral possibilities present themselves for further development of this road-based dead reckoning.  As was described in “Meeting Design Goals”, there are many opportunities to provide additional complexity to the vehicles' movement with no additional network expense.  Currently an extremely simple smoothing system is used to provide smooth turning for vehicles, but a more complex method that considers  vehicles' centers of mass and turning radii could produce a more realistic turn.  Smooth acceleration and deceleration is not currently supported.  Vehicles begin movement at their full road travel speed, and stop movement instantly without deceleration.  In the future, this could be replaced with a more reasonable behavior.Another potential area of improvement is the management of latency when an update is received.  Currently, when a remote vehicle receives permission to travel further it will remain behind the local vehicle by whatever distance the latency involved in the update creates.  As discussed, these times should not accumulate under reasonable network conditions.  Furthermore, because urban travel generally features frequent stops a vehicle these discrepancies generally are corrected rapidly.  The fidelity provided by the current version of road-based dead reckoning has proved adequate so far.If a greater degree of fidelity was required, however, some interpolation could be used to bring the vehicle into closer synchronization using the times provided by updates.  One way to do this would be to use the DIS standard smoothing algorithm to perform the correction.  [4]  Another solution if smooth acceleration and deceleration is added would be to manipulate the vehicle's acceleration to bring it into line with the actual position.4.4  LimitationsThe described approach to dead reckoning poses several limitations.  The first and most obvious is the limited scope of what can be dead reckoned: only vehicles traveling on a road network can be dead reckoned with this method.  When not on roads, vehicles need to use another method such as first or second order dead reckoning.  Furthermore, this method is only suitable for simulating computer controlled vehicles that are unlikely to suddenly change their plans.  Clutter vehicles meet this requirement, but any human controlled vehicles and some of the other computer controlled vehicles do not.  While it might be possible to write an algorithm to detect road-like movement and fill in the fields needed for road-based dead-reckoning, it would still be much less reliable than with the Clutter vehicles, especially around intersections where the next road of travel cannot be known and with human operators who are unlikely to drive in a perfectly predictable fashion (ie. in the exact center of their lane).The complexity of this method as opposed to the more elegant formulas of first- and second-order dead reckoning also make it less desirable.  All simulators must know of the road network, adding additional code to the simulator and increasing memory usage.  In addition, this method cannot be easily described as a set of mathematical formulas so re-implementing the road-based dead reckoning code with consistency could require significant additional effort in situations where multiple differing simulators cannot simply share the same source files.  This contrasts with more traditional methods such as those defined in the IEEE DIS standards, which are comparably simple and have a standard set of algorithms, implementation details, and naming conventions.  [4]5.  ConclusionThe density of traffic and frequent intersections inherent to cities presents difficulties to dead reckoning in a distributed environment where latency is a factor.  Furthermore, the sheer volume of traffic requires that usage of system and network resources be kept as frugal as possible to avoid overwhelming the system.By using foreknowledge of the paths of vehicles in conjunction with a known road network, it is possible to dead reckon simulated urban traffic with greater fidelity and less network activity than with traditional first- or second-order dead reckoning.  These improvements are not without cost.  This method is much less flexible than traditional dead reckoning.  Only computer-controlled vehicles following known paths that are at predetermined for the near future can be simulated.  Furthermore, the implementation of such an algorithm is more complex and difficult than the simple Newtonian formulas of first and second order dead reckoning.  Despite these drawbacks, however, for some applications such as the urban traffic simulation performed by Clutter road-based dead reckoning offers a way to improve fidelity of the traffic simulated while reducing the resources required for simulation.REFERENCES[1]  Schaffer, R.  1992.  The Applicability of Distributed         Simulation Techniques to High Performance Aircraft.        American Institute of Aeronautics and Astronautics.[2]  Speicher, D. & Wilbert, D.  2004.  Simulating Urban        Traffic in Support of the Joint Urban Operations        Experiment.  Interservice/Industry Training,       Simulation & Education Conference (I/ITSEC).[3]  Ceranowicz, A. & Torpey, M.  2004.  Adapting to       Urban Warfare.  Interservice/Industry Training,        Simulation, & Education Conference (I/ITSEC).[4]  IEEE Standards Committee.  1996.  IEEE Standard       for Distributed Interation Simulation- Application        Protocols.  The Institute of Electrical and Electronics      Engineers, Inc.  NY, NY.Author BiographiesDALE MOYER is a developer of the ClutterSim application.  He is a Software Engineer at Lockheed Martin Simulation, Training & Support Advanced Simulation Center (LM STS-ASC) in Burlington MA.  Dale holds a BS in Computer Science from Worcester Polytechnic Institute.DAN SPEICHER is the lead developer of the ClutterSim application.  He is a Software Engineer at Lockheed Martin Simulation, Training & Support Advanced Simulation Center (LM STS-ASC) in Burlington MA.  Dan holds a BS in Electrical Engineering from Cornell University.A Road-Based Algorithm for Dead ReckoningDale MoyerDan SpeicherLockheed MartinSimulation, Training, & SupportAdvanced Simulation Center164 Middlesex TurnpikeBurlington, MA 01803HYPERLINK "dale.moyer@lmco.com"dale.moyer@lmco.com, HYPERLINK "dan.speicher@lmco.com"dan.speicher@lmco.comABSTRACT:  Dead reckoning algorithms play an important role in network based simulations, predicting the movement of entities between state updates to provide the illusion of smooth movement.  Traditional dead reckoning algorithms assume a constant velocity or acceleration, and use calculations based upon these assumptions to plot the movement of the object over time.  Travel along roads in an urban environment, however, often features frequent stops and turns.  Because of the latency inherent to distributed simulations, this may cause vehicles to appear to drive through other vehicles, drive through intersections without stopping, or drive off of a road.  Correcting these infidelities in dead reckoning causes additional anomalies such as discontinuous movement as a vehicle teleports back into place.This paper describes an alternate method of dead reckoning that uses knowledge of the vehicle's initial road entry time, current road, destination road, and the distance that the vehicle is permitted to travel.  This method can predict the movement of vehicles using roads with higher fidelity; the vehicle can follow bends in a road, turn at intersections, and stop when needed without additional updates.  Updates are only required when the vehicle is permitted to move further along its path.  This method is also extremely resistant to latency.  After the vehicle is first placed upon the road system no further clock-based synchronization is required, yet latency the of the updates will not accumulate and cause the vehicle to fall further and further behind its actual location.  In addition, under reasonable network conditions the vehicle should not require teleportation or other significant correction to adjust its position.  Use of road-based dead reckoning over more traditional methods allows us to greatly improve the fidelity of dense urban traffic simulation while minimizing network traffic.  EMBED Word.Picture.8  Figure 4.3: Road travel exampleFigure 4.1: Converting from road position to world positionFigure 4.2: Communication between simulators with road dead reckoningFigure 4.4: Information contained in road dead reckoning updates