Federation Initialization and the RTI 1.3: Lessons from the JTLS-GCCS-NATO FederationJeff NielsenThe MITRE Corporation1820 Dolley Madison Blvd.McLean, VA 22102703-883-5679jnielsen@mitre.orgKeywords:JTLS, federation initialization, synchronization points, RTI 1.3ABSTRACT: A previous SIW paper (98F-SIW-153) reported on the development of the JTLS-GCCS-NATO Federation.  Phase I of this federation experiment culminated on September 29, 1998 with a demonstration of basic federation capabilities.  This paper discusses lessons learned during the federation integration and testing period, specifically regarding the issue of federation initialization.  The basic problem of federation initialization is ensuring that all federates are in a correct and consistent state prior to beginning the federation's "work" (e.g., executing a scenario).  To initialize the JTLS-GCCS-NATO federation, each federate needs to receive a basic set of object discoveries and initial attribute value updates, while coordinating invocation of the time management services.  To this end, we defined a detailed initialization procedure based on the use of synchronization points.  During our testing, however, we encountered a variety of unanticipated complications with initialization.  While some of these involved design decisions by individual federates, many were due to implementation details of the RTI 1.3. As a reference for future developers, we discuss topics including what synchronization points do and do not guarantee, delayed object discoveries, and missed attribute value updates.  We conclude with initialization-related recommendations and solutions.  This paper presents information representing the HLA development process underway by DMSO and the DoD AMG.IntroductionA paper presented at the Fall 1998 Simulation Interoperability Workshop reported on the ongoing development of the JTLS-GCCS-NATO Federation [1]. This was an experimental federation sponsored by the Defense Modeling and Simulation Office (DMSO) to further explore the issues of simulation-to-C4I-system linkage using the High-Level Architecture (HLA).  The previous paper highlighted several key decisions made during the design stage of federation development in order to address a variety of technical challenges.  Phase I of this federation experiment culminated on September 29, 1998 with a demonstration of basic federation capabilities for sponsors and participant organizations.  The federation integration and testing period which preceded the demonstration (June-September, 1998) provided many valuable lessons and insights, and allowed us to evaluate the impact of our design decisions.  One set of decisions in particular proved especially troublesome to implement in practice: those regarding federation initialization.  We encountered a variety of unanticipated complications with trying to successfully execute a federation initialization procedure. While some of these problems could be traced to individual federate errors, many were due to implementation details of the DMSO-provided Runtime Infrastructure (RTI) version 1.3.  This paper discusses lessons learned during integration and testing related to the issue of federation initialization, specifically in the context of the current RTI 1.3 implementation.  We provide recommendations to future federation developers, and suggest how the HLA specification might be refined to prevent similar difficulties in the future. The federatesFigure 1 shows a conceptual diagram of the federation.  The individual federates are shown as circles communicating with the HLA RTI, and the labeled arrows represent the data that each federate publishes and/or subscribes to.  By way of introduction, a brief description of each federate follows. The JTLS Combat Events Program (CEP) is the core process of JTLS.  The CEP does all the modeling of the combat units, the events, and the battlefield environment.  It contains the algorithms for computing the state of simulation objects, and reacts to orders created by human operators (players).GDS, the Genis Data Server, is used as the data management and distribution component of the JTLS system.  The CEP sends state information for all simulation objects to the GDS.  The GDS, in turn, services the information needs of a vast array of simulation "clients," including player consoles, data display terminals, and data translation modules that enable linkage to C4I systems.OTH-GEM is the Over-the-Horizon Genis External Module.  This program takes simulation state data as input, and produces OTH-Gold messages that can be delivered to real-world C4I systems (those that accommodate the OTH-Gold message protocol).GCCS, the Global Command and Control System, is the battlefield situation display and information-management system for theater- and joint-task-force-level commanders and their staffs.The MÄK Plan View Display (PVD) is a commercial, HLA-compliant product that provides real-time display of federation objects in the form of icons.  By adapting to a federation object model (FOM), the tool can be customized to run with different federations.The NC3A Land Order Translation Module (LOTM) is a response-cell support tool that enables role players to enter mission orders using more "natural" operational terms and graphics.  The LOTM then transforms this data into a set of JTLS orders for subordinate units.  "NC3A" refers to the NATO Consultation, Command, and Control Agency (the former SHAPE Technical Center).The NC3A Aggregator is a response-cell tool intended to reduce the role players' workload by making it easier to discover and report status information for aggregate units (made up of smaller sized units that are explicitly modeled in the JTLS game). The aggregator calculates the status information for an aggregate unit from the data for the individual constituent units.The NC3A ICC Air Track Formatter is a software module similar to OTH-GEM.  It uses the simulation state data for aircraft, air missions, air bases, SAM sites, and radar sites as input and generates output in the appropriate format for several NATO C4I devices, including OPUS, ACBA, and ICC.The NC3A Bi-MNC Report Generator is a family of processes that translate a subset of JTLS simulation data into well-structured, formatted messages.  These messages can then be delivered to the training audience via real-world communications systems.  The modules accomplish the end-to-end process of preparing and injecting the reports into the communications backbone. Federation InitializationThe basic problem of "federation initialization" is ensuring that all federates are joined to the RTI and are in a correct and mutually consistent state prior to beginning the federation's work. In many federations there is a significant amount of information that must be communicated "up front" before federates can begin doing any useful processing.  This may include reference data to be shared among federates such as a description of common terrain, or initialization values such as the starting date and time.  At the very least, it will include a set of initial federation objects with their starting states.  This data should preferably be distributed among the federation in an orderly and efficient way.  For example, the JTLS-GCCS-NATO federation consists of one primary data-producing federate—the JTLS game itself—and a number of "subscriber" federates that are interested in receiving game data.  As a large-scale combat simulation, JTLS starts up with an extensive set of reference and initialization data (called the "scenario") which it reads from a set of files.  This data includes things like unit and ship prototypes; equipment and supply categories; and the name, composition, command hierarchy, and location of all simulated units at time zero.  It also includes the terrain on which the game will be played.  Each of the subscriber federates in the federation needs some subset of this data, based on what it does.  For example, both the GCCS and the LOTM subscribe to ground units, so they must know about any ground units that exist at the game's beginning, together with their names, starting locations, etc.  The GDS likewise needs complete information about the supply categories in order to populate its database correctly. Therefore, to initialize the JTLS-GCCS-NATO federation, each federate needs to Join,Discover all initial objects that pertain to its subscription interests,Receive ("reflect") initial attribute value updates for these objects, andEnable the time management services it will use (i.e., become time regulating and/or time constrained).Only after this is accomplished can the federation begin "running" by advancing game time.Defining an Initialization ProcedureRequirementsDuring the federation planning stage, we identified several important requirements for federation initialization.  These were as follows.All initial objects should be discovered before any objects are updated.  In other words, a federate should receive all of the "Discover Object" callbacks before any "Reflect Attribute Values" callbacks arrive.  This was a concern primarily because of cross references in the FOM.  Many objects in the FOM have attributes that are "pointers" or references to other objects (e.g., a "Surface" object holds a pointer to the object functioning as its "higher headquarters").  If attribute updates began arriving at a federate before it had discovered all of the objects it was subscribed to, it could potentially receive a reference to a still-undiscovered object.  This situation would have been especially difficult for the GDS federate to handle, because of its existing database structure.  This first requirement was actually the impetus for developing an initialization procedure. While it was easy enough to require the JTLS CEP to register all objects before beginning to update them, we wanted a way to ensure that all of the corresponding discover messages would arrive at the GDS before the attribute updates (reflections).  A second requirement was that all initial attribute value updates should be sent only once.  It is fairly standard procedure for a federate to send a "Request Attribute Value Updates" message immediately upon discovering any object (the RTI 1.3 will even do this automatically if you set a RID parameter).  But with all of the subscriber federates joining at the same time and with many overlapping subscription interests, we wanted federates not to request updates during initialization, in order to avoid flooding the publishing federate (JTLS) with a large number of potentially-redundant requests.  As the number of federation objects increases, this can become a serious performance issue.  As long as every federate joins and subscribes before updates begin , there is no reason that the CEP should need to send initialization data more than once for any given object. Third was the requirement that federation time should represent the JTLS game time.  This affected initialization in two important ways.  Because all of the initialization data must arrive before game time advances beyond zero, we could not use the HLA time management services to control the delivery of initial attribute updates—they would necessarily come in receive order. Secondly, when time management was begun, JTLS (as the only time-regulating federate) needed to enable time regulation before any of the time-constrained federates began requesting time advances.  Using synchronization points for initializationIn order to address these requirements, we devised a formal initialization procedure which makes use of the HLA synchronization point services.  These services allow all federates in a federation (or a subset) to "synchronize" at a given point.  One federate begins the process by registering a synchronization point, to which it gives a name or label.  All other federates then receive the announcement of synchronization point label, and each one subsequently notifies the RTI when it has "achieved" the synchronization point.  Once all federates have achieved synchronization point label, the RTI sends a "Federation Synchronized at label" callback to the entire group.The JTLS-GCCS-NATO federation initialization procedure uses these synchronization points to segment initialization into different phases.  Federates that reach the end of a phase before other federates essentially wait until all others have "caught up" before proceeding to the next phase.Figure 2 shows the first version of the initialization procedure, which consists of three different synchronization points in succession followed by a fourth that is announced but never achieved.  The first point occurs after all federates have issued publication and subscription requests and registered initial objects, the second after all federates have sent out initial attribute value updates, and the third after all federates have turned on their appropriate time management flags.  By synchronizing at these three points, the procedure attempts to ensure the following things.All federates have the chance to finish subscribing to objects before initial attribute value updates are sent (so that updates follow discoveries and only need to be sent once).  All attribute value updates are sent before time management is "turned on" (so that the updates arrive in receive order and can be processed immediately).All time management flags are set before any federate begins requesting time advances (so that no constrained federate races ahead of a regulating one). The "running" synchronization point remains pending throughout the remainder of the federation execution as an indication to late-joining federates (which receive the announcement of "running" upon joining) that the initialization phase is over.  Unexpected Test Results We encountered a number of challenges with trying to get the initialization procedure to work correctly in practice. As we executed the procedure in federation tests over a period of several months, we observed a variety of unexpected results.Some initial updates never receivedOne of the first things we noticed in early testing is that federates would consistently finish the initialization period with "uninitialized" objects.  In other words, a federate would correctly discover all of the applicable game objects registered by the CEP, but would never receive the initial attribute value update for some of these.  We verified that the CEP was issuing all of the correct "Update Attribute Values" calls, but for some reason a percentage of these were not resulting in "Reflect Attribute Values" callbacks on the subscriber side.   Discoveries after updates and out of orderAnother problem (which turned out to be related to the first) was that subscriber federates did not receive all object discoveries before updates started to arrive (our principal initialization requirement).  Instead, discoveries would continue to arrive after a federate had started processing attribute update reflections.  (Again, the CEP was correctly registering all objects and waiting for the "Federation Synchronized at publish/subscribe/register" callback before sending out any updates.)Furthermore, we observed that the order in which objects were discovered at a subscriber federate was different than the order in which the CEP had registered them.  These results were especially puzzling in light of assurances we had received from RTI developers that the RTI 1.3 would exhibit first-in first-out (FIFO) behavior between any two federates, as long as reliable transport was used.  Time-constrained federates racing aheadAnother unexpected result later in our testing involved the time management portion of the initialization procedure.  As soon as the "running" synchronization point was announced (signaling the end of the initialization period), one or more of the time-constrained federates would "race ahead" in federation time as if there were no time-regulating federate.  We verified that the CEP was indeed enabling "time regulating" status during the "time_management_on" phase, and that all federates were invoking the synchronization point services at the appropriate time.  Nevertheless, these constrained federates would still begin advancing time rapidly before the CEP had advanced at all.   Synchronization points did not seem to helpA common theme in all of these problems is that the synchronization points did not seem to be functioning as we had anticipated.  These were precisely the kinds of issues that the initialization procedure was supposed to solve—ensuring that all discoveries arrived before any updates, allowing all federates to turn on time management together before requesting time advance grants, etc.  Judging from the test results, however, something different was obviously happening.  Consider, for example, the sequence of initialization events shown in Figure 3, which is typical of what we saw in our testing logs.  Output traces from the CEP and from a subscriber federate are shown side by side, with arrows showing which callbacks on the subscriber  side were generated by which service calls on the CEP.  The "Federation Synchronized" callback generated by the RTI is shown as a heavy line.  One would expect that none of the arrows would cross and that all of the arrows with origins before the synchronization point would also end before the synchronization point.  The heavy arrows show instances where these expectations are not met.Note that even though the CEP registers all objects before achieving synchronization point p and then waits for "Federation Synchronized" before announcing point u, the subscriber federate does not even discover object y until well after u is announced.  Yet the update for object x actually arrives at the subscriber before u is announced.  The other problems discussed in this section of missed updates (for object y) and the re-ordering of discoveries can also be observed.  The synchronization points in this case seem to be completely unrelated to the ordering of other events. RTI 1.3 Implementation detailsIn talking with the RTI developers, we learned that all of these unexpected results were due to implementation details of the RTI 1.3—details of which we had been unaware during federation design.  Many of these implementation details involved performance optimizations added by RTI developers for the 1.3 software.  Those that help explain our results are discussed briefly below.  Bundling of object discoveriesBeginning with version 2 of the RTI 1.3, object discovery messages are "bundled" by default  (Specifically, it is the Distribution Object Manager or DOM objects that are bundled.)  This means effectively that several discovery notifications are held and then sent together as a bundle.  Because attribute update messages are not bundled but are always sent immediately, this helps to explain how some discoveries could arrive after updates on the receiving end.  In addition, with earlier versions (prior to version 4) of the RTI 1.3, if an attribute update message for an object arrived at a federate's local RTI component (LRC) before the discovery message for that object, the update was simply discarded because the object was unknown to the LRC.  This explains our missed initial updates.  A portion of the discoveries were delayed long enough so that when they finally arrived at a subscriber, the LRC had already received and discarded the corresponding update messages.  (Since version 4, there has been a RID parameter which can be adjusted to cause update messages themselves to prompt discovery of the object if it has not already occurred.)  The ordering difference between registrations and discoveries was also a side effect of this bundling. The DOM object bundles are stored in a hashtable and then sent out in hash order. Independence of synchronization point servicesOur synchronization points had not worked as anticipated because, as we learned, there is no relationship between the synchronization point services and other HLA services.  In fact, they are effectively independent of the other services in the path they take through the network.We had designed our initialization procedure with the assumption that synchronizing the federation would function as a kind of global "flushing" mechanism, where all services called by each federate prior to achieving a given synchronization point would finish propagating their results across the federation before the "Federation Synchronized" callback for that point was sent out.  But this is not the case.  Because the synchronization point messages actually travel on a separate path or "channel" with the RTI 1.3, the order in which they are received has little to do with the order in which other callbacks arrive. This explains both why we could get discoveries during the "update" phase of the initialization procedure and why the constrained federates could still race ahead after the federation synchronized on "time_management_on."  In both cases, the "Federation Synchronized" callback (and the announcement of the next synchronization point) would arrive before callbacks generated by earlier service calls.  In the time management case, for example, the notification that there was a time-regulating federate present would not be received by a constrained federate until some time after the federation synchronized, "running" was announced, and the federate had already begun requesting time advance grants.  (The "Time Constrained Enabled" callback is a local operation which takes into account only the time-regulating federates that are already known when "tick" is called.) Multiple paths through the networkThe "separate paths" through the network referred to in the previous paragraphs exist for several reasons.  First, some service messages (such as synchronization points) go through the fedex, while others (such as attribute value updates) travel directly point-to-point.  Also, by default the RTI 1.3 uses multiple processes (known as "reliable distributors") to handle the distribution of the reliable message traffic.  So in one federation, there can actually be a number of possible paths between any two federates.  Evaluating the SituationComplications due to incorrect assumptionsWe were initially surprised to learn about these RTI 1.3 implementation details, mostly because they shattered various incorrect assumptions that we had made.  It also seemed to us that these implementation decisions caused the RTI to behave in non-intuitive ways.  It is important to note, however, that none of these implementation details violate the HLA specification.  On the contrary, the RTI 1.3 is perfectly compliant with the 1.3 specification.  The specification is simply silent on all of the issues discussed above.  It says nothing, for example,  about a relationship between synchronization points and object registrations.  It  likewise says nothing about discoveries happening in the same order as registrations.  So RTI developers are free to make the kinds of implementation decision described.  In short, all of the complications we encountered can be traced to two incorrect assumptions that we had made during the design of the initialization procedure.  The first of these was to think of the RTI in terms of a "single pipe" model, where messages exhibit FIFO behavior between any two federates.  Much network communication behaves in this way, so it is somewhat natural to apply this model—even subconsciously—to the RTI in one's thinking. The second assumption was that, even in the absence of FIFO behavior, the synchronization point services would provide a mechanism to control the order of other services.  We assumed that there was an implicit relationship (again based on the single-pipe model) between synchronization points and other messages.What do synchronization points guarantee?Understanding the way synchronization points are implemented in the RTI 1.3, we were forced to re-examine how and if they could be used effectively during federation initialization.  The key was in understanding what these synchronization points can and can not communicate.  Although they do not communicate any kind of global state (as we had anticipated), synchronization points as implemented are still a good mechanism for one federate to notify others that it has reached a certain state in its processing.  The caveat is that the federate must be able to determine independently if it has reached that state. For example, each federate knows when it has registered all of the objects that it is supposed to, so this fact can be communicated through a synchronization. point.  But a federate has no way of knowing when it has discovered all of the federation objects corresponding to its subscriptions, or when it has reflected all of the updates that have been sent out at any given point in time.  These events can therefore not be communicated with synchronization points. The biggest problem with our initialization procedure is that we were trying to use synchronization points to communicate states that federates could not determine independently—states such as when all objects have been discovered, when all updates have been received, when time management switches have propagated across the network, etc.  Once we understood the limitations on what our initialization synchronization points could actually communicate—that the service calls had been completed but that the callbacks may not have arrived—we could make alternate design decisions.  Initialization Solutions With a more complete understanding of the RTI 1.3 implementation, we tried various things to see if we could still achieve our original initialization requirements.  Adding another synchronization pointWe first added an additional phase and associated synchronization point to the initialization procedure.  While a federate has no way of determining whether it missed the initial update for a discovered object (e.g., because the discovery was delayed), it does know whether or not it has ever received an update for the object.  We exploit that fact by using a synchronization point named "reflect" following the "update" phase, in order to address the problem of missed updates.Our revised initialization procedure is given in Figure 4.  As shown, the "reflect" phase gives all federates the chance to request any updates that they may have missed. A federate does not achieve "reflect" until it has received an initial attribute value update for all of the objects it knows about.  If at the end of "update" a federate still lacks values for some attributes, it can begin requesting them, since it knows that the publishing federates have finished sending initial updates.  Once the entire federation synchronizes on "reflect," it means that all federates have the initialization data they need.The problem with this solution is that it sill relies on one major assumption.  This assumption is that all discoveries stemming from registrations in the "publish/subscribe/reflect" phase will arrive before the end of the "reflect" phase.  Obviously, a federate can only request an update for an object if it has already discovered it.  If a discovery message were delayed sufficiently not to arrive until "time_management_on", the subscriber federate could still end up with an uninitialized object.  In practice, the assumption that all discoveries will arrive within some bounded time seems to hold true, and adding the additional synchronization point has the benefit of allowing more time for lingering discovery callbacks to reach their destinations.  (We never observed discoveries that arrived following the "reflect" phase).  Admittedly, though, it is still a theoretically unsatisfying solution.Experimenting with the RID fileIn discussing our initialization challenges with the RTI developers, they recommended experimenting with different parameters in the RID file. This file contains numerous settings that control the RTI's behavior in many ways, including whether or not it uses some of the performance optimizations.We performed some limited experimentation with four parameters in the RID file.  We tried setting "dom_update_rate" to zero, to cause all DOM object updates to be sent immediately and thus prevent any bundling of object discoveries.  We likewise tried setting "tcp_bundling_toggle" to false, to avoid any bundling of the TCP messages themselves.  After version 4 of RTI 1.3 was released, we set the "default_heavyweight_interval" to zero, to force complete DDM information to accompany every attribute update and thus permit update messages to force discovery when necessary.  Finally, we altered various settings to force the RTI to use a single reliable distributor, permitting only a single path through the network between any two federates.  We varied the settings for these four parameters separately and in combination with, to see what how it affected the RTI behavior.  We achieved somewhat mixed results with these efforts.  Although we successfully solved the problem of missed attribute value updates, we were yet unable to achieve our initialization goal of receiving all discovery callbacks before any updates arrive  Regardless of what we varied, we still observed late object discoveries and inconsistent synchronization point behavior.  We expect, however, that with the recent release of the graphical RID editor, performing additional experimentation of this nature will become easier.  Pausing before synchronizationTo make initialization work in practice, we eventually resorted to inserting pauses in the code at various points.  We discovered, for example, that a pause of 10 seconds between the time that all objects were registered and the time that "publish/subscribe/register" was achieved by the CEP provided enough time for most of the discovery callbacks to happen on the subscriber side.  We did a similar thing at the end of the "update" and "time_management_on" phases.  As with object discoveries, pausing for 10 seconds after setting the time management flags but before achieving "time_management_on" was sufficient for the RTI to communicate which federates were regulating and which were constrained, thus fixing the problem with constrained federates racing ahead.The drawback to this solution is obvious.  How does a federation determine how long is long enough to pause?  While 10 seconds was sufficient in our particular federation  situation, one can only guess at how this figure might increase with additional federates or objects.RecommendationsWe close with a set of recommendations based on our experiences—recommendations aimed at both the present and the future.  For the short term, we offer some suggestions to developers building federations with the current RTI 1.3.  We then advocate adoption of a longer-term, more general solution involving enhancements to the HLA specification itself.  Recommendations for RTI 1.3 federationsThe most important lesson from our experience is to be aware of any assumptions you have about the RTI's behavior and to carefully verify these assumptions before making important design decisions.  In particular, do not rely on FIFO behavior for messages between two federates—either with repeated invocations of the same service (e.g., multiple registrations) or with different services executed in sequence (e.g., an interaction followed by an object deletion).  At runtime, the order can be different on the sending and receiving ends.  It is also essential to understand the limitations of synchronization points if you plan to use them in any way.  As discussed above, the synchronization point services have no relationship with any other services except themselves.  Put another way, all you can be sure of when you receive a "Federation Synchronized" callback is that the other federates have each performed "Synchronization Point Achieved."  This is still useful in some situations.Be aware that using a synchronized initialization procedure like the one we describe has associated costs.  Using synchronization points places constraints both on which federates can join the federation and when they can join.  Because synchronization points are announced to all joined federates, every federate needs to achieve them before the federation can proceed.  This means that only synchronization-point-capable federates can join—at least until initialization is over.  This is important to keep in mind if one wants to use federation logging or management tools, for example, since generic tools may not have a good mechanism for responding to synchronization points.Even if a federate has implemented synchronization-point-handling code, it also must be able to capable of behaving appropriately depending on when it joins the federation.  Our initialization procedure assumes that all federates will join at the beginning and then execute the procedure together. Nevertheless, it makes testing much more difficult if a federate is unable to join after initialization is over.  If this is the case, every time a federate crashes and wants to re-join, the whole federation must be re-started.  To be robust, any federate that wants to participate should include code that can detect and correctly handle any of the three joining possibilities: before, during, or after initialization.  If a federate joins after the initialization procedure is over it may need to handle initialization-related tasks (such as getting an initial update for all subscribed objects) differently.Depending on the needs of the federation, such overhead could possibly be avoided by foregoing a formal initialization procedure and effectively treating every federate as a "late joiner."  In this method of initialization, for example, a federate would always request an initial attribute value update upon discovery of an object (rather than waiting for them to arrive during an "update" phase).  This is a simple and safe approach, provided that the number of federation objects is small enough that redundant attribute value requests do not adversely affect performance.  With tens of thousands or hundreds of thousands of federation objects (as  exist in large JTLS scenarios), the requirement of sending only one initial update per registered object is important.  In the general case, of course, a federate can not assume that it will automatically receive an initial update for each newly-discovered object.  And in general federates should be designed to be independent of a specific initialization procedure as much as possible.  A federate can be programmed to expect a certain initialization protocol, but it should still be able to function correctly even if another federate does something wrong.  Finally, the most practical advice is that you need to allow the RTI sufficient time to deliver all callbacks during the different phases of  initialization.  Because synchronizing the federation does not do this in and of itself, pauses should be inserted in the code of one or more federates (with the RTI's timed "tick" call) before the federate achieves each synchronization point, as described above.  The length of time one needs to wait in a particular federation will need to be determined empirically.Recommended refinements to RTI servicesAlthough we did develop practical solutions for the initialization complications we encountered, we are convinced that the best solution for the kinds of problems we describe would be to strengthen the HLA specification slightly.   Because of the current specification's silence on some issues, we do not believe that there is a "foolproof" way to achieve all of our initialization requirements.  The basic problem is that it is currently difficult to control the order in which things happen in a federation without using the time management services. Placing time stamps on messages is the only way with the current RTI 1.3 implementation to affect the order in which callbacks arrive.  But, as in our case, a federation may have valid reasons for deferring the use of time management in certain situations like federation initialization.  Some federations may also wish to avoid the time management services altogether, as in the case of so-called "real-time" federations.  Furthermore, time stamps  apply only to attribute value updates, interactions, and object deletions.  You can not use time management to specify the order of discoveries, for example.  And without some level of control over the order of federation messages, it is difficult to design a federation.Two simple additions to the HLA specification would make it easier to control the order of federation events.First, the specification could require a relationship between synchronization points and a set of other HLA services—including those like object registration that have no associated time stamps. Second, for all of the call-callback service pairs (e.g., register/discover, update/reflect), the specification could mandate that ordering between any two federates be maintained (per-source ordering). These two additions would be extremely beneficial to federation developers.  The first would make synchronization points much more useful as an ordering mechanism in cases where time management is not or can not be used.  The second would cause the RTI to behave in a more predictable FIFO manner for sets of identical service invocations (although developers would still need to be cautious about the ordering between different services).Either of these additions to the specification would make it possible to define a theoretically correct initialization procedure for the JTLS-GCCS-NATO federation with our specified requirements.  Having both would provide even more flexibility.  Furthermore, these additions would cause the RTI to behave in a more intuitive manner overall.  People naturally begin with a set of assumptions about what constitutes "reasonable" behavior for an RTI, and these suggested additions would help to avoid surprises like those we experienced.ConclusionIn conclusion, it is difficult (if not impossible) to define a theoretically foolproof initialization procedure with goals similar to ours using the current RTI 1.3 implementation.  This could be remedied by making the HLA specification more explicit about synchronization-point and ordering behavior in the RTI. In the meantime, there are practical ways to accomplish initialization successfully.Acknowledgments The author wishes to thank the following members of the federation development team for the contribution of their creativity, energy, and experience to the project:  Jonathan Roberts, Reenah Kang, David Ward, and Ellen Roland (JTLS); Cheryl Ammann and Dennis Brockway (GDS); Sherry Barnes (OTH GEM); Jennie Womble and Chip Bulgin (GCCS); Steve McDonald and Nils Reker (PVD); and Tom Koolen, Aad Van Stegeren, and Anton Van Weel (NC3A).  Appreciation is also expressed to Jean Graffagnini and Steve Wurster for integration support and FOM management.  The proposed initialization procedure upon which we based our work was developed by David Seidel of The MITRE Corporation.ReferencesJ. Nielsen and M. Salisbury: "Challenges in Developing the JTLS-GCCS-NC3A Federation," Fall 1998 Simulation Interoperability Workshop (98F-SIW-153), September 1998.U.S. Department of Defense: "High Level Architecture Federate Interface Specification, Version 1.3," 20 April 1998.Author BiographyJEFF NIELSEN is a Software Systems Engineer at The MITRE Corporation. As a member of the HLA Cadre team, he provides technical and management support to DMSO-sponsored federation efforts, including the JTLS-GCCS-NATO federation.  Mr. Nielsen holds an M.S. in Computer Science and an M.A.Ed. in Instructional Technology, and is currently pursuing a Ph.D. in Computer Science.Figure 1: Conceptual Diagram of the JTLS-GCCS-NATO FederationFigure  SEQ Figure \* ARABIC 1Figure 2: First Version of Initialization ProcedureFigure 4: Revised Initialization ProcedureFigure 3: Sample Initialization Event Trace