Simulation Initialization and ControlGeoff Sauerborn Gary MossRichard PearsonUS Army Research LaboratoryATTN: AMSRL-WM-BFAberdeen Proving Ground, MD  21005-5066Alan ScramlinUS Army Aberdeen Test CenterATTN: STEAC-TC-VAberdeen Proving Ground, MD  21005-5066Keywords:HLA, bootstrapping, RTI, NON-HLAABSTRACT: Several services are built into the Department of Defense High Level Architecture (HLA) specification which facilitate simulation (federate) management and control.  Control of this nature is extendible to the simultaneous management of numerous federates.This paper outlines the design for a prototype simulation testbed being developed at the U.S. Army Aberdeen Test Center.  This testbed intends to use these HLA services to initialize and control federates during a simulation exercise.  Inherent limitations of this control method are pointed out, especially concerning "uncooperative" federates.  Non-HLA extensions that allow centralized and automated control of simulation bootstrapping (federate launching) and termination are explained.1. IntroductionThis paper outlines the design for a prototype testbed for simulations being developed at the U.S. Army Aberdeen Test Center.  The testbed is intended to be a workstation for controlling distributed virtual tests. To monitor and control simulations, the workstation design capitalizes on simulation management (SIMAN) features built into the High Level Architecture (HLA) specification.  The intent is to use these services to initialize and control federates during a simulation exercise.  Inherent limitations of this control method are pointed out, especially concerning "uncooperative" federates.  Non-HLA extensions (that do not violate the HLA rules) are explained.  These extensions allow centralized and automated control of simulation bootstrapping (federate launching) and termination.2. Overall DesignThe purpose of the Ground Systems Testbed (GSTB) is to allow a test engineer to design, configure, execute, control, and analyze the results of a virtual test.2.1 Design – PhilosophyThe central philosophy of the design is to allow the test engineer to concentrate on the business of conducting the simulation and analyzing resulting measures of performance.  In order to facilitate this, the testbed is designed to insulate the operator from unnecessary details of a simulation (unless the user deliberately wishes to expose certain details). Additionally, to the extent that it is practical, we wish to automate the setup, initialization, and management of federates and the overall federation exercise. Simulation details come in many forms and fidelities such asScenario Description Network Topology Parameter Initialization and MonitoringScenario Description usually implies the highest conceptual view of the simulation. A scenario description is applicable to the entire simulation exercise as well as individual components.  The scenario describes the intent of what the simulation or components are supposed to do in an operational notion.   Network Topology involves simulation components and their connective topology.  It includes both the notional network topology (as that is implied by the HLA Federation Object Model (FOM), the organization of the runtime data exchange), as well as the physical network topology.  The physical topology is concerned with items such as network address, which federates are run on what computer resources, etc. Parameter Initialization and Monitoring involves assigning values to simulation parameters (especially during simulation initialization).  This is implicitly tied to the scenario development phase.  Parameter assignment must comply with the intent of the virtual test (scenario).In this paper, we shall concentrate on parameter initialization and on how the GSTB implements federate initialization within the context of HLA.  First, we shall describe the GSTB’s overall architecture at a high level.  Finally, we shall provide further details about those portions of the architecture that relate directly to simulation initialization and control.2.2 Design – High Level ViewThe GSTB is logically organized into a three-tier architecture.  Tier 1 constitutes user level applications and interfaces implemented using thin clients as JAVA applets.( Tier 2 is used mostly for middleware services used to execute and control tier 3 resources.  The resource layer (tier 3) is where resources (such as databases, HLA simulations, hardware-in-the-loop, etc.) reside. Figure  SEQ Figure \* ARABIC 1.  Architecture High Level ViewTier 3 resources may already be connected in some manner.  The GSTB does not itself connect applications to each other, instead, notions of each component’s built-in connectivity capability is maintained in a tier 3 database, as we describe next.  2.3 Design – Model Descriptions Language (MDL)All descriptions about a simulation or component are contained in a relational database.  This information is stored in records we call Model Description Language (MDL) records.   Included in the MDLs are references to data such as (parameter) initial conditions and operational range (parameter envelope). This has great potential to assist the virtual test designer (the GSTB operator) by implementing data input validation.  Certain errors can easily be avoided such as assigning parameters an out-of-range value.  Later, we shall see how the design proposes to use these records to initialize simulations. Initialization information and allowable parameter range are not the only data recorded in the MDL records.  Logical connectivity of the components (whose connectivity is already programmed) is also registered in MDLs.  Using this information, tier 1 and tier 2 have the potential to deduce any required (but missing) distributed components.  It should also be possible to recommend alternate components that may accomplish the same or a similar required task.  With further work developing the metadata descriptions, there is the potential to automate more esoteric types of error checking during the scenario design.  For instance, notions of fidelity might be encoded in the MDL.  This could prevent mismatching components with differing fidelities or trying to combine components with incompatible concept models of the mission space (CMMS).  In effect, this would allow the MDL to be used to describe the CMMS of the model at a certain fidelity level with fitness of use for a particular purpose. The completeness of the descriptive format and how well it can describe the conceptual model will directly impact the validation process.  Pace outlines some of the types of information that should be included in a CMMS structure to facilitate VV&A.1  This might be a good starting place when designing CMMS concepts into the MDLs.Assistance to the scenario developer is not limited to error checking.  For example, the GSTB may be able to suggest components that could be used to replace a missing component, or recommend components to be used as a translator between two otherwise incompatible components.  This is because MDL metadata include component dependencies (information about input requirements) as well as provisions (information about the type of output or service that a component provides). Using this information, tier 1 user applications should have access to enough information to determine which components are meant to communicate or could serve as a translation service between components.  (Algorithms that process these data can be placed on any tier that makes sense, thus are not limited to tier 1.)The approach of describing models and simulation components with metadata is not new.  The Defense Modeling and Simulation Office (DMSO) is currently working on a scenario description format called “Order of Battle Data Interchange Format (OB DIF)”.  However, thus far, OB DIF has been focused on platform level scenario descriptions and is not suited for the engineering-level focus of the GSTB.  [See:  HYPERLINK "http://obdif.arlut.utexas.edu/" http://obdif.arlut.utexas.edu/]  Hunt and Harte have presented a similar approach (at the platform level).2  They are using a macro/metadata approach to describe the simulation exercise scenario.  That scenario description is edited and stored at one user interface toolkit, then passed onto a separate simulation execution phase.The Extensible Markup Language (XML) is ideal for imbedding data such as parameters and their default values.4   Since there is currently no DIF suitable to be used as an MDL export format, we have chosen to keep MDLs in their current relational database structure and export them using XML.  XML lets you define your own markup language, unlike the HyperText Markup Language (HTML) which has a predefined fixed format.  The XML standard is maintained by the World Wide Web (WWW) Consortium (W3C).6    XML is not only a flexible document encoding format, but it is particularly suited for serializing relational database information (like our MDLs) and metadata properties of web-based resources.  This is the current extent of XML’s use in the GSTB, but it probably has a bright future in general Modeling and Simulation (M&S).There have been several Simulation Interoperability Standards Organization (SISO) papers suggesting direction and XML’s M&S application.  Lacy and Tuttle give a good overview of its general application to M&S particularly in recommending its use to create a self-describing data formats.  This general data interchange format (DIF) would contain (an XML tagged) Context Free Grammar using Backus-Naur form (BNF).  Their paper also has a nice list of XML references.5  Miller and Filippelli presented its use as an alternate Object Model Template file format.6Design – Details Regarding Modeling & Simulation ControlFigure 2 reveals a more detailed view of the types of services and components within the GSTB’s three tiers.Figure  SEQ Figure \* ARABIC 2.  GSTB Architecture - detailed.Note in Figure 2 a form of the familiar HLA “lollipop” diagram (repeated in Figure 3). Figure  SEQ Figure \* ARABIC 3.  Execution Servers Bootstrap Federates.The HLA-specified connectivity through the HLA Run Time Interface (RTI) is displayed with the “lollipop” shaped bubbles labeled “RTI exec,” “Fedex,” “federate,” and “Management Object Model (MOM) Federate.”  These bubbles communicate through the block labeled “Inter-process Communication” where the RTI passes HLA data objects.However, note the addition to this traditional HLA lollipop schematic.  In this same diagram, there exists connectivity from the GSTB to the federates via the execution server blocks (bypassing the RTI).   HLA rule 3 states that all FOM data among federates shall pass via the RTI.7  However, bypassing the RTI in this manner this does not violate HLA rule 3 as explained next in section 2.3.1.The Process Manager Daemon (PMD)This is a remote application (remote as seen from the perspective of the GSTB workstation (user interface layer / first tier).  The PMD application resides on the host machine on which an application is to be executed.  Its purpose is to provide bootstrap level start-up and shutdown access to that application.  The PMD is highlighted in Figure 4 and is actually labeled “Execution Server.”  Figure 4.  The (remote) Process Manager Daemon (PMD).The PMD acts much like a daemon in that it resides active in the background on a host system and waits for commands.  It does not communicate any HLA runtime FOM data on behalf of the federates (as this would be a violation of the HLA rules).7  The link from the PDM to a federate is used to execute “hard” controls (such as bootstrapping or terminating the federate process on the host system).  JAVA has a runtime object implemented in its current Java Development Kit (JDK 1.2) release which makes it possible to execute a native process and return an instance of a Process object.   The Process object is therefore pure JAVA and platform independent.  This object can be used to monitor and control the process at a fundamental level (e.g. start, kill).  The controls provided are somewhat primitive, but they have proved sufficient thus far in the GSTB’s current implementation.Though Figure 3 displays only HLA federates as being launched (and possibly shutdown) by PMDs, it is not a requirement that the bootstrapped program be a federate.  PMDs may execute (launch) any program (HLA or non-HLA).  Furthermore, even though Figure 3 shows only one application per PMD, a single PMD may simultaneously launch and monitor numerous programs.  It is expected that only one PMD will reside on a single host machine, though this is not a solid requirement at this time in the GSTB’s design and may change as the PMD is implemented. The PMD communicates with the tier 2 Process Manager Controller (PMC) via a JAVA Remote Method Invocation (RMI) link (see 2.3.2 PMC).  The tier 3 PMD acts on commands sent to it by tier 2.2.3.2   The Process Manager Controller (PMC)As Figure 5 shows, the PMC maintains control of all connections to all PMDs.  The PMC is the module that sends the commands, such as “launch application” (paraphrased) to the PMDs.  It is expected that the PMC will be a single module or application; however, this is not a necessity as there are means by which this functionality may be distributed among many tier 2 modules, which effectively operate as a unified remote process controller. Both the PMD and PMC are JAVA applications and communicate via JAVA RMI.Figure 5.  The Process Manager Controller (PMC)The PMC shall receive its commands from the GSTB operator on tier 1 (via an RMI link).  The actual command sent to the PMC from the user-level interface will be a relatively high-level command.  For example, a command sent to the PMC (from tier 1) might be, for example, “launch HLA applications participating in a particular pre-defined scenario” (paraphrased).   The PMC will then retrieve (or have passed to it from tier 1) the MDLs associated with that pre-defined test scenario.  Following this, the PMC will decompose each MDL to determine the appropriate commands to be sent to the tier 3 PMDs in order to launch each HLA federate that participates in the pre-defined test scenario.3. Design Relating to HLA Simulation Control MechanismsThis section explains the specific portions of the overall design that apply HLA to simulation initialization and control.  It covers the use of the MOM (in 3.1) and the how specific RTI APIs will be used to “push” attributes into an object’s state (in 3.2). Section 3.3 explains how federates must cooperate to make this state change meaningful and why it is important for federates to not only accept the pushed attributes values, but they must also implement the intent of the data push.3.1 Leveraging MOM data.The purpose of the GSTB MOM federate is to be the instrument by which HLA object data are initialized or changed.  At any time, this MOM federate can gain ownership of parameters and attributes of interest from the HLA federates that own them.  At the start of the simulation, it changes the state of parameters or attributes to reflect the initial value assigned by the GSTB operator.  After changing an object’s state, the MOM federate will then return ownership of those parameters or attributes to the original federate.3.2 Object State Change (Via Attribute Push).Federate Requirements:  The GSTB MOM capabilities just described imply that, to be highly integrated with the GSTB, HLA federates should implement the HLA RTI Ownership Management capabilities.8  These specifications are shown in Table 1.(Table 1.  HLA (v1.3) Object Ownership Capabilities for Robust GSTB integrationHLA IF Spec.HLA Interface (IF) Specification Title7.2Unconditional Attribute Ownership Divestiture 7.3Negotiated Attribute Ownership Divestiture 7.4Request Attribute Ownership Assumption † 7.5Attribute Ownership Divestiture Notification † 7.6Attribute Ownership Acquisition Notification † 7.7Attribute Ownership Acquisition 7.8Attribute Ownership Acquisition If Available7.9Attribute Ownership Unavailable † 7.10Request Attribute Ownership Release † 7.11Attribute Ownership Release Response While not the thrust of this paper, we have identified what we consider to be a desirable change to the HLA Federate Interface Specification.8  Specifically, there is no capability in the HLA services shown in table 1 that allow the MOM federate to ensure that it is returning attribute ownership to the very same federate that it is trying to initialize!  We are currently “working-around” this limitation by including a target federate designator in the “user-supplied tags” argument.  However, this requires special logic embedded in the initialized federate to process the user-supplied tag to achieve our desired result.  (The desired result being that the target federate and only the target federate is initialized).  This work-around is not a general-purpose solution that allows attribute modification of any HLA federate.   Therefore we wish to explore changing the HLA specification.In addition to initializing or modifying federate attributes, the MOM federate will also be used to access MOM data objects for the purpose of administration and control of the federation exercise as a whole.  This function alone can be a very intricate and complex application if implemented to a reasonably complete state.  It is expected that initially this will be implemented as a set of simple basic commands to one or more federates. These shall include the RTI IF specified federation-wide commands (Create, Destroy, Pause, Resume, Save, and Restore as shown in Table 2).   Table 2.  Required Federation Management HLA IF Specifications Implemented by the MOM Federate.HLA IF Spec.HLA Interface (IF) Specification Title4.2Create Federation Execution4.3Destroy Federation Execution 4.4Join Federation Execution 4.5Resign Federation Execution4.11Request Federation Save4.12Initiate Federate Save †4.13Federate Save Begun 4.14Federate Save Complete4.15Federation Saved †4.16Request Federation Restore 4.17Confirm Federation Restoration Request † 4.18Federation Restore Begun †4.19Initiate Federate Restore † 4.20Federate Restore Complete4.21Federation Restored † In the GSTB design, model initial conditions are fed into the system via MDLs.  This is where the MOM federate enters into the simulation control picture.  The MOM federate first sees what federates have joined the HLA exercise by querying MOM objects.  It then determines from the MOM what attributes are being published by a particular federate.  The MOM federate will use this information for a number of different actions. Mostly, it will be used to return information to the operator.  Examples of foreseen actions are answering the operator’s queries concerning publish/subscription for federates or reporting errors when an attempt is made to set an attribute not simulated (published) by a federate. 3.3  “Uncooperative” FederatesTo avoid being labeled “uncooperative”, a federate needs to do a little more than just implement the RTI services prescribed in tables 1 and 2.  After a federate has joined an HLA exercise, the GSTB will control it, by changing its attribute values as necessary.  It is therefore incumbent upon the federate to use this updated attribute value to reflect an “expected” new state.  The federate may appear to be uncooperative in this regard if the next state updated is not dependent on the variable being updated.  (For example, a ground vehicle federate that updates its position based on some pre-defined path, modifying this federate’s most recently published position, will have no effect on its next position state update.)It also does not suffice to simply modify a single dependent variable.  All dependent variables must be accounted for when attempting to modify a federate’s state.   By way of example, a flight simulation federate which has its aircraft’s position and velocity changed should also have its orientation modified appropriately in order to be “trimmed” into the air currents to avoid structural disintegration.  Depending on the fidelity of the federate whose state is being modified, there may be more or fewer variable dependencies to be updated.  While the MDLs may contain some notion of variable dependencies, good object oriented design demands that it be the responsibility of the federate developer to assure these complex relations are upheld whenever a dependent parameter is (unexpectedly) modified. 4.  ConclusionsThe DMSO, by defining the HLA as a standard, has helped to facilitate interoperability and connectivity between M&S assets.  Furthermore the agency's sponsorship of HLA tools has made it possible for HLA Federations to be implemented in a cost effective manner, the difficulties of migrating legacy applications to HLA notwithstanding.  However, to deploy this technology to the consumer requires a tremendous amount of packaging to insulate him/her from the complexity of configuring and launching the HLA federates.  At ATC, we are developing the GSTB for the test engineer who does not necessarily have any background in running M&S.  More likely the engineer is accustomed to designing, configuring, executing and controlling live tests exclusively.  Therefore the GSTB must provide a user interface which presents the engineer with information about the available assets in familiar terms and provide the means to configure a virtual test without knowing details about how to run each federate, or how to start up the RTI.  We believe that MDL metadata can be designed that can describe M&S assets to facilitate configuration at the federate level (or equivalent for non-HLA assets) as well as initialization and control of these federates during a virtual test.  Furthermore, we intend to design the MDLs and related components of the GSTB architecture to be applicable to a wide range of M&S domains beyond T&E.  Finally, by using the XML standard to represent the serialized version of the MDLs, the GSTB and follow-on development efforts can leverage the growing number of editors, validating parsers, browsers and other tools that are available for dealing with this powerful language for data exchange.5.  References[1]	Pace D. K., “Conceptual Model Descriptions”,  Proceedings of the Spring 1999 Simulation Interoperability Workshop, Simulation Interoperability Standards Organization, March, 1999. [99S-SIW-025] [2]	Hunt K., Harten E.: “A New Paradigm for Developing and Maintaining Scenarios for Distributed Simulation Systems” Proceedings of the Spring 1999 Simulation Interoperability Workshop, Simulation Interoperability Standards Organization, March, 1999. [99S-SIW-179][3]	Garingo G., Augins J., “XML to facilitate Interoperability between Repositories” Proceedings of the Spring 1999 Simulation Interoperability Workshop, Simulation Interoperability Standards Organization, March, 1999 [99S-SIW-175] Gary D. Garingo Innotiv Incorporated 8799 Balboa Avenue San Diego, CA 92123 619-268-1102 x206 garingo@webeng.com  James S. Augins Innotiv Incorporated 8799 Balboa Avenue San Diego, CA 92123 619-268-1102 x203 augins@webeng.com] Ken Hunt, AEgis Research Corporation, 6703 Odyssey Drive, Huntsville, AL 35806, 256-922-0802, khunt@aegisrc.com,   and LT Eric Harten, Electronic System Center, 5 Eglin Street, Hanscom AFB, MA 01731, hartene@hanscom.af.mil[4]	T. Bray, J. Paoli, C. M. Sperberg-McQueen, editors: “Extensible Markup Language (XML) 1.0”, World Wide Web Consortium (W3C) Recommendation, February 1998  [HYPERLINK "http://www.w3.org/TR/REC-xml"http://www.w3.org/TR/REC-xml]. [5]	L Lacy, C Tuttle, “Interchanging Simulation Data using XML”, Proceedings of the Fall 1998 Simulation Interoperability Workshop, Simulation Interoperability Standards Organization, September, 1998. [F98-SIW-193]. Dynamics Research Corporation 11800 Research Parkway, Suite 100 Orlando, Florida  32826 Lacy@Orlando-DRC.com  CTuttle@Orlando-DRC.com ] [6]	Miller G., Filippelli L., “An XML Representation of HLA Object Models”, Proceedings of the Spring 1999 Simulation Interoperability Workshop, Simulation Interoperability Standards Organization, March, 1999 [99S-SIW-089]  Gordon James Miller Lawrence J. Filippelli Ball Aerospace & Technologies Corp. 8381 Old Courthouse Rd., Suite 340 Vienna, VA 22182 703-917-9125 gjmiller@ball.com, lfilippelli@ball.com]. [7]	U.S. Department of Defense, “High-Level Architecture Rules Version 1.3”, 5 February 1998 (20 April 1998 Document Release).[8]	U.S. Department of Defense “Draft Standard [For] Modeling and Simulation (M&S) High Level Architecture (HLA) - Federate Interface Specification DRAFT 1”, 20 April 1998.Author BiographiesGEOFFREY SAUERBORN has gained extensive simulation experience, particularly in platform level modeling and few-on-few war gaming simulations. He has participated in numerous studies for the DoD, analyzed weapon systems performance, sensor performance, and conducted other trade-off studies relating to armored ground systems. He has experience in distributed battlefield simulation design and implementation and has written various distributed environment analysis tools.  Over the past 15 years, Mr. Sauerborn has served as a mathematician with the U.S. Army Research Laboratory. He has a degree in applied mathematics and a Masters degree in computer science.GARY MOSS has been a Computer Scientist with the U. S. Army Research Laboratory for 18 years.  Immediately after receiving his BS in Computer Science, Gary began work at ARL developing application software in C language under the UNIX Operating System.  His early work was related to geometric model development and model interrogation in support of Vulnerability/Lethality Analysis.  His particular focus was on 3-D graphics applications and user interfaces.  He devoted 10 years to the Modular UNIX Vulnerability Estimation Suite (MUVES) project at ARL.  MUVES is a comprehensive software architecture for conducting Vulnerability Analysis.   He was brought on board to develop the GUI and later became heavily involved in development of the core packages as well as serving as technical lead on the project.  Toward the end of his involvement with the MUVES project, Gary became involved with web development and created the MUVES web site.  About 2 years ago, Gary transferred to the Simulation Concepts Development Branch (in ARL/ISTD) which develops and integrates tools for synthetic environments.  In his new job, he has been using Java to develop cross-platform and web-enabled applications under Windows NT and UNIX with an emphasis on distributed client/server architectures, web-based GUIs and 3-D graphics for virtual environments. Biographical Sketch for Gary Moss updated Tuesday, June 08, 1999ALAN SCRAMLIN is a test engineer and mathematician at the U.S. Army Aberdeen Test Center (ATC).  He has more than 15 years’ experience in the test and evaluation field.  He has served as a test director for fielded Army combat systems and has also developed extensive expertise in the field of computer science.  He has been instrumental in implementing ATC’s real-time GPS capabilities.  His computer science related contributions to the Army have been demonstrated in networking and most recently in developing data-mining algorithms for large data sets captured from live ground systems tests.  He is currently completing a Masters degree in electrical engineering at the University of Delaware.  RICHARD PEARSON has worked for the Army Research Laboratory for more than 25 years.  The first 20 years were spent studying the gas dynamics of air blast and air blast simulators. For the last 5 years, he has worked in the area of combat simulation and weapons analysis. Mr. Pearson has a BS in Physics, an MS in Mechanical Engineering, and has recently completed a second MS in Computer Science. (  Thin Client - placing user interfaces on relatively low powered workstations to perform the bulk work or computations on other platforms.  This allows powerful server applications to be used on relatively slow (thin) client computers over relatively slow (thin) networks.( The † symbol indicates that this specified HLA interface is implemented as a callback form the RTI.