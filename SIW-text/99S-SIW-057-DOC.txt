SEDRIS Past, Present, and Future —Technically SpeakingBill HoranDr. Rob CoxScience Applications International Corporation12479 Research ParkwayOrlando, FL 32826407-207-2753, 407-207-3609horanw@saic.comcoxr@saic.comKeywords:  SEDRIS  ABSTRACT: SEDRIS stands for Synthetic Environment Data Representation & Interchange Specification. This paper describes the evolution of SEDRIS.  It begins by laying the foundation of why SEDRIS was started, which led to the objectives of the SEDRIS program.  Included is a discussion of the evolution of the SEDRIS data model and the SEDRIS Application Programmer’s Interface (API), including a discussion of the decisions that drove their design.    The current state of the SEDRIS software is discussed, including the data model, API, and the utilities present in the 2.0 release.  To a lesser extent, the design and evolution of many of the SEDRIS utilities is presented.  Possible future extensions to SEDRIS and the software utilities are also discussed, including the possibility of developing a means for SEDRIS-based applications to interact, as well as the possibility of providing a Java interface to SEDRIS. Further details on what SEDRIS is and what it is doing can be found at the SEDRIS web site at www.sedris.org.1. SEDRIS Past1.1 IntroductionIt has been the objective of the U.S. Department of Defense (DOD) for years to analyze its fielded and prototype systems’ capabilities.  To accomplish a portion of this objective, a modeling and simulation (M&S) activity was developed.  A significant component in this M&S activity was the creation of databases that represent the physical world.  To create a database requires a database generation system.  These systems are faced with the challenge of establishing consistent and correlated databases at the lowest possible cost, both in terms of time and money.The DOD attempted to address this problem in the 1980’s with a multi-service program called Project 2851.  The result of this project was the Standard Simulator Data Base (SSDB) Interchange Format (SIF) and the Standard Simulator Data Base Facility (SDBF) at Kirtland Air Force Base, New Mexico.  About the same time, the Simulation Networking (SIMNET) program began at the Defense Advanced Research Projects Agency (DARPA).  The key concept was the networking of homogeneous and later heterogeneous simulations.  Further requirements included a common representation of the environment among the heterogeneous simulations.  These requirements highlighted the new environmental data representation needs, as used by networked heterogeneous systems, which could not be met by existing interchange methods.  Further requirements were placed on the M&S community; in particular, those of the computer generated forces, high-density terrain, ocean, atmosphere, and space databases.Without an effective way to interchange the full range of environmental data in the networked M&S community, it became apparent a new database interchange mechanism was required.  Thus, the Synthetic Environment Data Representation and Interchange Specification (SEDRIS) program was born.  SEDRIS facilitates the transmission and reuse of environmental data among heterogeneous systems through a standard data representation model and interchange mechanism.  It fully represents the environment by capturing all data elements and their relationships.  It also provides a standard data interchange mechanism and format to support the distribution of environmental data and promotes the sharing of databases between simulations.1.2 The SEDRIS visionData interchange is not just for reuse in building M&S databases, but is key for achieving interoperability between distributed, heterogeneous training systems/networks.  The successful interchange of environmental data requires both a loss-less and an unambiguous transfer of data from one system to another.  Loss-less in the sense that no data is lost during the conversion interchange process.  Unambiguous in the sense that the meaning of all data interchanged is fully understood.  In the past, this interchange was accomplished by point-to-point conversions between two specific systems, often implemented as a program to translate from one file format into another.  This required the development of custom data conversion software because each database used different (often proprietary) formats.  The writing of the translation program usually represented a large learning cost for the programmer(s), in both time and funds, to learn the details of one or both systems (formats) involved in the conversion.  And then, if a new format or system came along that also needed to interchange data, all programmers involved in the interchange code once again needed to learn all of the details of the systems (or formats) involved in order to ensure that no data was being lost or misused.  Thus, it is an expensive and time-consuming process.The SEDRIS vision (and its process) is the creation of a data representation model that supports easy access to interchanged data through the use of Application Programmer Interfaces (APIs).  The “data model”, for short, enables the open interchange of data by providing a common representation from which native (possibly proprietary) data can be converted to and from SEDRIS.  Programmers no longer need to learn the complete details of the environmental representation of the other systems involved in the data interchange. Instead, programmers only need to learn the details of the SEDRIS data model and understand how to map their own data into and out of such representation. With its standardized data model and APIs, SEDRIS provides an open and integrated transmittal mechanism for all synthetic environment data, for both producers and consumers, at a considerable cost savings.1.3 The SEDRIS objectivesAs with any project, it must meet stated objectives of its sponsor.  For SEDRIS, the U. S. Defense Modeling and Simulation Office (DMSO) outlined in the DOD Modeling and Simulation Mater Plan that providing timely and authoritative representations of the environment is a core requirement to achieve interoperability among aggregated heterogeneous simulation systems.  SEDRIS accomplishes that objective and also promotes interchange and reuse.As conceived, the specific objectives of SEDRIS were:By using a data representation model, capture the complete set of environmental data elements and their relationships.Implement a standard API for accessing data elements.Minimize the cost to access and reuse data by lowering the software barrier to entry.Provide a standard interchange mechanism between database builders and consumers.Facilitate interoperability of networked heterogeneous simulations.Support reuse of environmental databases between disparate simulations.Use the same data model as an access mechanism to import and export source data into and out of various database generation systems.Promote consensus understanding of the diverse requirements and implementation choices used within the M&S community through education.1.4 History of the SEDRIS data modelThe primary key to realizing the objectives of SEDRIS is to develop a data model capable of representing all of the synthetic environment information needed for any simulation.  The representation must be defined so that everyone can understand all of the information stored using SEDRIS. This is how that challenge was attacked.In 1994 STRICOM/PM CATT gathered a small core group of people, with broad experience in the M&S community, who developed the initial data representation model. This model began as a discussion of concepts.  By December 1995, a diagram of the data model was called the SEDRIS Data Elements' Logical Relation Diagram.  The diagram showed some 69 “types” of data elements and their relationships.  Graphically, each “type” was represented by a rectangle, with the name of the type inside it, and arrows pointing to other elements to signify relationships between elements.  An associated text dictionary defined each of the types. In an effort to avoid confusion or arguments over the semantics of various possible representations, the “types” were referred to as simply “bubbles” or “things” — not objects, not classes, not entities, nor any other word with a preconceived and possibly overloaded meaning.Presentations were made to the Distributed Interactive Simulation (DIS) community using this “Bubble Diagram” of the SEDRIS data model.  These presentations were well attended and often generated interesting discussions, but the discussions were short lived.  A common complaint was that data model was too difficult to understand because it used its own, non-standard notation.  A portion of any SEDRIS presentation was spent on explaining how to read the diagram, which had nothing to do with interchanging synthetic environment information.  The key to understanding a common representation of the synthetic environment is to understand the concepts captured by the SEDRIS data model.  But in order to understand those concepts you have to understand the data model — and that was too much trouble for many.  It was suggested that SEDRIS would be better received if it could be more easily read, perhaps by adopting one of the various ‘standard’ data-modeling notations.In December 1995, SEDRIS dropped its home-grown “bubble” notation and represented the same information by using the notation of the Object Modeling Technique (OMT), often called the Rumbaugh notation after its inventor, Dr. James Rumbaugh.  “Types” or “bubbles” were converted into “classes”.  Many relationships and organizational rules that had been implicit or explained only in the data dictionary in the old data model became explicit in the OMT diagram of the new data model.  By June 1996, after many internal revisions and internal “releases”, SEDRIS started the clock over and created a release 1.0 for its internal developers.  By then, the OMT form of the data model diagram spanned ten pages, displaying one hundred and eighty classes and the relationships (such as inheritance, aggregations, and associations) between these classes.Ironically, an important part of any introductory technical presentation on SEDRIS still involves an explanation of how to read the notation used to display the data model.  While OMT is understood by many in the community, it is neither a universal language nor is OMT as popular as it once was.  The reader is referred to the “SEDRIS Future” section for what changes may be made to the SEDRIS data model to overcome these problems.Next, industry was queried for input in the extensive development of the SEDRIS data model.  The industry participants included a broad spectrum of data providers, database developers, and applications developers.  This group was employed to ensure the SEDRIS data model was complete and had the ability to support a wide variety of environmental representations and unique database designs.  These industry participants were required to develop mapping documents.  A mapping document shows the logical mapping of each item from a participant’s environmental representation into the SEDRIS data model.  It also shows the logical mapping of SEDRIS classes back into the participant’s native data format for all of the SEDRIS classes that a participant is interested in consuming. The process of developing a mapping document was required to ensure the SEDRIS data model supported all data types for the M&S community.  The participation of these industry members and their analysis of the SEDRIS data model through the writing of their mapping documents is the key to the success of SEDRIS.  These participants often found problems and inconsistencies with the data model — either information they needed which the data model had no place for, or a portion of the data model which they could not understand.  Of the original core SEDRIS team,  a few continued to work with the industry participants to create a new SEDRIS team — a team composed of all of the SEDRIS associates.  Since 1995, this new team, the SEDRIS Associates, has been refining, adding to, and sometimes even redesigning portions of the data model in order to achieve the creation of the SEDRIS data model available today.1.5 History of the SEDRIS APIThe SEDRIS Application Programmers Interface (API) is an interface between applications and the underlying SEDRIS transmittal medium.  This design allows for the independent evolution of the applications and the interchange data structures.  The API was defined as a ‘generic’ API in that it treated every SEDRIS class equally.  The API is very structurally oriented in that it deals with pointers to SEDRIS objects, and the relationships between SEDRIS objects.  Given a pointer to a SEDRIS object, the API could:Retrieve a list of the aggregates of the object (retrieve objects which contain the given object).  For example, given a Vertex, retrieve a list of the Polygons that contain the Vertex.  This is walking “up” the structure of a SEDRIS transmittal.Retrieve a list of components of the object (retrieve the objects contained by the given object).  For example, given a Polygon, retrieve a list of the Vertices contained by the Polygon.  This is walking “down” the structure of a SEDRIS transmittal.Retrieve a list of objects associated to by the given SEDRIS object.  This is walking “sideways” across the structure of a SEDRIS transmittal.  Within SEDRIS, if one object is associated to another object, this means that the two SEDRIS objects are different representations of the same notional object.  For example, a Union of Primitive Geometry containing numerous Polygons could be associated to a Property Grid, if both the Union and the Property Grid represented the same notional object, such as a portion of a terrain surface.Retrieve the data for an object.  For example, for a Red-Green-Blue Color object, retrieve the values for Red, Green, and Blue for that object.So, given a SEDRIS object, the API allowed one to go “up” from the object, “down” from the object, “sideways” from the object, or to retrieve the data for that object.  This summarizes the basic capabilities of the original API, and also explains why the API was “generic”.  It makes no difference to the interface whether an object is a Polygon, a Vertex, a Linear Feature, a Property Grid, or an object of any other SEDRIS class.  The interface provided the same capabilities for all objects.After much discussion, it was decided that the SEDRIS API would be defined as a header file written in ANSI C.  Other languages such as C++ and Ada were considered, but ANSI C was selected in an effort to minimize the cost of entry for SEDRIS users.  In 1994-95, C was seen by the SEDRIS core team as the best supported and the easiest language to link with, if it was necessary to link in an application using another language.  Many (to date, all) data providers implement their SEDRIS code in C++, but this C++ is “hidden” behind the C interface.  To a user of SEDRIS, data is read from the C interface that is defined by the collection of ANSI C SEDRIS header files.The original SEDRIS API was designed in 1994 by some of the designers of ModSAF.  Obviously, the most common function for a user retrieving data from SEDRIS is going to be “Give me the next object I am looking for.”  So, it is no surprise that the a large part of the SEDRIS API focuses on allowing users to specify what objects they want to retrieve.  Users create “search filters”, which include “rules” that an object must fulfill in order for that object to be returned to the user as the “next” object that the user is looking for.  The original rule set was designed as a postfix expression stored in an array, usually stored through the use of macros in order to make the expression easier to read.  Many new types of rules and other search criteria have been added to the API, but a search filter is still composed of rules encoded as a logical (boolean) postfix expression. A collection of macros and examples are still provided to make it easier for programmers to understand how to create search filters from the macros.The original API has grown over the years.  As functions were added, each function was examined with the question “Is this function necessary to retrieve data from a SEDRIS transmittal?” vs. “Is this function useful, but not necessary, to retrieve data?”  SEDRIS has two levels of its Read API, Level 0 and Level 1.  All necessary functions were placed in the Level 0 Read API.  Functions determined to be useful but not necessary were collected in the Level 1 Read API.  For example, a function that converts an image (a texture) from one scan direction to another is a Level 1 function.  That function is a very useful one for users who care about textures within SEDRIS, but it is not strictly needed.  SEDRIS fulfilled its goal of providing access to the data of an image object via the Level 0 API.  The encoding of that object is loss-less and unambiguous (the scan direction of an image is one of the many parts of information defined for an image).  The scan direction was not lost and is a readily understood (unambiguous) piece of information for anyone retrieving an image from SEDRIS.  The difficult part for a consumer is in dealing with an image if that image was encoded using a different scan direction than the one the consumer uses.  In order to make the life of a SEDRIS consumer easier, this additional ‘convenience’ function was created — a function to convert an image from one scan direction to another.  This is an example of one of the ‘convenience’ functions placed in the Level 1 API.Although the goal is still to keep the Level 0 API as independent as possible from the data model, a few dependencies were allowed to creep in.  Special functions to support the retrieval of data from images and data tables (including grids) were added to the Level 0 API. For all other objects, when retrieving an object’s data, all of the fields for that object are retrieved at once. Since images and data tables can potentially be very large, even larger than the amount of memory available on the user’s machine, it was decided to provide the ability to retrieve images and data tables a section at a time.  The size of the section is controlled by the user.Also, certain user directives for searching are based on the types of organizations allowed in the data model (such as organized by time, organized by level of detail, etc.).  If the data model changes in such a way that the definitions of images, data tables, or the organizational schemes are altered, then some functions in the Level 0 API also have to be altered accordingly.  However, that is only a small dependency between the data model and the API.  For the most part (for the rest of the over three hundred classes in the data model), changes to the data model have little or no impact on the interface defined by the API.Other APIs in addition to the Read API were created and added to SEDRIS.  One example is the Conversions API — a stand-alone API (an API independent from the other SEDRIS technologies) which is capable of converting between coordinate systems, color models, and units. Due to the usefulness of the coordinate system conversion code, it is expected that this Conversion API will be found to be useful far beyond the “normal” user community of SEDRIS.Another example of an additional API is the data model API.  The data model API is not involved in the storing or retrieving of SEDRIS data.  Instead, the data model API provides an online, read-only description of the structure of the SEDRIS data model.  For each class in SEDRIS, the data model API provides: the text name of the class, the subclasses of the class (if any), the types of associations, aggregations, and components of the class (if any), a complete technical description (name, size, length, type, etc.) of the fields of the class (if any),and other data model dependent information.1.6 History of the SEDRIS utilitiesA series of tools were envisioned to support SEDRIS users.  These tools would be based on the SEDRIS API.  Their function would be to aid a SEDRIS user in examining, validating, and viewing a SEDRIS transmittal.  The initial tools included tools such as Depth, Checker, Browser, Model Viewer, and the Side-by-Side Terrain Viewer.1.6.1 DepthDepth was designed as a basic debugging tool to be used by SEDRIS data providers.  Depth is a simple command line tool with no graphics or GUIs, written entirely in C.  Its output is entirely textual.  Given the name of a SEDRIS transmittal, the Depth program depth traverses an entire SEDRIS transmittal in depth first order (visit the ‘children’ of node before visiting the ‘siblings’ of a node), printing out each object as it goes.  So, basically, Depth prints out a text listing of a SEDRIS transmittal.  The output is indented to indicate the hierarchy levels of the transmittal, and the verbosity of the output can be controlled via command line switches.  This tool proved invaluable during the early development of the SEDRIS API to verify that a user could retrieve every object from a transmittal without ‘crashing’ the API.The original version of Depth was created manually, including the customized print statement for each class within SEDRIS.  Then, of course, the SEDRIS data model was updated.  This meant that for all of the classes changed, their print statements in Depth would also have to be changed.  It did not make sense to do this as a manual task every time the data model changed.  Using the SEDRIS data model API, Depth is now a ‘generated’ program.  A program was written to ‘generate’ the code for Depth.  For the most part, Depth is one large switch statement with a customized set of print statements for each class within SEDRIS.  Writing a program to query the data model API and to produce the appropriate C print statements based on the information from the data model API was much easier than re-coding each of the print statement by hand would have been.  Eventually, the print statements themselves were moved into the data model API so users can take advantage of these print statements to debug their own code.  Instead of creating their own debug print statements to print out a particular SEDRIS object, users can reuse the various printing functions now provided via the data model API.1.6.2 CheckerChecker also was conceived as a plain text program.  It looks for syntactical (structural) errors in a SEDRIS transmittal.  Once again, its purpose is to help data providers in developing code to produce correct SEDRIS transmittals.  It also is a plain, command line utility — pure text, no graphics, written entirely in C.  As it scans a transmittal, Checker reports on any errors it encounters — such as missing components that are required (for example, a polygon must have at least three vertices), or components which are not allowed (for example, attaching vertices to a property grid). Like Depth, Checker is an automatically generated SEDRIS product. Thus, it can always be kept up-to-date with the latest version of the SEDRIS data model.  Having no graphic dependencies (using only “printf” statements for output), Checker and Depth have no known platform limitations.  Checker and Depth will work on any platform that has a C compiler.1.6.3 BrowserBrowser is an X-Windows based utility written in C.  It presents a hierarchical view of SEDRIS objects in a transmittal and functions as a point and click browser.  Browser displays both the data values (the fields) and the components of any object.  It was designed as a quick demo for I/ITSEC ’96, and has evolved little, if at all, since that time.  Even so, it has been an extremely useful tool for consumers to use when examining and learning the composition of a transmittal from which they might want to extract some information.  Browser’s use of X makes it inconvenient, but not impossible, to run on a PC.1.6.4 Model ViewerThe Model Viewer is a visualization tool written in C.  It uses OpenGL for its graphics and originally relied on X and GLX for its windowing environment. Like Browser, given its dependency on X, the original Model Viewer is difficult to install on a PC.  One has to buy an X server that understands GLX for a PC.  For an easier method of running the Model Viewer on a PC, the reader is referred to the “GLUT Model Viewer” section of this paper, under “SEDRIS Present”.The Model Viewer was again intended for SEDRIS data producers, and it is technically oriented.  There is no GUI.  All input is done through the keyboard.  Each key controls one or more features of the viewer.This viewer displays polygons from the geometry of the Models in the Model Library of a SEDRIS transmittal.  It allows the user to examine each Model, one at a time.  User's viewpoint may move around the model — the model is always located at the center of the screen.  The Viewer provides support for viewing different levels of detail, different states of a model, and for texturing.  It also allows a user to examine the Images (textures) in the Image Library, one at a time.  It does not fully support all of the types of geometry possible within SEDRIS — it only supports polygons.  It does not support lights, or grids, or features, or anything else that is not a polygon.  Even so, it has been a very useful tool for debugging transmittals by examining models and for displaying models for demos.1.6.5 Side-by-Side ViewerOne key utility developed for SEDRIS was the Side-by-Side Viewer, written by AcuSoft.  The user interface for this program is in Java, but the graphics use Performer, so this application can only be run on an SGI (Performer is an SGI specific graphics system) at this point. This program displays up to sixteen databases at a time.  There are various display modes, all designed to allow the user to visually detect differences between the databases.  The program is intended to compare two or more databases with the understanding that the databases being compared are supposed to be “the same”.  Ideally, the databases would have no differences.  This program has been used to compare databases as such databases are translated into SEDRIS, into other formats, and then back into SEDRIS.  As a debugging tool, this program has been able to quickly show many problems that were introduced by various conversion processes.  The problems were examined, the bugs in the conversion programs were fixed, and all involved were grateful for the utility of this program.  This application is also an important tool in the study of potential interoperability problems that may arise between different systems who obtain the same source database, convert it to their internal format, and then provide the results back as a new SEDRIS transmittal.2. SEDRIS Present2.1 IntroductionSEDRIS 2.0 was released on January 7, 1999.  It can be found at the SEDRIS web site — www.sedris.org.  To find out what is currently available, the reader is referred to the web site.  2.2 SEDRIS data modelThe 2.0 release of SEDRIS includes three hundred and forty SEDRIS classes.  The OMT diagram covers twenty-three pages (and is available in either PostScript or PDF format).  The data dictionary, which defines and describes each of the classes, is also available in either plain text or in HTML.  The easiest way to use the data model is to examine the OMT diagram while sitting next to an HTML browser with the HTML version of the data dictionary loaded.  Within the HTML dictionary, all of the classes have the appropriate links to any and all related classes.  For a single class, the dictionary describes the class, gives examples of how to use the class, has a list of Frequently Asked Questions (FAQs) with their answers for that class, and lists the ANSI C structures used by SEDRIS to represent the data for that class.Certain parts of the data model are complicated enough to be worthy of their own separate, more detailed explanation.  Technical guides are being written to cover the following topics within the SEDRIS data model: Topology, Control Links, Data Tables, Hierarchical Index Tables, Images and Color Models, Attribute Inheritance and Contexts, and the SEDRIS Data Coding Standard.From all of these topics, only the SEDRIS Data Coding Standard (SDCS) will be discussed here and even then only briefly.  The SDCS fulfills a very important need in SEDRIS — the need to be able to identify (label) an object.  The SDCS defines a set of SEDRIS Classification Codes (SCC), SEDRIS Attributes Codes (SAC), and SEDRIS State Codes (SSC).  All are important, but the SCC may be the most important.  How does a user find what they are looking for inside of a SEDRIS transmittal?  By knowing which SCC values to search for.  Want to find railroads?  Then look for objects in SEDRIS that have the code for railroad attached.  Want to find waterfalls?  Look for waterfalls based on the SCC value for waterfall.  For more details see the information at the SEDRIS web site about the SDCS, but understand that in order to be able to meaningfully extract any information out of SEDRIS it will be necessary to become familiar with the SDCS.2.3 SEDRIS APIAs discussed earlier, the SEDRIS API has been broken into four distinct sections or ‘functional groups.’  All SEDRIS APIs are defined by ANSI C ‘header’ files.  The Conversions API provides the ‘low-level’ functionality to convert coordinate values between coordinate systems, to convert color values between color models, and to convert measurements for certain units.  The Conversions API is independent of all of the other SEDRIS APIs.The Data Model API provides information about the SEDRIS data model.  It is independent of any transmittal.  It is primarily useful for developing applications that benefit from knowing the structure of SEDRIS classes.  This structural information includes the text names of the classes, how many fields the classes have, the text names of the fields, the C types of the fields, the text names of the enumerated values, etc.The Level 0 Read API is used to find and extract information from one or more SEDRIS transmittals.  More than one transmittal can be open at the same time.  There are many implementations of the Level 0 Read API.  One implementation allows a user to read SEDRIS transmittals from the SEDRIS Transmittal Format (STF) files.  For more details on STF, see the other papers about STF both in this conference and at the SEDRIS web site.  Another implementation of the SEDRIS Level 0 Read API allows users to read SEDRIS transmittals from S1000 files (S1000 is the database format for SIMNET/ARPA databases). The implementation does an in-memory conversion of the S1000 data into SEDRIS data as the user requests SEDRIS data.  The STF and S1000 implementations of the SEDRIS Level 0 Read API are distributed as part of the core SEDRIS software.  Many data providers also have developed in-memory conversion implementations for the SEDRIS Level 0 Read API, which work for their own format. The Level 1 Read API is a collection of utility functions.  Level 1 never accesses a SEDRIS transmittal directly.  Instead, Level 1 gathers its data from both parameters passed in by the user and from making calls to the Level 0 Read API.  SEDRIS actively seeks submissions from the community for any utility functions useful for processing SEDRIS data (such as a function to interpolate from one grid spacing to another) for possible inclusion in future releases of the Level 1 API.The Conversions, Data Model, and Level 1 API are all distributed as C source code.  The Level 0 API is most often distributed as a mixture of C++ source code and (for formats other than STF) some amount of pre-compiled object code. Various ‘passthrough’ APIs also exist for the Level 0 Read API.  The Dynamic API, for example, allows a user to link their program against the Dynamic API and be able to use another API implementation to actually read the data, such as the STF implementation of the Level 0 Read API, or the S1000 implementation of the Level 0 Read API.  The Dynamic API uses shared objects, so that when a user asks to open a SEDRIS transmittal of type “x”, the Dynamic API, at run time:figures out which implementation of the Level 0 Read API is needed to read a transmittal of type “x”,loads that implementation into memory (if it is not already loaded),and then redirects all further calls dealing with transmittals of type “x” to the API implementation for type “x”.The user never has to be concerned about which version of the API to link their program against.  By default, within the SEDRIS build environment, all applications are linked against the Dynamic API.Another ‘passthrough’ API is the Debug API.  Similar to the Dynamic API, it acts as a thin layer between the user and whatever other API implementation is actually going to read the transmittal.  The Debug API never reads a transmittal on its own.  The Debug API does however keep track of objects to ensure that all objects for a transmittal are freed before the transmittal is closed, that only valid objects are used in data retrieval calls, etc.  The Debug API is intended for use by SEDRIS consumers to help debug their applications.2.4 SEDRIS ApplicationsMost of the applications discussed in section 1.6 of this paper are still being used and are available at the web site.  In addition, one or two other applications should be available at the web site by the time this paper is published.2.4.1 Content CheckerThis utility (also known as SEE-IT) examines the content of a SEDRIS transmittal for "geometric" correctness.  Currently the tool checks for cracks in the terrain, if the roads meet at proper junctions, sliver polygons, intersections of roads, rivers, and bridges, and a variety of other anomalies that are usually found in terrain databases. In the future, content checking for other non-terrain types of data will be added.2.4.2 Feature ViewerThis utility allows a user to see the two-dimensional features of a database, or to visually compare the features from two databases.  The graphics are Tcl/Tk based.  This application might be redesigned in Java in order to avoid any dependencies on Tcl/Tk.  Although Tcl/Tk is a very useful language/utility, Java is probably a more widely compatible language to use across the many platforms SEDRIS is supporting.2.4.3 GLUT Model ViewerThe Model Viewer described in section 1.6.4 is now available in two different versions.  The X/GLX version requires a platform to provide an X implementation with the GLX extension.  This is not readily available for a PC environment.  This is why the X and GLX interfaces were replaced with GLUT 2.4.4 More Browsers, more Model ViewersThe original versions of Browser (see section 1.6.3) and the Model Viewer (see section 1.6.4) have spawned numerous descendants.  Some were extensions to the original source code.  For example, some Model Viewers have been modified to use mouse input as well as keyboard input.  Others were different implementations of the same ideas, such as a Java based SEDRIS Browser, using none of the source code from the original X-based Browser, but functioning in a similar manner.  For various reasons, some of these applications may not be included in the ‘core’ software.  These applications would have to be obtained directly from their creators.2.5 SEDRIS Core ProductsMany of the SEDRIS core products have already been discussed.  They include the data model, the APIs, and the various utilities.  A key SEDRIS core product is the SEDRIS build environment.  This allows for a push button installation of SEDRIS for the different platforms that are supported by SEDRIS.  Also, an important product that SEDRIS has is its extensive documentation.  The SEDRIS documentation is readily available at the SEDRIS web site.  When new functionality is added to SEDRIS, the documentation is updated, although the documentation usually lags slightly behind the functionality.  The current documentation includes a SEDRIS overview, technical guide set, and miscellaneous documents and SEDRIS presentations.  Other core products are the database x to SEDRIS and SEDRIS to database x conversion products.  Again, contact your individual data providers to find out if they have SEDRIS converters for importing and/or exporting SEDRIS data.  Information on SEDRIS converters should also be available at the SEDRIS web site.3. SEDRIS Future3.1 IntroductionSEDRIS has now transitioned from a research and development program into a production program that supports various M&S activities within the DOD.  However, as with any technology program, if it remains static its ability to continue to be a benefit to the community diminishes.  This is because as new technologies are developed they may have applicability to SEDRIS and its objectives.  Thus, those technologies must be evaluated for that applicability and then selectively integrated into the SEDRIS baseline.  There is no way of determining what new technologies will be developed, but in this section we will layout some potential technologies and modifications to the SEDRIS baseline that could be of benefit to the overall program and the M&S community.3.2 The SEDRIS Data ModelThere are several areas being investigated for integration into the data model.  Support is being added for space (as in outer space) related items into SEDRIS.  This includes the space environment that is required to simulate space interactions (i.e. charged particles, coronal mass ejection, etc.)  Another area of the data model being extended is the support for sensors and sensor related data.  Minor extensions to fully support C4I (operational and M&S) applications will also be added. Finally, as mentioned before, the SEDRIS data model was based on Rumbaugh (OMT) notation.  Basically, OMT has been replaced by the Unified Modeling Language (UML), developed by Dr. Grady Booch, Dr. Ivar Jacobson, and Dr. James Rumbaugh.  Now that the UML notation has matured, it is likely that the data model diagram for SEDRIS will be converted into UML in the ‘near’ future.  This should simply change the notation used to describe the SEDRIS data model and should not affect any of the concepts within SEDRIS.3.3 The Future of the SEDRIS APIAs the SEDRIS community expands, there will be a need for extending the SEDRIS API.  At a minimum, more utility functions should be added to the Level 1 API. The SEDRIS program was built on the cooperation of many organizations from industry and government.  These organizations, and new SEDRIS associates, will continue to suggest modifications to the SEDRIS API.  These suggestions will be evaluated by SEDRIS core technical team for possible inclusion into the SEDRIS baselineAnother area of potential extension is the interfaces.  Currently, the one and only interface to SEDRIS is by using ANSI C.  There is a potential that the SEDRIS interface(s) could benefit by using Java. One of the drawbacks to writing Java applications for SEDRIS is that in order to extract data from SEDRIS, they eventually have to resort the interfacing with the SEDRIS C interface.  We are considering adding both Java and C++ interfaces to SEDRIS.  These interfaces would have the same functionality as the current C interface, but should hopefully make the development of C++ and Java applications for SEDRIS much easier.One definite addition will be that of the SEDRIS Write API.  Currently, in order to produce a SEDRIS STF transmittal, one must implement an in-memory conversion of the SEDRIS Level 0 Read API on top of one's native format.  Using that API implementation, a user then runs a program called “traverse”, which pulls the SEDRIS data through the Read API implementation and then writes the SEDRIS data into a set of STF files.  This is a difficult process, because the task of implementing an in-memory conversion Level 0 Read API on top of a format is a non-trivial one, especially if the execution efficiency is of interest.  A guide is available at the web site to help with this task, but it would probably be easier to just write a program that pushes the SEDRIS data out using the SEDRIS Write API.3.4 Future SEDRIS Applications and UtilitiesAs previously discussed, there are several SEDRIS applications and utilities.  There may be a need to add more GUIs and to standardize the GUIs between the various existing SEDRIS “viewers.”  Ideally, we would like to be able to browse through a transmittal with a browser, click on an object, and then press “display”.  If the object is a model, then the Model Viewer would be invoked, displaying the model.  If the object is a property grid representing atmospheric or oceanographic data, then a viewer capable of displaying atmospheric or oceanographic data would display the object (such viewers do exists and work on displaying atmospheric and oceanographic SEDRIS data has been done using Vis5D).  But, in order for this entire approach to work, the applications need some way to communicate with each other.  For example, the Browser needs to be able to say “This object is the current object.  Please display this object.”  And the Model Viewer (or some other application) needs to be able to receive and process that type of message.  Maybe this communication will be done by the development of a SEDRIS protocol, where all applications are equals.  Maybe the applications will be redesigned to follow the Model-View-Controller (MVC) paradigm.  Maybe a Framework or an Object Framework will be developed for SEDRIS in order to make the creation and integration of SEDRIS applications easier. The future of SEDRIS holds room for very interesting technical developments, not just within the data model and the API, but within the development of applications to examine (and perhaps value add to) SEDRIS transmittals.New applications will also be developed.  Some possible applications under consideration include an analytical way to compare the correlation between multiple SEDRIS transmittals (whose original source data was the same database).  Also, there needs to be a way to create partial transmittals, update transmittals, and edit transmittals.  The most important applications, by far, will be the applications that extract data from SEDRIS and convert the data into a format to be used by a simulation or by some other application to achieve some objective.  Such applications do exist and have been developed by SEDRIS Associates and industry partners.  Many of these applications will appear in commercial products.  Keep in mind that all of the applications discussed in this paper are merely utilities to help us achieve a goal — the goal of interchanging synthetic environment information.Author BiographiesBILL HORAN is a Simulation Engineer with SAIC (ASSET Group — Orlando office).  Since September 1995, Mr. Horan has been an integral member of the SEDRIS core team, where he has worked full-time on the technical development and support of the SEDRIS effort.  He has over five years of experience in DIS, synthetic environment representations, computer-generated forces, visual systems, and network communications. He has given presentations at many DIS workshops, primarily within the Synthetic Environment Working Group, Land Subgroup, and the CGF Working Group.  Mr. Horan has a B.S. degree in Computer Science and a Masters degree in Computer Engineering from the University of Central Florida, Orlando, Florida.DR. ROB COX is a Senior Scientist with SAIC.  Dr. Cox serves as project director and principal investigator for SEDRIS at the SAIC Orlando office.  His Ph.D. is in Meteorology from Texas A&M University. Dr. Cox has served in a diverse set of assignments including Korea, Nebraska, and Washington DC.  Through the years he has supported many experiments and wargames including ULCHI FOCUS LENS and wargames at the Warrior Preparation Center in Germany.  Dr. Cox has authored or co-authored over 2-dozen articles and papers in scientific conferences and journals.  