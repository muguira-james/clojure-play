Coordinated Control of HLA Tools Using a Separate Tools FOMDave FergusonGary HallMotorola Systems Solutions GroupAdvanced Distributed Simulation Systems12424 Research ParkwayOrlando, FL 32826407-823-7000D.Ferguson@mot.com, Gary.W.Hall@mot.comKeywords:Tool Interoperability, Multi-FOM Support, FOM Agility, Simultaneous Federation Support, Re-Use, Federation Management, Monitoring, Visualization, Runtime Controls, Data Collection, AAR, Data AnalysisABSTRACT: Simulation tools such as data loggers and stealth viewers provide services for monitoring and analyzing an exercise.  One approach to providing these services, which promotes interoperability and avoids modifying the underlying exercise FOM, is to use a tools FOM.  The tools FOM is used to create a separate tools federation, which operates concurrently with the exercise federation, for inter-tool communication.  This removes all inter-tool network traffic from the exercise federation and removes the need for tool classes and interactions to be included in the exercise FOM.This paper describes lessons learned in designing and implementing a tools FOM.  The tools FOM is used to coordinate control between simulation tools and to encapsulate exercise activity in order to allow flexible operation of the simulation tools.  Some technical challenges that were encountered while designing the tools FOM, such as interfacing with multiple local RTI connections (LRCs) from within a multi-threaded application are also addressed.1. IntroductionA simulation tool such as a data logger or a stealth viewer is used to monitor and analyze simulation exercises.  Often, these exercises use different Federation Object Models (FOMs).  Developing a tool that is capable of supporting multiple FOMs is essential to maximizing re-use, but it is a complex task.  Adding the ability to control that tool in an intuitive, exercise-centric manner promotes interoperability, but seems to compound this complexity.  However, these capabilities can be leveraged against each other to reduce complexity and increase re-use and interoperability by using a tools FOM.A tools FOM describes tools and their control in terms of HLA object and interaction classes [1]. These classes can be used to coordinate control between tools and encapsulate exercise activity to allow flexible tool operation.  The following paper describes a tools FOM architecture and techniques used to implement it.2. Separate Tools FederationOne advantage to using a tools FOM is that it allows tools to support an exercise federation without requiring modifications to the exercise FOM.  This is accomplished by using a separate tools federation which operates concurrently with the exercise federation.  A separate tools federation is also advantageous because the inter-tool communication overhead can be removed from the exercise federation.  However, implementing this feature presented a technical challenge.We wanted to develop an architecture that would support a simulation application that contains multiple tool components running in separate threads.    However, version 1.3r6 of the DMSO RTI does not support accessing multiple local RTI connections (LRCs) from multiple threads.  This problem was resolved by using a separate, transparent process for communicating with each LRC.  This federate process then multiplexes communication between the LRCs and the component threads using shared memory.  Figure 2.1 summarizes this configuration. EMBED Word.Picture.8  Figure 2.1 Federation Multiplexers3. Common FOM InterfaceFOM agility is a term used to describe a simulation tool‚Äôs ability to support many different FOMs.  This ability is important, because it allows the tool to be re-used in a variety of exercises.  This reduces the amount of training needed for the tool‚Äôs operator.  Furthermore, if custom features are added to the tool by a customer, the extent to which these features can be re-used is dependent on the tool‚Äôs FOM agility.  If the tool must be rebuilt for each FOM, then these custom features may be rendered useless.One way to develop a tool that supports multiple FOMs without requiring tool modifications is to develop a common interface to FOM objects and interactions.  This common FOM interface is used by the tool to gather the data it requires for performing its tasks.  Thus, the tool is isolated from FOM-specific details.3.1 Robust InterfaceA common FOM interface‚Äôs success is dependent upon its ability to furnish the kind of data a tool needs for operation without regard to the exercise FOM.  Providing services that are based upon simulation concepts, rather than one particular FOM implementation, is a good way to make a robust common FOM interface.  This kind of interface is extensible and re-useable across a variety of applications.Our common FOM interface provides simulation concept-based services by encapsulating these concepts into classes.  These classes, known as Criteria, exist in both the tools FOM and in executable code.  Their purpose is to analyze exercise data and categorize it, so that it can be used to configure and control a tool.The attributes defined in the tools FOM for a Criteria class describes the type of exercise data that it should analyze and the rules for determining if it is interested in that data.  The Criteria uses this data of interest to generate a list of objects or a list of events for use by a tool (objects and events will be discussed in Section 3.4).  This isolates a tool from having to gather the kinds of data it requires directly from an exercise.For example, consider a tool that will be used to listen to voice communications during simulation exercises.  Some FOMs may represent voice signals as an object attribute that changes over time, while other FOMs may represent them as an interaction.  Of course, the names of these objects and interactions may vary from FOM to FOM.  Instead of designing the tool to accommodate all of these possibilities, we will develop a SignalEventCriteria.The SignalEventCriteria will have attribute values that define the range of frequencies in which the tool is interested.  During an exercise, a SignalEventCriteria instance will gather and analyze data according to these attribute values and generate a list of Signal events accordingly. The voice communications tool can then use these events to perform its tasks. 3.2 Criteria ImplementationThe abstract Criteria class is divided into two subclasses, according to the type of list they generate.  These subclasses, which are also abstract, are the ObjectCriteria class and the EventCriteria class.  Neither one of these classes actually determines the contents of its list; this activity is delegated to subclasses.  Instead, these classes, along with their base class, define the minimum interface required for a Criteria class.There are several pre-defined subclasses of ObjectCriteria and EventCriteria, which are similar to the SignalEventCriteria described earlier.  These classes may be modified or left unused, according to the user‚Äôs needs.  Additionally, a virtually unlimited amount of new Criteria classes may be defined (the process for doing this is described in Section 3.5).One pre-defined ObjectCriteria subclass is the ComplexObjectCriteria class.  An instance of this class combines other ObjectCriteria instances using Boolean algebra in order to form a more complex Criteria. EventCriteria can also be combined this way by using an instance of the ComplexEventCriteria class.Figure 3.1 describes the Criteria class hierarchy. EMBED Word.Picture.8  Figure 3.1 Criteria Hierarchy3.3 Configurable Mapping MechanismObjectCriteria categorize exercise data into lists of objects so that a tool can gather different kinds of exercise data, while remaining isolated from the exercise.  However, the types of objects that appear on these lists cannot correspond directly to the object classes found in a FOM.  If they did, the lists would be of no use to a tool, because the tool may not be able to understand the contents of the list.For example, in one FOM, an attribute that contains an object‚Äôs location might be called Location, whereas in another FOM it might be called Position.  Consequently, it is necessary for a common FOM interface to provide isolation from the class definitions in a FOM.  This can be done by developing some kind of configurable mapping mechanism that bridges the gap between the interface and a FOM (i.e. a file, DLL, or GUI). 3.4 Mapping ImplementationWe use plug-in classes in order to map FOM object classes to our common FOM interface.  The plug-in classes are written in C++ and compiled into a DLL.  At runtime, the FOM classes are mapped to plug-in classes, and the plug-in classes are dynamically linked into the application.  When an object instance is discovered in a federation, a C++ object is created using the appropriate plug-in class.  This object then acts as remote proxy [2] for the federation object.All plug-in classes are derived from an abstract class called FederationObject.  This class defines a low-level interface for operations such as getting and setting individual attribute values.  Note that it is only an interface; it is the responsibility of the plug-in subclasses to provide an implementation.  This allows maximum flexibility in performing even the most basic operations.  For example, one FederationObject may set attribute values through HLA ownership management, while another may use interactions.By itself, the FederationObject class would not be at all useful in isolating a tool from the class definitions in a FOM.  The tools would still have to understand the semantics of the FOM.  In order to provide our tools with the basic information that they need to analyze a simulation exercise, an abstract subclass of the FederationObject class named SimulationObject was created.SimulationObject defines an interface to get and set basic simulation information such as location, heading, speed, and force I.D.  Like FederationObject subclasses, it is the responsibility of SimulationObject subclasses to provide an implementation.  For many FOMs, a single plug-in class derived from SimulationObject might be the only class needed to map the entire FOM for use with our tools.Figure 3.2 describes the FederationObject class hierarchy. EMBED Word.Picture.8  Figure 3.2 FederationObject Hierarchy (C++)One of the benefits of plug-in classes derived from SimulationObject is that they allow development of re-usable Criteria.  Suppose a LocationCriteria, which is used to determine when objects are located within a certain sphere of interest, exists.  If different FOMs used different attribute names or coordinate systems, and a subclass of SimulationObject did not exist, then the LocationCriteria would have to be modified to work with each FOM.  However, a single LocationCriteria can be written to work in any FOM by using the SimulationObject interface.3.5 SynergyIn order for a Criteria to actually analyze exercise data and generate a list of FederationObjects or events, it cannot exist only as an object instance in the tools federation.  There must be some executing code interpreting the state of the federation object instance into something a tool can use.  Fortunately, a mechanism has already been developed for mapping a FOM object class to a C++ plug-in class.  Remember, a Criteria class is defined in the tools FOM just like any other FOM object class.By making the Criteria class a subclass of FederationObject, we combine the class hierarchies to make a unified common FOM interface.  Figure 3.3 describes this combined class hierarchy.  The ObjectCriteria and EventCriteria classes provide the only interface necessary for a tool to use Criteria for configuration and control.  That is, they provide lists of FederationObjects or events.  The tool does not need to be concerned with the generation of these lists, because it is done by the plug-in classes that are mapped to the Criteria. EMBED Word.Picture.8  Figure 3.3 Combined Hierarchy (C++)4. Coordinated Inter-Tool ControlIn addition to Criteria classes, our tools FOM also contains object classes that correspond to the tools themselves.  These Tool classes have attributes that contain information needed to monitor, configure, and control a tool.  Some of the attributes defined in a Tool class may be used to contain Criteria.  A tool would use this kind of attribute anywhere data could be categorized in an exercise-centric manner.For example, a stealth viewer tool provides a 3-D view of a geographic region.  Without using Criteria, it would publish its current view with an attribute containing some coordinates that describe a geographic region.  However, some stealth viewers also have the ability to attach their view to a group of exercise objects, such as a fighter jet squadron.  Now, the stealth viewer must update the attribute that describes its current view every time the squadron moves.  This problem can be solved using Criteria.  Initially, the stealth viewer could publish its current view with an attribute containing a Criteria object that describes the geographic region.  When the view is attached to the squadron, it could create a Criteria object that describes the squadron and change the attribute value accordingly.One benefit to controlling a tool with Criteria objects is that tool control can be coordinated with many other tools.  This is possible because all of the tools can use the same Criteria objects.  Consequently, by modifying the Criteria objects‚Äô attribute values, all of the tools will respond accordingly.  This could be used to ‚Äúlink‚Äù tools, such as a data logger and a stealth viewer, together.  The data logger could use the Criteria object that describes the stealth viewer‚Äôs current view to record only objects seen by the stealth viewer.5. ConclusionA tools FOM encapsulates simulation concepts into classes.  These classes allow a tool to gather the kinds of data it requires without any direct knowledge of the exercise FOM. In order to isolate the tool from the class definitions in an exercise FOM, a configurable mapping mechanism can be used.  By combining the tools FOM with a configurable mapping, a common FOM interface is formed.  This interface allows tools to be developed that support multiple FOMs and provide intuitive, exercise-centric controls, while reducing complexity and increasing re-use and interoperability.6. References[1]	Darren R. Wetzel, Deborah Fulford:  ‚ÄúUsing HLA to enable cohesive control of disparate simulation tools‚Äù, Simulation Interoperability Workshop, 99S-SIW-202, Spring 1999.[2]  Erich Gamma, et al.:  ‚ÄúStructural Patterns‚Äù, Design Patterns, Addison-Wesley, Reading MA 1995.Author BiographiesDAVE FERGUSON is a Software Engineer at Motorola Advanced Distributed Simulation Systems, Orlando, FL.  He is currently developing the next generation of Motorola ModIOS tools.  He has a B.S. in Computer Engineering from the University of Central Florida. GARY HALL is the Lead Systems Engineer at Motorola Advanced Distributed Simulation Systems, Orlando, FL.  He has been involved in the distributed simulation marketplace for over nine years.  He has a M.S. in Computer Engineering from the University of Central Florida.