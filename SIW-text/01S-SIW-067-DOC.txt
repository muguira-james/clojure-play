RTI-NG Process ModelRoger D. WuerfelFrank J. HodumSAIC5400 Shawnee Road, Suite 110Alexandria, VA  22312703-333-5427, 703-333-5437Roger.D.Wuerfel@saic.com, fhodum@dctd.saic.com Keywords:RTI-NG, process model, tick. ABSTRACT: The RTI-NG 1.3 implementation has two process models for providing the local Runtime Infrastructure (RTI) component (LRC) with an opportunity to process network traffic and execute callbacks, asynchronous I/O (AIO) and polling.  The AIO process model creates an internal thread that is used to periodically poll the network and queue callbacks to be executed by the federate LRC when it calls tick.  The polling process model creates no additional thread; thus, the LRC is only active when the thread of control passes from the federate to the LRC, e.g., by calling tick.  Therefore, the two RTIambassador tick methods have slightly different executions depending on which process model is chosen.  The process model is selected by specifying either “Polling” or “AsynchronousIO” in the RTI.ProcessModel.StrategyToUse RID file parameter.  This paper will discuss the two process models along with some considerations for choosing the process model and an outline of the execution of tick() and tick(min,max).  RID file parameters that are relevant to these topics will be explained in context.  IntroductionThe Interface Specification (IF Spec) for the High Level Architecture (HLA) defines the functional interfaces between federates and the Runtime Infrastructure (RTI). The RTI provides services to federates in a way that is analogous to how a distributed operating system provides services to applications. []  For the HLA, this means that there are a set of services provided by the RTI that the client application will invoke and a set of services that the federate must implement that the RTI will invoke or as described in the IF Spec as “RTI initiated”.  These RTI initiated services define an interface of callback functions that the federate must implement that allows the RTI to deliver messages to the federate.  The IF Spec itself does not specify how an RTI implementation should deliver these callbacks to the federate except for the addition of two tick methods in the C++ API.The definition of how an RTI implementation delivers these callbacks to the federate will be referred to in this paper as the RTI process model.  Every RTI must have a method for obtaining CPU time so that it may receive messages from the communication channel and take the appropriate action, which may be to invoke a callback to the federate.  The RTI-NG implemented two different possibilities for the process model for an RTI.  This paper will discuss the two process models, some considerations for choosing the process model and an outline of the execution of tick() and tick(min,max).  RID file parameters that are relevant to these topics will be explained in context.  When “tick” is used it will refer to either tick() or tick(min,max) in general and “tick()” or “tick(min,max)” will refer to the specific tick method.Within the RTI-NG implementation, all network traffic received that represents a callback to the Federate Ambassador are converted to “commands” internally.  These commands are then placed on one of several internal command queues depending upon the type of callback and Time Management state of the federate.  This behavior is called the command pattern and allows the RTI to efficiently handle all types of federate callbacks consistently, in the correct Receive Order or Time Stamp Order manner in compliance with the Interface Specification.  Throughout the rest of the paper, the term commands and the queuing of commands will represent the Federate Ambassador callbacks and the correct ordering of those callbacks.Process ModelsThere are several process models that an RTI could implement such as utilizing some CPU time whenever a federate invoked an RTI service or a fully asynchronous method where the callbacks are invoked whenever a message is delivered on the communications channel.  Since the details of what should happen when a federate calls tick are not specified in the IF Spec it was decided for the RTI-NG implementation to emulate the functionality outlined in the previous RTI 1.3 implementation that is described in the RTI 1.3 Programmers Guide. []  This and the fact that the communications channels would be implemented with IP network protocols reduced the choices for the process model and lead to the decision to implement two different RID file selectable process models.  The first choice was a threaded model that allowed an asynchronous thread of execution to service the communications channel.  The federate, after initialization, would then only need to call tick to receive callbacks.  This would alleviate the worry about “starving” the RTI and the burden of sprinkling tick calls throughout the federate code, which were problems associated with the tick mechanism in previous implementations of the RTI.  The second choice was to have one thread of execution and the call to tick would service the communications channel as well as invoking callbacks upon the federate interface.  This mode would match the previous RTI implementation and is useful for real-time federates that cannot afford the cost of context switching between threads or want tighter control of CPU usage.Asynchronous I/O (AIO) Process ModelThe AIO process model was developed specifically to relieve the federate of the burden of scattering calls to tick throughout the federate’s code to guarantee that the LRC receives “enough” processing time.  Since the federate programmer has no effective means by which to discern when the LRC has received “enough” processing time, AIO mode is the preferred execution mode.  Note that this does not relieve the federate entirely from calling tick.  The federate must still call tick frequently enough to drain the callback queue so that memory exhaustion is avoided and that RTI administration messages may be executed by the LRC in the federate thread.  In other words, after initialization, tick can now be called by the federate only when it is prepared to handle callbacks from the RTI.The network or background thread will poll the network at a RID file configurable rate to service incoming data and queue Federate Ambassador callbacks to be executed by the LRC when the federate does call tick.  The rate that it polls the network is controlled by an adaptive algorithm that attempts to minimize the burden on the processor while still reading from the network often enough to prevent network starvation.  The polling rate of the network thread adapts to prevailing network load and the rate at which tick has been called within the bounds of several RID parameters.  When tick is called by the federate, the LRC has to acquire the lock for the resources shared between the threads and then the LRC is able to execute commands, such as federate callbacks.  When the federate thread has the resource lock, the network thread is suspended from servicing the network.  However, the federate thread (now in the LRC, since it holds the resource lock) will also service the network during the allotted time slice, provided that federate callback processing does not exceed this time slice. The RTI 1.3-Next Generation Programmer’s Guide states that during a tick with no arguments (tick()) invocation, the LRC will process incoming traffic, deliver callbacks to the federate, and perform various internal RTI maintenance tasks essential to the operation of the federation.  This is still true, even in AIO mode.  In fact, since the network thread adapts its own execution based partly on the last time tick was called, a federate program that ticks at a high enough rate can force the network thread to sleep indefinitely.  The execution time of tick() will vary with the number of commands on the queue and the execution time of the federate callbacks.  RTI::RTI_FALSE will always be returned by tick().  Using tick(min,max) will tell the LRC that it should try to execute commands for min seconds and will not start execution of another command if max seconds has elapsed.  The actual execution time of tick(min,max) will depend on the number of commands and the execution time of the federate callbacks.  Max time can easily be exceeded if a federate callback takes an excessive amount of time to execute.  The accuracy of the min and max time is also subject to the timer resolution on the processing system.  RTI::RTI_TRUE will be returned by tick(min,max) if there were commands left to be processed but it returned because of the max time being exceeded; otherwise, it returns RTI::RTI_FALSE.Polling Process ModelThe polling process model is a single threaded execution model where the LRC resides totally within the federate thread.  That thread has to service the network, queue commands, and execute those commands whenever the federate calls tick.  With this process model, tick() will service the network, queue commands, and execute commands until there is nothing on the network to service and there are no command left on any queues.  Therefore, the execution length of tick() will vary with the network load, the number of commands that need to be executed, and the execution time of the federate callbacks. RTI::RTI_FALSE will always be returned by tick().  Using tick(min,max) will tell the LRC that it should try to process for min seconds and will not start execution of another command if max seconds has elapsed.  The actual execution time of tick(min,max) will depend upon the number of commands and the execution time of the federate callbacks.  Max time can easily be exceeded if a federate callback has excessive execution time.  The accuracy of the min and max time is also subject to the clock resolution on the processing system.  RTI::RTI_TRUE will be returned by tick(min,max) if there were commands left to be processed but it returned because of the max time being exceeded; otherwise, it returns RTI::RTI_FALSE.Choosing A Process ModelThe implementation of all the IF Spec services requires either a lot of administrative data exchange between the federate LRCs or for that information to be stored in a centralized process.  Choosing between maintaining this necessary information in a distributed or centralized fashion is a design decision that has to examine the balance between performance and robustness. This choice also has an effect upon tick in that the LRC needs CPU time to communicate the administrative traffic in a timely manner.  The RTI-NG implemented a system where most information was distributed in the federates’ LRCs in order to improve performance of many of the services.  Therefore, it is suggested that the federate, even when using the AIO mode, call tick after operations that will result in administrative messages such as joining and subscribing so that the join process and discovers, respectively, can take place. This is because the network thread in most instances only creates commands that get queued for execution in the federate LRC, the federate LRC must still call tick to allow some administrative commands to be executed.As previously stated, since the federate programmer has no means to determine if the LRC is being starved or over fed with processing cycles, AIO is the preferred processing model.  This frees the federate programmer to call tick only when callbacks are desired or administrative messages are expected.  Although, tick still should be called often enough to drain the command queue to avoid memory exhaustion.  Contention for the CPU between the network thread and the federate thread could cause undesirable performance characteristics for some federates.  When the network thread is executing the federate thread will not be able to get the shared resource lock to execute commands and will therefore have to block in tick until the lock is released.The programmer will have to be more conscientious about the rate of federation traffic when using Polling mode.  Tick will have to be called frequently enough to ensure that the LRC is not starved which can lead to TCP/IP flow control problems that could pause the entire federation or to dropped messages for best effort traffic.  This mode does relieve the contention for the CPU and therefore gives finer control of the CPU utilization to the federate.Outline of Tick ProcessingThe outline of tick processing is presented for the RTI-NG 1.3v3.2  in the following pseudo-code.  RTI parameters are designated by prefixing a RID:: to the fully qualified name of the parameter and subroutines will be in bold type.The first pseudo code represents the behavior associated with the no argument version of ticktick()Check network thread for exceptions()If (RID::RTI.Scheduler.SingleCallbackPerTick) then	Poll network for input (0.0)	Execute one commandElse	While commands are available		Execute one command	End while commands are available	While there is network traffic available		Poll network for input (0.0)		While commands are available			Execute one command		End while commands are available	End while there is network traffic availableEndif This next pseudo code represents the tick with arguments.  This case differs from the previous case in that a timer is required for the RTI to meet the requirements of the min and max timeout parameters provided by the federates.tick(min,max)If (min > max) throw RTIException::RTIinternalErrorStart a High_Res_TimerWhile elapsed tick time < max	Check network thread for exceptions()	Until no more to do, Execute commands and poll(max – elapsed tick time)	If there was still work to do return RTI::RTI_FALSE;	Set elapsed tick time  = High_Res_Timer elapsed time	If elapsed tick time > min then leave while loop	Calculate remaining time(min – elapsed tick time)	Perform Work(remaining time)	Set elapsed tick time = High_Res_Timer elapsed timeEnd while elapsed tick time < maxCheck network thread for exceptions()Return RTI::RTI_FALSE if more commands are waiting and RTI::RTI_TRUE if there is nothing left to doPoll network for input(select time)Perform Work(select time)Check network thread for exceptions()Perform Work(select time)Set Last Work Time to current timePerform ORB Work(select_time)Perform ORB Work(select_time)Call select on connections with the select timeProcess a network message and create commandsThe next method describes the code to execute commands or callbacks on the federate ambassador and check the network in a loop for the duration of the timed tick.Execute commands and poll(time duration)start an High_Res_TimerNextTimeToTickOrb = 0.0while there are commands to execute and elapsed time < durationif elapsed time > NextTimeToTickOrb thenPoll network for input(RID::RTI.Scheduler.MinimumPollingIntervalDuringTickInSeconds)NextTimeToTickOrb += RID::RTI.Scheduler.ExecuteCommandsPollIntervalInSecondsEndifExecute one commandend whileCheck network thread for exceptions()If Polling Mode return;Else check shared exception queue for queued exceptions and throwCalculate remaining time(input time)remaining time = (input time > RID::Scheduler.MaximumPollingIntervalDuringTickInSeconds) ? RID::Scheduler.MaximumPollingIntervalDuringTickInSeconds ? input timeremaining time = (remaining time < RID::Scheduler.MinimumPollingIntervalDuringTickInSeconds) ? RID::Scheduler.MinimumPollingIntervalDuringTickInSeconds ? remaining timeRtiProcessModelNetworkReaderThreadManager::RtiProcessModelNetworkReaderThreadManager()Target Sleep Duration In Seconds = 0.3This last method is executed by the Asynchronous IO or background thread.  The algorithm wakes the background thread after the RID configurable period of time and first checks to see if the federate had ticked since the last time the background thread had executed.  If not, then the background thread will attempt to perform work by reading from the network.  The adaptive part of the algorithm now takes over.  If the read from the network actually had something to do, the Productive Poll flag is set to true.  If there was nothing to do then the Productive Poll flag is set false.  A true Productive Poll flag will cause the time to sleep until the next time the background thread wakes to be reduced by 25% and a false Productive Poll flag will case the time to be increased by 25%.  The theory here is that if there was something to do, then we are under some kind of load and the federate is not ticking often enough so we will wake the background thread more often.  If there was nothing to do then the federate is ticking often enough and there is no reason to utilize CPU resources waking the background thread to do nothing.  Finally, there are two RID parameters to provide a minimum (RID:: ProcessModel.AsynchronousThread.MinimumSleepDurationInSeconds) and maximum (RID:: ProcessModel.AsynchronousThread.MaximumSleepDurationInSeconds) value for the sleep of the background thread.  The minimum value is utilized to prevent the background thread from monopolizing the CPU under very heavy network load.  The maximum is to prevent the background thread from increasing the sleep time to such a high value that it would not be responsive in the event of a sudden increase in the network load.  Again each of these values is modifiable by the federate in the RID file.RtiProcessModelNetworkReaderThreadManager::poll()	sleep(Target Sleep Duration In Seconds)If (Federate ticked since last time the background thread executed)	Do until either 10 cycles or no more work to be done		Perform ORB Work(0.0)	Set Productive Poll true if did some workEnd do until either 10 cycles or no more work to be doneEnd If federate thread tickedMultiplier = (Productive Poll) ? 3 : 5Target Sleep Duration In Seconds = (Multiplier * Target Sleep Duration In Seconds)/4If (Target Sleep Duration In Seconds <	RID::ProcessModel.AsynchronousThread.MinimumSleepDurationInSeconds) {	Target Sleep Duration In Seconds = RID::ProcessModel.AsynchronousThread.MinimumSleepDurationInSeconds}else if (Target Sleep Duration In Seconds > RID:: ProcessModel.AsynchronousThread.MaximumSleepDurationInSeconds) {	Target Sleep Duration In Seconds = RID:: ProcessModel.AsynchronousThread.MaximumSleepDurationInSeconds}Discussion of Tick ProcessingThe core of the work done for servicing the network connections is accomplished in the Perform ORB Work method.  This method implements the Rector pattern which “allows event-driven applications to demultiplex and dispatch service requests that are delivered to an application from one or more clients.” []  The RTI-NG uses an implementation of the Reactor which uses the OS select on UNIX platforms or WaitForMultipleObjects function on Windows for the synchronous event demultiplexer and also supports scheduling of timeouts.  The Reactor will wait for one or more of the file descriptors in its file descriptor set to have data available or wait for the duration of the input time duration argument if none of the file descriptors has data become available.   When data is available on one or more file descriptors it can be read non-blocking to create commands that are then queued onto the shared queue.  Note that most operating systems have a lower bound on the granularity of the time duration argument of 10 milliseconds (ms).  This implies that if none of the file descriptors has data available, the select or WaitForMultipleObjects calls will not return for at least 10 ms even if the time duration argument was less than 10 ms.  Passing 0.0 as the time duration is a special case which does a non-blocking check on the file descriptor set and either handles one file descriptor or returns immediately.The network thread is represented by the RtiProcessModelNetworkReaderThreadManager::poll() method.  This method sleeps for an adjustable duration and then polls the network with Perform ORB Work if the federate thread has not called Perform Work while this thread was waiting to acquire the process lock.  If at least one message was processed, the sleep duration will be decreased and if no messages were processed the sleep interval will be increased.  The sleep interval is bounded by the RID parameters ProcessModel.AsynchronousThread.MinimumSleepDurationInSeconds and ProcessModel.AsynchronousThread.MaximumSleepDurationInSeconds.The tick() method pseudo-code shows that setting the RID::RTI.Scheduler.SingleCallbackPerTick  parameter to true will cause only a single callback to be processed per tick in either AIO or Polling Mode.   Otherwise, tick() will execute any commands that are queued up from the network thread if using AIO (the queue will be empty for the Polling Mode) and then proceed to poll the network and execute commands until no more messages are received on the network.  Notice that the argument to Poll network for input is 0.0 in this form of tick which translates to calling the Peform ORB Work with a 0.0 parameter which was discussed previously.  The tick(min,max) method watches the elapsed time since entry to determine when to leave the main loop by starting a high resolution timer upon entry and checking the elapsed time after executing each command.  The main loop executes until the elapsed time is greater than the max argument.  It will then execute commands and poll the network until either no messages are available on the network or there are no commands left to execute or the max time in tick(min,max) is exceeded.  Notice in Execute commands and poll(time duration) that it will not actually continue to poll the network if RTI.Scheduler.ExecuteCommandsPollIntervalInSeconds seconds has not elapsed from the last poll so that the process will not monopolize the CPU if there are no messages available, but it will continue to execute any commands in the queue.  If CPU usage by the federate process is not a concern then this RID parameter can be decreased so that messages will get pulled off the network sooner.  Another item to notice is that the argument to Poll network for input is a RID parameter.  This value can be set to 0.0 if CPU usage is not a concern, but the latency of messages is.SummaryThe RTI shares the process space with federates that use it and as such, must share the resources including the thread of execution with that federate.  The mechanism whereby the RTI is provided access to the primary thread of execution is through the use of the tick function.  The functionality of tick is undefined in the Interface Specification, which allows the RTI developers to implement tick in whatever fashion they see fit.  Several different implementations of tick are possible, and this paper described the two mechanisms that were utilized within the RTI-NG implementation.  Pseudo code described exactly the tick implementations within the RTI-NG.  The RTI-NG provides the ability to customize its tick behavior through a user modifiable RID file.  Several different RID file parameters and their effects upon tick and threading within the RTI-NG were described.  The NG implementation had user configurability as one of its goals, and the behavior of tick and the use of threads are two key areas where the user has complete control over the RTI’s behavior.  It is the authors hope that the information contained within this paper will help guide users in their use of the RTI by enhancing their understanding of the internals of one portion of the RTI.References[]  Defense Modeling and Simulation Office:  “High Level Architecture RTI Interface Specification, Version 1.3,” April 1998.[]  Defense Modeling and Simulation Office: High Level Architecture Run-Time Infrastructure Programmer’s Guide Version 1.3NG v3.2.[]  Schmidt, Douglas … Pattern-Oriented Software Architecture Volume 2, John Wiley & Sons, Ltd, New York, 2000.Author BiographiesROGER WUERFEL is a senior software developer in the Distributed Computing Technology Division of SAIC  He is currently the technical support manager for the RTI 1.3 Next Generation and has been working with the RTI 1.3 Next Generation development team for 3 years.  Roger Wuerfel has over 10 years experience with simulation including real-time human-in-the-loop flight simulation and real-time distributed simulation.  He received his B.S. in Aeronautical/Astronautical Engineering from The Ohio State University and is pursuing his M.S. in Modeling and Simulation from Old Dominion University.FRANK J. HODUM is a Deputy Division Manager with Science Applications International Corporation (SAIC) in Alexandria, VA.  He is the program manager for the RTI-NG (Next Generation) program and has been involved with HLA related development for four and a half years.  He has worked on distributed simulation infrastructures for a variety of simulation domains from engineering level simulations to real time human in the loop training simulations to very large scale virtual event driven simulations over the past seven years.  Mr. Hodum received his B.S. in Engineering Physics from Worcester Polytechnic Institute in 1994 and his M.S. in Engineering Management from the University of Central Florida in 1999.