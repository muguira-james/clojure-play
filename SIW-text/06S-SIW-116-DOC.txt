Adding Aggregate Services to the Mix: An SOA Implementation Use CaseBen SissonPaul GustavsonKarl CrossonSimVentions, Inc.11903 Bowman Drive, Suite 102Fredericksburg, VA 22408(540) 372-7727 HYPERLINK "mailto:bsisson@simventions.com" bsisson@simventions.com HYPERLINK "mailto:pgustavson@simventions.com" pgustavson@simventions.com HYPERLINK "mailto:kcrosson@simventions.com" kcrosson@simventions.comKeywords:Aggregation, SOA, BASS, BOMs, Web Services, InteroperabilityABSTRACT: The implementation of an aggregation support server, as a service oriented architecture (SOA), can not only enhance performance in a simulation environment, but allow data to be more meaningful to users within the “mix.” The mix represents the collection of independent systems, simulations, and supporting presentation tools brought together to support a service, joint, or coalition focused need such as analysis, testing, or training. Yet, the mix of entity-level and aggregate-level simulations within such an environment and the resulting data being conveyed often result in what can be thought of as obfuscated interoperability. That is, the data is conveyed, but the underlying meaning of what is being represented and exchanged may not be understood. The remedy historically has been to create a tight coupling with only simulations of common breed, and, if exchanged with simulations of different pedigrees is required, then custom bridges for those simulations and systems are designed and built. Using a SOA approach, however, allows a loose coupling connection of multi-pedigree participants within a simulation environment. As proven by the Base Object Model (BOM) Aggregation Support Server (BASS), an SOA approach to aggregating entities in a simulation can provide enhanced performance while at the same time maintaining the accuracy and details needed by the participants of both entity-level and aggregate-level simulations.   This paper explores BASS as a use case of how SOA can be leveraged within M&S.  We examine how the BASS web services provide a platform independent mechanism for supporting aggregation and deaggregation, which can be used in conjunction with any number of systems, simulations, and presentation tools. 1. IntroductionThe ability to perform large-scale simulation exercises has been an increasing need within the joint warfare community. A large-scale simulation exercise may require an entity load that is in excess of thousands. Since realistic performance is the paramount objective, invariably the models representing these entities are targeted at the high end of resolution. This degree of resolution coupled with the quantity of entities required to represent the combat environment can put undue strain on the systems that are at play. Typically, simulations representing high-resolution models and handling a large quantity of entities requires a rich amount of computational hardware, network bandwidth, and exercise management. Techniques such as scaling and filtering can be applied to boost abilities; however such exercise management practices are still limited to the available resources a system can allocate for supporting the quantity and model resolution needs of the entities that may be rendered at any one time during an exercise execution. The concept of aggregation, a technique for combining multiple entities into a single inclusive group, is considered a practical approach for managing large-scale simulation exercises and improving overall performance. Unfortunately, models used to represent entities and interactions are not typically built with aggregation in mind. This typically results in the customization of two or more specific simulation systems to accommodate the aggregation and deaggregation of models and entities amongst only themselves as they participate within the simulation exercise.   Furthermore, the mix of entity-level and aggregate-level simulations within a joint environment and the resulting data being conveyed often result in what can be thought of as obfuscated interoperability. Obfuscated interoperability is when data attempted to be exchanged by a “mix” of simulations may be conveyed, but the underlying meaning of what is being represented and exchanged may not be understood.   The remedy historically has been to create a tight coupling with only simulations of common breed, and, if exchanged with simulations of different pedigrees is required, then custom bridges for those simulations and systems are designed and built.What has been needed is the ability to process models and entities from various distributed simulations and systems, offer aggregation support of those models and entities to any simulation or system participant, and strive to maintain the validity of the exercise resolution regardless of the level of aggregation or deaggregation.  To achieve this, a service oriented architecture (SOA) design provides the foundational framework for establishing aggregation / deaggregation support within a “mix” of systems, simulations and various tools, which collectively represent a service, joint, or coalition focused simulation environment [1]. The implementation of an aggregation capability targeted to comply with a SOA approach will provide the aggregation support for the “mix” within a large scale environment. A set of aggregation / deaggration web services contained as part of an SOA implementation offers a practical way to begin to support the “mix”.  Specifically it will help maintain a high degree of resolution and entity quality while reducing the strain on the systems that are at play. In addition, operating as an independent passive participant within the simulation exercise, the aggregation support server will be capable of processing entity level information from other participating clients regardless of the client architecture. The solution will provide methods for the clients to participate in the aggregation process through the implementation of aggregation solutions provided by the aggregation support server. The native clients will then implement the solution, within the live simulation, enabling the aggregation of entities while still providing the high resolution and detail required within the exercise.2. BAF SolutionAs a possible aggregation support server solution, the Base Object Model (BOM) Aggregation Framework (BAF) defines a set of Web service interfaces for enabling aggregation, deaggregation, transfer control, load balancing, library management, model transformations, and logging of simulation data [2]. The BAF design applies an SOA approach in providing these interfaces thereby providing a non-binding mechanism for simulations to integrate and employ the adjunct services that a BAF server implementation will provide. The result for such simulations and the network, in which they are connected, includes better operational performance and throughput of the simulation data exchanged and increased interoperability among diverse simulations including entity-level simulations and aggregate-level simulations. 2.1 BAF SOA Design PrinciplesThe Service-Oriented Architecture (SOA) is a concept focused on the interoperability and loose coupling of integrated elements. The key of an SOA implementation is to focus on exposing existing application logic as loosely coupled services, subsystems, and system components. The BAF design is intended to encourage SOA level functionality for the clients, server(s), and system component solutions (i.e., BOMs) that are employed. The SOA concept is depicted in Figure 2.1.1.Figure 2.1.1 – Service and ConnectionsThe illustration represents a service consumer (i.e., client) sending a request message to a service provider (i.e., server). The service provider subsequently sends a response message back to the service consumer. The request and subsequent response provide interfaces that are defined in a way that is comprehensible to both the consumer and provider. Interfaces serve as the framework for the messages that are to be exchanged. This BAF document defines such interfaces, which are intended to be offered by a server and used by clients (i.e., simulations).   A common mechanism used to offer these interface connections is through the use of web services. Web services are a key building block for SOA implementations. An SOA implementation encapsulates application logic and the functionality shared via a common communications protocol, often using web services. BAF is designed as an intended SOA implementation for which clients (i.e., simulations) can be coupled with a server that provides BAF web services allowing the client to benefit from the aggregation solution, deaggregation solution, load balancing, library management, and transformation support BAF provides. For example, a BAF-based server could operate as an adjunct in a federation execution environment to provide aggregation and deaggregation support for the participating clients (i.e., simulations). Such clients can also decouple from the BAF server and still function independently, only losing the capability to leverage the adjunct services offered by a BAF server.  Other eXtensible Markup Language (XML) technology layers such as the Web Services Description Language (WSDL) and the Simple Object Access Protocol (SOAP) are often used to describe, bind, and enable communication for these web services. Additionally, the Universal Description, Discovery, and Integration (UDDI) can be used as a service broker to enable discovery of desired services. These interactions between the described layers showing how clients utilize an SOA implementation of BAF, which will include the use of federates (i.e., simulation clients) and BOMs, are depicted in Figure 2.1.2.  Figure 2.1.2 - BAF SOA Service and Connections with Federate Clients and BOMsThe BAF web services can be available both at design-time among model developers and at run-time with the constructive simulations that are at play over a network. Furthermore, providing the BAF as a Web service allows a myriad of clients developed for different platforms and languages to access and utilize the service, independent of the computing platform or language under which the BAF server is hosted or written.  2.2 Aggregation Types SupportedThe BOM Aggregation Framework (BAF) introduces two different types of aggregation approaches that can be supported by web services: model aggregation and entity aggregation. The following sections explore these two types of aggregation/deaggregation support provided by BAF.2.2.1 Model AggregationModel aggregations reflect the coupling of models, which can formulate larger models. Such aggregations can be identified prior to a simulation exercise. Thus, it is a non-exercise specific, class-based abstraction for composition. For instance, a composite of an automobile can be formulated to represent the sum of its parts. Within a BAF implementation, these parts will represent interface elements described using BOMs [3]. Such BOMs may individually represent an engine, wheels, car body, braking system, and suspension. In this example, the collection of object class interfaces defined within these individual BOMs could be used to formulate an aggregated automobile model represented in a BOM assembly The approach applied to support this type of aggregation is known as a Composite Pattern within “design pattern” circles.The Composite Pattern is used to form a collection of objects. In the case of BOMs, the BOM Assembly is used to represent a composite of BOMs. This composite is used to formulate the model representation for a federation [akin to a Federation Object Model (FOM)], a client [akin to a Simulation Object Model (SOM)], or an aggregation of elements or High Level Architecture (HLA) object classes. 2.2.2 Entity AggregationEntity instance aggregations, hereon referred to as entity aggregations, reflect the coupling of multiple entities into a single inclusive group. Thus, entity aggregations are focused on the coupling of exercise-specific object instances rather than object classes, which is what model aggregation provides. Unlike model aggregation, entity aggregation can be applied during a simulation execution. Thus, it is an exercise-specific object-based abstraction for composition. For instance, a composite of a company might be established to represent an isolated group of troops and their associated vehicles and equipment, such as tanks and armored vehicles. In this example, the collection of these entities, which are object instances of one or more BOM class types, could be combined to formulate an aggregated company defined by a container class BOM. The approach applied to support this type of aggregation is known as a Flyweight Pattern within “design pattern” circles. The Flyweight Pattern is intended to help manage large numbers of entities (i.e., class instances) within a simulation. Essentially, a Flyweight, which is supported by a dynamically defined BOM, will be used to represent a composite interface of a common group of client objects identified during an exercise. By identifying the common attributes of the classes representing the entities (or objects) within a system, a common container class can be defined; and where there are any differences in attributes among the various classes, these attributes can be maintained as extrinsic data passed in as arguments (using mechanisms such as HLA Interactions). 2.3 Aggregation Levels SupportedThe BAF supports two different levels of aggregation and deaggregation: first level aggregation, and second level aggregation. The following sections explore these two levels of aggregation /deaggregation support provided by BAF.2.3.1 First Level AggregationThe concept of first level aggregation is predicated upon the fact that an individual client is capable of sending messages across a network within a federation. The models and/or entities owned by the client can be aggregated into assembly interfaces for distribution across the network. This aggregation process is considered to be first level because the aggregation is conducted by the sending client, which controls the models and entities included in the messages. A major benefit of first level aggregation is the reduction in the number of messages being generated and sent over the network by a client. The result is a reduction on the network load and the Central Processing Unit (CPU) load. A distributed aggregation employed by a sending client is shown in a federation in Figure 2.3.1.Figure 2.3.1 - First Level Aggregation View2.3.2 Second Level AggregationThe second level aggregation approach considers a client that receives inbound messages from the network. This process is considered second level because the messages, once received by the client, can be pooled and represented locally as an aggregate by that receiving client. The client is not required to hold the models and entities in memory, thus helping to reduce the memory load and computing burden on the client. Figure 2.3.2 shows a localized aggregation employed by a receiving client.  Figure 2.3.2 - Second Level Aggregation View2.4 BAF Interface Service GroupsThere are four major interface service groups defined within the BAF architecture. Each of these groups is identified briefly in Table 2.4 and is described in more detail later in the document.Table 2.4 – BAF Interface Service GroupsInterface Service GroupsBrief DescriptionAggregation ServicesServices supporting aggregation and deaggregation of models and entitiesLibrary Support ServicesServices supporting item types such as BOMs, FOMs, BTMs, and BCIs, which are located within resource librariesMonitoring / Intercessory ServicesServices supporting the use of data logging, load balancing, entity transfer control, and statistics recorded during a simulationTransformation Support ServicesServices supporting the transformation of BOMs,  HLA FOMs, and MetadataA BAF implementation that offers these groups of interface services will provide clients with a Web service-capable automation mechanism for aggregation and deaggregation, library support, load balancing via monitoring and intercession, and the ability to support interoperability among clients using various models within a distributed simulation environment via transformation. Additionally, a BAF implementation will have the capability to capture the session information of an exercise in a data log, which could be retrieved and/or streamed via a Web service call. The specific interface methods offered by BAF supporting these capabilities are identified in the BAF Interface Specification.3. BOM Aggregation Support Server Implementation SimVentions has designed and developed the BOM Aggregation Support Server (BASS) to provide a common aggregation/deaggregation (agg/deagg) service interface, which can be used by clients regardless of computing platform or programming language. By applying web services and BOMs, BASS has been structured as an SOA that provides for model and entity agg/deagg, as well as first and second level agg/deagg.The distributed simulation network [i.e., HLA/ Runtime Infrastructure (RTI) or Distributed Interactive Simulation (DIS)] will continue to function as normal providing the real-time distribution of information to other clients. However, as a parallel support mechanism, BASS will provide automated agg/deagg support for enabled clients.  Figure 3.1 represents how BOMs are being used in the implementation of the BASS. In this figure, OneSAF operating as a client to the BAF implementation make both pattern and entity aggregation requests. The pattern aggregation request aggregates models together to form new models that share characteristics resulting in a Composite Pattern BOM. In the entity aggregation example, entities instances of models that have been registered with the BAF implementation are aggregated upon request as an example of a Flyweight Pattern BOM.The BASS was developed and implemented with the following technologies: BOMs, Web Services, XML, Patterns, Eclipse, Java, Concurrent Versions System (CVS), Apache Tomcat, and Axis.Figure 3.1 – How BOMs are used for AggregationIn Figure 3.2, an example is illustrated showing three pairs of entities that have been aggregated within the simulation environment. This is an example in which a Flyweight BOM has been generated as a solution to aggregate entities within a live simulation. Each entity was identified as a potential aggregation candidate by the BASS and a solution was provided to the clients of the simulation to be implemented to aggregate the entities and reduce the system load.Figure 3.2 – Entity AggregationFigures 3.3 through 3.5 show an example of the sequences involved during entity aggregation using the BASS. Entity aggregation takes place pre-simulation or during the actual simulation and is a situation where entity instances of model data are aggregated to be reflected as a single instance representing multiple entities. This process reduces the workload of the simulation. The amount of reduction is dependent upon the types and quantities of the entities involved in the simulation and aggregation.   Figure 3.3 is an example of an entity driver sending entity data to clients participating within the simulation exercise. In this example, the client is SV-AGG, which is a SimVentions client created to demonstrate our simulation and aggregation capabilities within a simulation environment. In this example, SV-AGG receives entity information from the entity driver. Then SV-AGG makes a request to BASS to join the aggregation support network where it registers an item, in this instance a model type of BOM, with the support server to represent the entities or a subset of the entities that are participating within the exercise. The BASS registers this information and sends IDs representing this information back to the client.   Figure 3.3 – Additional AggregationFigures 3.4 and 3.5 continue the process of this entity aggregation example by showing how BASS, acting as a passive participant within the simulation exercise, receives the same entity data that is being sent to the client and how it stores the data for aggregation analysis. Then when the client, SV-AGG, makes a request for an aggregation solution, BASS is prepared with live data to analyze the current entity situation and provide an aggregation solution to the client.  In turn, the client can retrieve and implement the solution to reduce load on the exercise.Figure 3.4 – Additional AggregationFigure 3.5 – Additional AggregationThis is an example where BASS acts upon the request of the client to prepare an aggregation solution that the client can implement. However, through the Load Balance Support options that are available with BASS, this process can be set up so that BASS is constantly monitoring the entities within an exercise and is automatically preparing solutions that the client can call at any point within the exercise without making a specific request for a solution.Figure 3.6 shows the sequence diagram of a typical interaction between a BASS client and a BASS server when making a request for an aggregation solution for entities within the exercise. This is an example of a client requesting the aggregation solution, like the example that was just described. Figure 3.6 – Entity Aggregation Sequence DiagramThe automatic Load Balance Support can be set up to provide a full range of aggregation support within the exercise including aggregation and deaggregation solutions. The process can also provide transfer control support, that will support the process of providing solutions to transfer the support of entities within the exercise from one client to another to better balance the load on the exercise.The process of Load Balance Support has a number of options that can be setup to act as triggers to generate aggregation/deaggregation solutions. Criteria for triggering these solutions include:  proximity to a specific obstacle, entity or feature in the synthetic battlespace; a change in the level of interest; or an increase (or decrease) in the physical entity load by the system and/or over the entire network.4. SummaryWe have explored the processes of aggregation and deaggregation within an SOA framework using an aggregation support server.  The SOA framework is represented through the BAF Interface Specification.  As described in this paper, a prototype implementation of BAF identified as the BOM Aggregation Support Server (BASS) has been used to demonstrate aggregation solutions to a small "mix" of simulation clients within an exercise network. Some of the benefits from this approach are identified as follows:Supporting aggregation without affecting the resolution of the simulation exerciseProviding an SOA solution that can be accessed by simulation clients regardless of architectureSupporting aggregation without affecting the detailed level of the data presented during the simulation exerciseImplementing aggregation to reduce processing entity loadsFacilitating better management of piece parts used to build the aggregation solution and govern the exchange of information within the simulation exerciseProviding aggregation support both pre-simulation and during simulationProviding flexibility to aggregate entities of varying model typesWe have shown that using an SOA approach allows a loose coupling connection of multi-pedigree participants within a simulation environment. As proven by the Base Object Model (BOM) Aggregation Support Server (BASS), an SOA approach to aggregating entities in a simulation can provide enhanced performance while at the same time maintaining the accuracy and details needed by the participants of both entity-level and aggregate-level simulations.   Additional InformationAdditional information and downloadable material on BAF can be found on the BOM Aggregation Framework SBIR Effort website at www.simventions.com/sbir_agg/.References[1]	Gustavson, Chase, Root, Moving Towards a Service-Oriented Architecture (SOA) for Distributed Component Simulation Environments, 05S-SIW-091.[2]	BOM Aggregation Framework Interface Specification, Version 1.0b, February 2005. [3]	SISO, BOM Template Specification – Volume I, Version 0.12 (draft), October 2005.Author BiographiesBEN SISSON is a senior systems engineer at SimVentions, Inc. (http://www.simventions.com) and is focused on the development and integration of technology for creating innovative and engaging experiences and solutions. He has recently worked on the development of the BOM Aggregation Support Server (BASS) which performs much of the aggregation discussed in this paper. Ben is a graduate of Strayer University, with a B.S. in Computer Information Systems and has supported a wide variety of data management engineering system efforts within the DoD as well as commercially. Ben lives in Virginia with his wife and three children.PAUL GUSTAVSON is a co-founder and Chief Technology Officer of SimVentions, Inc. (http://www.simventions.com) and is focused on the development and integration of technology for creating innovative and engaging experiences and solutions. Paul is a graduate of Old Dominion University, with a B.S. in Computer Engineering (1989), and has supported a wide variety of modeling and simulation, system engineering, web technology, and mobile computing efforts within the DoD and software development communities. He is a principal author of “C++ Builder 6 Developer’s Guide”; and contributor to other books and articles; and, has presented at numerous conferences. He is also a long-time advocate and pioneer of the Base Object Model (BOM) concept for enabling simulation composability, interoperability, and reuse. Paul lives in Virginia with his wife and two boys.KARL CROSSON is a computer engineer at SimVentions, Inc ( HYPERLINK "http://www.simventions.com" http://www.simventions.com) and is focused on the design and development of technology that enables rapid composability of components that can be applied in simulations within the Modeling and Simulation (M&S) domain. He has recently worked on the design of a framework that will support the automation of aggregations within various simulation environments. He has leveraged the OneSAF Objective System (OOS) to develop scenarios that can describe the organization structure and assign tasks within a constructive simulation. Karl is a graduate of Syracuse University, with a B.S. in Computer Engineering (2004). Karl lives in Virginia and enjoys reading, playing sports, and traveling.