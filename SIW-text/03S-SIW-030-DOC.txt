OneSAF: XML Performance in SimulationBoaventura DaCostaDynamics Research Corporation3505 Lake Lynda Drive, Suite 100Orlando, FL 32817407-380-1200bdacosta@drc.comRobin OutarScience Applications International Corporation12901 Science DriveOrlando, FL 32826-3014407-235-7660routar@ideorlando.orgKeywords:Modeling and Simulation, M&S, One Semi-Automated Forces Objective System, OneSAF, OOS, eXtensible Markup Language, XML, Performance, Document Object Model, DOM, Simple API for XML, SAXABSTRACT: The use of eXtensible Markup Language (XML) in modeling and simulation is not a new idea. There have been papers published on the subject as well as funded research to better understand where XML would be most beneficial. Programs such as Combat XXI and the One Semi-Automated Forces (OneSAF) Objective System (OOS) are benefiting from XML to both interchange and represent data. With all the benefits XML has to offer, there are some challenges. Performance is one of these challenges that still need to be tackled.This paper examines the performance challenges in using XML in a distributed simulation such as OneSAF. OneSAF XML performance concerns will be discussed including memory usage and execution speed. The use of validation, namespaces, and encoding will also be examined. This will entail discussions on the two most widely used XML interfaces for processing available on the market today, Document Object Model (DOM) and Simple API for XML (SAX). Both will be discussed through the use of Apache's Xerces XML parser. Lastly, lessons learned from the use of XML on OneSAF will be provided.1. IntroductionThe use of eXtensible Markup Language (XML) in modeling and simulation is not new. There have been a number of papers published on the matter, spanning various topics. Some papers have addressed finding neutral interchange formats for off-line sharing of data while others have involved the promotion of Computer Generated Forces (CGF) Behavior reuse in present and future simulation development. Organizations such as the US Army Training and Doctrine Command (TRADOC) Analysis Center (TRAC) in Monterey, California have sponsored research to standardize behavior representation using XML. In addition, systems such as the Close Combat Tactical Trainer (CCTT) Semi-Automated Forces (SAF), Modular Semi-Automated Forces (ModSAF), and Warfighter's Simulation (WARSIM) 2000 have been examined for potential behavior reuse using XML [1-6].Today, simulations are taking advantage of XML. Programs such as Combat XXI and the One Semi-Automated Forces (OneSAF) Objective System (OOS) are using XML to define data structures and promote data interchange and reuse. Started in 1996 and released as a World Wide Web Consortium (W3C) Recommendation in 1998, XML is quickly becoming a universal vehicle in which to structure documents and data via the Web. Commercial XML-native and XML-enabled products are now available providing everything from Integrated Development Environments (IDEs) to parsers and text-based repository search engines.  Some of these products have even been made available as open-source and royalty-free.XML, however, is still relatively new and has its challenges.  Performance is one of these challenges. XML is stored as text and, therefore, XML documents can get very large resulting in parsing challenges. The OneSAF program has embraced XML as its data storage and data interchange approach and has examined the performance challenges. This has resulted in the implementation of both numerous XML technologies and approaches. This paper examines the performance challenges in using XML in a distributed simulation such as OneSAF. OneSAF XML performance concerns will be discussed including memory usage and execution speed. The use of validation, namespaces, and encoding will also be examined. This will entail discussions on the two most widely used XML interfaces for processing available on the market today, Document Object Model (DOM) and Simple API for XML (SAX). Both will be discussed through the use of Apache's Xerces XML parser. Lastly, lessons learned from the use of XML on OneSAF will be provided.This paper begins with background information on OneSAF, XML, DOM, and SAX. These sections are not intended to teach these subjects, but rather provide the reader with some background for subsequent sections.1.1 OneSAFOneSAF is a next-generation CGF that can represent a full range of operations, systems, and control processes from individual combatant level and platform level to fully automated BLUFOR battalion level and fully automated OPFOR brigade level.  OneSAF is not a single product or system, but rather, a set of products each consisting of a set of interacting components and tools. These components provide overlapping functionality, which meets the various OOS system compositions [7].  They also interact with data and meta-data housed in repositories. These repositories are file-based and accessible through OOS-specific system repository services. Much of the data housed in these repositories is defined and structured using XML. Once fielded, OneSAF will be utilized across the three Army modeling and simulation domains of Advanced Concepts and Requirements (ACR), Training, Exercises, and Military Operations (TEMO), and Research, Development, and Acquisition (RDA) [8].1.2 XMLSince the World Wide Web Consortium (W3C) release of the XML 1.0 Recommendation there's been a definite increase in its popularity and use. Prior to its release, the two predominant markup languages available were Standard Generalized Markup Language (SGML, ISO 8879:1986) and Hyper Text Markup Language (HTML). While SGML is extremely powerful and extensible, it is difficult to use and not widely supported by the Web. HTML does provide wide support for the Web, but semantics for tags is fixed. As a result, XML was conceived as a markup language, which attempted to combine the power of SGML and the simplicity of HTML. Today, XML has matured into more than a document markup language. It has evolved into a vehicle for sharing and interchanging structured data [9]. XML is a meta-language, not a programming language. Through the use of rules (grammar) for designing structured data, XML itself is a language for describing languages [10]. XML is extensible, platform-independent, and supports internalization and localization [11].XML is being used in a number of industries. Since XML is not as restrictive as HTML, users may define the markup language appropriate for the need of the application.  XML has become so widespread that Microsoft's new .NET programming framework has XML support built-in. The new framework defines API's for reading, writing, and manipulating XML content [12]. Microsoft has also added XML support to the Microsoft Office suite of products.  Data can now be exported to and from XML in applications such as Microsoft Excel.Other companies have also invested vast amounts of resources to build XML-related technologies. For example, Sun Microsystems has integrated XML APIs into the latest release of the Java programming language. In addition, numerous XML-type databases, XML search engines, and other XML-enabled products are currently available. The open source community has also joined in with several XML-related products, helping to make XML more appealing now than ever.The Department of Defense (DoD) is no exception. The Modeling and Simulation (M&S) sector is currently using XML to address some of its data storage, use, and interchange challenges. Programs such as OneSAF are currently using XML to store and exchange data and meta-data internally and between simulations [5]. With so many XML-related products along with new recommendations being released, the future of XML seems very bright. However, while XML has been seen as a blessing by some industries, others have taken a much more cautious approach. XML is currently limited in both security and performance. Since XML is stored as free text, documents may be read by anyone with a simple text viewer. At the same time, these documents can also become very large, resulting in performance issues [13].1.3 Document Object ModelDOM is a platform-independent and language-neutral Application Programming Interface (API) that allows applications to dynamically read, manipulate, and write the content, structure, and style of both HTML and XML documents [14]. Influenced by SGML, DOM was originally a specification to allow both JavaScript and Java applications to be portable between Web browsers [15]. A W3C recommendation (Document Object Model (DOM) Level 1 Specification) since October 1998, DOM is now one of the predominate methods in which to work with XML documents. There are currently three DOM specifications available. Each is briefly described here. DOM Level 1 provides the core functionality specifications, such as navigation and manipulation.DOM Level 2 provides a stylesheet model, additional interfaces for document traversal, and support for namespaces. (Namespaces provide a simple way in which to qualify elements and attributes used in XML documents through association with URI references.)DOM Level 3 provides specifications on opening, saving, and validating XML document content. DOM is a logical model that may be implemented in any convenient organizational manner. However, documents are typically logically structured in memory as a hierarchical tree.Figure  SEQ Figure \* ARABIC 1: XML Document Fragment REF _Ref30831111 \h  \* MERGEFORMAT Figure 1 depicts a XML document fragment representing a U.S. Mailing Address. The XML document is structured in a hierarchical fashion. In this fragment, a U.S. address is composed of a name, street address, city, state, and zip code. The name is further decomposed into a first, middle, and last name.Figure  SEQ Figure \* ARABIC 2: DOM XML Document Representation REF _Ref30831111 \h  \* MERGEFORMAT Figure 1 depicts the same XML document fragment represented in DOM. The document holds the same hierarchical tree structure. Once populated, it can be traversed and updated via DOM interfaces. This allows vendors to implement a set of standard non-proprietary solutions promoting interoperable applications on the Web.1.4 Simple API for XMLSAX, originally a Java-only API, was developed from the need that a single, standard event-based API XML parser was needed.  Conceived (initial draft release) in January of 1998, SAX is considered by most in the XML community as the "de facto" standard for XML parsers [16].  SAX parses XML documents without the need to build memory resident structures that use excessive amounts of memory. Instead SAX invokes callbacks to client applications with information on the current element being processed. These callbacks continue until the entire document is traversed. SAX is a read-only parser. It does not support the writing of XML content to disk.  SAX release 2.0 is currently available and either partially or fully supported in a number of languages including:Microsoft's MSXML 3.0PascalPerlSAX in C++ Xerces-C [17]Java 22.0 XML PerformanceThis paper measures XML performance in two ways: memory usage and execution speed. A number of factors may affect these measures, including physical memory constraints, parsers, validating documents, using namespaces, and XML encoding. The following sections discuss XML performance in greater detail.  OneSAF employs a number of XML technologies. As a result a great deal has been learned from working with XML and using these technologies. Whenever possible, lessons learned are given on the use of XML and the various technologies.  2.1 Parsing Parsing and validation of XML data on OneSAF is currently being achieved using Xerces version 1.4.3 with current efforts moving towards Xerces 2. Xerces is an XML parser that complies with XML Schema and provides partial support for DOM level 2 (partial support for level 3) and SAX 2. Xerces is a project developed by the Apache Software Foundation. Xerces also provides support for XML validation and eXtensible Stylesheet Language Transformations (XSLT). 2.1.1 XercesThere are alternatives to Xerces. Developers have a choice of XML parsers from three major organizations: Apache Foundation, Oracle, and Sun Microsystems. The Apache Xerces parser supports DOM and SAX 2. The Oracle parser implements DOM Level 1, and SAX (both SAX and SAX 2). It has a partial implementation of DOM Level 2 and includes APIs for XSLT. The Sun parser (also known as Crimson or the Java API for XML Processing (JAXP), which was recently given to the Apache organization and is bundled with the Java 2 SDK v1.4.0.) incorporates support for DOM Level 2, SAX 2, XML Schema, and XSLT 1.0. This XML parser is based on the Project X parser from Sun and the Xalan XSLT processor from Apache. JAXP uses factory classes, allowing plugins into any conforming XML or XSL parser, promoting a standard mechanism for Java applications to interact with XML parsers.Xerces was chosen for OneSAF over the alternatives for a number of reasons. First, it supports both DOM and SAX parsing. This means OneSAF can benefit from both tree-based (DOM) and event-based (SAX) parsing. Second, both Apache and IBM support Xerces. Other XML products also support it, and an even broader client base is anticipated. Third, Xerces is supported in a number of programming languages including Java 2, C++, and Perl. Lastly, OneSAF adopted XML Schema Recommendation 1.0 as its XML data interchange format. At the time OneSAF began developing XML Schemas, Xerces was the parser of choice fully supporting the validation of XML using XML Schema. Many parsers available on the market at the time only supported XML validation through DTDs.2.1.2 Parsing ChallengesThe most challenging issue with the parsing of XML documents has been size when using DOM. DOM is a tree-based interface in which the parser creates an in-memory tree of nodes as the XML document is being processed. This makes DOM memory-intensive. Building a DOM tree can easily use as much as ten times the size of the XML document being parsed. For example, a one-megabyte document could easily require up to ten megabytes to be represented in memory. As expected, the larger the document, the poorer the performance.  This is based on a number of factors. The Java Virtual Machine (JVM) defaults to using 64 megabytes of the computer's total memory. This can be increased to whatever computers can support memory wise. (This issue would be isolated to Java only, of course).The total physical memory available in the computer handling the parsing.The complexity of the XML document. (I.e. the number of tags used, length of tags, complexity of hierarchy defined, and the total character count).The first reaction is to simply avoid DOM altogether and utilize SAX instead. Even though DOM is memory-intensive, it is a better solution when random access to separate parts of a document is required. However, DOM should only be used if absolutely necessary. DOM also provides both read and write support. An XML document can be represented by a DOM and written to a file on disk. The current release of SAX 2 does not support writing of XML. Lessons taken from OneSAF are that no one approach (using DOM or SAX) is adequate considering the diversity of the data being managed. Instead, an adoption in the use of both DOM and SAX is needed to meet the parsing requirements of the program. This resulted in policies providing guidance as to when to use SAX, DOM, or a combination of the two. These are briefly discussed in the following sections.2.1.3 Parsing SolutionsSAX is used only when reading of entire or partial XML documents is required. File size is not an issue, since SAX is event-based and triggers event callbacks for XML parsing events and does not read the entire document into memory. Therefore, SAX is very fast and memory efficient. Using SAX, however, does require the developer to create objects to hold the contents of the document being parsed. OneSAF has been able to successfully parse through entire XML documents up to 25 megabytes in size and successfully store the parsed data in memory. Additional tests have also been done. XML documents in excess of 500 megabytes have been parsed on OneSAF using SAX in approximately 20 minutes. These tests were performed on 1 GHz Pentium III Processors with 512MB of RAM. As expected, however, not all the data could be housed in memory at one time. DOM is used when both reading and writing of XML is required. This requires housing an entire document in a DOM tree. DOM is only used, therefore, with small XML documents. The data can be easily traversed and managed in memory and if necessary, written to disk. OneSAF has been able to successfully store, traverse, and manipulate XML documents between 1 and 2 megabytes in size using Xerces 1.4.3. Anything larger than 2 megabytes has resulted in poor performance. These results are based on an OneSAF development computer running both Windows 2000 and Linux with Pentium III Processors at 1 GHz with 512MB of SDRAM at 133MHz [18]. Current testing with Xerces 2 is showing much better performance. These results are discussed later in this paper.The two above cases are the simplest. They entail using either SAX or DOM independently. The third case entails the need to both read and write large XML documents. (In the case of Xerces 1.4.3, XML documents larger than 1 megabyte in size.) In such situations, consideration should first be taken to simplifying the XML document or content being written. For example, reduce the overall character count. This can be accomplished by avoiding lengthy element and attribute names, eliminating unnecessary use of space, replacing spaces with tabs if possible, or just logically dividing the XML content so that smaller files are written and managed in memory. If this optimization is not possible, a combination of DOM and SAX should be utilized. In this approach, a DOM is created from SAX events. Since SAX passes back all required information to build a DOM tree via callbacks (such as element names, attribute names, and values) a "mini" DOM tree can be created. This tree can represent the particular portion or fragment of XML document that needs to be traversed. This approach is very helpful and powerful when a DOM is needed to house a particular fragment of a large XML document. It avoids having to read parts of the XML document into memory that will never be needed.An example of this approach is searching a large catalog of publications that is stored in XML for a particular book. Depending on the size of the catalog, a DOM tree representation of the XML document may not completely fit into memory. The above approach solves this problem. The XML document can be parsed using SAX, when the desired book information is encountered a DOM tree is built. The SAX parser can then be easily aborted. (Aborting the SAX parser stops it from parsing the rest of the XML document). The performance gain with this approach far out ways the subtle complexity involved. While this approach involves using two different parsers, it does allow for a normally un-parsable XML document to be parsed.Writing the fragmented XML content back into the original XML document is another matter, however. Unfortunately, there is no solution to this problem available in the XML community at the time this paper was published. A number of vendors seem to be attempting to solve this problem, or at least appear to be heading in this direction with their XML solutions. However, nothing is currently available. For example Devsphere has released SAXDOMIX 1.0, which is a framework that contains builder classes that can forward SAX events or DOM sub-trees to applications during parsing. This framework provides simple interfaces that allow users to get DOM sub-trees during SAX parsing [19]. However, it currently does not support the serialization of this data back into the original XML document. OneSAF has adopted the policy that parsing large documents using DOM should be avoided. Instead, care should be taken to minimize the size of the documents. Some optimization measures have already been discussed. The following is a summary, which OneSAF developers take into consideration when working with XML.Is XML the best solution? Are there benefits from using XML to represent the data in question? Will OneSAF benefit from having a data interchange format (DIF) to represent this data?Have element and attribute names been kept at a minimum? In other words, have lengthy names been avoided?Has unnecessary use of spaces been removed? Use tabs if possible. (Keep in mind that some processors and editors treat tabs differently, especially when displaying text.)If comments and/or annotations have been used, are they really necessary? This markup will have to be parsed each and every time. Could this information be stored someplace else? How explicit is the XML DIF (XML Schema or DTD) in question? Is there added overhead because a meta-model approach has been taken? Could the XML grammar and structure be re-designed decreasing the amount of elements and attributes used without read-ability and functionality suffering?Lastly, can the XML document be logically divided into smaller documents, ensuring good performance?With so many XML-related products and new recommendations being released, it is anticipated that these parsing issues will be resolved over time. The following sections discuss some other factors that contribute to XML poor performance and examine OneSAF performance results with Xerces 2.2.2 Validation The validation of XML ensures that data content conforms to the grammar and structure as referenced by the supporting XML Schema or Document Type Definition (DTD). Validation is an important part of the OneSAF data architecture in that it provides a level of confirmation and verification that the data stored in any one XML document conforms to the grammar and structure, which defines it. OneSAF currently employs the use of Xerces 1.4.3 (with current efforts moving towards Xerces 2) to validate all XML content both against XML Schema and DTDs. OneSAF-specific XML content is defined using W3C XML Schema Recommendation 1.0. DTDs are also used on OneSAF, but only when adopted or reused from existing legacy programs.The most challenging issue with validating XML documents on OneSAF has of course been with speed and memory consumption. When using Xerces, having validator components in the pipeline will cause performance degradation. In a study performed by Devsphere, turning validation support on results in increased memory consumption of approximately 2.8% and a processing increase that is approximately 2.3 times slower than if validation had been turned off. (These results were based on a sample XML document with 50,000 records run on the Java 2 SDK v1.3 platform using Xerces 1.4. Please refer to the Devsphere.com Web site for the exact details of this study) [20]. The best way to avoid performance issues from validation is to simply turn it off in Xerces. Don't include validators (for either XML Schema or DTD) in the pipeline. Another solution is to only include the validator being used. For example, if validating against DTDs, don't include the XML Schema validator. (Keep in mind that each validator works differently. Some might not be able to distinguish between DTDs and/or XML Schemas.) OneSAF has adopted the approach of validation through policy. Clients using OneSAF data services can choose when to validate. For example, scenario data is stored in XML documents on OneSAF. These documents may become very large. Clients must decide when to validate these scenarios. Should validation occur upon saving a new document into a repository? Should validation occur only upon reading the scenario document? Or should validation occur through some other mechanism where all or a subset of scenarios are validated all at once prior to use? (OneSAF provides a Validate Repository Service, which allows entire repositories to be validated at once.)When validation is requested on OneSAF, two approaches are used. If the client wishes to have DOM already in memory and validated, then the DOM is re-validated using the Xerces parser. (The Xerces2 parser has partial implementation of the DOM level 3 specifications, which includes a revalidating DOM parser [22].) If the client wishes to have an XML document validated that is not in memory, but rather on disk in one of the repositories, then SAX is use to validate. (OneSAF has experienced considerable performance gains in validation of XML documents using SAX over DOM).2.3 NamespaceW3C describes XML namespaces as a means to "provide a simple method for qualifying element and attribute names used in Extensible Markup Language documents by associating them with namespaces identified by URI references" [23]. Namespaces promote reuse of markup instead of re-inventing it. It allows XML documents to use multiple markup vocabularies from external sources through URI references.Using namespaces with Xerces, suffers from the same performance issues as validation. The performance degradation is much more severe, though. In the same study performed by Devsphere turning on namespace and validation support results in increased memory consumption of 16.2% and processing that is 2.7 times slower than if both had been turned off. In all, the best way to eliminate this performance problem is to turn off namespace support in Xerces. Using namespaces, however, may not be avoided. OneSAF allows the use of namespaces. Clients, however, are encouraged to use namespaces only when absolutely necessary due to the performance costs.2. 4 OneSAF Validation and Namespace Performance BenchmarkingOneSAF has examined XML Performance using both version 1.4.3 and version 2 of the Xerces parser. Performance benchmarking and testing was performed under the following environment outlined in  REF _Ref30831759 \h  \* MERGEFORMAT Table 1:Software/HardwareSpecificationsXML Schema DocumentFile size: 1.95 MB (2,055,937 bytes)Element count: 40735Software:JProbe 4.0.2 (Benchmarking Software)Junit Testing Framework (Unit Testing Software)Xerces 1.4.3  and Xerces 2.0 (XML Parsing API)JDK 1.4.1 (JVM version)OneSAF Software:DOMReader classTestDOMReader classOperating System:Microsoft Windows 2000 with Service Pack 3Hardware:Pentium III 1.0 GHZ with 512 RAM and 60 GB HDDTable  SEQ Table \* ARABIC 1: OneSAF XML Performance Benchmarking SpecificationsUsing Xerces 1.4.3 with both validation and namespace features turned off, resulted in the XML document being parsed in an average of one minute and forty seconds (1:40) and utilizing an average of 14879 kilobytes (14.5 megabytes) of memory. Turning on both validation and namespace using Xerces 1.4.3 resulted in the same document taking an average of two minutes and fifty six seconds (2:56) and utilizing an average of 34138 kilobytes (33.3 megabytes) of memory. Overall, turning on namespace and validation support resulted in increased memory consumption of approximately 44.5% and processing that is approximately 1.8 times slower than if both had been turned off.Benchmark testing and use of Xerces 2 provided much better results. Using Xerces 2 with both validation and namespace features turned off, resulted in the XML document being parsed in an average of one minute and forty eight seconds (1:48) and utilizing an average of 13987 kilobytes (13.6 megabytes) of memory. Turning on both validation and namespace using Xerces 2 resulted in the same document taking an average of three minutes and twenty seconds (3:20) and utilizing an average of 14028 kilobytes (13.7 megabytes) of memory. Overall, turning on namespace and validation support resulted in increased memory consumption of approximately 1% and processing that is approximately 2.2 times slower than if both had been turned off. One will notice very little increase in memory consumption with validation and namespaces turned on, this is a result of the garbage collector being invoked several times more than when validation and namespaces were turned off. Garbage collection is very expensive, although the results indicate only a 1% increase; system performance was unacceptable when validation and namespaces were turned on.The performance increase between the use of Xerces 1.4.3 and 2 is significant. When validation and namespace are both turned on, even though documents took slightly longer to parse, the memory consumed during parsing was less than half. This has allowed OneSAF to double the size of XML documents it was able to originally successfully parse in DOM using Xerces 1.4.3 [21].  REF _Ref30831814 \h  \* MERGEFORMAT Table 2 provides a summary of the results discussed in this section. DescriptionParsing TimeMemory UsageXerces 1.4.3Validation and Namespace turned off1:4014879 kilobytes (14.5 megabytes)Xerces 1.4.3Validation and Namespace turned on2:5634138 kilobytes (33.3 megabytes)Xerces 2Validation and Namespace turned off1:4813987 kilobytes (13.6 megabytes)Xerces 2Validation and Namespace turned on3:2014028 kilobytes (13.7 megabytes)Table  SEQ Table \* ARABIC 2: OneSAF Xerces Benchmarking Results2. 5 EncodingThe W3C XML 1.0 specification requires that all processors (e.g. Microsoft Internet Explorer) automatically support the UTF-8 and UTF-16 encoding. When serializing XML documents, if either of these encoding are used, the encoding portion of the XML declaration (<?xml version="1.0" encoding="UTF-8"?>) is not needed. (Actually, the XML 1.0 recommendation doesn't require the entire declaration unless the version or other stand-alone information needs to be included for the system using the XML document.) If an encoding other than UTF-8 or UTF-16 is needed, this information must be included in the declaration. Once an encoding is chosen, there must be consistency between the character encoding specified in the XML declaration and the actual character encoding used to serialize the XML document.  The rule of thumb in selecting an encoding is to ensure that the best one is used. So which encoding is best? Different vendors will recommend different encoding schemes. For example, The Apache XML Project website recommends that documents be converted to US-ASCII or Unicode (UTF-8 or UTF-16) before parsing, since each character (when using ASCII) is guaranteed to be a single byte and map directly to the equivalent Unicode value. However, if characters beyond the ASCII range are or will be used, then one of the Unicode encoding should be selected. (Using either UTF-8 or UTF-16 will result in multiple byte sequences being read and converted for each character incurring a performance hit [24].) W3C, on the other hand, recommends that UTF-8 be used if a unique encoding is mandated and compatibility with US-ASCII is desired. W3C also points out that in some situations, such as for APIs; UTF-16 (or UTF-32) may be more appropriate [25].OneSAF, in studying the execution speed of parsing XML documents using UTF-8, UTF-16, and US-ASCII resulted in UTF-8 providing the best performance [26]. This study entailed parsing three program-specific XML documents. Multiple timings were collected for each document, and those averages were used to compute the average timing for each encoding. The timing results are shown in  REF _Ref30831860 \h  \* MERGEFORMAT Table 3.EncodingParse Time Results(In milliseconds)UTF-8339UTF-16359US-ASCII343Table  SEQ Table \* ARABIC 3: OneSAF Encoding Parsing ResultsTaking into consideration the recommendations of the XML community. The fact that UTF-8 appears to be the most commonly used encoding for XML with the additional fact that OneSAF requires character use beyond the ASCII range, not to mention the outcome of OneSAF encoding testing; the UTF-8 encoding has been adopted on OneSAF.3.0 OneSAF Lessons LearnedWith XML being an integral part of the OneSAF data architecture, there have been a number of lessons learned. The following list recaps the lessons mentioned in this paper as well as some others. These lessons apply to the use of XML in general as well as lessons learned during the implementation of some XML-specific technologies. This list is in no way complete. It should be considered a "living" list and will grow as more and more is learned from the use of XML on the OneSAF program. Don't use XML simply for the sake of using XML. Make certain that there are clear benefits to using it. Having to do a lot of translation and/or parsing will not result in good performance. So, don't use XML where it doesn't make sense.Depending on the parsing approach taken, using and parsing XML can be memory intensive. Make certain that both development and fielded hardware requirements can support the required memory needed. If memory concerns are an issue, SAX should be considered. The use of external entities, external DTDs or XML Schema, and namespaces should be avoided unless absolutely necessary. Even though these eliminate redundancy and promote reuse, they are expensive to use in parsing.Reduce the overall character count in XML documents. The smaller the document, the faster it will parse. This can be accomplished by avoiding lengthy element and attribute character names. Eliminate the use of space as well. Use tabs in place of spaces if possible. Spaces still have to be parsed, even it if is ignored by the application.If XML documents become too large, consider breaking them up logically into smaller documents. Avoid default values in attributes. Too many simply slows down processing. There are performance implications to using elements over attributes. If searching is in question, attributes have a bit of overhead for name-based lookup. It is, however, faster than linearly searching children nodes by name. Generally, don't over optimize in this area. Instead simply use elements for structure, or for things that contain structure; use attributes for simple-valued annotations that help describe the structure.Try to reuse parser instances. If the system is multi-threaded, consider establishing a parser pool of reusable parser instances. Simply avoid having to create a new parser every time one is needed.Depending on the parser being used, check the configuration carefully. Some parsers may perform differently whether using DTDs or XML Schema. It's best to check with the parser vendor for the recommended configuration based on the system in question. Some parsers may also have default features turned on. These features may incur poor performance. If features are not being used, turn them off.If validation is not needed, turn if off. Including validation will result in performance degradation. Also ensure that the correct validation is being performed. If DTDs are used, don't include XML Schema validation. Ensure that the correct XML encoding is being used for the system in question. Some XML IDEs and parsers will automatically assume Unicode ("UTF-8") if no encoding is specified. The three most common encoding schemes are ASCII ("US-ASCII"), or Unicode ("UTF-8" or "UTF-16"). Different vendors will recommend different encoding. If using "US-ASCII" ensure that the data will not include Unicode characters beyond the ASCII range, since multiple byte sequences must be read and converted for each character [24, 26].Fully understand the data being represented in XML. Realistically look at file sizes and determine the best parsers for the short and long term.A number of XML technologies may be necessary to accomplish the task. For example, both DOM and SAX may be needed, depending on the task and data in question. Don't limit an implementation to only one XML technology [27]. 4.0 ConclusionThe use of XML in modeling and simulation is not new. There have been a number of papers published on the matter, spanning various topics. This paper has focused on the performance aspects of XML in simulation, providing lessons learned from the OneSAF program. Memory consumption and execution speed concerns have been examined as well as the use of validation, namespaces, and encoding. XML is a maturing technology. Today it has become more than just a document markup language, but a viable vehicle in which to share and interchange structured data. As the popularity of XML grows and becomes more widespread, better solutions will become available addressing the performance concerns being tackled today.  5.0 AcknowledgmentSpecial acknowledgement goes to Tim Lucas and Karen Fraser for their research that proved invaluable in writing this paper.  6.0 ReferencesLacy, L.W., and G. M. Pearman. Computer Generated Forces Behavior Representation and Reuse Using the eXtensible Markup Language (XML). The Fall Simulation Interoperability Workshop, Orlando, FL, 17-22 September, pp926-932, 2000.Randolph, W., and D. King. Scenario Generation: XML To The Rescue. The Spring Simulation Interoperability Workshop, Orlando, FL, 2002.Lacy, L.W., and T.D. Dugone. USING XML TO SHARE OFFLINE SIMULATION DATA. Proceedings of the 2000 Summer Computer Simulation Conference, Vancouver, B.C., Canada, July 16-20, 2000.Lacy, L.W., T.D. Dugone., and R.W. Youngren. STANDARD DATA EXCHANGE METHODS FOR EQUIPMENT CHARACTERISTICS AND PERFORMANCE DATA. Proceedings of the Interservice/Industry Training, Simulation and Education Conference (I/ITSEC), Orlando, FL, 26-29 November 2001.DaCosta, B. XML Support for OneSAF Objective System Behaviors. 11TH-CGF-043, 11th Computer Generated Forces and Behavioral Representation Conference, Orlando, FL, May 2002. (Available at https://www.onesaf.net/References/Published/11TH-CGF-043.doc)Lacy, L.W., and T.D. Dugone. Representing Computer Generated Forces Behaviors Using eXtensible Markup Language (XML) Techniques. Proceedings of the Tenth Conference on Computer Generated Forces, Norfolk, Virginia, 15-17 May, 2001.OneSAF Architecture and Integration (A&I) Task Order. ONESAF product Line Architecture Specification (PLAS) - Volume I: Architecture Overview. Science Applications International Corporation (SAIC), Orlando, FL, September 2002. (Available at https://www.onesaf.net/Architecture_and_Integration/SystemsEngineering/SystemArchitecture/PLAS/OneSAF_PLAS_Volume_I.doc)Courtemanche, A., and R. Wittmann. OneSAF: A Product Line Approach for a Next-Generation CGF. 11TH-CGF-079, 11th Computer Generated Forces and Behavioral Representation Conference, Orlando, FL, May 2002. (Available at https://www.onesaf.net/Architecture_and_Integration/SystemsEngineering/SystemArchitecture/PLAS/11TH-CGF-079.doc)Abiteboul, S., and P. Buneman, and D. Suciu. Data on the Web: From Relations to Semistructured Data and XML. Morgan Kaufmann Publishers Web site: http://www.mkp.com/books_catalog/catalog.asp?ISBN=1-55860-622-XSol, S. What is XML. Web Developer's Virtual Library Web site: http://wdvl.internet.com/Authoring/Languages/XML/Tutorials/Intro/what_is_xml.htmlBos. B. XML in 10 points. W3C World Wide Web Consortium Web site: http://www.w3.org/XML/1999/XML-in-10-points Skonnard, A. XML in .NET: .NET Framework XML Classes and C# Offer Simple, Scalable Data Manipulation. MSDN Web site: http://msdn.microsoft.com/msdnmag/issues/01/01/xml/default.aspxMalik, M. Here to Stay: The Future of XML in Financial Services. Wall Street & Technology Online Web site: http://www.wallstreetandtech.com/story/mag/WST20020514S0004Le Hégaret, P., and R. Whitmer, and L. Wood. W3C Architecture Domain. W3C World Wide Web Consortium Web site: http://www.w3.org/DOM/Robie, J. What is a Document Object Model? W3C World Wide Web Consortium Web site: http://www.w3.org/TR/1998/REC-DOM-Level-1-19981001/introduction.htmlGenesis. The Official SAX Project Web site: http://www.saxproject.org/?selected=history1Other Languages. The Official SAX Project Web site: http://www.saxproject.org/?selected=langsOneSAF Architecture and Integration (A&I) Task Order. OneSAF Architecture and Integration Block A Hardware Baseline List. OneSAF.net Web site: https://www.onesaf.net/Architecture_and_Integration/SIT/minimum_hw.htmlDevsphere.com Java Development Services and Tools. Devsphere.com Web site: http://www.devsphere.comXML Parsing Benchmark. Devsphere.com Web site: http://www.devsphere.com/xml/benchmark/OneSAF Architecture and Integration (A&I) Task Order. Xerces2 Whitepaper Research. Science Applications International Corporation (SAIC), Orlando, FL, November 2002. (Available at https://www.onesaf.net/Architecture_and_Integration/SystemsEngineering/DataArchitecture/docs/xerces2.doc.doc)The Apache XML Project - Programming with DOM. The Apache Software Foundation Web site: http://xml.apache.org/xerces2-j/faq-dom.htmlBray, T., and D. Hollander, and A. Layman. Namespaces in XML World Wide Web Consortium 14-January-1999. W3C World Wide Web Consortium Web site: http://www.w3.org/TR/REC-xml-names/The Apache XML Project - Performance FAQs. The Apache Software Foundation Web site: http://xml.apache.org/xerces-j/faq-performance.htmlDurst, M. J., and F. Yergeau, and R. Ishida, and M. Wolf, and A. Freytag, and T. Texin. Character Model for World Wide Web 1.0 W3C Working Draft 30 April 2002. W3C World Wide Web Consortium Web site: http://www.w3.org/TR/charmod/#sec-EncodingsOneSAF Architecture and Integration (A&I) Task Order. XML Encoding. Science Applications International Corporation (SAIC), Orlando, FL, August 2002. (Available at https://www.onesaf.net/Architecture_and_Integration/SystemsEngineering/DataArchitecture/docs/xml_encoding.doc)OneSAF Architecture and Integration (A&I) Task Order. XML Performance and Tips Whitepaper Science Applications International Corporation (SAIC), Orlando, FL, July 2001. (Available at https://www.onesaf.net/Architecture_and_Integration/SystemsEngineering/DataArchitecture/docs/xml_performance_tips.doc)Author BiographiesBOAVENTURA DACOSTA is a Senior Software Engineer with Dynamics Research Corporation in Orlando, FL. He is leading the data engineering efforts for the OneSAF Object System as the Data Architect and Repository Lead. He received an M.A. in Instructional Systems and B.S in Computer Science from the University of Central Florida.ROBIN OUTAR is a Software Engineer with Science Applications International Corporation in Orlando, FL. He is currently involved in the development of the XML and Repository aspects of the OneSAF Objective System. He received a B.S. in Computer Science from the University of Central Florida.