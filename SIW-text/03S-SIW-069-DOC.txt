Model Execution in the OneSAF Objective SystemChristopher HendersonScience Applications International Corporation12901 Science DriveOrlando, Florida 32826-3014 HYPERLINK "mailto:Christopher.E.Henderson@saic.com" Christopher.E.Henderson@saic.comKeywords: SAF, CGF, Modeling, OneSAFAbstract:  The OneSAF Objective System (OOS) modeling effort must satisfy a set of challenging requirements. It must support a broad range of military operations, systems, and control processes. It must support models of various fidelity and resolution levels. It must support multiple user domains and applications that include both training and analytical objectives. And it must accommodate new requirements as they arise. To address these challenges, OOS has developed a composable architecture that emphasizes flexibility, extensibility, and integrability.The OOS modeling group has partitioned the development effort around three key aspects:Composition includes tools to graphically edit models.Representation includes grammars and management services for the models.Execution includes services for instantiating unit and entity models, and planning and executing behavior models.Prior work (see [6] and [7]) examined composition in detail. This paper begins by describing the requirements and derived goals of the OOS modeling effort. It then establishes basic OneSAF modeling concepts and ties these together into a coherent conceptual view of the system. The remainder of the paper focuses on the technical approach for model representation and execution.IntroductionThe OneSAF Objective System (OOS) will be used for a range of military domains and applications.  As a result, OOS must support modeling of a broad list of equipment and unit types, as well as the behaviors that control them.  Within OneSAF, the Modeling Infrastructure (MI) group is developing a modeling framework that includes services, data formats, tools, and processes required for model development. The recently christened Models Development (MD) group is responsible for developing the actual models.Note the implication here:  OneSAF makes a strong distinction between the modeling framework and the models built upon this framework.  The MI group has been developing the infrastructure since May, 2001, and the MD group began developing models in December, 2002.  Developing the framework before the models has resulted in a mature foundation on which the models are now being constructed, which has encouraged efficient development of reliable models. REF _Ref3525924 \h  \* MERGEFORMAT Figure 1 shows how the OneSAF framework services are partitioned. Although the diagram does not imply strict interface constraints, is does indicate the way in which each segment generally builds upon those below it, placing the most abstract ones at the top and the most fundamental ones at the bottom. Repository Services enable basic data management activities such as storage, retrieval, and version control. Composition and Common Services include coordinate types, logging services, system composition facilities, and other capabilities that are shared throughout the system. Simulation Infrastructure provides simulation services such as time management, event brokerage, and object distribution.Relying upon the low-level services below, the Modeling Framework lies near the top and provides a foundation on which OneSAF models are built. EMBED Word.Picture.8  Figure  SEQ Figure \* ARABIC 1 - OneSAF Layered Interface ViewOneSAF defines ambitious modeling goals:Model developers will be able to easily use existing OneSAF models to build new ones.Models will be modifiable during an exercise.After a mature set of models is established, users with limited software expertise will be able to tailor them to meet their unique requirements.The composable models approach presented here is designed to achieve these goals.  This paper begins with an overview of the modeling approach, presenting terminology and key concepts.  It then ties these concepts into a coherent, high-level system view. The remainder discusses the technical approach to modeling, including detailed discussions of representation and execution issues.Conceptual ViewThis section establishes the essential vocabulary for the OneSAF modeling effort and shows how these concepts integrate into a coherent system.Fundamental ConceptsThere are several key elements of OneSAF modeling:Battlespace actors correspond to real-world battlefield participants and include entities and units. Entities represent platforms (e.g. tanks, helicopters, trucks) and life forms (e.g. humans, military working dogs).  Units represent command and control structures (e.g. platoons, companies, battalions) that organize groups of entities. Battlespace actors are represented in data and are composed of physical models and behavior agents.Physical models provide mathematical representations of physical capabilities and serve as building blocks for battlespace actors.  Some common examples are weapons, vulnerability, mobility, communications, and sensing models.  These are implemented in Java and are built upon modeling framework services.Behavior models capture algorithms that command and control battlespace actors. These behaviors process perceptions and manipulate the physical capabilities of actors to simulate doctrinal effects.  There are two types of behavior models: Primitive and composite. Primitive behaviors are encoded in a programming language and provide simple behavioral functionality from which more complex behaviors are built.  Composite behaviors are represented in data and aggregate primitive behaviors into complex temporal structures.Behavior agents are software components that support planning and execution of primitive and composite behaviors.  Behavior agents, along with physical models, are the building blocks from which battlespace actors are composed. EMBED Word.Picture.8  Figure  SEQ Figure \* ARABIC 2 - Integrated Modeling ViewIntegrated View REF _Ref31105654 \h  \* MERGEFORMAT Figure 2 shows how the OneSAF modeling components interact with each other and with the rest of the system. At the center is the Modeling Framework, which provides interfaces and data formats from which models may be built. At the top are the modeling building blocks (physical models, behavior agents, and primitive behaviors) that are extended from the Modeling Framework, and the model compositions (units, entities, behaviors) that are built from these fundamental components.  At the top left, the Model Composer represents a set of graphical tools that are used to define the data descriptions of model compositions. As indicated, these descriptions are stored in a repository (the Models Library) and are used by the Modeling Framework to instantiate units and entities, and to plan and execute behaviors. The framework provides an interface to Environment Services for terrain reasoning and uses the Simulation Infrastructure to share attributes and events with other models.Development Organization REF _Ref3565955 \h  \* MERGEFORMAT Figure 3 indicates the three aspects around which the MI development effort is organized:Representation includes grammars for the composite model descriptions and services to manage these descriptions.Composition includes tools to graphically edit composite model descriptions.  These tools produce documents that conform to the grammars defined in Representation.  They also use Representation services to store and retrieve descriptions.Execution includes services for instantiating units and entities, planning and executing behavior models, and managing unit and entity perceptions.  The linguistic features defined by Representation drive the run-time features that are supported by Execution.  Like Composition, Execution uses Representation services to store and retrieve descriptions.The arrows in  REF _Ref3565955 \h  \* MERGEFORMAT Figure 3 indicate dependencies.  The features supported by Representation drive those that must be supported by Composition and Execution, which introduces dependencies on Representation.  But Representation products are developed independently of the Composition tools and Execution engine that use them. EMBED Word.Picture.8  Figure  SEQ Figure \* ARABIC 3 - Modeling Framework Development OrganizationTechnical ApproachThe remaining sections focus on the technical approach for the Representation and Execution aspects of  modeling.RepresentationThe Representation component (see  REF _Ref3565955 \h  \* MERGEFORMAT Figure 3) includes grammars for model composition descriptions and the services to validate and manage these descriptions. Grammars have been defined for a behavior definition language, a unit definition language, and an entity definition language.  Each of these languages defines how atomic elements (physical models, behavior agents, and primitive behaviors) may be composed into more complex models (units, entities, and composite behaviors).This composable approach provides several advantages:Composite models may be created and modified without changing source code.The features of the language are controlled by OneSAF and therefore may be tailored to meet modeling needs.Composite models do not rely on platform-specific computing capabilities.Composite models are stored as XML documents that conform to a formally defined grammar.  This grammar is used in two ways: 1. To ensure that composite model descriptions adhere to the prescribed syntax.  2. To rigorously define the linguistic features that must be supported by the Composition and Execution components.  The XML schema in  REF _Ref11909382 \h  \* MERGEFORMAT Figure 4 shows the top-level components of the grammar for the behavior definition language, which is the most complex of the three languages. The following sections elaborate on the features of this grammar.Behavior MetadataThe description_name and description_semantic sections provide locations to record a name and a human-readable description of the behavior.Variable TableThe table section defines parameters that drive the execution of the behavior. Three kinds of variables are supported: Input variables, local variables, and output variables.Input variables store values that drive the execution of contained primitive and composite behaviors.  For example a tactical road march behavior will require routes, lines of departure, start times, and other control measures.  These dependencies are precisely defined in this segment of the behavior.  Each input variable has a unique name by which it is referenced and a data type that constrains the values that it may hold.  Optionally, each input variable has a human-readable display name, which is used by interface tools to prompt users for values.  Each input variable is also designated as either mandatory or optional.  Mandatory input Figure  SEQ Figure \* ARABIC 4 - Composite Behavior Description Grammarvariables must receive a value from the behavior caller, while optional variables may be supplied at the caller’s discretion.Local variables store interim values that are passed among contained behaviors during execution.  As with input variables, each local variable has a unique name and a data type.Output variables store the end results of behavior execution.  These variables allow values to be passed back to the caller.  Like input and local variables, each output variable has a unique name and a data type.Timelines and Rule SetsThe evaluation_timeline and execution_timeline sections specify temporal sequencing of existing primitive and composite behaviors. The two have identical syntax but differ in purpose. The evaluation timeline determines whether performing the execution timeline is feasible in a given situation. That is, it checks for planning failures. The execution timeline describes the steps required to actually perform the behavior. This means that execution timelines modify the state of the simulation and consume simulation time, while evaluation timelines do not.Both types of timelines support temporal sequencing based on the temporal relations described in Allen, 1984.  Timelines use references to primitive and composite behaviors, which are contained within a variety of temporal constructs (see  REF _Ref12521963 \h  \* MERGEFORMAT Figure 5).  Referenced behaviors may be arranged to execute sequentially, in parallel, repeatedly, and conditionally.  These four temporal constructs may be nested to an arbitrary depth.  So for example, a parallel may contain sequential elements, which contain conditional branches, which contain behavior sequences.Timelines capture knowledge in a procedural way, which is appropriate for scripted, algorithmic behavior. But often it is intuitive to encode behavior declaratively in the form of condition-action pairs (rules). The rulesets section (see  REF _Ref11909382 \h  \* MERGEFORMAT Figure 4) of a behavior is where such rules are defined.Note that the composite behavior grammar supports two behavioral paradigms. Timelines capture procedural knowledge, while rule sets capture declarative knowledge. Neither style is superior in all situations, but instead each is appropriate for certain kinds of behavior. The two styles are complementary for capturing military doctrine. Timelines are used to encode the “normal” sequence of steps in a behavior, while rule sets are used to define reactions to situational interrupts.Supporting ServicesSeveral supporting services are required for the model description languages to be useful: Storage and retrieval of model descriptions in a standard formatSyntax checking to ensure that the description documents comply with the modeling language grammarsDependency checking to ensure that referenced model descriptions existFigure  SEQ Figure \* ARABIC 5 - Timeline GrammarExecutionWhile the Representation component defines the format for composition descriptions, the Execution component (see  REF _Ref3565955 \h  \* MERGEFORMAT Figure 3) provides an engine for turning these descriptions into actions at run-time. It  includes services for instantiating units and entities, planning and executing behavior models, and managing unit and entity perceptions. Some of the concepts herein are taken from [3].The execution engine supports three categories of models: Battlespace actor models, physical models, and behavior models. Each of these is discussed in detail in the following sections.Battlespace Actor ModelingBattlespace actors correspond to real-world battlefield participants and include entities and units. Entities represent systems that can be represented within the synthetic environment and that can express observable behavior.  An entity may be a life form (e.g. human, military working dog) or a platform (e.g. tank, helicopter, truck).  Units represent command and control structures (e.g. platoons, companies, battalions) that organize groups of entities.  A unit may be a component of a military, paramilitary, quasi-military (guerilla or terrorist cell, etc.), governmental or other organizational hierarchy.  Traditional military units are organized by echelon with well-established command and control structures, while paramilitary and quasi-military units may cooperate through more dynamic or ad-hoc relationship structures. As  REF _Ref3859952 \h  \* MERGEFORMAT Figure 6 shows, each actor contains agents, a world model, and a blackboard.  Agents provide physical and behavioral capabilities. The world model provides knowledge storage and retrieval, and inferencing capabilities. And the blackboard supports inter-agent communication.There is little agreement within industry regarding the definition of an agent, but we take a pragmatic approach: We are interested in incorporating approaches that lead to a high-quality system, not in formally defining the notion of agent hood. We pick and choose the attributes that are useful, but in general, our definition of agent is based upon descriptions in [4] and [5]. Taking this view, our OneSAF agents currently exhibit:temporal continuity: The state and identity of the agents persist over long periods of time.reactivity: The agents perceive and react to these perceptions.autonomy: The agents are proactive and set their own agendas, rather than being directly controlled.collaborative behavior: The agents work together to achieve common ends. inferential capability: They derive beliefs that are not explicitly perceived. EMBED Word.Picture.8  Figure  SEQ Figure \* ARABIC 6 – Static Battlespace Actor View As mentioned, battlespace actors contain two types of agents.  Physical agents provide physical capabilities such as weapons, vulnerability, mobility, sensing, and communications.  There is a clear correlation between physical agents and real-world physical capabilities.  A truck that contains a mobility agent will have the ability to move, and a life form that contains a weapons agent will have the ability to shoot.  Behavior agents facilitate the use of behavior models and do not correspond cleanly to real-world capabilities.  For example, behavior agents commonly support planning and executing behaviors, and collecting and reporting subordinate information on behalf of a unit.Each actor also contains a blackboard, through which its agents communicate by posting and receiving trigger events. A blackboard approach has been shown in [2] to provide advantages for computer-generated forces (CGF) applications. We selected a blackboard control mechanism for the following reasons:It allows agents to be inserted or removed from an actor with minimal impact on other agents.It allows integration of agents that were implemented independently using various paradigms.It frees agents from the need to support a complex control strategy.It provides event-driven control.Service requests (triggers) are separated from service providers (agents), which allows convenient, explicit control over the set of services that a system configuration supports. REF _Ref3860469 \h  \* MERGEFORMAT Figure 7 depicts a run-time instance of a battlespace actor.  It shows an entity, but a similar diagram applies for units as well.The entity contains a variety of agents, including both physical (mobility, weapons, commo, sensor, vulnerability) and behavioral (scheduler and command).  These agents are arranged around the blackboard/world model, which provides services for storage and retrieval of perceived truth and inter-agent communication (via events called triggers).  Note that this architecture supports introduction of new functionality in the form of new agents.  A new agent need only understand how to use the interface to the blackboard and the data types used to communicate between agents in the system.The depicted entity interacts with the OneSAF simulation engine to share attributes and events with actors, GUI tools, and other software components  EMBED Word.Picture.8  Figure  SEQ Figure \* ARABIC 7 - Dynamic Battlespace Actor Viewwithin the system.  The diagram indicates a couple of common event types that an entity might send and receive:  Orders, which stimulate the entity to plan and execute behaviors, and reports, which influence and reflect the perceived truth of the entity.  The entity also relies on various facilities that include Environment Services, which support terrain queries and terrain reasoning, and Repository Services, which provide data management capabilities.Each actor also contains a world model, in which the perceptions of the actor are stored and shared among the agents. The world model supports assertion and retraction of facts and provides rule-based inferencing services. To impose design discipline on agent development, the world model may only be accessed through the blackboard, so it may be viewed as blackboard extension.Physical ModelingWhen simulating the physical world, there is an inherent need to represent the physical attributes and behaviors of the objects in that world.  This is the purpose of the Physical Modeling Framework.  The various facets of an object’s physical representation are subdivided into general categories.  These physical models are composed together to model the physical representation of a particular Entity such as a vehicle or individual combatant (or life form).  The Physical Modeling Framework sub-component provides functionality that allows consistent development of physical models to take place.  As shown graphically in  REF _Ref18752833 \h  \* MERGEFORMAT Figure 8, the framework is divided into two major areas, the Core Physical Modeling Framework and the Specialized Physical Modeling Frameworks.In the Core Physical Modeling Framework, generic physical modeling services provide common functionality and generalization across multiple areas of physical modeling.  This is in contrast to the Specialized Physical Modeling Framework, where domain-specific frameworks provide specialized services tailored to specific areas of physical modeling.  These specialized domain-specific frameworks enable the efficient development of an ever-growing library of physical models of varying complexity, efficiency, fidelity, and resolution.  As shown in  REF _Ref18752908 \h  \* MERGEFORMAT Figure 9, within the modeling space, specific combinations of physical models are configured to represent specific Entities. EMBED Word.Picture.8 Figure  SEQ Figure \* ARABIC 8 - Physical Modeling Framework Logical DiagramThe Core Physical Modeling Framework provides four types of functionality.  First, it provides abstract classes that establish a generic interface to all types of physical models.  This provides a common representation for the specialized frameworks and enables them to use the same communication mechanisms.  Second, the core framework provides factories for generic instantiation of different physical model implementations at runtime.  This supports composition of Entities in data versus code.  Third, the core framework provides a set of geometry services that are crucial to the implementation of realistic physical models.  These services provide common functionality for representing and manipulating the geometric attributes and relationships of physical articulations such as guns, turrets and hulls.  Finally, the core framework provides mechanisms for publishing information about physical capabilities for behaviors to use.The specialized modeling frameworks provide eight sub-component frameworks for the development of eight categories of physical models.  Additional categories may be added in the future. The current specialized frameworks support modeling:WeaponsVulnerability (damage)SensorsTurretsMobilityCommunications Combat Service SupportMines EMBED Word.Picture.8 Figure  SEQ Figure \* ARABIC 9 - Entity Composition with Physical Agents Behavior ModelingOneSAF Behavior Modeling provides mechanisms necessary to encode and execute military tasks that command and control battlespace actors.  There are several concepts intrinsic to behavior modeling: Behavior agents, primitive behaviors, and composite behaviors.Behavior agents are software objects that provide command and control capabilities such as planning, plan execution, and situation assessment.  Along with physical agents, they form the building blocks from which battlespace actor models are composed.  Note that behaviors, not behavior agents, capture doctrine in the system. Behavior agents provide common services that support the use of these behaviors.  Example behavior agents are the scheduler, which provides the ability to receive and schedule orders, and the command agent, which provides the ability to plan and execute orders.Primitive behaviors are coded in Java and provide fundamental chunks of doctrinal functionality from which more complex behaviors are built.  In general, they process perceptions and manipulate physical agents to produce doctrinally accurate effects.  Example primitives might determine a unit’s formation, change an entity’s weapon control status, or command an entity to move along a route. Primitive behaviors are captured in Java code and provide fundamental behavioral capabilities such as move or shoot.  They serve as the building blocks for more complex, composite behaviors.  At run-time, primitives are executed in containers that impose temporal sequencing constraints.  In the context of these containers, primitives fall into two categories:  Foreground and background.  Foreground behaviors affect temporal flow of control. This means that the primitive will cause its temporal container to wait for it to finish before the temporal container can advance to the next behavior.Background behaviors do not affect the temporal flow of control, which means that execution of a primitive will not cause its temporal container to wait for it to finish before it executes subsequent behaviors.Composite behaviors are represented in data and aggregate primitive and other composite behaviors into more complex temporal structures.  An example composite might define the sequencing of primitive behaviors necessary to defend a battle position. Composite behaviors are captured in XML data files that are consistent with the OneSAF Behavior Definition Language (BDL) defined by the Modeling Services component. Composite behaviors specify both temporal and data dependency relationships among contained behaviors, and they are required to match the XML schema used to specify the OneSAF BDL. SummaryThe OneSAF Objective System has developed a composable approach to modeling that emphasizes flexibility, extensibility and integrability.The Modeling Infrastructure group has developed a modeling framework that includes common services to support battlespace actor modeling, physical modeling, and behavior modeling. The framework features:Support for agent-based model development.A world model for storage and retrieval of perceptions, and inferencing based on these perceptions. A blackboard which provides a decoupled inter-agent communication mechanism.The Models Development group began building models on this framework in December, 2002.References[1]	Allen, J. F.: ”Towards a General Theory of Action and Time,” Artificial Intelligence, Vol. 23, pp. 123-154, 1984.[2]	Braudaway, W.: “A Blackboard Approach to Computer Generated Forces,” Proceedings of the 3rd Conference on Computer Generated Forces and Behavioral Representation, Orlando, Florida, pp. 11-20, March 1993.[3]	Courtemanche, A.: “An Execution Engine for Composable Behaviors,” Proceedings of the 30th Summer Computer Simulation Conference, Reno, Nevada, 1998.[4]	Etzioni, O., and Weld, D. S.: “Intelligent Agents on the Internet: Fact, Fiction, and Forecast,” IEEE Expert, Vo. 10, pp. 44-49, 1995.[5]	Franklin, S. and Graesser, A.: “Is It an Agent or Just a Program? A Taxonomy for Autonomous Agents,” Proceedings of the 3rd International Workshop on Agent Theories, Architectures, and Languages, Springer-Verlag, New York, 1996.[6]	Henderson, Christopher and Grainger, Bart: “Composable Behaviors in the OneSAF Objective System,” Proceedings of the 2002 Interservice/Industry Training, Simulation, and Education Conference, Orlando, Florida, December, 2002.[7]	Henderson, Christopher and Rodriguez, Angel: “Modeling in OneSAF,” Proceedings of the 11th Conference on Computer Generated Forces and Behavioral Representation, Orlando, Florida, May, 2002. Author BiographyCHRISTOPHER HENDERSON has software experience in a number of industries, and has generally worked on projects involving applications of artificial intelligence techniques.  In recent years he has worked on modeling and simulation projects and is currently the Modeling Manager on OneSAF.  He holds a BS in Computer Science and an MS in Artificial Intelligence, both from the University of Georgia.