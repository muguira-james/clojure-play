SEDRIS: An Object-Oriented Data Representation Modelin a Procedural WorldMichele L. WorleySAIC12479 Research ParkwayOrlando, FL 32826(407) 207-3607 HYPERLINK mailto:michele.l.worley@saic.com michele.l.worley@saic.comKeywords:SEDRIS; Object-Oriented; data representation model; API; interchange; SDRMABSTRACT: In an effort to make the SEDRIS API platform-independent and thus increase its portability, the SEDRIS API specification is written in C, a procedural programming language, rather than an object-oriented language such as C++. This paper discusses how SEDRIS implements its object-oriented API in a procedural programming language. It provides a general overview of the layered structure of the API, then discusses in detail the functionality of the Data Representation Model API and Level 0 API in providing information on object relationships and properties, such as access to the data members of an object, is-a relationships, and has-a relationships.IntroductionThe Synthetic Environment Data Representation and Interchange Specification (SEDRIS) provides an object-oriented Data Representation Model, the SEDRIS Data Representation Model (SDRM) for describing the physical environment (terrain, ocean, atmosphere, space). Rather than describing specific data (relationships between such things as sound speed, temperature, roads, houses, etc.) as in a data model, the SDRM describes how such data can be represented.In addition to the SDRM, SEDRIS has an Application Programming Interface (API) that provides access to data provided in SEDRIS transmittals. The SDRM uses inheritance to provide data producers with the greatest flexibility in describing their data, while the API uses polymorphism to simplify the consumer's task of extracting data from SEDRIS. These object-oriented techniques allow data producers and consumers to interchange their data more effectively.Overview of the layered structure of the APIThe SEDRIS API consists of several layered APIs. The conversions API provides definitions of atomic types such as SE_BOOLEAN, SE_INT32, SE_UINT32, SE_FLOAT64, etc., together with support for converting between different spatial reference frames (sometimes known as coordinate systems) and different color models. The EDCS (SEDRIS Environmental Data Coding Specification) API (also known as the SDCS API) provides support for the use of EDCS codes and units by higher levels of the API. The SDRM API provides definitions of the classes and types used by the SEDRIS data representation model, including defining legal relationships between classes.The DRM APIThe functions of the data representation model (DRM) API are primarily oriented toward providing information on legal relationships between classes, and meta-information describing the data members of classes. In an object-oriented language such as Java, this kind of information might be supported by explicit reflection capabilities of the classes, in which a class, when queried, could supply information about itself. SEDRIS’ C implementation provides equivalent information, without relying on explicit object-oriented structures.For instance, the SE_TOKEN_ENUM enumeration is provided as a list of all SEDRIS classes, and is used to represent classes for various functions. The SE_IsA function, which determines whether two classes have an is-a relationship, takes two SE_TOKEN_ENUM enumerators as arguments.As a general statement, the DRM API provides information about classes: whether a class is abstract, what its superclass is, what classes of objects it may have as components, etc. For example, for the Polygon class, the SDRM will indicate that:it has 1 field, polygon_flagsit is-a Primitive Geometry (which is also its superclass), and thus is-a Geometryit is neither abstract nor a link classit must have 3 or more Vertices as components; optionally, it may have Colors, Image Mapping Functions, etc.In addition, the DRM API provides the various SE_xxx_FIELDS data structures, together with SE_FIELDS and SE_FIELDS_PTR. Each class X has a corresponding SE_X_FIELDS data structure, used to define the fields of that class. Even if X has no fields, there is an SE_X_FIELDS structure, with a placeholder integer field named “na”, for “Not Applicable”. These individual SE_xxx_FIELDS structures are used to build up a single structure, SE_FIELDS, containing a tagged union of the various SE_xxx_FIELDS. In C, it looks like:typedef struct{	SE_TOKEN_ENUM tag;	union	{…	SE_ACCESS_FIELDS Access;…	} u;} SE_FIELDS;For example, if in an SE_FIELDS variable we have tag = SE_ACCESS_TOKEN, then the corresponding union member is u.Access.To support polymorphism, all SEDRIS objects contain an SE_FIELDS rather than their individual fields structure, so that the procedural C implementation of the level 0 API can support one SE_GetFields function for all SEDRIS classes.The DRM API also contains a number of convenience functions dealing with fields. Just as Java supports a toString() method for each type, allowing the user to print Java objects, SEDRIS supports the SE_PrintFields() function, which prints the contents of a given SE_FIELDS variable, together with a number of helper functions to print variables of individual types used to build up the fields of SDRM classes. In addition to SE_PrintFields(), the data representation model API also supports an SE_ValidFields() function, which checks a given SE_FIELDS variable’s contents for correctness.The Level 0 APIThe level 0 API, unlike the DRM API, provides access to individual instances. Consider an individual terrain polygon from an s1000 database, when represented in SEDRIS:polygon_flags is set to contain the SE_TERRAIN_POLYGON flaghas a Property Value indicating its STGS mobility codehas a Rendering Priority Levelhas 3 or 4 VerticesThe Level 0 API, Encapsulation, and PolymorphismThe Level 0 Read API and Level 0 Write API are provided (in the reference implementation) with C interfaces; the implementation details are hidden from the user. Fundamental to both is the notion of a virtual “SEDRIS Object”, called an SE_OBJECT. The SDRM does not have a formal “SEDRIS Object” class as an ancestor for all other SEDRIS classes; the API provides this notion of an abstract SE_OBJECT.Figure 1. SEDRIS SDRM classes from an API point of view.As shown in figure 1, SEDRIS objects break down into 4 categories from an API perspective. All SEDRIS objects are treated as SE_OBJECTs by the API. An SE_OBJECT acts as a “virtual superclass” for all SDRM classes. (Future work on the DRM for ISO standardization will add an explicit “universal superclass” to the DRM to make this more apparent.) All Level 0 functions, in both the Read and Write APIs, operate on SE_OBJECTs. Most SDRM objects fall into the category of “generic” SEDRIS objects; that is, their classes do not require special methods within the API to perform operations or access their data members.SE_OBJECTs contain a set of data members, referred to as fields. Some abstract and container classes have no fields. For instance, consider Spatial Domain, which acts as a container for 2 ordered Location objects, specifying the spatial extent of the Spatial Domain’s container. Since all the information provided by a Spatial Domain is given by its 2 components, Spatial Domain has no fields. SE_OBJECTs also have several methods, which are represented as Level 0 API functions. These methods are:Retrieve the fields for read-only access.Replace the fields with a new set of values (write-only).Identify the class of the object.Retrieve the Synthetic Environment object corresponding to the transmittal to which the object belongs.Act as the starting object (root object) of an iterator.Retrieve unique ID of the object (if the transmittal to which the object belongs supports them).Retrieve current effective transformation for the objectRetrieve reference countSet/get user data pointerRetrieve number of paths to Synthetic EnvironmentAll SEDRIS objects are encapsulated. The SE_OBJECT structure’s implementation is hidden from the user by the interface, so that consumers cannot access the underlying data members and methods except through the interface. Objects belonging to “generic” SEDRIS objects only have the above “generic” methods.“Generic” SEDRIS Objects and Their MethodsAll SEDRIS objects have some common methods. However, since SEDRIS’ reference implementation is in C, a procedurally oriented language, these “methods” must be implemented as functions. In addition, SE_OBJECT is defined such that its structure is hidden, by declaring it as a pointer to a structure (which is defined by the API implementation rather than the interface).The SE_IdentifyObject() function identifies the class of an object, returning it as an SE_TOKEN_ENUM. This SE_TOKEN_ENUM can then be used as a parameter to various SDRM functions to retrieve information about the class:SE_IsA() – compares 2 SE_TOKEN_ENUMs to determine whether one class is a generalization of the otherSE_IsAbstractClass() – whether the given class is abstractSE_IsLinkClass() – whether the given class is a “link” class, i.e. is used as the link object on an association or composition relationshipSE_ComponentsList – given an SE_TOKEN_ENUM, retrieves the list of classes to which that class may legally have associations, and the multiplicity of each association. This information can be used in conjunction with SE_BidirectionalAggregation, which indicates, if 2 classes A, B have an aggregation relationship, whether A=>B is bidirectional.SE_AggregationsList – given an SE_TOKEN_ENUM, retrieves the list of classes to which that class may legally have associations, and the multiplicity of each associationSE_AssociationsList – given an SE_TOKEN_ENUM, retrieves the list of classes to which that class may legally have associations, and the multiplicity of each association. This information can be used in conjunction with SE_BidirectionalAssociation, which indicates, if 2 classes A, B have an association relationship, whether A=>B is bidirectional.The SE_GetFields() function retrieves the fields of an object for read-only access. This function takes an SE_OBJECT and a pointer to an SE_FIELDS_PTR variable as parameters, and if the parameters are valid, passes out the fields of the object via the SE_FIELDS_PTR variable.The SE_PutFields() function in the write API replaces the fields of an object during write-only access. This function takes an SE_OBJECT and a pointer to an SE_FIELDS as parameters, and if the parameters are valid, outputs the fields of the object to the transmittal to which the object belongs. The fields must be of the correct type for the class of object to which they’re being added.SEDRIS Synthetic Environments and Their MethodsAs shown in figure 1, some SEDRIS classes have additional properties and methods. Synthetic Environment objects are one such class.Consequently, Synthetic Environment objects support additional methods to:open and close the corresponding transmittalretrieve the current effective color model for the transmittalretrieve the current effective world coordinate system parameters (if any) for the transmittalidentify the level of support for object IDsidentify the SDRM version and EDCS version of the transmittalCurrently, the Read and Write APIs have different functions for opening a transmittal. The Read API’s function is SE_OpenSE, which, given a transmittal name and a pointer to an SE_OBJECT, opens the transmittal in read-only mode and returns its Synthetic Environment object. The Write API’s function, on the other hand, is SE_OpenSE_Write, which opens a transmittal in write-only mode, creates a new Synthetic Environment, and returns it to the user to begin creating a new Synthetic Environment.The two APIs conceptually deal with the same objects, but currently their reference implementations are separate. The Read API can only open transmittals for reading, while the Write API can only create new transmittals. Future work in SEDRIS includes merging the implementations of these 2 APIs to allow Read API functions to be called for Write API objects (where it makes sense), and to allow the modification and update of existing transmittals.Consequently, the Read API functions SE_GetColorModel(), SE_SetColorModel(), which retrieve and set the current effective world color model, only apply to the retrieval of Read API objects in read-only mode. Setting the world color model to a different value than the default provided by the transmittal (which can be retrieved by calling SE_UseDefaultColorModel(), then SE_GetColorModel()) does not change the transmittal on disk, but only its representation in memory.Similarly, the Read API functions SE_GetCoordinateSystemParameters(), SE_SetCoordinateSystemParameters() only retrieve the current effective coordinate system parameters for transmittals in memory, and do not affect any transmittal(s) on disk.Note that in addition to acting as the root object for a transmittal, a Synthetic Environment object is treated by both the read and write APIs as a handle for the transmittal. That is, the Synthetic Environment object retrieved by an SE_OpenSE() call must be retained while the transmittal is being kept open for reading. Passing it to SE_CloseSE() acts as a call to not only destroy the Synthetic Environment object in memory, but closes the corresponding transmittal. Similarly, a call to SE_CloseSE_Write frees a Synthetic Environment and closes the corresponding new transmittal.SEDRIS Image Objects and Their MethodsThe SDRM class Image does not contain a representation for the pixels/texels of the Image. Instead, the API encapsulates access to the pixels/texels of the Image via the SE_GetImageData() (in the Read API) and SE_PutImageData() (in the Write API) functions.Given an Image object, SE_GetImageData() retrieves the pixels of the Image, which are defined by the API implementation. These pixels are retrieved as an array of bytes, which are interpreted according to the image signature information defined in the fields of the Image.In the Write API, an Image’s fields must first be defined by an SE_PutFields call, in order to define the number of MIP levels the Image has, and the dimensions of each MIP level, before the Image’s data can be added.SEDRIS Data Tables and Their MethodsThe abstract SDRM class Data Table, like its concrete subclasses, does not contain a field corresponding to the cells of the table (the actual ‘data’ of the data table). Instead, the data of a data table is hidden by the API implementation, and can only be accessed via the appropriate API function calls.Early in the SEDRIS project, there was considerable debate about the kinds of tables that should be supported. In addition to supporting a simple “retrieve all information for the cells in a given region of the table”, there are efficiency considerations that often make it desirable to use cells in 2 other formats. The first, called a “packed” table, contains the same information as a “normal” layout, but is accessed as a simple array of bytes, without regard to “nice” word boundaries and the like. The second, called an “element” table, retrieves only one specified element per cell of the data table. Element data tables allow the user to deal with a stream of values all of a single atomic type, rather than with the cumbersome SE_PROPERTY_DATA_VALUE structure used by “normal” data tables to allow each element of a cell to be of a different type.Rather than representing these 3 types of tables as different SDRM classes, the API supports 3 types of methods for accessing the cells of a table, which allow the user to access the cells of the table in various arrangements:SE_GetDataTable(), SE_PutDataTable() - retrieve/create all elements for the cells within a specified regionSE_GetPackedDataTable(), SE_PutPackedDataTable() - retrieve/create all elements for the cells within a specified region, in a packed formatSE_GetElementOfDataTable(), SE_PutElementOfDataTable - Retrieve/output a specific element for all cells within a specified regionSummaryThe above has been a general introduction to how SEDRIS supports its object-oriented SDRM, via a C interface rather than an interface defined in an object-oriented language such as Java. Future work in SEDRIS includes the integration of the read and write APIs into a single framework, the Reference API Implementation Framework (RAIF), as well as a prototype mapping of the SEDRIS interface into Java.My thanks to Jesse Campos, Rob Cox, Bill Horan, and Farid Mamaghani for their support.ReferencesCampos, Jesse and Carswell, John. “The SEDRIS API, Reference API Implementation Framework, and SEDRIS Transmittal Format.”  Simulation Interoperability Workshop, Spring 2000. To be published.SEDRIS Data Dictionary (Version 2.5). (1999). File:  HYPERLINK http://www.sedris.org http://www.sedris.org, under Documentation.Author BiographyMICHELE WORLEY is a Software Engineer with SAIC (ASSET Group – Orlando office). Ms. Worley is a member of the SEDRIS core team, and maintains the data representation model. Ms. Worley has a B.S. degree in Computer Science from the University of Central Florida. EMBED MSDraw.1.01  