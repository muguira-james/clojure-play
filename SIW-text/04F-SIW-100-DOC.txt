If RTI’s Have a Standard API, Why Don’t They Interoperate?Trevor W. Pearce, Nima Bahrami FaridDepartment of Systems and Computer EngineeringCarleton University, 1125 Colonel By Drive, Ottawa, Canada, K1S 5B6{pearce,nima}@sce.carleton.caABSTRACT:  This paper provides some insight into the commonly asked question: Why don’t different RTIs interoperate? The simple answer is: RTIs are not required to interoperate. SISO is the logical organization to standardize RTI interoperation, but before doing so, a clear understanding of the implications of such a standard should be understood. The goals of this paper include providing insight and understanding, which might lead to an RTI interoperation standard eventually (but not in this paper). The paper contributes understanding towards:the fundamental nature of distributed systems, the RTI as middleware for distributed simulations, and how DIS and current SISO efforts such as Dynamic Link Capability, and the Open RTI Protocol relate to RTI interoperation. Publish and Subscribe mechanisms are used to illustrate the nature of distributed versus centralized systems, and to point out that all participants in a distributed system must use the same algorithms. The RTI API standardizes the interface to a set of distributed services, but does not address the implementation of how the RTI might provide the services. The paper includes a discussion of related efforts within the SISO community, and closes with some comments and questions about some possible ways forward. The paper suggests that RTI interoperability might be considered in the context of a broader discussion of evolving the HLA to address the needs of federation developers.1.   IntroductionThe goal of the High-Level Architecture (HLA) [5] is to provide an interoperability standard for simulation components, and the Run-Time Infrastructure (RTI) is the middleware that facilitates interoperability. The HLA standardizes the API for RTI services, but does not place implementation constraints beyond the behaviour visible to federates (simulation components) at the API. This API-approach to standardization has some advantages. RTI vendors have more freedom, since RTI implementations are not constrained in how they are designed and implemented internally to provide the required services. The API standard also creates a  “black box” perspective, which promotes modularity and separation of concerns. Ideally, RTI users should not be distracted by RTI implementation details, which (in theory) should simplify the use of the RTI. The HLA specifies the RTI API; however, the current version of the specification does not require different RTIs to interoperate. In today’s Internet age, some may find it unusual to have an interoperability specification that does not require interoperability of its supporting middleware. Imagine what might happen if a similar API approach was taken for Internet interoperability. Each computer would be equipped with an operating system (middleware) layer to execute applications, and the applications would connect to the middleware through a standard API. Unfortunately, applications could only expect to interoperate with computers running the same manufacturer’s operating system. Clearly this would be a severe restriction to Internet interoperability! The Internet interoperability specification gets around the problem of different vendor middleware by standardizing more than just an API. In particular, Internet standards include layered protocols for Internet services. Interoperability includes adhering to the protocols as well as the API. For the HLA to achieve interoperability among different vendor RTIs, the HLA would also have to include protocol specifications associated with RTI services.The goals of this paper are to provide insight and understanding into RTI interoperability, and to suggest some possible directions for future work that might eventually lead to an RTI interoperation standard (but not in this paper). Ideally, the paper contributes understanding towards:the fundamental nature of distributed systems. Distribution introduces issues that are not relevant to centralized systems. A distributed system perspective is needed to understand RTI requirements.  the placement of the RTI API within a model for distributed system middleware. A simpler model has surpassed the OSI model for distributed systems, and the RTI is presented as a middleware layer in the simpler model. how DIS and current SISO efforts such as Dynamic Link Capability, and the Open RTI Protocol relate to RTI interoperation. The discussion gives a bleak short-term outlook for RTI interoperability.To provide some practical context for discussion, publish and subscribe mechanisms are used to illustrate the nature of distributed versus centralized systems. A key point is that all participants in a distributed system must use the same algorithms. CORBA provides some examples of publish and subscribe services that have been standardized in a way to ensure interoperation of the resulting middleware, and some relevant differences between the HLA approach and CORBA are presented. The paper closes with some comments and questions about some possible ways forward towards RTI interoperability. There appears to be a difference between the needs of those developing distributed federations, and those who develop (typically) centralized federates. The needs of federation developers is suggested as an area that might be worth pursuing to strengthen the HLA standard. A discussion of RTI interoperability may be an appropriate subtopic in the context of federation concerns, rather than being singled out as an independent topic.2.    Distributed SystemsDistributed systems and centralized systems are fundamentally different. One of the key differences is the amount of local information that is available to allow decisions to be made. In a centralized system, all information needed to make a decision is local. For example, suppose a centralized system must make a decision based on the values of a set of variables. Since all variables are located locally, the decision can be made easily. In distributed systems, each participant has variables relevant to the participant’s goals, and participants must have knowledge of other participants’ state in order to make local decisions. Making decisions based on the values of a set of variables in a distributed system is (generally) more complex than in a centralized system. If all of the variables are local to the participant making the decision, the problem reduces to the centralized case. If the variables are partitioned among a set of participants, i.e. the variables are not all local to a single participant, then cooperation and communication are required among participants in order to make the decision. The participants require a means of sharing state information to enable local decisions by each participant. The need for distributed participants to cooperate and communicate to accomplish system wide objectives is not present in centralized systems, but is an essential requirement of distributed systems.The sharing of information in distributed systems has been a central concern since the inception of distributed systems. Eugster et al [2] give a survey of mechanisms that have evolved for this purpose, including message passing, remote invocations, and shared spaces. The authors conclude that publish and subscribe mechanisms are the most desirable from the application’s perspective, as the publish/subscribe is the only approach that decouples participants in time, space and flow. The authors group support for both interest management and notification together under the general publish/subscribe heading. Interest management records the type of information that specific participants (publishers) will make available to others, and the types of information that specific participants (subscribers) would like to receive from others. Notification uses the recorded interests to deliver specific instances of information generated by publishers to interested subscribers. The advantages of publish/subscribe include scalability; however, the authors warn that gaining this advantage at the application level come at the expense of increased complexity in the implementation of the supporting infrastructure services. The authors advise that the advantages of using a publish/subscribe mechanism can only be realized by an appropriate distributed infrastructure. The RTI includes a publish/subscribe mechanism for sharing information among federates. The interest management services are named publish and subscribe, and there are additional notification services that allow attributes (data) and interactions (events) to be communicated among interested federates. Through the remainder of this paper, “publish” and “subscribe” will be used to refer to the general publish/subscribe mechanism for sharing information, and are not intended to refer to the specific RTI interest management services.The “black box” view instilled by the HLA’s API-approach hides the distributed architecture of the RTI from federate developers. As a result, federations are often depicted as shown in Figure 1, where individual federates (F1, F2 & F3) are shown as components composed with a single RTI “box”. This diagram is in some ways misleading, since it suggests that there is a single RTI component (a counter-argument suggesting that it is the correct view is given later). In reality, the RTI “box” has an internal architecture that typically includes at least one Local RTI Component (LRC), consisting of at least the ambassadors, for each federate. Furthermore, the RTI architecture may include additional embedded components that do not run federates, but are dedicated to supporting the RTI. Figure 2 shows a configuration in which each federate is executing on its own dedicated node, and has its own LRC. This example is intended to convey a realistic RTI architecture that can be used to expose and discuss RTI interoperability issues, and is not intended to represent all RTI implementations. The LRCs provide a simulation-oriented middleware layer between the application and the network. The network below the LRCs has been shown as a “black box”; however, it too has an internal architecture of distributed and embedded components to support networking. For simplicity, assume that the network does not included embedded RTI components, and therefore, the LRCs must accomplish all RTI functionality. The implementation of RTI services, such as service to support the publish/subscribe mechanism, requires each LRC to communicate and cooperate. The LRCs must agree on how to implement the services, and the implementation will determine the efficiency of the resulting RTI.Figure 1:  Black Box view of RTI ArchitectureFigure 2:  Local RTI ComponentsThe need for all participating LRCs to agree on service implementation is the root of the RTI interoperability problem. Naïve approaches may simplify the LRC code, but may not scale efficiently for more demanding federations. The HLA RTI specification does not constrain vendors to specific RTI architectures and service implementations, and therefore, if the “black box” in Figure 1 is interpreted to mean one particular vendor’s RTI, then the figure might be argued to be the correct view under the current specification.  A case study of three publish/subscribe implementations for distributed robotics systems [1], illustrates the impact of the distributed infrastructure. A naïve approach based on distributed call-backs is modelled after the object-oriented observer pattern [4]. The publisher maintains a reference to a call-back method for each subscriber interested in a publisher’s information. To publish information, the publisher uses remote method invocation services to invoke each subscriber’s call-back method to inform the subscriber. Clearly this approach does not scale well, since the publisher must perform a remote method invocation for each subscriber. Scalability is hampered by the coupling of participants: the need for the publisher to have knowledge of each subscriber, and the need for the publisher to interact with each subscriber. A second approach based on CORBA event services [10] introduces an abstract event channel to decouple the publishers and subscribers. The services overcome the scaling problems of the observer pattern approach; however, the services do not provide priority, reliability and ordering for the information published into the event channel. If these quality of service (QoS) attributes are desirable, then they must be implemented above the event services in the publisher’s and subscribers’ local middleware components. A third approach uses the CORBA notification services [11], which are a superset of the event services and include filtering and QoS support beyond the event notification services. When analyzed for latency and scalability, the observer pattern approach outperformed the others for small applications, but did not scale well. The advantages of the event and notification services began to emerge as the applications scaled up, and the approaches outperformed the observer pattern approach.The robotics case study above provides valuable input to the RTI interoperability discussion. Suppose there are three federates in a federation, and three different RTIs. Furthermore, assume that each federate is executing with a different RTI’s LRC, and that each one of the RTIs uses a different one of the publish/subscribe approaches described in the case study. Figure 3 shows the resulting configuration. Suppose that LRC1 is based on the observer pattern approach, LRC2 uses CORBA event services, and LRC3 uses CORBA notification services. Each LRC presents the federates with a standard API for the publish/subscribe mechanism; however, each has implemented the supporting services differently. The federates could all invoke the publish/subscribe mechanism on their local LRC, but given the different implementation schemes, it seems unlikely that the LRCs in this example would interoperate. To ensure RTI interoperability, all of the participating LRCs must use the same publish/subscribe approach.Figure 3:   Federation with different RTI LRCs3.   Middleware for Distributed Simulations Reference models break large problems into more manageable components. The ISO/OSI reference model for distributed systems emerged in 1984 to provide a 7-layer model for participants in distributed systems, and the model has played a key role in early research and development of distributed systems. The model has been central to the development of middleware (and hardware) to support communication; however, the model has been less successful at higher layers of abstraction where the specific needs of applications do not fit the OSI layers as easily. A more general, 3-layer reference model has emerged as shown in Figure 4. The communications layer provides generic protocols for distributing information, and is often modeled internally using the four lowest layers of the OSI model (i.e. the transport, network, data link, physical layers). The application services layer contains middleware that presents sets of application-specific services to the applications layer, and uses the communication layer to interact with other participants. Figure 4:    Three layer reference modelThe RTI fits nicely into the model shown in Figure 4. The communications layer typically uses the TCP and UDP transport protocols. The application services layer represents the RTI. As discussed earlier, the HLA standardizes the API between the application and application services layers, but does not address the algorithms to be used in RTI implementations.  Federates reside in the application layer. A key point in Figure 4 is the distinction between the application services and communication layers. All non-application-specific communication details are handled in the communications layer. The applications services middleware provides protocol and implementation support for application-specific services. A common misconception is to view distributed simulation middleware as “just” a communication platform for federates. This view is appropriate for the earlier Distributed Interactive Simulation Standard [6], but overlooks services such as data management and time management, which were introduced into the RTI in an attempt to create more robust support for distributed simulations. The following brief discussion will position DIS in the context of Figure 4, and will allow further understanding of why the RTI is more than “just” a communication platform.The DIS standard does not distinguish between the application services and application layers, and focuses on the interface between the communication layer and the software above the communication layer. The DIS standard specifies all formatting and encoding aspects of the Protocol Data Units (PDUs) that are exchanged at the interface, but does not further specify application services above the communication layer. The publish/subscribe mechanism used in DIS is very simple. Each participant has a public and private data set, and a vector of all other participants who have interest in the public data set. When a participant modifies values in its public data set, it broadcasts appropriate update PDUs to the interested participants. The simplicity of the DIS approach has some inherent limitations. For example, the expression of interest does not allow subsets of public data sets to be specified, so participants receiving update PDUs must filter the PDUs to monitor the subset of interest. This places overhead on the participants, and any message filtered out and ignored by a participant represents unnecessary network traffic. Also absent in the DIS standard is a means to order messages in time. This can result in out-of-order anomalies. For example, an observer might receive a PDU indicating that a tank has exploded before receiving a PDU indicating that a missile has been fired at the tank. The DIS model views the communication layer as the middleware supporting distributed simulation, and therefore, the middleware is “just” a communication platform for participants.The goals of the HLA include providing a more robust distributed simulation environment that both overcomes perceived limitations of the DIS approach, and offloads the implementation of support services from the applications. For example, HLA data management services allow participants to express interest in subsets of public data, and to dynamically change the subsets of interest. In theory, this reduces unnecessary network traffic by only sending updates of interest. As another example, the HLA also includes time management services, which can eliminate out-of-order anomalies. The bundling of the HLA services into the RTI middleware effectively offloads the implementation of the services to an application services layer (as in Figure 4). As middleware, the RTI provides simulation-specific services like data management and time management. These simulation-specific services are not communication services, and the communication services reside in a layer below the RTI. Clearly, the RTI is not “just” a communication platform for federates.The standardization approach taken in the HLA is different from that taken in DIS. The HLA specifies the RTI API (between the application and application services layer), and does not specify RTI implementations and the lower-level messages that might be exchanged. The HLA approach is often called an API standard. The DIS approach is sometimes called a wire standard, since all messages exchanged “across the network wires” are standardized. As in most design decisions, there are tradeoffs associated with the approaches. Much can be learned from other approaches to middleware standards, such as CORBA [9]. The CORBA standards take the multi-layered approach to middleware that was introduced in the OSI model. In this approach, each layer is specified in terms of the interface it provides to the layer above, the interface provided by the layer below, and how the layer uses the lower level interface to realize the services it provides. In addition to specifying a user API (the interface to the layer above), the standard also includes a specification of an abstract implementation of the layer in terms of the services provided by the API of the layer below. In contrast, the HLA specifies only the RTI API, and does not specify an abstract implementation of the RTI services in terms of communication services.Mullally et al [8] have suggested a message-based wire standard for a subset of RTI services. General Dynamics has developed a reference implementation, and there was sufficient SISO interest to form the Open RTI Protocol Study Group (discussed later). The proposed standard is presented in a manner similar to the CORBA/OSI approach. From the brief discussion of the publish/subscribe mechanism, the abstract implementation appears to be based on the observer pattern described earlier. The implementation refers to the PDUs exchanged at the communication layer interface (the PDU details are presented in a manner similar to the DIS standard). The specification of the abstract implementation is very informal, and is explained in terms of when/why certain PDUs should be sent, and how an application should react when certain PDUs are received. The abstract implementation of the middleware provides sufficient detail to allow others to develop compatible RTIs, which could then interoperate for the specified services. 4.   Opinions on Some Current ActivitiesThis section discusses some current relevant SISO activities. The Open RTI Protocol Study Group and the HLA Evolved Product Development Group are the activities with the greatest potential to influence RTI interoperability. There has been some interest expressed in launching an Open Source RTI effort, and this is discussed briefly. The emerging Dynamic Link Capability standard is briefly mentioned, but only to clarify that it is relevant to RTI interchangability, not RTI interoperability. In addition to SISO activities, some opinions are also given on CORBA activities. In most cases, the discussion is very opinionated and based on perceptions at the time of writing. Due to the dynamic nature of the activities, it is quite possible that the opinions may no longer be valid.The Open RTI Protocol Study Group was inspired by General Dynamics’ success with a wire protocol for a subset of RTI services [8]. The General Dynamics protocol was suggested as an initial starting point, but the Study Group seems to have stalled without making any further progress. Ideally, the Study Group would have discussed the pros and cons of the concept and alternatives, and then if an open RTI protocol seemed feasible, converged on a direction to guide a Product Development Group in developing a standard. Although this effort has the greatest potential to result in RTI interoperability, it does not appear to be leading towards an RTI interoperability standard.The HLA Evolved Product Development Group is carrying out a maintenance activity on the HLA standard by integrating clarifications based on interpretations that have emerged, and introducing community-driven changes to the existing standards. This effort is still in the early stages, and the list of concerns to be addressed is still being compiled. So far, there has been little discussion relevant to RTI interoperability, and this has been limited to transportation types. Further more, the discussion has been more about issues in porting federates among RTIs that might not support the same transportation types, and has not included discussion of RTIs interoperating using consistent transportation types. It is not even clear how RTI interoperability would be introduced into the existing standards, since only the RTI API is standardized. Introducing RTI interoperability would require expanding the standard to include abstract implementations of RTI services, and standardization to the wire-protocol level. The scope of such a change would seem to warrant an alternate effort, such as the Open RTI Protocol discussed above, and does not appear to fit within the goal of a maintenance activity for the existing HLA standard.There have been several previous and on-going RTI projects that are open source or source available, for example [7], [3], [12]. Since DMSO stopped distributing free RTIs, there has been a resurgence of interest in “free” RTIs available as open source. The economics of using an RTI is certainly a valid concern, and one that should be discussed seriously when considering RTI interoperability; however, open source projects will not necessarily lead to RTI interoperability. An open source project might play a role as a reference implementation for interoperable RTIs; however, this would only be useful in the presence of a proposed standard for RTI interoperability.The Dynamic Link Capability (DLC) standard is currently undergoing balloting for acceptance. The concept of DLC is to allow federates to be moved to new RTIs without necessarily requiring the federate to be recompiled and re-linked into an executable form. In terms of Figure 4, DLC allows a different LRC to be introduced as the application services middleware layer without requiring the rebuilding of the federate (application) that is using the LRC. Obviously, if the execution runtime environment is changed beyond the scope of RTI (i.e. outside of the application services layer), it might be unrealistic to expect the federate executable to be directly portable. For example, if a federate were being ported to a machine with a different processor, it would be reasonable to expect that the federate executable must be rebuilt. Clearly, the DLC effort is relevant to RTI interchangability (not interoperability), since it provides a consistent mechanism for federates to connect to an LRC. The HLA community can learn a lot about interoperability from CORBA. First and foremost, CORBA is a mature technology that provides a host of examples of standards for interoperable middleware components. Fundamental in the standards is the inclusion of abstract implementations in terms of the APIs of lower layers. Without this, distributed local components could not interoperate. Also worth watching is the evolution of CORBA services, the introduction of new CORBA services, and the changes that arise as CORBA expands into new areas. With the current similarities and overlap of many services between CORBA and the RTI, some might wonder whether CORBA might eventually expand to include all RTI services. This seems unlikely in the near future since the needs of distributed simulation (such as time management) do not appear to align within the boundaries of CORBA’s current interests. Furthermore, the CORBA technology is skewed towards the client/server architecture for distributed objects, which might not be appropriate for all RTI architectures.5.   A Way Forward?Before considering possible ways forward, perhaps it might be worthwhile to consider whether it makes sense to mandate RTI interoperability. As suggested in the opening paragraphs, the idea of requiring a widely distributed set of nodes to run the same vendor’s middleware seems counter to expectations in the Internet age, and at first glance, RTI interoperability would appear to be a logical goal. However, requiring different vendors’ RTIs to interoperate involves agreement on the algorithms for the implementations of RTI services. The need to agree on algorithms raises the question: can algorithms be found that will suit the needs of all users, and therefore warrant being entrenched as the approach to be taken by all? The robotics case study considered earlier suggests that the answer is no. Consider two RTI scenarios based on publish and subscribe services from the study. In case 1, a (relatively) small and simple federation with limited memory resources is concerned about execution speed. The observer pattern might be favoured since it outperforms the other approaches for small federations, and is likely to have a smaller memory footprint. Case 2 is a (relatively) larger and more complex federation in which network performance is a key factor. The memory footprint penalty will likely lose significance in the face of scalability, and an approach based on CORBA notification services might be preferred. The circumstances associated with each case lead to different conclusions about which approach is optimal. Choosing one of the approaches as the standard for both cases would result in non-optimal performance in one of the cases. In light of the above argument, a means to achieve RTI interoperability becomes less clear. The remaining discussion in this section suggests some ideas and scenarios that might bear further consideration.  Black Box RTI: One of the potential stumbling blocks in discussing RTI interoperability is the monolithic, black box view of the RTI described earlier (recall Figure 1). The black box view is appropriate for the developers of individual federates, but is very awkward for those tasked with realizing federations. Realizing a federation includes activities such as selecting an RTI, attention to networking details such as topology, firewalls, and bandwidth, devising fault tolerance strategies, and coordinating the distributed effort of assembling federates into a running federation. A black box view of the RTI is not appropriate in this domain. When selecting an RTI, information should be available regarding how the RTI will perform for the desired federation and network architecture. If interoperating RTIs eventually appear, then this will be an RTI selection factor. When there are issues below the federate level, some degree of transparency, along with diagnostic and troubleshooting help should be available at the RTI level. Interoperating RTIs would provide a step towards transparency, since the service algorithms and wire protocol messages would be known publicly. Perhaps some further discussion is needed on how the HLA might evolve to meet the needs of federation developers. RTI Profiles: The current RTI standard dictates the set of services that is deemed appropriate for all federations. The selection of an RTI for a specific federation must account for the specific needs of that federation, and the complete set of services may not be needed. Furthermore, including the complete set may force non-optimal RTI implementations due to complexities in the interactions among service groups. For example, including Distributed Data Management (DDM) services in an RTI implementation may complicate the implementation of the publish/subscribe mechanism. The complications arise because the DDM service group and the publish/subscribe service group are not orthogonal, i.e. the correct operation of each service group depends on the presence of the other. In cases where DDM services are not used, the RTI implementation might be simplified by omitting the DDM implementation and any related concerns. Other standardized middleware domains, such as Ada, POSIX, CORBA and Java, have faced similar concerns. The response has been the creation of standard profiles that organize services into a common core along with additional subsets that are appropriate under different requirements. Typically, the need for profiles arises as the domain of application of the middleware expands. Most recently, the push into wireless domains has resulted in middleware profiles that are targeted to platforms with scarce computing resources. The profiling approach allows more efficient middleware implementations, which can be optimized to meet the needs of the different profiles. There appears to be a basic subset of RTI services that are widely used, for example, the services addressed by the General Dynamics wire protocol [8]. Beyond that, there may be room for RTI profiles that address requirements such as real-time, data distribution, time management, and alternate transportation types. If RTI profiling was feasible, perhaps an interoperability profile could be specified to allow RTI interoperability among a specific subset of services. While RTI profiling has been a long-standing topic of discussion, perhaps some further discussion is needed on the merits of profiling vs. a single complete set of services.Component-Oriented Composable RTIs: One way to tailor middleware to specific needs is to have a component-oriented architecture, and to allow users to configure the middleware to address their requirements. A component-oriented composable RTI might be useful to federation developers who must deal with heterogeneous computing platforms distributed across a particular network topology with network-specific infrastructure quirks. Perhaps some further discussion is needed on how RTI interoperability might be obtained in the context of a composable RTI. Perhaps an RTI could be configured with standardized, interoperable implementation components when desirable, and re-configured with specialized components for applications where the advantages of specialized components in a single RTI used by all federates outweighs the advantages of RTI interoperability.The Future: Speculation on future requirements and applications of the RTI should be considered when discussing RTI interoperability. While there are many directions that this discussion might take, consider the possibility of federate servers. There may be a future advantage in providing federates as services obtained on the Internet. Including such a federate in a federation would require connecting to a federate server, and an instance of the federate would be spawned and dedicated to the client’s federation. The actual execution of the federate would be done on resources associated with the server, not resources associated with the client. The advantages of this include: a single source for the federate, so changes and upgrades are instantaneously available to all users; the ability to charge per use of the federate; and the protection of any intellectual property in the federate (i.e. the client cannot reverse engineer or copy the federate because they do not have direct access to the executing federate). RTI interoperability would be an important aspect in the success of federate servers. The absence of RTI interoperability would require the server to use the same RTI as the client. This is not an insurmountable problem (e.g. the RTI services might be provided by a similar RTI server), yet the presence of interoperable RTIs might simplify the problem. Perhaps further discussion is needed on potential future applications, and how RTI interoperability might play a role.6.   ConclusionsThe short-term prospect of RTI interoperability does not look positive. Few would argue against the seductive vision of Internet-like interoperability among different vendors’ RTIs, yet there are logical reasons why this should not be rushed without careful consideration. This paper has provided some information towards the understanding of what RTI interoperability means in the context of distributed systems, and how some current activities are (or are not) relevant. The paper has also argued that the advantage of RTI interoperability will be offset by the disadvantage of trying to make one algorithm suit all needs. The case study example of publish/subscribe services has been used to illustrate that a single optimal publish/subscribe algorithm is unlikely to be found. Rather than abandon RTI interoperability, further discussion is needed to devise a strategy that will allow RTI interoperability to coexist with specialized RTIs. Perhaps the RTI interoperability discussion should be part of a broader discussion of how the HLA might evolve to address the needs of federation developers.AcknowledgementThe author sincerely thanks the reviewers for their insightful and helpful comments. Their input has helped to improve the paper.7.   References[1]	M. Amoretti, S. Bottazzi, M. Reggiani, S. Caselli,“Evaluation of Data Distribution Techniques in a CORBA-based Telerobotic System”, Proc. of the 2003 IEEE/RSJ Intl. Conf. on Intelligent Robots and Systems (IROS 2003), October 27-31, 2003 - Las Vegas, NV[2] 	P.Th. Eugster, P.Felber, R. Guerraoui, A.-M. Kermarrec, “The Many Faces of    Publish/Subscribe”,  ACM Computing Surveys, 35(2), pages 114-131, June 2003[3] 	The French National Aerospace Research Establishment – Toulouse Research Center (ONERA-CERT), CERTI Open Source RTI, Toulouse, France http://www.cert.fr/CERTI/[4] 	E. Gamma, R. Helm, R. Johnson, J. Vlissides, “Design Patterns”, Addison-Wesley Publishing, 1995, ISBN: 0201633612[5] 	“IEEE Standard for Modeling and Simulation (M&S) High Level Architecture (HLA)”, IEEE Std 1516-2000, 2000.[6] 	“IEEE Standard for Distributed Interactive Simulation”, IEEE Std 1278-1993, 1993[7] 	The MOVES Institute, “eXtensible RTI”, Naval Postgraduate School, Monterey, CA, http://www.npsnet.org/~npsnet/xrti/ [8] 	K. Mullally, G. Hall, D. Gordon, B. Pemberton, C. Peabody, “Open, Message-Based RTI Implementation - A Better, Faster, Cheaper Alternative to Proprietary, API-Based RTIs?”, Proc. of the 2003 Spring SIW, April 2003, Paper 03S-SIW-112, http://www.sisostds.org/[9] 	Object Management Group, Common Object Request Brokerage Architecture (CORBA), http://www.omg.org/[10] 	Object Management Group, “CORBA Event Service Specification”, Version 1.1, March 2001, http://www.omg.org/technology/documents/formal/event_service.htm[11] 	Object Management Group, “CORBA Notification Service Specification”, Version 1.0.1, August 2002, http://www.omg.org/docs/formal/02-08-04.pdf[12] 	Parallel and Distributed Simulation Lab,  “Federation Development Kit”, Georgia Institute of Technology, Atlanta, GA, http://www.cc.gatech.edu/computing/pads/fdk/Author BiographyTREVOR W. PEARCE is an Assistant Professor with the Department of Systems and Computer Engineering at Carleton University, Ottawa, Canada. His research interests are in embedded real-time systems, distributed simulation, and engineering methodologies. RTIF1F2F3F3F2F1NetworkLRCFederationLRCLRCRTINetworkCommunication LayerLRC2LRC1LRC3F3F2F1Application Services LayerApplication Layer