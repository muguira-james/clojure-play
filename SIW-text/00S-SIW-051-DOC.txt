Visual construction of JavaBean federatesMark CusackNick ExonPeter HoareRoger HoyleDefence Evaluation and Research AgencySt Andrews Road  Malvern, Worcestershire WR14 3PSUnited Kingdom{cusack, njexon, peteh, rh}@signal.dera.gov.uk Keywords:JavaBeans, visual construction, HLA, Jini ABSTRACT: The arrival of component technologies such as JavaBeans has resulted in a new approach to software development that has the potential to increase code reuse and reduce development times. Simulation can benefit from this technology by exploiting components as reusable simulation artefacts.The Java Component Federate Infrastructure (JCFI) takes advantage of the latest developments in the Java programming language, including bean contexts and Jini, to support simulations composed of hierarchical collections of JavaBeans. Our components typically represent a subsystem of a platform entity, for example its sensor, propulsion, or behavioural capability. At execution time, JCFI uses Jini technology to manage federation distribution and initialisation, and provides the components with access to communication and time management services in a way that is consistent with the HLA approach.We have extended the JCFI to incorporate visual simulation construction tools and techniques to support the rapid assembly of federates and federations. The visual programming technologies supported by Java allow users such as analysts, who are not programmers, or do not have time for programming, to quickly construct and execute simulations. In our approach, the graphical representation of a JavaBean simulation component is manipulated and customised using either a commercial-off-the-shelf (COTS) Integrated Development Environment (IDE) or a modified version of Sun‚Äôs BeanBox.The JCFI has been used to develop a flexible simulation environment to support command and control research. The use of simulation technology to stimulate Command Information Systems (CIS) is expanding in response to new initiatives such as Battlefield Digitisation; these have the potential to increase the complexity of CIS to the extent that simulation is the only practical way to exercise the functionality, explore new concepts, and validate implementations. Our system provides a rapidly reconfigurable and extensible capability through its use of components and visual assembly.1. IntroductionThe use of simulation in the defence domain is becoming increasingly widespread, and any progress that can be  made  in  reducing  costs  and  development ________________This work was carried out as part of the Technology Group 10 of the MoD Corporate Research Programme.¬© British Crown Copyright 1999/DERA. Published with the permission of the Controller of Her Britannic Majesty‚Äôs stationary Office.times is desirable, particularly in the current climate of falling budgets.  One way of reducing overheads is to develop simulations that are flexible in that they are capable of adapting to new and changing requirements.Among software developers the consensus is that the best way of ensuring flexibility is to build systems out of reusable components conforming to a ‚Äúplug-and-play‚Äù architecture. The functionality of a system can then be changed or extended by substituting components or plugging in new components.While the idea of reusing previously developed software is not new, the arrival of component software technologies has resulted in a new approach to software development that enhances the role of components as reusable artefacts. Key technologies include the JavaBeans component architecture [1], and the Jini connection technology [2], both developed by Sun Microsystems. In JavaBeans, the emphasis is shifted from programming software to building a system by assembling and integrating existing components. Each component, or JavaBean, is capable of being manipulated and customised using builder tools. When combined with intuitive visual metaphors, these builder tools have the potential to allow non-programmers to construct software systems from ready-made JavaBeans. Because JavaBeans are written in Java, programmers have easy access to features such as platform independence, graphics, and networking. Taken together, the power of the Java language and the simplicity of the JavaBeans architecture work to reduce software development times and promote reuse.Jini is a distributed computing environment that extends the concept of ‚Äúplug-and-play‚Äù to networking. A Jini-enabled hardware or software component, or service, can be connected to a Jini network and announce its presence. Existing services on the network can be notified of the arrival of the new service and reconfigure themselves accordingly. Jini provides support for clients that wish to use such a service to locate it and call on it to perform tasks. The Jini architecture takes many of the ideas from the JavaBeans architecture and the Java language, and generalises them for distributed computing.A number of simulation frameworks have been developed based upon the JavaBeans component architecture [3-6]. These frameworks make use of the high level abstraction provided by JavaBeans to represent sections of a model. At the lower level, Java language features such as threading and event handling allow simulation concepts to be incorporated into the frameworks in a natural way. Java is well supported within wider simulation initiatives such as the High Level Architecture (HLA) [7], which provides run-time support for distributed simulation. A number of HLA implementations are available that are either written in Java, or provide a Java API to a C++ implementation [7-9]. Java is an ideal implementation language for the HLA since both possess well-designed object-orientated characteristics. These characteristics can be exploited to provide a smooth mapping between programming language and simulation constructs.Our Java Component Federate Infrastructure (JCFI) [3] draws together the JavaBeans architecture and the HLA to produce a run-time environment in which federates composed of reusable components can participate in a distributed simulation. We have used the JCFI to investigate the issues surrounding the visual construction of HLA federates from JavaBeans. To achieve this, we have taken Sun‚Äôs BeanBox, a free graphical tool for customising and joining JavaBeans, and transformed it into a powerful tool for visually composing simulations. In addition, we have assessed the suitability of a commercial-off-the-shelf (COTS) Integrated Development Environment (IDE), to the task of composing HLA federates from JavaBeans. In this paper, we present an overview of the JCFI and discuss the recent extensions to provide support for federation initialisation and execution using the Jini architecture. We describe our modified BeanBox, and present our experiences of using COTS tools to visually construct HLA simulations. We also show how interoperability can be achieved between C++ federates and JavaBean federates within the JCFI scheme, and highlight the similarities and differences between our approach and the HLA‚Äôs. Finally, we give an account of the use of the JCFI-BeanBox environment to create a simulation tasked to stimulate a Command Information System (CIS).2. Overview of the JCFIBefore giving an overview of the JCFI it is worth giving a short definition of a JavaBean. A JavaBean is a Java object or a set of objects that performs a well-defined task. In its simplest form, a JavaBean is an instance of a Java class that has a no-argument constructor. A JavaBean possesses a state, which is maintained in the JavaBean‚Äôs member variables, known as properties. The state is exposed through get and set methods on the JavaBean. JavaBeans can advertise changes in their state by exchanging Java event objects, or by performing direct method calls on each other. It should be noted that there is no super class from which all JavaBeans are derived.The JCFI provides run-time support for collections of JavaBean components that interact to perform a simulation. The JCFI defines two types of basic JavaBeans: Simulation Components and Simulation Containers. Users may subclass Simulation Components and Simulation Containers to add their own functionality. Simulation Components possess the code to perform the simulation, and they run in their own thread of execution. Simulation Containers provide a nesting context for Simulation Components and for other Simulation Containers, which can lead to the formation of a simulation with a hierarchy or logical structure. Simulation Components within a Simulation Container are free to communicate directly with one another via the Java event model, or by invoking methods directly on each other. Simulation Components advertise the types of events that they are capable of producing or consuming by instantiating JCFSupport objects to handle event production, and implementing JCFListener interfaces to deal with event consumption. When a Simulation Component is placed into a Simulation Container that already contains Simulation Components, the other Components are automatically notified of the new arrival, and use Java‚Äôs reflection capabilities to analyse what events the newcomer is capable of producing and consuming. The existing Simulation Components publish and subscribe to these events accordingly, thus establishing channels of communication between Components.Communication between Simulation Components in different Simulation Containers takes place via Translator Components. A Translator Component is a subclass of Simulation Component whose task is twofold: it maintains a list of the events produced within the Container to be made visible outside the Container; it performs any necessary conversions to events passing between Simulation Components in the same Container, or to events coming in to or going out of the Container. The Translator Component plays an important role in promoting reuse. It is possible that during the construction of a simulation, Simulation Components with different origins could be assembled together within the same Container. The Components might have been created at different times and designed for use in a completely different context. It is the task of the Translator to reconcile the differences between the Simulation Components so that they may interoperate. The Translator Component represents a pragmatic approach to reuse, since we acknowledge that it is not always the case that JavaBean simulation components can be reused within our framework without rewriting code. In our scheme, however, we are able to restrict code rewriting to the Translator Components, in addition to relying on the conventional mechanisms for customising components supported by the JavaBeans architecture. Figure 1. illustrates the nested arrangement of Containers, Components and Translators, and the event interactions.2.1 Run-time vs Design-time CharacterThe hierarchy of JavaBeans is implemented using the BeanContext API. The key interfaces in the API are the BeanContext interface and the BeanContextChild interface. JavaBeans that implement BeanContext act as containers for JavaBeans that implement BeanContextChild. Since the BeanContext interface extends BeanContextChild, JavaBeans that are bean contexts can also provide a nesting context for other bean contexts. The parent-child relationship between JavaBeans established by bean contexts is analogous to the relationship between GUI containers and components. However, bean contexts allows for the formation of a parent-child hierarchy from JavaBeans that do not necessarily have a graphical representation. It is possible for JavaBeans to possess both a GUI representation and an abstract representation provided by bean contexts. This duality can be exploited at design-time, when the graphical aspect of a JavaBean‚Äôs character allows it to be manipulated and customised within a builder tool. In this representation, systems can be composed from hierarchical collections of JavaBeans using an intuitive visual metaphor. At run-time, when the graphical representation is no longer required, the hierarchical relationship between the system‚Äôs components is preserved by bean contexts. In the JCFI, Java‚Äôs Abstract Window Toolkit (AWT) containers supply the graphical representation of our Simulation Containers; our Simulation Components are AWT components. However, because of name space collisions between certain classes in Java, the Simulation Containers cannot implement the BeanContext interface directly. Instead, they implement the BeanContextProxy interface and supply a bean context to nesting JavaBeans by delegation. Simulation Components are able to implement the BeanContextChild interface directly.The BeanContext API introduces the concept of a service to which nested JavaBeans can subscribe to and make use of. JavaBeans that supply a service to other beans implement the BeanContextServiceProvider interface. The service bean registers with its context and passes to it a reference to an object that actually provides the service. Service beans can be placed at any point within the bean context hierarchy, and can offer the service to any JavaBeans nested within the same context. In addition, if a JavaBean requests the use of a service that does not exist within the same context, the context delegates the request up to its parent, until a matching service is found, or the top of the hierarchy is reached.What generally happens when a JavaBean requests a service is that the requestor supplies an interface describing the service to its parent bean context. If a service that implements the interface is found, the service object is passed back to the requestor, and the requestor can make direct method calls on the service. Services simplify the interaction process by keeping the number of events in the system down. Services are also a mechanism to allow JavaBeans to communicate with each other, in addition to using event exchange.The JCFI makes extensive use of the event classes defined in the BeanContext API. When a new Component or Container is added to a Simulation Container, JavaBeans already present receive a BeanContextMembershipEvent. This event contains information concerning the new bean, and allows existing JavaBeans to form connections to it. In addition, Simulation Containers and Components are alerted to the presence of a new bean context service by a BeanContextServiceAvailable event. 2.2 Time ManagementThe JCFI supports time management down to the Simulation Component level. JavaBeans wishing to follow logical time subscribe to a time management service. The time management service provides two mechanisms for advancing time: the Time Advance Request (TAR), and the Next Event Request (NER). The time schemes are similar in functionality to those supported by the HLA [9], and have been described by us in a previous paper [3].2.3 Support for Distributed SimulationThe JCFI uses an HLA Runtime Infrastructure (RTI) to provide support for distributed simulation. For a federate constructed from JavaBeans, an RTI Translator Component (RTITC) provides access to the local RTI component. The RTITC is placed in the outermost Simulation Container and converts incoming HLA object attribute updates into Java events. The RTITC also performs the reverse task of converting events generated by the JavaBeans into object attribute updates described in the Federation Object Model (FOM).2.4 Jini Support for Federation InitialisationWe have extended the JCFI to take advantage of the spontaneous networking capabilities offered by the Jini architecture. The JCFI uses Jini to distribute JavaBean federates out to appropriate hosts on a network, and to execute the federation. The approach relies on either establishing a Jini network of Run Services, or using one that already exists. A Run Service is a Jini service supplied as part of the JCFI, and it is designed to provide a client with access to a Java Virtual Machine (JVM) located on a different host. A number of Run Services initiated across a network constitutes a general-purpose computing surface, and any Jini client that has the desire to execute code remotely can use this surface to do so.The interaction between a Jini client and a Run Service involves the following: first, the Jini client uses the standard Jini Lookup Service to locate a Run Service. Then, if a Run Service exists on the Jini network, the Lookup Service passes a proxy to the Run Service back to the client. The client communicates directly with the Run Service via the Run Service proxy using the Remote Method Invocation (RMI) protocol. To use the Run Service, the client passes a reference to a local object that implements the java.lang.Runnable interface to the Run Service via the proxy. This causes the code and data of the Runnable object to migrate to the remotely located Run Service, where it is executed in a new thread. A Federate created using the JCFI is both a Runnable object and a Jini client. Our JavaBeans federates are capable of seeking out a remote Jini Run Service, migrating to it, and then executing. Upon execution of the federate within the Run Service, and provided an RTITC bean exists, the federate will join an existing federation using the RTI protocols. If each federate is programmed with the total number of federates participating in the federation, then the RTITC will block federate execution until all federates have joined. The RTITC makes use of Management Object Model (MOM) information to achieve this.By using Jini, we can take advantage of the fault tolerance and service matching it offers. For example, in order for a Run Service to remain part of the Jini network, it must obtain a lease from the Lookup Service. After a period of time, the Run Service must apply to the Lookup Service to renew the lease, else the lease is cancelled. If cancellation occurs, the Lookup Service will no longer advertise the existence of the Run Service to interested clients. Leasing is essentially a generalisation of Java‚Äôs garbage collection mechanism to a distributed environment.Service matching allows Jini clients to distinguish between Run Services based on criteria known as entries, passed to the Lookup Service by the Run Service during registration. An entry for a service might contain information such as the hostname, type of machine, or even physical location. JCFI clients can match to these criteria to ensure that federates run on appropriate hosts.It should be noted that although Jini services are not the same as bean context services, there is no reason why bean context services could not be supplied as Jini services. For example, it might be more appropriate to provide federates with access to a terrain database through a Jini service rather than through a bean context service. This way, the terrain service could take advantage of hardware better suited to the task, and also offer the same service to a number of Federates. 3. Visual Construction of Federates3.1 Using COTS ToolsWithin the JCFI, there are two phases to producing a JavaBeans federate. First, the individual Components and Containers are developed and packaged as JavaBeans. Second, JavaBeans are assembled and configured to form the federate. Developing a JavaBean means writing Java code, and there are a number of COTS tools to support this task. We use Borland‚Äôs JBuilder3 [10] for this task. As well as providing a programming level of support for bean construction, JBuilder also supports the graphical assembly of systems from JavaBeans. Once individual beans have been built they can be added to a palette for use as components in other applications. The way that JBuilder approaches system assembly is interesting as it highlights one of the possible mechanisms for connecting JavaBeans together. When selecting and placing a component into the application being built, JBuilder uses Java‚Äôs reflection capabilities to find all the properties possessed by the JavaBean and displays them in a properties dialog window. Properties on the JavaBean can be changed either by using the simple dialogs provided by JBuilder, or by using custom property editors supplied with the JavaBean itself.When a new instance of a component is created and added to a container within JBuilder‚Äôs User Interface Designer, code is automatically generated which will create the component at run-time and preserve the relationship with it‚Äôs parent container. Changes to properties of components at design-time are also preserved at run-time by the generation of appropriate code.JBuilder is an effective tool for building individual bean components and there are many other comparable tools available in the market place, some of which are freely available. However, there is an alternative way of assembling ready-made components into a federate, which is the topic of the next section.3.2 Component Assembly with the JCFI-BeanBoxOnce Simulation JavaBeans have been developed, the process of assembling and configuring hierarchies of beans can be performed at a higher level using a simpler tool.Sun‚Äôs reference implementation of JavaBeans provides an exemplar application for this kind of configuration called BeanBox [1]. We have modified the publicly available source of the Sun BeanBox to support some of the more specialist requirements for simulation configuration. It should be noted that everything demonstrated in our modified BeanBox (JCFI-BeanBox) could be achieved using a COTS tool such as JBuilder. However, our JCFI-BeanBox offers greater flexibility in the way that beans can be visually manipulated and also allows more control over how the bean configuration information is saved, for example, allowing it to be stored as eXtensible Markup Language (XML), as discussed later.Figure 2 shows the main window of the JCFI-BeanBox in operation. The figure shows an example federate, constructed by dragging and dropping Simulation Containers and Components from a palette on to a workspace in the main window. The federate is constructed from a series of nested Simulation Containers shown by the different levels of grey in the window. The federate consists of two simple vehicles, which are represented by two Vehicle Containers, labelled VEHICLE1 and VEHICLE2. Each Vehicle Container contains three Simulation Components that possess the code to simulate the vehicle: a Dynamics Bean  (responsible for motion), a Navigator Bean   (responsible for route planning) and a Commander Bean  (responsible for the vehicle‚Äôs intelligence). Each Vehicle Container also carries a Vehicle Translator, , which establishes a communications link between the Simulation Components in the Vehicle Container, with other vehicles within the federate. Simulation events pass along these links at run-time.In addition to providing a context for the vehicles, the top level Federate Container holds the RTITC, which establishes a link between vehicles in the federate and entities in other federates. The JCFI-BeanBox represents all communications links by drawing lines between the Components. Also contained within each vehicle is a Registration Service (RS) bean. The RS bean provides JavaBeans nested in the same Vehicle Container with unique identifiers. This service could be used to distinguish two or more of the same type of JavaBean in the Container, for example.  In addition to offering Java-HLA translation, the RTITC is also a bean context service provider, offering time management, registration and synchronisation services to vehicles directly, and to vehicle subcomponents by delegation.When a Simulation Container or Component in the main window is selected, the property editor associated with the selection is displayed. Figure 3 shows property editors associated with the Dynamics Bean and the Vehicle Translator. It also shows, at top-right, JCFI-BeanBox‚Äôs palette of ready-made Simulation JavaBeans.The property editor for the Dynamics Bean is shown at the bottom-right of Figure 3. The Dynamics Bean has two properties associated with it: maximum acceleration, and maximum velocity. These parameters can be changed using the property editors so that at run-time, the vehicle in which the Dynamics Bean is placed has appropriate velocity and acceleration characteristics.Shown at centre-right in Figure 3 is the property editor for the Vehicle Translator. In addition to providing event translation capabilities, the Vehicle Translator possesses properties describing the vehicle as a whole, such as its name, its type, and its location. Rather than entering numbers to represent the position in a text box, in this example, use has been made of a custom editor (shown on the left of Figure 3), to allow the placement of the vehicle onto a map. The custom position editor makes use of third party Java components from the ILOG JViews toolkit [11], which supports geographic visualisation and geospatial co-ordinate transformation. The BeanBox uses an approach to setting properties that is distinct to JBuilder‚Äôs. When a Component is dropped into a Container from the palette, an instance of that Component is created within the BeanBox environment. The properties of the JavaBean are discovered by reflection and they are displayed in a property dialog (as in Figure 3) and can be edited in a similar manner to JBuilder. However, changes to the properties are actually made by setting the state of the components within the BeanBox. The state of all JavaBeans within the BeanBox can be saved to disk by capturing and copying their internal state variables in a binary file using the serialisation facility of Java. The JCFI-BeanBox extends this idea to allow users to save a serialised version of their federate, or a text-based description of the model based on XML. The main advantage of using an XML-based method for storing the component configuration is that, since XML is text-based, we can edit it outside of the builder tool, if necessary. The XML description makes use of IBM‚Äôs XMLParser for Java [12]. Either of these saved representations can be distributed to Jini Run Services on a network using the JCFI-BeanBox‚Äôs in-built Jini support, and then be reactivated as federates within the simulation.A number of modifications were made to the publicly available BeanBox distribution to extend its functionality the ways described above. Major changes include converting the BeanBox to use Sun‚Äôs Swing package for windowing, instead of AWT. In our version, Simulation Components placed within a Simulation Container connect themselves together; in the original BeanBox, connections between JavaBeans had to be made by manually connecting ‚Äòwires.‚Äô Also, we added facilities to allow the nesting of Components and Containers, thus enabling the construction of hierarchical federates.A context sensitive help facility was also added to BeanBox to allow users to find out information about the JavaBeans in the palette. The help facility is in the form of HyperText Markup Language (HTML) documents, which contain information on how to use the beans and property editors, and which link to JavaDoc HTML pages automatically generated from the JavaBean source code.4. JavaBeans and HLAThe object-orientated qualities displayed by the HLA and Java can be exploited to provide a smooth mapping between high level simulation concepts and low level programming structures. In this section, we discuss this mapping in the context of interfacing our Java system with a legacy C++ HLA federate.Table 1 gives a summary of the mappings we have used between the HLA and Java Beans architecture.HLAJAVAObjectsJavaBeans or collections of Beans in a container with a Translator Bean.Object attributesJavaBeans propertiesInteraction parametersJava event fieldsAttribute updatesJava eventsInteractionsJava eventsAs shown in Table 1, HLA objects can be represented using a single JavaBean, where the attributes are supplied by the bean‚Äôs properties. Alternatively, an HLA object can be represented by components within a container, where each component has a specific functional purpose. In such a case, the attributes of the HLA object are given by the properties of the nested components. Figure 4 shows two composite JavaBeans, each one representing a vehicle capable of participating in a JCFI simulation. The BaseEntity vehicle and the MilitaryEntity vehicle are distinguished by the presence of a Weapons Bean, and different Translator Components. As discussed earlier, the Commander Bean, Navigator Bean and Dynamics Bean provide the vehicles with intelligence, route planning and motion capabilities, respectively. EMBED Word.Picture.8  To facilitate interoperability, each vehicle is capable of representing an HLA object defined by the Real Time Platform Reference FOM (RPR-FOM) [13]. The BaseEntity vehicle possesses properties that map directly onto attributes of the RPR-FOM Base Entity object. Likewise, properties of the JavaBeans contained within the MilitaryEntity vehicle correspond to attributes of a Military Entity object in the RPR-FOM.In the RPR-FOM, the Base Entity object and the Military Entity object form part of an inheritance hierarchy, with the Military Entity object being a subclass of Physical Entity (not shown), which in turn is a subclass of Base Entity. This inheritance hierarchy is replicated within the JCFI scheme in two ways: by subclassing JavaBeans or by delegating this responsibility to other JavaBeans.  How these two approaches are used in an implementation is arbitrary. To demonstrate this flexibility, we have produced implementations of the two vehicles depicted in Figure 4, utilising a mix of both delegation and inheritance. In the case of a MilitaryEntity vehicle, the FOM inheritance is partially represented by extending Translator Components: the MilitaryEntity Translator subclasses the PhysicalEntity Translator, which subclasses the BaseEntity Translator. The BaseEntity Translator possesses properties that map onto attributes that are not dynamical in nature, such as EntityType. The MilitaryEntity Translator augments these inherited properties with extra ones, corresponding to attributes such as ForceID.The attributes relating to the dynamical characteristics of the Base Entity object (and of the Military Entity object) are supplied by delegation, by the Dynamics Bean. The Military Entity object also possesses delegated attributes supplied by the Weapons Bean.In the JCFI scheme, a Java event is defined for each JavaBean, where the event object has fields corresponding to the properties of the bean. A Dynamics Bean has a related DynamicsChangeEvent with the fields shown in Table 2.DynamicsChangeEventPositionAccelerationVectorVelocityVectorAngularVelocityVectorOrientationWhen the vehicle‚Äôs dynamics change, a DynamicsChangeEvent is produced containing the new dynamics state of the vehicle, and is received by any other components in the same context that implement the DynamicsChangeListener interface. For our vehicles, a new DynamicsChangeEvent is received by a Translator Component, which constructs a new event based on the fields in the received event, and on the properties possessed by the Translator itself. For a BaseEntity vehicle, this new event is called a BaseEntityEvent; for a MilitaryEntity vehicle, a MilitaryEntityEvent is created. These events are capable of conveying the current state of the vehicle to beans outside of the vehicle container that implement the corresponding listener interface, such as an RTITC. From the HLA perspective, these events possess all the information required for an RTITC to make BaseEntity or MiltaryEntity attribute updates over an RTI.One difference between our system and the HLA is that, in the HLA scheme, only attributes that have changed are updated. When a change to a JavaBean property occurs, all the properties of the bean are broadcast in a Java event, regardless of whether they have changed or not. This allows us to simplify the handling of events, since we do not need to keep track of which attributes have changed.  However, the ability to send only the values of attributes that have changed is a desirable feature when dealing with a large federation, and it is straightforward to add this functionality to the JCFI. A simplification can be made for a homogeneous federation of JCFI federates, where the need for a JavaBeans-HLA mapping is effectively removed, and the RTI can simply operate as a message passing communications bus. In this case, the HLA objects representing entities in the system can be defined within the FOM to have only one attribute. When an update to this attribute occurs, prompted by an outgoing Java event from a JCFI federate, the event is serialised into a byte stream and passed to the RTI as the value in the attribute-value pair set. Other JCFI federates receiving such an update from the RTI would reconstitute the event from the serialised data, and update their local representation of the entity accordingly.In addition to building an inheritance hierarchy of translators, it is also possible to create a hierarchy of Java events and event listeners. Using such hierarchies, it becomes possible for a listener to not only receive its corresponding event, but to also receive any other events that subclass that event. For example, a Stealth Bean, that wants to display positions of entities irrespective of their type, only needs to implement the BaseEntityListener interface to receive all events of type BaseEntityEvent and its subclasses. Furthermore, a hierarchy of Java events can be used to implement HLA interactions, with the fields of the events corresponding to interaction parameters. The transient nature of interactions, and their membership of FOM inheritance hierarchies, allows them to be well represented by Java events. To demonstrate that our system can be used in an HLA federation, we have interoperated a JavaBeans federate with a C++ federate. The resulting federation conforms to the RPR-FOM [13], and relies on a communications infrastructure provided by the DMSO RTI 1.3v6.The JavaBeans federate consists of a BaseEntity vehicle and an RTITC, both placed within a Simulation Container. The RTITC subscribes only to the Position and EntityType attributes belonging to objects derived from the Base Entity class. The RTITC stores the last BaseEntityEvent it receives from a vehicle, and when a new event is received, compares the two events to find which attributes have changed. The changed attributes are then sent over the RTI as HLA attribute updates. Any incoming HLA attribute updates from the RTI are translated into BaseEntityEvents and then sent to the BaseEntity vehicle. The second federate consists of a C++ implementation of the BaseEntity vehicle.This example highlights the ease with which our JavaBeans scheme maps onto the HLA object model. The mapping is straightforward enough to encompass the whole of the RPR-FOM, and is scalable to a large number of federates.5. Example Application: Stimulating a CISThe first application developed using the JCFI has focussed on supporting DERA‚Äôs command and control research programme.  The use of simulation technology to simulate and stimulate Command Information Systems (CIS) is expanding mainly in response to new initiatives such as the digitisation of the UK‚Äôs armed forces.  New systems being proposed and introduced are increasing the complexity of CIS to the extent that simulation is the only practical way to exercise the functionality, explore new concepts, and validate implementations.The aim for the CIS simulation environment was to provide a flexible, reconfigurable modelling tool that could create and stimulate a CIS with representative information flows. Experiments within the CIS arena are mainly concerned with the management, dissemination and presentation of information flows and any CIS stimulator needs to try and represent the full richness of data streams.  The first experiment supported by the JCFI was designed to evaluate the possible use of Collaborative Virtual Environments (CVEs) to support situational awareness in conjunction with a Common Operational Picture (COP). The experiment was structured to have two manned command headquarters, one deployed and one permanent, both processing their own information feeds. To examine the effect of the CVE, deliberate misinformation and correlation errors were introduced into the two headquarters‚Äô information feeds. The effectiveness of the collaboration was gauged by the way that the ambiguities were resolved. The main CIS application that was stimulated was the INRI ICS Common Operational Picture [14] product, which is based on the US GCCS system. This package accepts a number of different types of formatted messaging streams including Over-The-Horizon Targeting Gold  (OTH-T Gold) [15] format messages, and displays the track information in NATO standard symbology to the users. To meet the aim of the experiment, each command centre received subtly different information based on the same ground truth simulation by a process called ‚Äòmangling.‚Äô Figure 5 shows a partial view of the simulation configuration showing how this was achieved. PositionEvents from each vehicle model can be sent directly to a command headquarters producing a ‚Äòground truth‚Äô perception of the synthetic world. Communication between the simulation and the CIS application was via an OTHCommuncations Bean dropped into the federation. The entity PositionEvents are translated by this bean into OTH-T Gold format messages for the CIS application.The same PositionEvent can also be received by a ManglerBean Translator in a container, and passed onto a so-called Mangler Bean, which modifies the position or entity information subtly before passing the event on to the second command headquarters. The extent of the  ‚Äòmangling‚Äô was determined by an interpreted JPython script which at runtime changes attributes of the data.The interesting feature of our simulation framework highlighted here is that by using containers as contexts it is possible to reuse the same Bean (in this case the OTHCommunications Bean) in different contexts without writing new code. In fact, to visualise the ground truth and ‚Äòmangled‚Äô versions of the output data, a Stealth Bean could also be dropped into each context without modification. For the experiment, the simulation system could be used in two modes. The simulation could either be run in real time, with the OTH-T Gold messages being sent directly to the CIS application, allowing the operator to interact with the models as the exercise progresses. Alternatively, the OTH-T Gold messages could be stored in a log file and subsequently replayed using a replayer application, which itself was a simulation constructed using our system. In addition to the track and entity information, our system was also able to produce E-mail messages, either in real time or from a log file. These messages could be sent synchronised with the track data to augment the simulated ‚Äòreality‚Äô experienced by the experiment participants. EMBED Word.Picture.8  This application demonstrates the versatility of our system, with its ability to rapidly assemble a simulation, and highlights the reusable nature of the system. It also illustrates the ease with which our system can be linked to other applications, in this case the CIS, where a JavaBean possessing the correct event listeners is simply dropped into the simulation.6. SummaryWe have shown that by combining COTS products, free software, and component-based software development technologies, it is possible to construct an environment in which non-programmers can create HLA simulations. Our approach exploits powerful visual metaphors to compose federates and federations from reusable JavaBeans in an intuitive fashion. Once created, our JCFI system supports the execution of a federation that adheres to HLA standards such as the RPR-FOM.We believe that Java and the JavaBeans component architecture represent ideal implementation technologies for the HLA, since each possesses well-designed object-orientated characteristics. We have shown that these characteristics can be exploited to provide a smooth mapping between high-level simulation concepts and low level programming constructs.Our work on the BeanBox visual construction tool, and the JCFI run-time environment has reached a natural conclusion. Because of the novel approach taken, and the widespread interest in cost-effective simulation solutions, this work has attracted interest from academia in the UK, as well as from other parts of DERA. In addition, we intend to use ideas generated by this research in our next project: Realistic Synthetic Environments for Secure CIS.7. References[1]	Sun Microsystems: ‚ÄúJavaBeans: The Only Component Architecture for Java Technology‚Äù http://java.sun.com/beans/.[2]	Sun Microsystems: ‚ÄúJini Connection Technology‚Äù http://www.jini.org/.[3]	Mark Cusack and Peter Hoare: ‚ÄúComponent-Based Development in HLA using Java‚Äù Proceedings of the 1999 Spring Simulation Interoperability Workshop, 99S-SIW-042, Orlando, Florida, 1999.[4]	John A. Miller, Yongfu Ge and Junxiu Tao: ‚ÄúComponent-Based Simulation Environments: JSIM as a Case Study Using JavaBeans‚Äù Proceedings of the 1998 Winter Simulation Conference (WSC'98), pp. 373-381, Washington, DC, 1998.[5]	Herbert Praehofer, Johannes Sametinger, Alois Strizinger: ‚ÄúDiscrete Event simulation using the JavaBeans Component Model‚Äù Proceedings of the 1999 International Conference on Web-Based Modelling and Simulation (WEBSIM99), San Francisco, California, 1999.[6]	Kevin J. Healy and Richard A. Kilgore: ‚ÄúIntroduction to Silk and Java-Based Simulation‚Äù http://www.threadtec.com/silkintro.html.[7]	DMSO: ‚ÄúHigh Level Architecture‚Äùhttp://hla.dmso.mil/. [8]	Pitch: ‚Äúportable Runtime Infrastructure (pRTI)‚Äù http://www.pitch.se/prti/.[9]	HLA Products, Inc.: ‚ÄúJavaRTI‚Äùhttp://www.hlaproducts.com/JavaRTI.html.[10]	Inprise Corp.: ‚ÄúBorland Jbuilder3‚Äùhttp://www.borland.com/jbuilder/.[11]	Ilog, Inc.: ‚ÄúJViews Component Suite‚Äùhttp://www.ilog.com/products/jviews/.[12]	IBM Corp.: ‚ÄúXML Parser for Java‚Äùhttp://alphaworks.ibm.com/tech/xml4j/.[13]	Graham C. Shanks: ‚ÄúThe RPR-FOM: A Reference Federation Object Model to Promote Simulation Operability‚Äù Proceedings of the 1997 Spring Simulation Interoperability Workshop 97S-SIW-135, Orlando, Florida, 1997. [14]	International Research Institute, INRI C4I (ICS),	http://www.inri.com/.[15]	Operational Specification for Over-The-Horizon Targetting GOLD (OTH-GOLD) Revision B. Navy Center for Tactical Systems Interoperability, August 1996.Author BiographiesDR. MARK CUSACK is a Scientist in the Parallel and Distributed Simulation section of the UK Defence Evaluation and Research Agency in Malvern. He joined DERA in 1998. He obtained a PhD in Computational Solid State Physics from the University of Newcastle upon Tyne in 1996.DR. NICK EXON is a Scientist in the Parallel and distributed Simulation section of the UK Defence Evaluation and Research Agency in Malvern. He obtained a BSc (Hons) in  Physics and PhD in the Microwave Properties of High Temperature Superconductors from the University of Birmingham. After completing his PhD he joined the High Temperature Superconductivity Group at DERA Malvern in 1993. In 1999 he joined the Parallel and Distributed Simulation section.DR. PETER HOARE is a Principal Scientist in the Parallel and Distributed Simulation section of the UK Defence Evaluation and Research Agency in Malvern. He received a BSc(Hons) and PhD degrees from Royal Holloway, University of London in 1988 and 1993 respectively. He has been working in parallel and distributed simulation since joining DERA in 1993. Currently he is the technical lead of several programmes in the UK researching the use of the DoD High Level Architecture, including Project FlasHLAmp (a joint UK MoD/Industy simulation technology transfer programme). Also he is currently a Drafting member of the HLA Standards Development group developing the IEEE standards documents.ROGER HOYLE is a Senior Scientist in the Parallel and Distributed Simulation section of the UK Defence Evaluation and Research Agency in Malvern. He received a BSc(Hons) and an MSc from Birmingham University in 1991 and 1992 respectively. He joined DERA in 1996 and started working within the Parallel and Distributed Simulation section in 1997. ComponentTranslatorContainerFigure 1: The JCFI supports a hierarchical collection of Containers, Components and Translators, that interact via event exchange to perform a simulation.Figure 2: The JCFI-BeanBox federate construction tool, showing a federate consisting of two simple vehicles. The vehicles are themselves composite beans. EMBED PBrush  Figure 3: Property editors associated with the Translator Component for VEHICLE1 in Figure 2. Also shown at top right is JCFI-BeanBox‚Äôs palette of JavaBeans. Table 1: Mappings between HLA and Java.Figure 4: A BaseEntity vehicle (top) and a MilitaryEntity vehicle (bottom).Table 2: The attributes of a Dynamics Change Event.Figure 5: Partial diagram of the CIS stimulation set-up illustrating the advantages of using containers to aid component reuse.