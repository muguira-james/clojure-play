A Browser-Based Framework for Rapid Federation DevelopmentChristopher LenfestPeter SassoneThom McLeanCollege of Computing, Georgia Institute of TechnologyAtlanta, GA 30032-0280clenfest@cc.gatech.edusassone@ece.gatech.eduthom@cc.gatech.eduABSTRACT: To speed federation development and deployment, we propose a platform-independent framework for web browser-based federates. Though the application running in the browser is a fully formed federate, it makes use of an existing run-time infrastructure (RTI) for federation communication. CORBA is used to translate method invocations and call backs between a native, verified RTI and the Java federate while being transparent to both. This transparency is essential for ensuring full interoperability with native federates while allowing additional functionality for Java federates. These applications plug into the provided applet framework, hiding communication complexity and providing a standard look and feel (L&F). Programmers can now focus on algorithms and object models needed in their simulation, rather than peripheral issues such as user-input, output, and initialization. These Java applications acquire the language‚Äôs semantic safety and extensive multimedia library, as well as object serialization that provides the programmer with simple access to remote data structures. Altogether, federation authors should be able to provide more fully-featured federates in less time with the proposed infrastructure. To demonstrate the effectiveness of this approach, we have used the Federated Simulation Development Kit (FDK) with browser-based federates to rapidly implement several interactive, graphical simulations.	IntroductionThe Federated Simulations Development Kit (FDK) software developed at Georgia Tech is a software system that contains composable modules for building run-time RTIs. On top of one of these RTIs (the Detailed RTI) we have added the ability to create Java federates as well as the traditional C++ federates. These Java federates are fully functional and can interact with each other as well as with C++ federates, and they can fully participate in the simulation. Our major goals for these federates were three-fold. Firstly, federation developers familiar with programming for the DRTI should have as familiar an environment as possible- the API should look exactly the same in Java as it does in C++. Secondly, federates should be able to run as a Java applet in a web browser, not solely as a stand-alone application. Finally, in order to ensure compatibility, no changes could be made to the existing FDK code base.Platform Independence	One of the biggest incentives to use Java generally comes from the write-once, run-anywhere platform independence. When a federate is written in Java, any machine becomes a candidate for participation in simulation. If the same federate is written in C++, many factors contribute to how easy it will be to move the federate to another machine. In addition to recompiling the RTI, a user would also need to ensure that their application compiles and runs on the new platform. Java federates can run on any platform so long as a Java virtual machine(VM) exists for that platform. When Java source code is compiled, the result is an architecture neutral intermediate format Java bytecode, and the same bytecode can be run on any platform. Not only does this feature have the ability to save money when a network administrator considers that having a homogonous cluster for simulation is not necessary, but a simulation developer has the freedom to distribute a single binary version of his software, rather than having a binary distribution for each platform, or a source distribution. This advantage also manifests itself in  SHAPE  \* MERGEFORMAT Figure  SEQ Figure \* ARABIC 1.  Overview of platform-independent federate execution.  Java applications emulate C++ applications via the Applet/Hook combination.the ability to serialize objects and send them as messages in the simulation. In Java, object layout is always consistent, so a federate can send an entire object as a part of a message rather than being forced to break an object down into its more primitive elements. ArchitectureIn our implementation, Java federates can participate in the federation without making any changes to the FDK, the Object Model, or the network layout. As illustrated in Figure 1, the client connects to the federation via a proxy federate using CORBA as the underlying remote procedure call (RPC) mechanism. The proxy federate is essentially an application, standard for all Java federates, that passes method invocations from the client to the RTI and callbacks made from the RTI to the federate back to the client, all the while marshalling and unmarshalling any parameters and return values. The federation as a whole has no idea that the proxy federate is not handling all calls itself, but rather delegating its work to a third party to do all of the real processing, nor does it care as long as it has a location to send messages to, and all incoming messages are formatted properly. To allow a developer to successfully create a Java federate and connect it to the rest of the federation there are three main pieces that need to be in place. Although we used the FDK and DRTI, these pieces will be the same regardless of the RTI that being used, and irrespective of the language that its API is implemented in.  The first step is to port the API to an Interface Definition Language (IDL) file. Secondly, a proxy federate needs to be created in order to facilitate communication between the Java  federate and the RTI.. Third, there needs to be a framework of Java classes that can connect to the federation seamlessly, without the  federation developer worrying about the details of how communication with the federation is achieved. Interface Definition LanguageSince the  federation is ignorant of the existence of any Java  federates, all interactions with the RTI must behave in exactly the same way as they do when there is a traditional federate. Therefore, each procedure in the API must also be in the IDL. For the implementation of the DRTI, we have two interfaces, one for calls made by the  federate into the RTI, and another for callbacks to the  federate. In each case, there is a one-to-one correspondence between procedures in the API and those enumerated in the interface.In our implementation, we choose to use CORBA as the IDL mainly because of the support that is built into the Java API for CORBA and its regard as a universal standard, but we could have also chosen DCOM, SOAP, XML-RPC or any other RPC mechanism. The choice of what RPC mechanism to use should be informed upon interoperability, extensibility, and performance, but is beyond the scope of this paper. Figure  SEQ Figure \* ARABIC 2. Screenshot of Java federate viewport running Battlefield Simulation Applet.Proxy FederateAs mentioned earlier, the key responsibility of the proxy  federate is to facilitate communication between the Java federate and the rest of the federation. This task would be a trivial exercise but for the fact that we must translate between two entirely different type hierarchies. Each type in the RTI will have a corresponding type that is derived from the CORBA remote object hierarchy. When a calling method is dispatched from CORBA and the call is made into the proxy federate, it will then convert all parameters and return values as necessary. One point to note is that this conversion would not be necessary if the RTI were written with the idea of allowing remote CORBA federates in mind. If the types were subclasses of the stub definitions generated by an IDL file, the object could be passed in to the RTI directly. This feature would yield a significant performance improvement, as it would cut in half the number of memory copies necessary for each method invocation, marshalling all parameters once for RPC rather than twice.Each proxy federate will have exactly one Java federate that is connected to it. However, multiple proxy federates may be run on the same machine, but they will occupy separate address spaces. Each federation should have a CORBA name server running to facilitate the client‚Äôs ability to identify and attach to the correct proxy federate. When a client connects to the name server, calls may be redirected to the corresponding proxy federate.Java ImplementationIn addition to providing essential functionality in our Java library to enable federates to connect to and interact with federations in a uniform manner, we also have created a standard viewport and web interface API for federates to plug into, as illustrated in Figure 2. At all times, the user has access to information about the federation such as how long the simulation has been running and information about the proxy federate that it is connected to. The only part of the applet that is specific to the federate (and thus programmed by the federate developer is the area in the region titled ‚ÄúFederate Viewport‚Äù.  Obviously, a developer could decide not to use this framework if screen real estate is at a premium, but the standard look and feel gives the end-user a constant sense of the current state of the simulation as a whole.In order to create a Java federate and allow it to attach to the federation, all the application writer has to do is create a class and make it implement the Federable interface. This interface has four methods, getViewport(), join(), run(), and stop(). The join() method will be called when the applet first starts up, run() is the main execution loop, and stop() is called when the user presses their logoff, so the federation can manage logoffs gracefully. The getViewport() method returns the Federate Viewport, this is where all graphical information will be displayed to the end user if applicable. The code for the interface and a skeleton for a real federate are shown in Figure 3.Another point to mention is that once an RTI is defined in an IDL, creating an API to connect to the proxy federate in a language other than Java would require roughly the same amount of work. Our main focus was to have  federates that could be controlled from a web browser, but creating  federates based on Python or C# is certainly feasible. Once the API is in an IDL, any language that can talk CORBA, can make calls into the proxy federate.Benefits of Java FederatesProgramming in Java allows the user to develop a federate faster than an equivalent federate in C++.  Benefits of Java include semantic differences with C++ that eliminates errors, as well as an extensive API for graphics.Safety	By choosing to develop a  federate in Java rather than in C++, a programmer can benefit from Java‚Äôs security measures, as well as avoid numerous pitfalls inherent in programming C++. The most obvious advantage is Java‚Äôs lack of pointer arithmetic; a problem that can be a constant source of frustration to those who develop in C or C++. This semantic restriction prevents developers from seeing a whole class of bugs that make development of simulation more difficult, and could cause a simulation to fail at an inopportune time. All array accesses are bounds-checked at runtime in Java, so any array accesses are assured of touching data that is inside the array. This feature makes buffer overflows, a constant security concern, trigger an exception rather than invalidly accessing a piece of memory. 	Java also has the benefit of automatic garbage collection. When the runtime environment determines that an object held in memory has no references to it from the root set, the memory that the object used can be freed by the virtual machine for other purposes. This property is in direct contrast with programming in C++ where the onus of responsibility for memory management lies solely with the programmer. Memory leaks can be notoriously difficult to find and diagnose. Again, we have a situation where not only do we save time for the programmer in development, but we can ensure that an entire class of bugs never make it into the field. Though it is still possible to run out of memory in Java, the only way to do so is to consciously keep around references to expired objects.Rapid DevelopmentJava‚Äôs platform independence naturally lends itself to speeding  federate development. Java is guaranteed to run consistently on all platforms, removing any need for library version or platform version conditionals in applications. Its consistent object model, serialization abilities, and extensive application programming interface (API) also allow programmers to rapidly develop  federates with minimal effort. These qualities allow Java  federates to be debugged readily and extended simply.  We will discuss each in turn.Though object-oriented (OO) languages are not new, they are becoming more common for large projects which involve a large amount of debugging and verification. Polymorphism and inheritance maximize code reuse while making the design phase of the application shorter. Object-oriented programs are easily expressed in flow-charts and easily extended without fear of breaking existing code.  Though C++ has an object model, Java‚Äôs is strictly enforced (code cannot exist outside of objects).Serialization is the conversion of objects (even objects pointing to other objects) into a serial set of bytes.  Java can store these bytes on disk, print them to the screen, or transfer them to another Java application to be un-serialized to recreate the original object. Through the use of serialization, our implementation can extend the most basic RTI message-passing system to transfer full objects. This reduces the need for complex protocol-layer objects, attributes, and parameters  to communicate. Instead, a Java object which is consistent with the application object model can be sent.Java‚Äôs extensive API, tightly controlled by Sun Microsystems, is constantly growing to minimize the amount of code a programmer must write. This includes basic data structures (such as efficient hash-tables and vectors), utility classes (such as network stacks, file parsers, and thread libraries), and graphical user-interface elements (buttons, frames, scrollbars). It also includes comprehensive 2D and 3D graphics libraries as well as full video and audio functions. A Java  federate programmer is free to give the user a full multimedia interface to the  federation while still allowing basic functionality for text-based C++  federates.	 Uses of Browser-Based FederatesThough the benefits of Java are numerous, there may be some question as to the usefulness of having the  federate run in a web-browser rather than running as a stand-alone application. Although we admit for most number-crunching applications, it makes more sense to run most  federates as a Java application rather than in a web-browser, we will present some examples which will demonstrate the advantages of this environment.Simulation MonitorIn a situation where a simulation takes a long time to execute and intermediate results may be important, it would be extremely useful to have a monitor node that could, at any time, look into the simulation to retrieve necessary data. Since Java responds easily to interactive input, it would be very easy to conceive of an application that had graphical menus for various nodes, and the user could click around to find the information he wants or needs. Such an application could also benefit the user community by allowing them to determine that a simulation is producing incorrect or unacceptable results and allow them to stop the simulation without having to wait for it to complete. By having a browser-based federate, a user could sit at any computer and, assuming it had sufficient security permissions, go to a web page and check the status of the simulation. Unlike other monitoring tools, this monitor would be a full federate partner, and would be powerful enough to perform any function that the developer chose to give to it.  SHAPE  \* MERGEFORMAT Figure  SEQ Figure \* ARABIC 3.  The Federable interface, and a MyFederate Class.Battlefield SimulationFigure 2 shows an extremely simple battlefield simulator that allows multiple users access to a battlefield map and troop locations, and allows federates to move troops around the battlefield, while updating the display for the entire simulation. This functionality would be valuable for any collaboration that needs to happen between people in different locations. Video conferencing would allow two generals to look at the same map together, but our simulation would allow two generals to modify troop positions on the map, and see each other‚Äôs modifications in real time. Rather than tell someone your idea, you could show them. Again, no special software would be necessary in order to be able to collaborate in this extremely powerful way, just a web browser. Input/Output FederateAnother possible use for browser-based federates, is in initializing the data upon which the rest of the  federation will base its execution, and then present results of the simulation back to the user upon completion. If a user has the ability to dynamically initialize a federation, this would not only give them the ability to set up and run simulations quickly, it would fundamentally change the requirements of the type of person who would be able to execute a simulation. With an easy to use web-interface, simulation setup and results could be put directly in the hands of the person who cared about the results of the simulation, without the necessity of going through a system operator. If the simulation were designed properly, a minimal amount of training would be required in order to allow the subject matter expert to interact with the simulation directly. EMBED Excel.Chart.8 \s Figure 4.  Run-time comparison of PongPong micro-benchmark across different federate configurations and message exchanges.PerformanceTo analyze the performance impact of the CORBA/Java layer on runtime, we wrote a simple federate micro-benchmark called PongPong in both C++ and Java. The algorithm logs into the federation, and ping-pongs short messages back and forth between two federates as rapidly as possible. This should strain the application-infrastructure interface as each message requires a send call and a receive call-back.We ran this application for 100, 1000, and 10000 message exchanges to analyze performance scaling. Figure 4 above shows the runtime of PongPong in three different federation configurations ‚Äì with two Java federates, with two C++ federates, and with one of each. As the figure shows, the runtime impact is very small. In fact, the performance difference between configurations (~3%) was well less than the run-to-run variation on the same configuration (~8%). Though this micro-benchmark is hardly representative of all parallel and distributed applications, we feel its rapid-fire nature characterizes a worst-case scenario for Java-based federates.ConclusionsIn this paper, we have shown some of the benefits of developing federates in Java as opposed to C++, as well as ideas for applications that would take advantage of the ability to run a federate within a web browser. Browser-based federates have two major qualities that recommend them from the perspective of the end user. The first highlight is that browser-based federates contribute to the mobility of simulation. When users travel, they can take their simulation with them. The second major benefit of browser-based federates is a general increase in the accessibility of simulation. Though instructions to log into a secure server, export their display and launch a federate might be intimidating for a lot of people, almost everyone is comfortable with the idea of going to a web page and interacting with whatever menus and options pop up. This ease-of-use has the potential to make simulation more readily accessible to the masses. When simulation is easy, it has a greater possibility of being widely used.ReferencesDefense Modeling and Simulation Organization, ‚ÄúThe High Level Architecture,‚Äù  HYPERLINK "http://www.dmso.gov/hla" http://www.dmso.gov/hla.S. Ferenci, K. Perumalla and R. Fujimoto, ``An Approach to Federating Parallel Simulators,'' 14th Workshop on Parallel and Distributed Simulation (PADS 2000), May 2000, pp. 63-70.I. Foster, C. Kesselman, and S. Tuecke. The anatomy of the grid: Enabling scalable virtual organizations. International J. Supercomputer Applications, 15(3), 2001.Fujimoto, R., Ferenci, S., ‚ÄúRTI Performance on Shared Memory and Message Passing Architectures,‚Äù 1999 Spring Simulation Interoperability Workshop (March 1999).Server SideRemote Client SideGeneric applet framework which translates method calls between the CORBA interface and the FDK.Java FederateProxy federate which translates method calls between the Corba interface and the FDKCORBATraditional FederatesFederationFDKC++AppJavaApplicationC++AppFDKHookApplet/* java template for Federates */public interface Federable {   JPanel getViewport();   void join();   void run();   void stop();}class MyFederate implements Federable {   /* instance variables */   private JPanel myViewport;   ...   JPanel getViewport() {      /* return handle to view port */      return myViewport;   }   void join() {      /* join federation */      /* register object instances */      /* publish and subscribe */   }   void run() {      /* execution loop */      while ( !done )         ...   }   void stop() {      /* resign from federation */   }}