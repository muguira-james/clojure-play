Virtual Interactive Environment Worldspace (VIEW)Steve JohnsonLockheed Martin Information SystemsPO Box 5260Albuquerque NM 87185-5260steve@taccsf.kirtland.af.milCapt Daniel P. StormontDet 4, 505 CCEG/ENP1655 1st St SEKirtland AFB NM 87117-5617dstorm@taccsf.kirtland.af.milKeywords:Distributed Interactive Simulation (DIS), Environment Generator (EG), High Level Architecture (HLA), Object-Oriented Design (OOD), Theater Air Command and Control Simulation Facility (TACCSF)ABSTRACT:  The Theater Air Command and Control Simulation Facility (TACCSF) is a premier advanced distributed simulation facility, simulating command and control of theater air assets. The core of the TACCSF is the Master Simulation (MSIM) program, which was developed in the 1980s for the Identification Friend, Foe, or Neutral (IFFN) project. MSIM provides high fidelity simulation of command and control assets at the theater level, including IFF, sensor, and jammer effects. It provides a unique blend of constructive, virtual, and live entities for a wide variety of users. MSIM has been extensively modified and extended since it was built, but it is hosted on obsolete computer equipment and is getting increasingly more difficult and expensive to maintain. Additionally, TACCSF has used a commercial product, Scenario Toolkit And Generation Environment (STAGE), to provide ground entities and ballistic missile fly-outs. TACCSF started the VIEW project to incorporate the desirable elements of the MSIM environment generator and to provide the entities currently generated in STAGE, into an object-oriented framework, hosted on modern computers. VIEW will allow rapid generation of scenarios, using a three-dimensional graphical user interface (GUI). VIEW will also provide visibility into a scenario by providing stealth viewer capability and real-time data analysis using pre-defined measures of performance (MOPs). The first prototype of VIEW was demonstrated in October 1997. This paper discusses the capabilities of MSIM, the capabilities of the VIEW prototype, the expanded capabilities of the first release, and expected capabilities for future releases. The object-oriented method being used by the VIEW team is also discussed, as well as integration of commercial-of-the-shelf (COTS) products, and incorporation of High Level Architecture (HLA) capabilities. 1. What is TACCSF?  The Theater Air Command and Control Simulation Facility (TACCSF) is a state-of-the-art distributed simulation facility operated by the Air Force at Kirtland Air Force Base in Albuquerque, New Mexico.  The core of the facility was originally developed for the Identification Friend, Foe, or Neutral (IFFN) project in the 1980s.  To satisfy the objectives of the IFFN project, an environment generator (the Master Simulation, or MSIM, program) was developed by Logicon, along with high fidelity, operator-in-the-loop simulators for various “sensor” and “shooter” systems.  Examples include Airborne Warning And Control System (AWACS), PATRIOT, Homing All the Way Killer (HAWK), and F-15C simulators.  Upon the completion of the IFFN tests, TACCSF was formed to perform studies at both the engineering and operational levels, with emphasis on command and control. The strength of TACCSF’s command and control modeling, combined with advances made in Advanced Distributed Simulation (ADS) and the addition of more sensor and shooter simulators were instrumental in our inclusion in the 505th Command and Control Evaluation Group (CCEG), which just recently came under the newly-formed Air and Space Command and Control Agency (ASC2A).  TACCSF expects to play a key role in the Air Force’s Command and Control Battlelab and in the Command and Control Training Innovation Center (C2TIC).2. The Master Simulation (MSIM) Program  The Master Simulation (MSIM) program is the “heart” of the TACCSF.  MSIM was an environment generator (EG) developed specifically for the IFFN test and was one of the first EGs to combine a large number of high-fidelity constructive entities with virtual simulators in a realistic electronic warfare and IFF environment.  The level of fidelity of the command and control models in MSIM is still a unique capability in the modeling and simulation community.MSIM provides the ability to model the air war (and to a limited extent, land and sea entities) with up to 2000 tracks (up to 400 simultaneously), while providing a perceived picture appropriate to the operators of the command and control and combat units.  With the addition of realistic datalink capabilities and a DIS gateway, MSIM is able to communicate with other simulators, environment generators, and combat systems worldwide. 3. Why VIEW? While MSIM provides a great number of capabilities, some of which are unique to MSIM, it is reaching the end of it’s useful life.  MSIM was written in FORTRAN on Concurrent Corporation computers and has been extensively modified over the years.  As a result, both the hardware and software have become increasingly difficult to maintain.  Also, the impetus towards use of the High Level Architecture (HLA) and the desire to make scenarios easier to develop and modify requires a more flexible design for our environment generator.At the same time, the unique capabilities of MSIM need to be retained, as does the ability to interface with the operator-in-the-loop simulators.   Additionally, TACCSF has been using the Scenario Toolkit And Generation Environment (STAGE), a Commercial-Off-The-Shelf (COTS) product developed by VPI, Inc. to supplement the ground war modeling of MSIM and for high-fidelity ballistic missile flyouts.These factors motivated us to develop a replacement for MSIM, which we are calling the Virtual Interactive Environment Worldspace (VIEW).  VIEW will retain MSIM’s unique capabilities in high-fidelity command and control modeling at the theater level while increasing flexibility and expandability.4. Development Methodology used for VIEW The debate on how the real world is organized (physically or functionally) has raged since the time of the ancient Greeks, who considered a world of actions vs. A world of objects. The existence of these components illustrate the fundamental decisions we must make when considering how to model pieces of the world with computers.  Should our model be algorithmically based or object based.  Which is to ask should we physically decompose our world, or break it up by actions?Either way is difficult for humans as our brain was not designed to remember many things at one time.  The fact that phone numbers are 7 digits is not coincidence.  We certainly can’t remember the hundreds or thousands of relationships present in software which models complex systems.  We need abstraction to assist us with that.The exercises that VIEW will model are very much hierarchically defined by physical entities; their components, specific functionalities and  relationships with each other.  This is a hierarchy very similar to the main components of Object Oriented Design;  classes of objects, encapsulation of data and methods and the ability to communicate via methods with other objects.  These similarities helped convince us that the Object Oriented paradigm was appropriate for the design of VIEW. TACCSF designs a great deal of code to support its operations.  The majority of this code either directly or indirectly contributes to modeling real world activities.  Recognizing similarities in entities that TACCSF models provides us with an opportunity for an enormous amount of code reuse.  Appropriate classes can certainly be copied or used from code libraries.  However, recognizing software design patterns can circumvent redundant code design at a very high level, even before high level classes and objects are conceived.  An expanding body of design pattern work documents many of these software design building blocks.  A dozen or more of these patterns have been used to build VIEW.Proper object-oriented design is very modular and can drastically reduce dependencies via class interfaces. If we correctly design the original components, reintegrating components into another application should take a bare minimum of redesign.  The modification to the interfaces between classes to allow it to communicate with its new client(s) should be relatively painless if the original component interface was sufficiently decoupled from its client classes.Examples of this at TACCSF are the classes modeling radio communications.  When developing these classes for VIEW, we decoupled the classes from the clients to allow these classes to be used in the development of an AWACS model slated to be developed by 1999.  The ability to use the existing VIEW communication classes in the AWACS provides enormous savings in development time, which is rolled right into the initial development estimate.The real world is a dynamic place, and all sorts of changes are likely to occur.  VIEW’s object-oriented design provides the flexibility to easily shift our design by simplifying certain component designs while providing more detail on other components in order to keep abreast of these changes.4.1 The Object-Oriented Design of VIEWDesigning VIEW in an object-oriented fashion was attractive for a number of reasons: 1) The size and complexity of VIEW is well served by the organizational hierarchy offered by an object-oriented design. 2) Object oriented design provides a logical framework for implementation on parallel architectures, and VIEW must be very scaleable.  3) VIEW models an extremely complex system.  The designers must understand both the system and the software model.  Rapid prototyping encourages small changes from previous prototypes, which allows human designers to control and understand the design process.  Remember that the human mind can only work with a half dozen of so concepts at a time.  Rapid prototyping allows us to improve software by working with the specifics of one part of a problem while maintaining an abstract handle on related parts.  4) VIEW must be able to change for a number of reasons.  In addition to the general tendency of most software evolving to suit changing customer needs, VIEW must be easily modifiable to exploit future leaps in technology and evolve to provide expanded and higher fidelity simulations.  This is beyond planned code reuse, and is more akin to planned code expansion.  5) Physically decomposing what we know about the present environment in an object oriented fashion provides us with an accurate yet expandable foundation for the implementation of unknown future requirements.  This allows us to design a system with a long life span.The nature of Object-Oriented Design (OOD) localizes design changes to a few classes and their interfaces.  As new insights and ideas are generated via the design process, the directness of the mapping from real world physical components to modeled objects allows efficient modification of these objects as the model evolves.  The VIEW design cycle takes advantage of this aspect of OOD by making a deliverable schedule that encourages iterative design.  The schedule is actually a flexible cycle constructed around schedule deliverable dates.The first consideration in the design of view was capturing a high level description of the real world environment that VIEW will model in a way that would allow us to address customer requirements.4.2 The TRDThe Technical Requirements Document (TRD) captures the VIEW requirements.  TRD development lays down the foundation for the OOD.  The TRD requirements are based on, and traceable to, requirements in the  Functional Requirements Document (FRD).  The design of VIEW started when VIEW team members brainstormed vocabulary that could be used to capture these requirements.  This simple vocabulary needs to capture the requirements in a series of nouns and verbs that are loosely diagrammed in a Use Case Model. (See figure 1.) The TRD is the complete group of Use Cases generated from the FRD.  To get a good visual idea of what’s going on here, see figures 1, 2 and 3. EMBED Word.Picture.8Figure 1.  VIEW Top Level Use CaseThe Top Level VIEW Use Case illustrated in figure 1 shows the results of brainstorming the FRD.  The brainstorming netted three main “verbs” of what VIEW needs to do.  PLAN its exercise.  EXECUTE the exercise.  And, ANALYZE the exercise execution.  One can inspect the use case to see the many “nouns”  (Battle State, External Systems, Scenario, etc.) that the brainstorming developed to describe the problem captured in the FRD.  And, this is where the hierarchical organization of Mother Nature kicks in.  Each of the verbs (the system functionalities) can be further broken down.  See figure 2 for a top level vocabulary to use in the Execution portion of VIEW.  Notice that many of the “nouns”, the actors from the top level use case, are also included in this lower level use case.  EMBED Word.Picture.8Figure 2.  VIEW Execution Use CaseEMBED Word.Picture.8Figure 3.  Execute Test Use CaseWe can continue this process with the Execute Test portion (see figure 3) of Execution to get an idea of what’s needed for Execution testing by constructing the Execute Test Use Case.  And so on, until you arrive at a point where the fidelity level of the situation you wish to model is reached and it is time to stop brainstorming use cases and start developing classes.  And of course, the nouns identified while brainstorming are objects to be blueprinted with class diagrams.  Use case development is kind of an art.  One in which the “real world” view of the problem is a major consideration which drives the brainstorming and shapes the overall system foundation.  4.3 Class DiagramsThe point at which you stop developing use cases and start constructing class diagrams might be somewhat fuzzy.  But, what transition isn’t?  Notice that the three Use Case diagrams have all referenced a Battle State (BS) object.  This indicates that the BS is involved in VIEW concerns at high, medium and low levels (as opposed to an object that might be created to support another object).  In designing a class diagram, one must consider the object’s position in the big picture when considering what functionality and data elements are appropriate for an object of that type.It is important to continually remind ourselves of the flexible nature of the design cycle.  At any time in the design process, designers may need to modify previous elements of the design where (for whatever reason; new requirements, new problem expert input, or surreptitious new insights) changes have been recognized.  These modifications should happen continuously!  The flexibility of iterative design provides an arena to learn about the real world problem as well as a methodology to design and document a model of the problem.  It is important to remember that design descriptions and diagrams are not only development tools, they are part of your system documentation.The VIEW project uses the Rational Rose design tool to assist in class design.  Rational Rose is a software application that is based on the Unified Modeling Language for object oriented design.  Design team members are assigned potential classes to design.  Designers reference related use cases to determine the functionalities required for particular objects and decide on appropriate object data members.  These decisions are incorporated into the class diagram (see figure 4 for the VIEW Battle State class diagram).  Notice that the VIEW Battle State class diagram includes the class data elements, methods and also relationships to other classes.  These relationships can include a variety of relationship types such as inheritance and aggregation.  The relationship may contain a one or two word descriptor further defining the relationship.  A completed class diagram can show data members, class methods and object relationships.  After making the appropriate updates to the related Use Cases, the Class Diagrams are used to aid prototyping.Figure 4.  VIEW Battle State Class DiagramPrototyping provides a way to verify the correctness of a component’s design, to develop at a code level and perhaps gain new insight into the component problem and provide some code snippets for use when building the production code.In a large part, the VIEW Software Specification (SS) is almost a “side effect” of the design process.  The SS contains all the use case diagrams, class diagrams, state transition diagrams and test cases.  The design process leaves a legacy of well-documented design!5. The VIEW Prototype Our goal for the first VIEW prototype was to represent all the highest level design areas and provide a cross-section demonstration of VIEW’s capabilities.  This offered enough of a proof of concept demonstration of lower level components to convince ourselves that our design was sound.  And, when considered within the context of our rapid prototyping theme, our initial prototype provided a first cut at implementing the highest object level relationships of VIEW.5.1 Consolidating Individual DesignsThe first prototype brought team members, who generally only needed to be concerned with their own design assignments, to the point of actually performing iterative design as a team.  Previously, there was less of a need to perform coordinated iterative design as the majority of team input in the design cycle was in a critiquing capacity.  Team members would work on individual component designs and receive team input at daily design reviews.  The transformation (that takes place at high level integration) from individuals making many their own decisions to a group making a single informed decision is an important milestone in the design process.  It’s where individual ideas end and the single VIEW system begins.  The smoothness of this transformation reflects how similar the team members view of the big picture was and how well everyone communicated their design concerns.  A design critique is not just a comment on someone else’s design.  It is actually the first step towards integrating individual ideas into a main design.  Successful team design review puts everyone on the same page and insures that everyone is familiar with the evolution of the overall design.Object-oriented design defines a vocabulary for telling a story.  In this sense, the initial problem decomposition into use cases comes full circle.  We identify nouns and verbs (objects and relationships via methods) which allow you to tell stories of particular scenarios for parts of your modeled problem.  Lets look at our Battle State class diagram (figure 4).  This diagram is a kind of descendent of the Top Level VIEW Use Case diagram in the sense that as lower level use case and class diagrams were derived, a kind of object vocabulary was defined from the initial noun/verb vocabulary of our initial Functional Requirements DocumentThe goals reached at the completion of the first VIEW prototype addressed many issues surrounding VIEW development.  VIEW is composed of 3 main components - Planning, Execution and Analysis.  Each component is dependent on consistent inter-component interaction which requires that some of the initial prototype development actually contributes to the (complex) problem definition.  The use cases define the high level requirements of VIEW with an infrastructure of high level objects.  This is the initial physical decomposition of the problem.5.2 From Planning to Execution to AnalysisThe scenario we used in the first VIEW prototype consisted of one Red aircraft, one Blue aircraft and one Red ground vehicle.The Red aircraft was a Fulcrum (a type of MIG) on an intercept mission.  The Fulcrum was scripted to take off 2 minutes after the exercise start with its sensor turned off.  It was armed with 4 AA10 missiles. (These are radar-controlled missiles.)The Blue aircraft was an F15 on a DCA (Defensive Counter Air) mission.  The F15 was scripted to take off from Seoul 2.5 minutes after the exercise start.  The F15’s sensor was scripted to be turned on 5.5 minutes after take off.  The F-15 was armed with 4 Advanced Medium Range Air to Air Missiles (AMRAAMs).Figure 5.  VIEW Prototype ScenarioFigure 5 illustrates the state changes scripted for the various platforms.  The ground platform (the gray track) was scripted to drive for a while, turn, slow down, and drive some more.  The aircraft scripts were a bit more elaborate; including changes in heading, speed and altitude.  Notice that the Blue F15 and the Red Fulcrum were scripted to pass right by each other.  This was done purposely to demonstrate the dynamic behaviors which were turned on when the Blue sensor sensed the Red Fulcrum.The Planning phase of VIEW includes processes that are necessary to define the exercise.  Our exercise included administrative information such as exercise length, environment information and entity information such as entity side, position, armament, speed, altitude, controllers, etc.  The prototype defined the three above tracks with the scripting language and parsed this information and placed it in appropriate tables in the database.The Execution phase took this information from the database, built the appropriate objects and set them in motion.  More specifically, a Scenario Controller object read track information from the database, packaged it in intermediate objects and utilized the Execution administrative communication channels to send these packages along to appropriate controllers.  The Battle State object (a controller that administrates over the entirety of all of the VIEW entity states) took these intermediate objects and constructed the actual tracks.  The Battle State is driven by a timer which allows it to update each entity’s state at a rate of 30 Hz. Once initialized, the exercise ran all of the scripted behaviors in much the same fashion, by encapsulating the command data in objects and broadcasting them to the environment.  Controllers gathered environment data and executed the scripted commands until an event takes place which changes a track’s control from that of a script controller to a dynamic controller.  In our prototype, when the red track came into the blue track’s radar range, the blue track’s dynamic controller invoked the appropriate behavior algorithm(s) until the event that triggered the dynamic behavior was ended (the blue track engaged the red track and shot it down).  The blue track then resumed its scripted behavior.  Notice that this is how the real world operates.The Analysis phase listened to a variety of the communication channels during Execution and constructed Measure Of Performance (MOP) objects.  The MOPs contained state and control information relative to the (scripted and dynamic) activities of the tracks during Execution.  The analysis MOPs provided the pieces that described the circumstances around which certain activities took place.  Analysts could then take these pieces and try to explain exercise activities.6. Capabilities of the First Release of VIEWVIEW is an environment generator.  This is a fact that is sometimes misunderstood by people who first hear about VIEW.  Often, they think that VIEW software will simulate an AWACS, or an F15.  This is false… and it is true.It is false in the sense that VIEW does not exist to provide a primary modeling capability for an AWACS, F15 or any real life entity.  VIEW’s primary mission is to provide an environment for both constructive and operator-in-the-loop nodes (a human at an F15 mock up, for instance).  In doing this, VIEW can generate any number of simulated tracks for many, many different types of entities including AWACS and F15s.  In a sense it is true that VIEW will simulate AWACS and F15s.  However, these tracks exist exclusively to populate an exercise with tracks (to generate an environment) for more sophisticated nodes to utilize.  This is an important distinction to understand.VIEW will provide a very scaleable framework.  The only limits on the number of entities, fidelity of the environment, and realism of the communications in VIEW are the limits of available processing power and network bandwidth.6.1 The high level capabilities of viewThe TACCSF legacy systems include the AWACS, F-15C, F-15E, MCE, PATRIOT and Hawk missile battalions.  These systems will be networked with VIEW via a Local Area Network (LAN).VIEW will interface with live, virtual,  and constructive nodes.  VIEW maintains its environment at 30 Hz for the majority of the fast moving simulators.  VIEW will output the state of its environment to the simulators as fast as the network protocols will allow.VIEW will support the running of more than one exercise simultaneously.The SRL is a database that will maintain a history of scripted track configurations.  The SRL will allow different scenarios to be built from previously constructed entities.  For example, if a new F15 configuration with mounted components X, Y and Z is designed for an exercise, it is stored in the SRL for use in future scenarios.Scenarios can be built via a GUI which will generate a script used to populate a scenario database.  Scenario designers will also have the option to build the scenario by editing the script.Data surrounding scripted and dynamic behaviors that take place in the exercise will be collected and saved for exercise analysis.An exercise will consist of an environment, terrain, features (such as buildings and bridges), scripted tracks (which includes track definitions and future events),  communication information and exercise length among other things.The Test Director will be able to control the exercise.  He will be able to run, pause, fast forward and stop the exercise, as well as create and delete constructive entities in real-time.VIEW will define and support multiple behavior possibilities for entities.VIEW supports DIS protocols, as well as real-world datalinks such as TADIL-A, JTIDS, and PADIL.There will be a quick look capability for analysts to inspect and correlate MOP data during or shortly after the exercise execution.VIEW will interface with a Data Link Monitor with allows users to view messages passed over communication channels.7. Future Releases of VIEW Some specifically scheduled future releases of VIEW will include modeling oceans, space and environment features (such as bridges and buildings).  This will open the possibilities to add ships, submarines and spacecraft to the environment along with their particular movement models.  In addition, VIEW plans to add animals (humans), directed energy weapons, more MOPs, and environment snapshots.  VIEW intends to interface with HLA sometime in the future.  These capabilities are slated to extend the first release of view.8. Integration of COTS Products VIEW uses a variety of commercial-off-the-shelf software.  Informix is the relational data base that VIEW uses to store the scenario planning information; both template type information of the components that make up part of VIEW’s infrastructure and data that the scenario designers use to define specific exercises for VIEW.  The state of a VIEW exercise at time zero comes directly from the scenario script’s creation and control commands, which are interpreted by the appropriate execution control objects who create scripted entities and pass their initial control commands on to the entity’s controllers.  All of this information is read from the Informix data base.Performer and MultiGen are utilized to define and maintain graphics.  MultiGen is an object builder used to build graphical representations of objects.  Terrain, features, planes, buildings, bridges - anything with a graphical representation can be built from MultiGen.  Performer is a series of SGI libraries used for real time visualization.  Most of the Performer libraries are real time functions to display graphics.AVS is a GUI builder used to design all of the Human- Computer Interfaces (HCI) used by VIEW.Rational Rose is the Object Oriented Design tool we use to assist us in developing VIEW Use Cases, Classes, State Control Diagrams and Class interaction diagrams.  A great deal of our design documentation resides in Rational Rose files.Speed Shop is a collection of performance tools VIEW developers use to optimize code. We are also actively investigating the use of fielded simulation systems (such as ModSAF) and planning systems (such as CTAPS) to provide portions of the VIEW functionality.  This reduces the amount of “re-inventing the wheel” the VIEW team has to do and provides commonality with other systems.9. Incorporation of HLA Capabilities As stated earlier, one of the reasons for developing VIEW is to transition TACCSF to use of the High Level Architecture.  While HLA is a bit of a moving standard at present, our intention is to stay involved in the HLA development process, keep abreast of successful HLA applications, and incorporate the HLA capabilities that make sense for VIEW as they are needed.10. Conclusion VIEW will continue to build on the successful legacy established by MSIM.  We here at TACCSF are very excited about the potential of VIEW and the “new paradigm” of object-oriented design.  We are already extending some of the VIEW lessons learned and some of the methodologies employed to other projects at TACCSF.  We fully expect VIEW to carry us into the 21st century as a leader in distributed command and control simulation.Author BiographiesSTEVE JOHSON is a programmer with the VIEW team at TACCSF.DAN STORMONT is Chief of the Project Engineering division at TACCSF.  He has been the Det 4 engineering lead for VIEW since the start of the project.