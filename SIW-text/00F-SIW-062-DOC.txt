Using the IEEE 1516.1 RTI C++ APIStephen T. BachinskyJ. Russell Noseworthy, Ph.D.Frank J. HodumObject Sciences CorporationScience Applications International Corporation5400 Shawnee Road, Suite 1106330 Locust Tree LaneAlexandria VA, 22312Alexandria, VA 22312sbachinsky@dctd.saic.com, fhodum@dctd.saic.comj.russell.noseworthy@objectsciences.comKeywords:  HLA, RTI, IEEE 1516. ABSTRACT: The C++ API (application programmers’ interface) to the IEEE standard for the High Level Architecture (HLA) Interface Specification has been modified to improve the software reliability, usability, and extensibility characteristics.  These improvements are achieved through the use of stronger type safety, consistent memory semantics, standard data container interfaces, and specialization support for different RTI implementations.  A major modification was to embrace the Standard C++ Library that contains common constructs for items such as character strings, run-time exceptions, and containers.  This paper discusses the changes made to the API and provides examples of proper usage for HLA applications and RTI implementations.IntroductionThe motivation for the U.S. Department of Defense (DoD) High Level Architecture is to address the key requirements identified by the 1995 DoD Modeling and Simulation (M&S) Master Plan.  In particular, the HLA provides a standard framework for developing M&S applications in a manner that helps to promote reuse and interoperability.  The HLA is more than a programming interface standard; it includes guidance on effective processes and procedures related to the activities associated with the full lifecycle of M&S events.The HLA is composed of a set of rules that govern the proper use of the HLA, a template used to define the syntax and semantics of the data exchanged between interoperating applications, and a specification for a set of common modeling and simulation services.  These services are primarily involved in the efficient exchange of information between multiple applications working together to solve complex problems.  Details concerning the HLA can be found at the following URL:  < HYPERLINK "http://hla.dmso.mil/" http://hla.dmso.mil/>.Creation of standard specifications and processes benefits the community by avoiding duplication of effort in developing/maintaining common functionality and promotes best practices that help achieve reuse and interoperability.  Additionally the HLA standardization process has brought together various domains (e.g., training, analytical, test & evaluation) to investigate common requirements and techniques to ensure the common framework properly supports the entire community.The core of the HLA is a software “middleware” component referred as the Run-Time Infrastructure (RTI).  The RTI software is used by simulation programs to simplify implementation of the common M&S services and provides a standard programming framework.  The RTI specification provided by the HLA standard is separated into two interfaces: RTIambassador and FederateAmbassador.  The RTIambassador defines all of the services that an application (i.e., a federate) can invoke on the RTI.  Likewise, the FederateAmbassador defines all of the callback services that the RTI can invoke on the federate.These RTI interfaces are described in a programming language neutral fashion in the HLA Interface Specification.  The current HLA Interface Specification is version 1.3 that was approved by the Architecture Management Group in February 1998 [1].  Several application programmers’ interfaces (APIs) have been developed for common programming languages and are included with the specification: C++, Java, Ada 95, and IDL.An RTI implementation conforming to the HLA standard will provide the necessary files for an application to use and implement the appropriate interfaces.  In the case of the C++ programming language, various header files are provided along with the RTI software library.Currently the HLA activity is undergoing standardization with the IEEE (Institute of Electrical and Electronic Engineers).  During this standardization process the existing HLA 1.3 specification was refined by the working group and balloting group.  These refinements include changes to the RTI programming interfaces.The remainder of this paper discusses the changes to the specification and the C++ RTI API in support of the proposed IEEE 1516.1 standard.  Initially the functional changes to the HLA Interface Specification are discussed with their impact on application developers.  Next the paper explains the specific changes to the C++ API and their motivation.  Finally an approach to the conversion of existing 1.3 applications is presented with plans to develop some supporting tools. IEEE 1516.1 SpecificationThe following sections describe the major changes to the HLA Interface Specification IEEE standard that affect existing HLA 1.3 applications.  The IEEE changes are mostly minor refinements to the existing 1.3 specification and were primarily incorporated to address inconsistencies or functional omissions.  Until the IEEE 1516 specifications are standardized the draft versions are copyright to the IEEE and reproduction is not permitted.  Note that the following sections do not capture all of the IEEE specification changes, but represent key modifications that need to be considered when transitioning 1.3 applications to the IEEE standard.Consistent Publication/Subscription SemanticsAt its core, the RTI is a data dissemination infrastructure based on a publish-subscribe paradigm.  Producers of data publish the relevant characteristics of that data and consumers of data subscribe to data with particular characteristics.  The relevancy mechanism can be based on data types (class-based routing) or it can be based on particular values of the data or values of associated data (value-based routing).  In HLA terms the RTI services supporting class-based and value-based routing are referred to as Declaration Management (DM) and Data Distribution Management (DDM) services, respectively.Under the HLA 1.3 specification the semantic behavior of the DM and DDM services were inconsistent.  The DM publication/subscription services contained replacement semantics, in which each new publication or subscription would override the previous settings.  The DDM publication/subscription services acted in an additive fashion, in which each new publication or subscription would be added to the existing settings.The IEEE specification unifies the DM and DDM publication/subscription behavior to always be additive.  This allows different parts of a federate application to make local publication/subscription changes without having to know the global publication/subscription state of the entire federate application.Existing HLA 1.3 federate applications will need to search for existing DM publications and subscriptions to determine whether the software was written to exploit the replacement behavior.  Where the replacement semantics is required the federate software can be modified to first invoke the publication or subscription service for the particular data type without any attribute, parameter, or region qualifiers.  This invocation will have the effect of removing the publication or subscription state.Single DDM Routing SpaceUnder the HLA 1.3 specification multiple routing spaces were permitted.  These spaces are used to support value-based routing associated with the DDM services.  A change was made for the IEEE 1516.1 specification to support only a single routing space with an infinite number of dimensions.  In effect the new DDM mechanism does not modify the ability to specify arbitrary routing descriptions, it has simplified the mechanism by eliminating over-specification.Additionally the bounds that are used to define the permitted range of possible values for each dimension within a routing space were changed from a fixed floating-point representation to a user-defined integer representation.  This change allows the federation to provide an indication to the RTI as to the number of possible permitted values that will be used for routing decisions.The impact of this change on existing HLA 1.3 federate application software is minimal because it is really a change to the Simulation and Federation Object Models (SOM and FOMs).  Those federations that have used DDM services extensively will need to combine their multiple routing spaces into a single space.Object Instance Handles and NamesUniqueness for the numeric handles and names of object instances was not guaranteed in the HLA 1.3 specification.  The IEEE specification now enforces that the RTI returns a federation unique numeric handle to identify a particular object instance.  Furthermore, the RTI will provide a unique name (character string) for the object instance if a name is not provided by the federate application.  If the federate does provide an object instance name the RTI is required to ensure that the name is unique for the federation.These modifications do not negatively impact existing HLA 1.3 federate applications.  If the existing applications required uniqueness they were required to build some mechanism individually.  The IEEE modifications will ensure that compliant RTI implementations provide unique object instance handles and names.Logical Time for Receive Order MessagesPreviously in the HLA 1.3 specification only time-stamped messages were permitted to provide a logical time-stamp with object updates or sent interactions.  The IEEE specification allows applications to provide time-stamps even if the time management services are not in use.Under the HLA 1.3 specification federate applications that required time-stamps without the use of time management services had to create attributes or parameters to hold the time-stamp.  Additionally the time-stamp could be supplied within the user-supplied tag that is associated with the object update or send interaction services.Process ModelSince the RTI software is linked together with one or more federate applications it is necessary for the different events to share resources (e.g., processor, I/O).  The term process model is often used to describe the mechanism used to support the efficient processing of events within an application.  In the 1.3 RTI implementation a service called “tick” was used by the federate to allow the local RTI component to perform processing.  In addition to this, “tick” was used to indicate to the RTI that they federate is prepared to handle callbacks.This approach suffers from two major disadvantages.  The first is that combining when to give the RTI cycles and when the federate is prepared to handle callbacks in one service call is restrictive.  A federate may wish to give the RTI processing cycles, but may not be in a position to receive any callbacks.Another disadvantage with the tick service is that it is a “polling” model.  A polling model is not very efficient in a dynamic environment where the resource needs of the RTI and the federate are changing, because the federate software is not able to determine when the RTI needs processing cycles.In the HLA IEEE specification there is a separate mechanism for the federate to receive callbacks.  This Evoke Callback service comes in two flavors; one is used to accept a single callback and the other to accept multiple callbacks based on minimum and maximum time values.  This interface also supports a multi-threaded federate in which a “thread pool” is created to enable the callback to occur asynchronously.The HLA IEEE specification does not explicitly define any mechanism that is used to provide the local RTI component with access to the processing thread.  It is up to the RTI implementation whether a separate internal RTI thread (or threads) will be used, an interrupt mechanism enables RTI processing (such as signals), or some other way of siphoning processing from the federate thread is utilized.Existing 1.3 federate applications will need to identify all calls to the tick service to determine whether that call was used to give the RTI processing time or whether it was needed to receive callbacks.  If the tick call was used to receive callbacks the tick invocation will be replaced with a call to one of the Evoke Callback services.  If the tick call was invoked only to provide processing cycles to the RTI it can be removed.MOMThe Management Object Model (MOM) is composed of HLA objects and interactions that the RTI is required to support.  The RTI sends these updates and interactions to report on the internal state of a particular RTI component, federate, or federation.  Additionally, MOM interactions can be used to control the operational behavior of a particular RTI component, federate, or federation.During the HLA IEEE refinement the MOM definition was formally defined using the Object Model Template (OMT) [3].  The data types for the MOM object attributes and interaction parameters were also specifically defined in the OMT.Two MOM interactions were added to support the ability of an application to query the state of a synchronization point.  This was prohibited in the HLA 1.3 specification and could result in an unrecoverable state if a federate application was to become unresponsive before achieving synchronization.  The IEEE specification was also modified to allow certain MOM interactions to be delivered during a save or restore operation to avoid a similar “deadlock” situation with a misbehaving federate.These changes will not impact existing 1.3 federate applications transitioning to the IEEE specification, unless they needed to develop a separate mechanism to support unresponsive federates in conjunction with synchronization points, saves, or restores.An additional modification to MOM in the HLA IEEE specification is the optional support of Data Distribution Management (DDM) services used in conjunction with MOM.  This allows federations to more precisely control the exchange of MOM data between federates, where as in the 1.3 specification the MOM data is often a full broadcast.IEEE 1516.1 C++ APIThe following sections describe the structural changes to the RTI C++ API that occurred during the IEEE standardization process.  The motivations for these changes were to rectify some inconsistencies in the RTI 1.3 API, improve usability and safety, and embrace standard C++ constructs.Header File LayoutThe header files that make up the 1516.1 C++ API differ markedly from their RTI 1.3 counterparts.  The changes were introduced to provide flexibility for RTI implementers as well as to eliminate the need to include the entire API if only small subset(s) are required.  However, users seeking the familiar “RTI.hh” file will find a corresponding file, aptly named “RTI_1516.h”.Several of the header files contain the word “specific” in their names.  This is used to indicate that the contents of that file are specific to a particular RTI implementation.  Users should have no particular need to concern themselves those files.Users will find familiar typedefs, such as RTI_Fed-erateHandle, carry forward from the RTI 1.3 to the RTI 1516.  However, the value of these typedefs in the RTI 1516.1 is implementation-specific.  Thus they are not necessarily an alias for the C++ built in type, long.The extension on the header files was changed from “.h” to “.hh”.  This change was made due to the inflexible nature of the Microsoft Visual C++ integrated development environment that does not properly recognize .hh files as C++ source files.In addition to .h file, there may be several .i files and .cpp files that are shipped with the RTI 1516.1 C++ API from a given vendor.  These files contain inlined method definitions and class template definitions, respectively.  Naturally, both of these types of files are implementation-specific, and thus are not part of the 1516.1 Specification.Standard C++ ConstructsThe C++ API is intended to be make use of several classes from the Standard C++ Library, e.g., std::wstring, std::vector, std::set, etc.  At the time the specification was written, not all compilers in widespread use had standard-compliant libraries.  For that reason, and for that reason alone, the Standard C++ Library classes used in the C++ API were renamed with the prefix “RTI_”, e.g., RTI_wstring, RTI_vector, RTI_set, etc.  In all respects, the classes named with the “RTI_” prefix behave identically to their corresponding “std::” class.It must be stressed that this renaming of the Standard C++ Library classes is intended to be a very temporary workaround to a transient problem.  Any RTI 1516.1 C++ implementation that supports a non-compliant C++ compiler must use the prefixed version of the standard class names.  However, once the non-compliant C++ compilers have been retired, all occurrences of the “RTI_” prefix should be expunged from the 1516 C++ API in favor of their proper “std::” counterparts.  Given the rate at which C++ compilers are advancing, it is anticipated that even the initial RTI 1516.1 implementations need not be burdened with the “RTI_” prefix, instead immediately adopting the more proper “std::” classes.More information on the Standard C++ Library may be found in a number of books, including [3].Standard Wstring ClassThe Standard C++ class, std::wstring is a class designed for holding and manipulating text strings, composed of wide (i.e., 16-bit) characters.   Apart from the fact that it is made up of wide characters, it is similar to the more familiar std::string class.Both classes provide the user a high-level representation of a textual string that supports such operations as copying, appending, indexing, and so forth.Standard ContainersAn important subset of the Standard C++ Library is known as the Standard Template Library (STL).  This library is a collection of class templates that is categorized in three parts:  containers, iterators, and functions.The standard containers include std::list, std::set, std::-map, std::vector, and so forth.   These containers have well-documented properties and uses.  As part of Standard C++, they are familiar to C++ programmers.  These standard containers are used extensively in the RTI 1516.1 API.  For example, RTI_AttributeHandle-Set is a typedef to std::set<RTI_AttributeHandle>.The standard containers are indexed using standard iterators.  An iterator is a generalize index that can be used with an arbitrary container.  They support the concept of the start and end of a container, as well as advancing.  For example, every element of a container could be visited by starting with an iterator that refers to its beginning and incrementing that iterator until it is equal to the iterator that refers to the end of the container.Finally, a large number of functions are included in STL as part of the Standard C++ library.  For example, std::sort() can be used to sort a container.  To visit every element of a container, the std::for_each() function could be used.  To locate an element of a container, std::find() is available.Further discussion of the STL containers, iterators, and functions is beyond the scope of this paper.  The reader is referred to [4] which provides an excellent description of the STL concepts.Standard Auto_Ptr ClassThe std::auto_ptr class is used in the RTI 1516.1 C++ API in order to disambiguate the memory semantics of dynamically allocated memory that crosses the API from federate to RTI or vice versa.The std::auto_ptr class is a class template that behaves like an ordinary pointer with the important exception that it implements strong memory ownership transfer semantics.  This means that when a pointer is assigned to an std::auto_ptr, the std::auto_ptr assumes ownership of the pointer and will delete the memory to which the pointer points when the std::auto_ptr goes out of scope.  Ownership of the memory can be transferred from one std::auto_ptr to another by assignment or copy construction.  When one std::auto_ptr is assigned to another, the std::auto_ptr on the left hand side assumes ownership of the memory and the std::auto_ptr on the right hand side points to 0 (i.e., it is a NULL pointer).The RTI 1516.1 C++ API does not use any naked pointers.  Thus the question of memory ownership (i.e., who is responsible for deleting the memory) never arises.  If the federate allocates memory that the RTI should delete, that memory is contained in an std::auto_ptr when it is given to the RTI so the RTI will always delete it (i.e., that std::auto_ptr will delete the memory for the RTI).  The same is true in reverse, when the RTI allocates memory to pass to the federate.Type SafetyType safety and type consistency were important considerations in the creation of the C++ API.  The 1.3 API did not provide this type safety, or consistency.  For example, the types used for all handles are effectively the same to the compiler.  Thus, the compiler cannot aid in finding errors when incorrect handles are passed to API methods.  The Regions in the 1.3 API break type consistency.  All types returned from the RTI to the federate are handles except in the case of the Regions where a pointer is used.  The IEEE interface has converted all arguments in the API to real C++ objects, with an abstract interface.  This abstract interface prevents the user from creating an instance of any of the classes, because the actual implementation code is not exposed to the RTI user.  This abstraction of the types helps to prevent misuse of the API types.  In addition, by using real C++ classes, the compiler will prevent users from calling RTI methods with erroneous arguments.RTI Implementation SpecializationOne of the objectives for the 1516 C++ API was to allow for RTI implementations to specialize behavior of exposed classes (e.g., handles, attribute values). The alternative was to force all RTI implementations to implement these classes the same way. For example, the API could force an object instance handle to be a long integer. Unfortunately we felt this was too restrictive, and we didn't feel we should take on the responsibility to make the right choice for everyone. It also would eliminate the RTI vendor from making the classes have specialized behavior (i.e., instead of object instance handle being a long it could be a vendor defined C++ class that had specialized behavior tailored to the internal details of the particular RTI).AlternativesGiven that we wanted to allow the RTI vendors to specialize these exposed classes there are two alternatives that can be used in C++: (1) Abstract Base Class Approach - The API defines an abstract base class for each exposed class that each RTI vendor would override.  (2) Parameterized Class Approach - The API uses a template for each exposed class in which the RTI vendor specializes by defining the template arguments.The difference between the two approaches is that the parameterized classes provide compile-time type safety and the abstract base classes require run-time typing.  The downside of the abstract base classes is that the RTI would need to internally perform run time type identification (RTTI) operations to safely cast the base pointer to a pointer to the actual implementation class.  In addition the API would also need to provide factory mechanisms to allow federates to create vendor specific derived classes, but returning a base pointer.  While there will be a performance cost in using the abstract base classes over the parameterized classes, it is difficult to assert that the additional cost is significant.  In light of the choices above and lack of a link-time compatibility requirement the C++ API utilized the parameterized approach.Difficulties with Parameterized ClassesThe issue with the parameterized class approach is that the vendor specialization causes unique mangled C++ symbols to be exposed in which a federate application must be recompiled with different RTI implementations that specialize these classes differently.  This is typically not an issue because the compilation is straight forward if the RTI implementation adheres to the standard API.  But in the case of federates or tools in which the end user does not have access to the source code they must use the same RTI implementation that was used to compile the federate application.  This forces the federate/tool vendors to provide versions for each RTI implementation that want to support.Even if the issue above were resolved using the abstract base class approach, the implementation of the "RTI_" Standard C++ Classes would need to be standardized across all RTI implementations to provide link-time compatibility.  Currently, this is not defined by the IEEE standard, as well as other minor issues required for link-time compatibility such as the name of the RTI object library and the fact that it needs to by a Dynamically Linked Library (DLL).  All of these issues would need to be defined in the IEEE specification if link-time compatibility was a requirement.Link Time CompatibilityDuring the working group activities and initial ballot process there was no discussion regarding link-time compatibility.  In short, it was never identified or discussed that link-time compatibility should be a requirement until extremely late in the process, too late to fully specify all of the required elements, so link time compatibility is not assured by the 1516 Specification.Furthermore, providing link-time compatibility does not address issues with run-time compatibility (all RTIs will not have the same behavior).  Expecting to provide a product that is developed and tested with one RTI implementation and runs properly with other RTI implementations is very risky.  The only way to ensure that application code works with a particular RTI implementation is through thorough testing.IEEE 1516.1 Conversion ProcessThe conversion of an application from the 1.3 API to the 1516.1 API is conceptually straightforward since the changes are mostly to tighten up areas where the 1.3 specification was not clearly defined and remove over-specifications in the spec.  That said, the actual implementation coding changes are significant.  The actual normative C++ code for the specification is almost completely different.  As previously discussed the C++ API changes were needed to improve the type-safety and portability of the API.  In addition, the changes embrace new features of the ANSI C++ Standard.To aid in the conversion process a set of hyperlinked documents will be developed which will link from elements in the 1.3 specification to elements in the new IEEE 1516.1 specification.  This will aid developers who can easily see what parts of the new specification correlate to sections in the old 1.3 API.  Links will exist from both directions so that users can examine how features in the new specification relate to those in the older 1.3 specification and vice versa.  These hyperlinks will also exist for the Appendices to provide connections between the completely new types, methods and interface elements to their counterparts in the old 1.3 specification.  Converting an application will consist of initially identifying all of the RTI methods used by the application and then finding the corresponding method in the 1516 spec.  Many of the methods will correlate directly between the two APIs.  The major difficulties will lie in understanding the types and the mechanisms for utilizing the new arguments in the 1516 spec.  An example of a major difference in the API is the old mechanism of simply declaring an RTIambassador and then using methods on this instance has been replaced with the use of a Factory pattern.  In order to create an RTIambassador, the application developer creates an RTI_RTIambassadorFactory and calls the createRTIambassdor on this class.  This allows the RTI developer to perform any initial state setup required for the particular implementation during the create call, before the RTIambassador has been created.  This per-RTIam-bassador setup might be a determination of the use of threads in the application.  If the particular RTI implementation had separate classes defined for a multithreaded vs. a single threaded federate, the create method in the factory could determine this and create the correct instance of the RTIambassador appropriate for the configuration. ConclusionsThe IEEE interface provides a more consistent, logical and complete specification than the 1.3 specification.  It fixes a number of deficiencies identified with the 1.3 specification and provides a standard that is controlled by an international standards organization, which aids in the international adoption of the High Level Architecture.  The C++ API provided with the IEEE specification is significantly different but much improved over the 1.3 API in the areas of portability, use of C++ standards and type safety.  The overall long term benefits of the IEEE specification will outweigh the costs of converting existing applications and/or learning the IEEE API for new applications.References[1]	High Level Architecture Interface Specification Version 1.3,  HYPERLINK "http://hla.dmso.mil/tech/ifspec.html/" http://hla.dmso.mil/tech/ifspec.html/.[2]	Object Management Group, http://www.omg.org.[3]	The C++ Programming Language, Special Edition.  Bjarne Stroustrup.Addison-Wesley, 2000.[4] Generic Programming and the STL, Matthew H. Austern.  Addison-Wesley, 1999.Author BiographiesStephen T. Bachinsky is a division manager with Science Applications International Corporation (SAIC) in Alexandria, VA.  He has been working on the HLA activities since 1995 and is currently the program manager for the RTI-NG (Next Generation) development and support activity.  As a member of the HLA IEEE Working Group and Ballot Resolution Committee he supported the refinement of the Interface Specification and C++ API.  His interests include the system architecture, software design, and development of large-scale distributed information systems.Frank J. Hodum is a Deputy Division Manager with Science Applications International Corporation (SAIC) in Alexandria, VA.  His is the deputy program manager for the RTI-NG (Next Generation) program and has been involved with HLA related development for three and a half years.  He has worked on distributed simulation infrastructures for a variety of simulation domains from engineering level simulations to real time human in the loop training simulations to very large scale virtual event driven simulations over the past six years.Dr. J. Russell Noseworthy is Chief Scientist of Object Sciences Corporation in Alexandria, VA.  He has been lead architect for the RTI 1.3 NG development team for the past 2 and a half years and is the principal author of the RTI 1516.1 C++  API.  Dr. Noseworthy’s interests include the design and development of complex distributed and real-time computer systems and object-oriented middleware development. To be precise, IDL is not a programming language but is the Interface Definition Language associated with the CORBA standard [2].PAGE \# "'Page: '#''"   Need date of AMG approval of 1.3