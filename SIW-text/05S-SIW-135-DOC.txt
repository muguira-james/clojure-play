Implementing RTI Object Ownership Transfer Using SIP ServicesTrevor PearceCarleton UniversityDepartment of Systems and Computer Engineering1125 Colonel By Dr.Ottawa, Ontario, K1S 5B6, Canada (613) 520-2600 HYPERLINK "mailto:pearce@sce.carleton.ca" pearce@sce.carleton.caScott HolbenLockheed Martin AeronauticsAdvanced Development Programs86 South Cobb Drive MZ0674 D-1AD2Marietta, GA (770) 494-0475 HYPERLINK "mailto:scott.holben@lmco.com" scott.holben@lmco.comClaude Van Ham Carleton UniversityDepartment of Systems and Computer Engineering1125 Colonel By Dr.Ottawa, Ontario, K1S 5B6, Canada (613) 520-2600 HYPERLINK "mailto:cvanham@sce.carleton.ca" cvanham@sce.carleton.caKeywords:HLA, RTI, SIP, Ownership Transfer, Conferencing, SMSF, NCOABSTRACT:  The next generation of networks will provide exciting opportunities for Network Centric Operations. The SISO and M&S communities may be able to leverage these networks to solve RTI issues such as secure enterprise firewall traversal, fault tolerance and QoS.  One promising direction is the collaborative VoIP technology called SIP (Session Initiation Protocol). SIP is being positioned to emerge as an Internet standard that will become as ubiquitous as HTTP as the VoIP market matures.  Hence, US and coalition forces are likely to adopt SIP to render operational warfighter collaboration services on next generation coalition networks.  In addition to addressing the RTI issues mentioned above, an RTI implemented using SIP technology could be coupled more easily with the growing body of SIP-enabled applications.  This would be possible since the RTI and these applications would be based on a common architectural technology.   The opportunity to leverage SIP technology could lead to huge development and design savings for next generation warfighter communication systems.This paper has 4 goals:to begin the development of an RTI model that might easily align an Open RTI with the potential advantages of SIP technology for M&S middleware,to use progressive RTI services in a case study to explore RTI conferencing to propose an implementation strategy for using SIP services to implement the Open RTI, andto gauge support for the establishment of an HLA-SIP M&S Framework (SMSF) Study Group, and to encourage participation.The discussion of the potential advantages of SIP includes a high-level introduction to the HLA and SIP services. A preliminary RTI conferencing model is developed to sufficient detail to model RTI Ownership Transfer behavior. This behavior goes beyond the depth of both DIS services and the services considered by the previous Open RTI Protocol Study Group.  Ownership Transfer is representative of the RTI services envisioned for progressive innovation in distributed simulations.  Three strategies are proposed for mapping the RTI conferencing model to SIP, and the SIP-nominal strategy is recommended for further research. Ideally, the paper will help to convince a critical mass of SISO participants to become actively involved in an HLA-SIP Study Group.1. IntroductionThe High Level Architecture (HLA) is an IEEE standard that supports interoperation among individual modeling and simulation (M&S) applications. The individual applications are called federates, and a group of interoperating federates is called a federation. The Run-time Infrastructure (RTI) is the supporting middleware, which provides the services that allow federates to interact as a federation. The RTI API is standardized [1]; however, RTI implementations are not required to share underlying protocols. Thus, individual federates attempting to interoperate using different RTI implementations will not necessarily interoperate. The Session Initiation Protocol (SIP) has all but replaced H.323 in the implementation of Voice over Internet Protocol (VoIP) systems; moreover, this protocol can be used to support a variety of communication scenarios. SIP takes on additional importance in light of the potential use of VoIP to realize DoD’s long-term goals of network centric warfare [2]. In this paper we follow the direction suggested in [3] and explore the possibility of implementing the RTI API on top of SIP.  The benefits of successfully doing so are multifold; SIP is a robust protocol based on simple primitives and backed by the huge Telecom market.  Furthermore, SIP is already supported by numerous extensions.  Finally, a SIP-based RTI will support the integration of simulations into other SIP-enabled applications.SIP applications are often designed around the concept of a multi-party conference. This paper presents some initial research into modeling a subset of RTI services in terms of conferencing. The goal of the model is to provide an alternate perspective on RTI services that will simplify the implementation of an RTI using the SIP. The specific area of RTI services referred to as ownership management services is used to provide a realistic case study.  The services go beyond the depth of both DIS services and the services considered by the previous Open RTI Protocol Study Group. The services are representative of the progressive RTI capabilities envisioned for innovation in distributed simulations. Hopefully, the conferencing model will evolve with further research into an “open RTI” that easily maps to generic conferencing capabilities supported by SIP.     In the remainder of this section, we introduce the HLA and SIP.  The discussion of SIP includes the basic SIP services and how these services might be used to support conferencing capabilities.  Section 2 presents an abstract, component-oriented model of an RTI implementation. The goal of the model is to arrive at an RTI implementation model that can be interpreted to represent realistic implementations. Section 3 introduces some conferencing concepts. The RTI implementation model and the conferencing concepts are then used in Section 4 to suggest an RTI conferencing model for the case study RTI services.  Section 5 relates the RTI conferencing model to the SIP, and our conclusions are presented in Section 6.1.1 The High Level Architecture (HLA)The HLA was developed by a consortium of stakeholders (government, corporate and academic) as a result of a U.S. DoD desire to decrease the cost of modeling and simulation development.  The resulting solution is a flexible architecture capable of supporting the reuse and interoperability of federates.  The HLA supports the combination of separate, distributed simulations (federates) into a single, larger aggregate simulation (a federation).  The standard is comprised of three documents: the HLA Framework and Rules [4], the HLA Federate Interface Specification [1] and the HLA Object Model Template (OMT) Specification [5].  A federation consists of three elements: 1) one or more federates, 2) a Federation Object Model (FOM) which uses the OMT to specify the information that may be exchanged among federates in a given federation, and 3) a supporting Runtime Infrastructure (RTI) to provide services to the federates, enforce the HLA Rules and control the federation execution.A FOM describes information (data) that can be shared among federates.  The HLA supports two types of data representations: objects and interactions.  Both are defined using a class hierarchy scheme. An instance of an object class is typically used to represent a persistent simulation entity.  An object instance may have one or more instance attributes that represent state of the object. Attributes may be updated to represent changes to the entity as the federation execution progresses. HLA interactions allow federates to share data associated with transient events.    The RTI is software middleware that: 1) services supporting the creation, management and persistence of a federation, 2) the creation, use, ownership and deletion of object instances, 3) the means to invoke specified behaviors across federate boundaries, 4) the services to manage the coordination of time among federates within a federation.The RTI is defined as an interface specification [6], not as an implementation. RTI developers are free to realize the requirements of the specification as they choose as long as the HLA rules and interface specification behavior (i.e. service-specific pre and post conditions, and exceptions) are maintained.  The RTI provides a service API for federates to call, and a callback API that must be implemented by each federate. The RTI provides six categories of service along with a seventh group of several support services.  A brief discussion of each service category follows. Federation management services support the creation of federation executions. An RTI may control more than one federation; and each is given a unique name.  Federates join and leave a federation using these services, and federates may be a member in more than one federation at a time. Federation management services are also provided to save federation state, set up synchronization points and carry out related chores.Data sharing in the HLA is based on a publication-subscription model that decouples producers from consumers.  Declaration management services allow federates to indicate their intent to produce (called publish in the HLA) and consume (subscribe) data.  The RTI’s object management services use this information to route attribute updates and interactions between federates.Object management services deal heavily with object instances. These services allow a federate to register (create) new object instances, and to distribute attribute updates and interactions according to declared subscription interests. The publication and subscription of object instance data is accomplished at the attribute level, while interactions occur at the interaction class level.   Object management services also allow the deletion of an object instance, but this will be discussed after the concept of object ownership.The owner of a particular object instance attribute may update that attribute, and only one federate at a time may own the attribute. Ownership management services support the transfer of instance attribute ownership between federates.  Ownership applies only to object attributes, not interactions, and is viewed at an instance attribute level, not the object class level (i.e., a federate can own a particular instance attribute without owning the entire set of the object’s attributes).  If an object instance becomes unowned by every federate then the object instance is said to be unknown.  HLA object instances are often created implicitly with the “HLAprivilegeToDeleteObject” attribute. This attribute is initially owned by the federate that initially registers the object instance. Only the owner of this attribute may delete the associated object instance.  When an object is deleted, a remove callback is triggered at each federate that previously declared interest in the object, by subscribing to the class of the object. Time Management services allow federates to share a notion of logical time. The services can enforce varying of degrees of synchronization among federates. Time management is outside the scope of this paper.  Data Distribution management (DDM) services are used to define “value-based routing spaces” that are finer grained than the declaration management “class-based routing spaces”. DDM publications and subscriptions are scoped to federation-specific regions of applicability to minimize the routing of unnecessary subscription traffic. Although DDM influences the updating of attributes, the services are not considered further in this paper.Finally, various support services provide a multitude of functions such as the setting of various federation–wide switches, obtaining federate, object class and instance handles or names from the RTI for use in other service calls. These services are not considered further in this paper.We now take a closer look at the RTI publish-subscribe mechanism, with the goal of exposing the requirements for the RTI conferencing model introduced later in Section 4. In the following, we assume a federation has been created through appropriate use of federation management services.We first consider the simpler case of the interaction.  It is used to invoke some transitory remote federate(s) behavior in the simulation. A federate invoking the behavior is said to send the interaction.  Subscribing federates receive interaction callbacks and act accordingly (i.e. as determined by federate developers) depending on the interaction’s class and, usually, the values of the parameters set by the sending federate.  Before a federate may send an interaction, however, it must declare its intent to publish the associated interaction class by identifying the class within a call to the proper declaration management or DDM service.  Similarly, federates wishing to receive invocations of a given interaction class must first subscribe to it.  Data transfer using object class attributes is more complex.  Before a federate can produce class attribute data it must declare its intent to publish the class attributes it wishes to send.  After declaring the intention to publish a class, a federate may begin registering object instances of that class.  An RTI register is essentially an object instance factory for object classes used to instantiate RTI reachable object instances. When an instance is registered, the registering federate owns all of that instance’s attributes in which the federate had previously declared publication interests. Any attributes the registering federate has not declared publication interests are initially unowned. Other federates that have declared an intention to publish the unowned attributes may acquire ownership of the attributes once the instance has been registered and locally discovered (discussed below). Once registered successfully, an instance attribute may be updated by the owning federate.  The RTI update behavior causes a message containing the new attribute value to be sent to all federates subscribing to that attribute. The message is sent in a reflect callback. By subscribing to a declaration management class attribute, a federate will be informed of every updated change to every instance of the associated class attribute. Subscribing federates become aware of the existence of new instances through discover notifications. Each time a new object instance is registered, a discover callback is triggered at each federate subscribing to any of the associated class attributes. If a subscriber joins a federation after an object has registered, the subscribing federate will not receive a discover callback. Instead, the federate may passively discover instances as updates are reflected, or may actively ask for an update of all existing instances. Note, only the current value of an attribute can be discovered, the RTI maintains no historical data such as instance attribute values or interactions that have been sent.  Recall that multiple federates may own subsets of the attributes of an object instance, but only the owner of a specific attribute may update it.  Appropriate ownership management services exist to support push and pull transfers of attribute ownership.  Either the owner or federate desiring to acquire ownership can initiate a transfer.  In the push model, the owner seeks to divest ownership by informing the RTI. The RTI then informs all federates eligible to become the new owner (i.e., those that publish the class attribute), and the first to respond is awarded ownership.  In a pull model, a federate that wishes to acquire ownership of a specific instance attribute informs the RTI, which may then contact the current owner to complete the transfer if the owner is agreeable. Ownership cannot be taken from a federate without its consent nor can ownership be forced upon a federate without that federate’s consent. Federates always use RTI services to update attributes and send interactions.  The RTI distributes the information to each subscribing federate. Similarly in ownership transfer, all negotiations are handled through RTI services. The RTI maintains persistent records of the existence of object instances, current attribute owners, and the publication and subscription interests of federates. The RTI does not maintain persistent records of current instance attribute values, or the history of such value changes. As a consequence, each interested federate must instantiate its own data structure to maintain this data locally as needed.    1.2 The Session Initiation Protocol (SIP)The Session Initiation Protocol (SIP) is a session layer control protocol; i.e., layer five of the ISO seven-layer model. It is designed to allow applications to create, control and terminate network-based, multi-point, multimedia communication sessions such as Internet-based IP telephony calls, conferences and gaming sessions.   SIP is intended to be used as an “out-of-band” control protocol which means that it is to be used over different communication channels than those used for transferring the resulting communication session data.  In practice, however, both channels are often rendered on the same links. SIP is a relatively simple but highly flexible protocol being used widely in Voice over Internet Protocol (VoIP) networks. The protocol also lends itself for use by any network-based application requiring the establishment and control of communication sessions between two or more end points.  The core protocol [7] defines SIP primitives while other RFCs (specifications) define extensions and more complex services based on the primitives. The core Session Initiation Protocol provides five principal functions supporting communication:            1) discovery of recipient location, 2) determination of whether a recipient is available to engage in communication, 3) facilitated negotiation of the endpoint parameters (e.g., CODEC and media transport protocol) to be used during the session, 4) set-up of the session, “ringing”, and 5) management of the session while it is active.SIP endpoints are called user agents.  They are usually implemented on a user’s computer but may be implemented in other hardware such as cell phones, PSTN (public switched telephone network) gateways, etc.  The user agent endpoint is composed of a user agent client (UAC) and a user agent server (UAS).  The endpoint UAC sends requests such as invitations to join a session. The UAS endpoint receives these requests and sends response messages, indicating its success or failure in carrying out the request.  A SIP user agent endpoint operates in the role (UAC or UAS) appropriate for the function it is currently executing.  Thus, SIP endpoints (e.g., phones) exhibit Peer-to-Peer (P2P) capabilities. UAC and UAS components are also implemented in SIP proxy servers which are used in the network to route requests, find user endpoints and provide other intermediary support services.  SIP provides core primitives that can be used to implement additional services such as establishing two-party or conference call communication sessions.  Core SIP defines six methods (requests) that initiate transactions. INVITE is the most important of these: it is used to initiate a communication session, “dial a telephone number.” The ACK method is used to verify the receipt of a final response to an INVITE. An ACK completes the three-way handshake required to negotiate a session that may take some time to complete, “lift a ringing telephone handset off the hook.”  An ACK is considered part of the INVITE transaction if the INVITE fails; otherwise, it is deemed a separate transaction. A CANCEL is used to “hang up the telephone before the call is fully established.”  Once a telephone session is established, a BYE is used to “hang up the telephone.” The OPTIONS method is used by a UAC endpoint to query a UAS about its capabilities. The UAS component is found both within an endpoint and also in intermediary SIP servers such as the proxy, registrar or redirect server.  The capabilities of SIP a UAS are the methods, option tags, profiles, MIME body types, event packages etc. supported by the UAS.  An OPTIONS query is used to ensure that a desired extended SIP capability is supported before sending a request to use that capability, unless the called upon UAS registers its capabilities [15].  In that event, the UAC utilizes “caller preferences” [16].  Finally, the REGISTER transaction enables an endpoint to register its location and, potentially, its capabilities on a network, i.e., the public Address of Record (AOR) and the associated IP address of the endpoint. (The SIP REGISTER should not to be confused with a HLA register.)  The REGISTER method is sent to a SIP registration server (registrar) by an endpoint, and the registrar then populates a location service.  The registrar, location service and proxy server are often collocated.  A proxy server using the same location service populated by the registrar will forward future requests for an AOR, e.g., sip:7705550475@lmco.com, to the proper endpoint locations previously registered to the same AOR.The Session Initiation Protocol uses an HTTP-like request-response transaction model.  A SIP transaction is comprised of one request and zero or more provisional responses followed by a final response. Transactions are relatively short lived; however, state can be established to transcend multiple transactions. This state is called a dialog and it is used to establish a longer lasting peer-to-peer relationship between two endpoints for the duration of a session.   The dialog is tightly coupled to an associated SIP media session, the media/application channel(s) complementing the SIP signaling channel.  There is typically a one-to-one associative relationship between a dialog established using INVITE and a session.  The session may be comprised of zero or more application/media channels.  Consider a conference call example.  A conference server hosts the conference in which dialogs are established between each participant and the server.  Each participant enters the conference by sending a SIP INVITE request to a Uniform Resource Identifier (URI) such as sip:conf5@wbi.org.  The audio communication channel associated with the participant’s dialog is subsequently established.  In the Telecom environment, dialogs are frequently established by SIP extension methods such as SUBSCRIBE [9] and REFER [10]; however, this paper emphasizes INVITE established dialogs because they are fundamental for understanding the recurring conference theme within this paper. From the core SIP specification [7], INVITE established dialogs have three states: early, confirmed and terminated.  An early dialog is established once the recipient UAS endpoint returns a provisional response.  Early dialogs are terminated with a CANCEL. A confirmed dialog can only be created after a successful response to an INVITE is received by the UAC endpoint.  A BYE, invoked by any endpoint UAC, is used to terminate a confirmed dialog.  When a dialog is terminated, the associated session media channel is also automatically terminated. The BYE forces the dialog into a permanent terminated dialog state.Before certain methods can be invoked on an endpoint, dialogs involving those endpoints must exist in a given state.  For example, a CANCEL method requires an early dialog, an ACK a confirmed dialog, and a BYE requires either an early or a confirmed dialog. Not all transactions must be associated with a dialog.  For example, an OPTIONS request does not establish a dialog, only a short-lived transaction.  The same is true for a REGISTER or the PUBLISH [11] request.  SIP uses text messages to carry requests and responses between UAC endpoints and UAS endpoints.  The Transmission Control Protocol (TCP) or User Datagram Protocol (UDP) transports are typically used by SIP to carry messages.  SIP also supports the Stream Control Transport Protocol (SCTP), allowing transaction messages to process with essentially the speed of UDP and much of the reliability of TCP.  SIP supports these transport mechanisms in both IPv4 and IPv6 networks.SIP messages contain a single text header, with multiple header fields, and a blank line separating the message body from the header.  Many SIP headers are borrowed from SMTP and HTTP.  Syntactically, the header begins with a request method or response code. All request headers contain at least a destination AOR, a sender AOR coupled with a sender tag to uniquely identify the endpoint, transaction sequence information and a Call-ID. The Call-ID is uniquely defined by the requesting UA endpoint.   This information allows messages to be uniquely identified as belonging to a specific transaction and often a specific dialog.  Most response headers will have a recipient tag uniquely identifying the recipient endpoint. Both the sender and recipient tags and the Call-ID identify the SIP dialog. The transaction ID for each communication hop is identified by the branch parameter in a Via header field. Source routing information is also included in the SIP Via header fields.  This is used to ensure that responses to requested transactions for which no dialog has been established will return along the same path from which the request arrived. Similarly, including source routing data ensures messages associated with a particular dialog follow a consistent route between end points. Proxy servers route information and can be either stateless or stateful.  Stateless proxy servers do not hold transaction or dialog state information. They efficiently route messages and are usually found within large core Telecom carrier SIP networks connecting enterprises.  Stateful proxies maintain the state of transactions and sometimes the dialogs associated with message passing. INVITE dialog stateful proxies are often referred to as “call stateful” proxies. SIP firewalls are call stateful.  SIP proxies are permitted to add, delete and modify certain SIP message headers. When routing is involved, the initial signaling pathways and the established dialog pathways are not the same.  Once both endpoints have established dialog pathways, messages (e.g., ACK, BYE and the associated transaction responses) are typically sent directly between endpoints; circumventing any proxies traversed during the initial setup.  This is a default behavior of SIP endpoints; however, if a proxy used in the initial session setup desires to stay in the messaging path of a dialog, it may do so by inserting a special header into the SIP messages being routed. Both stateless and stateful proxy servers may insert this SIP “Record-Route” header.   Stateful SIP proxies use this mechanism to ensure trans-enterprise security policies are enforced. This also allows stateful proxy servers to provide billing and signaling server services such as call forwarding or incoming/outgoing call screening. Forwarding and call screening services are often implemented with the Call Processing Language (CPL) [17, 18].  XML-based CPL screening policies can be set by an administrator to enforce enterprise screening policies and can be augmented safely through tailoring policies defined by end users.  CPL is a general purpose mechanism for forwarding, redirecting and rejecting connection request and can be used to provide the equivalent functionality of a centralized SPAM filter for email.  VoIP SPAM is referred to as Spam over Internet Telephony (SPIT).  Strong authentication will minimize SPIT from user agents pretending to be someone they are not, spoofing. To complete the discussion of SIP message components, the content of the messages being routed should also be described. Message content following the header is referred to as the SIP body. The text Multipurpose Internet Mail Extension (MIME) type specified by a SIP header determines the content of the SIP body.   A message body is routed with its header but is not modified by proxy servers, unlike the header. Message bodies often contain set-up information such as media CODEC type, media transport protocol, media packet rates, media QoS information, etc.  The Session Description Protocol (SDP) [19] contains such data and is the most common data type found within SIP INVITE bodies.  Further examination of the SIP response is useful.  A UAS responds to a UAC request by sending one of a series of possible response codes, following the HTTP paradigm.  Response messages contain the appropriate response code, signifying the result of the request.  Response codes are represented by three-digit integers. The first digit specifies one of six response classes of which the message is a member, i.e., 1xx – 6xx. The latter two digits indicate a specific code for the UAS’s attempt to respond to a request.  For example, a 1xx response such as “100” is a member of the provisional class.  It indicates that a UAS is in the process of “Trying” to satisfy the request. Provisional codes are subsequently followed by a final response, a 2xx response (or higher).  Similar to INVITE requests, 2xx responses often contain SDP bodies.  2xx response codes represent success, 3xx redirects, 4xx request failure, 5xx server internal error and 6xx global failure.  SIP uses the HTTP digest authentication mechanism to allow a UAS to force a UAC to authenticate itself with a “zero knowledge proof” [7, 20] by returning a 401 or 407 response to the UAC request.  Since a bi-directional authentication mechanism is defined in RFC 2617 [20], the client can also authenticate the server. To supplement the already strong SIP authentication mechanisms, Transport Layer Security (TLS), Secure MIME (S/MIME), Secure Real Time Protocol (SRTP) and Internet Protocol Security (IPSec) may be applied to protect the signaling messages and session media from manipulation, man-in-the-middle attacks, replay attacks and other security threats.SIP signaling with TLS encryption used at every proxy hop between two communicating endpoints is called SIP Secure (SIPS).  SIPS provides only hop-to-hop encryption for messages and does not afford the confidentiality provided by end-to-end encryption.  S/MIME provides end-to-end encryption for SIP message bodies.  S/MIME encoded bodies can also be passed inside a SIPS encoded signaling channel.  Both SIPS and S/MIME can be used (separately or together) to encode the SDP. An encrypted SDP body can be used to safely pass a secret session key between endpoints for SRTP to AES encode the RTP media data.   When URL addresses (e.g., sip:truck@10.1.1.5) are used to initiate communication between endpoints instead of more anonymous URI addresses, SIP endpoints can communicate directly to one another without using proxy services.  URL addresses tend to contain information about a network’s private working details; URI addresses do not.  Major enterprises use URI addresses for email, not URL addresses. Strict endpoint-only communication will work sufficiently well if there are a manageable number of endpoints within a single enterprise.  Bypassing proxy servers does not scale well for locating endpoints, and this approach does not work across enterprises implementing any respectable security policy to protect sensitive information.Finally, most enterprises block the opening of static UDP pinholes in firewalls because of the well -documented security risks associated with using a stateless protocol across a firewall.  The only noteworthy exceptions to this best practice are Domain Name Service (DNS), Internet Key Exchange (IKE) and, for some enterprises, the Network Time Protocol (NTP).  SIP is quite different in this respect.  Because of the statefulness of SIP dialogs, the signaling channel may use UDP/TCP/TLS/SCTP to dynamically negotiate pinholes across firewalls for a real-time UDP-based media/application channel transport.  SIP proxy servers having a trust relationship with a firewall are used to enforce a strong authentication posture of the SIP endpoints desiring to open egressing trans-enterprise pinholes for communication.  Hence, SIP solves the real-time UDP transport problem across enterprise firewalls that most of today’s RTI implementations tend to ignore. SIP supports authenticated dynamic pinholes for both UDP and TCP. 1.3 Conferencing Services using the Session Initiation ProtocolThe IETF has defined a conferencing architecture that disaggregates conferencing responsibilities to host scalable conferences. Numerous Telecom vendor implementations currently support tens of thousands of telephone calls simultaneously 24x7.  Since a conference server is essentially a user agent, servers can be cascaded or aligned in tree-like structures to provide scalability into the millions. Conferences can be provisioned using HTTP, ad-hoc SIP extensions or by other protocols. A conference URI factory (i.e., pattern) is often used to allocate conference URIs for new conferences having default conference policies.  When combined with an INVITE, this factory pattern can be used to provide open RTI register functionality. Once the conference URI is known, each SIP participant may join by  invoking a SIP INVITE method to the URI of the designated conference, provided the conference policies (includes security policies) are followed.  Conference-unaware user agents can’t explicitly control the conference policies or conference floor ownership.  Conference-aware user agents may change a conference policy, moderate a conference or take control of a floor, thereby taking ownership of the conference.  The owner or creator of a conference does not have to be conference-aware.  In addition to a conference server allowing user agents to call into it, servers can issue a mass set of INVITE transactions to all conference participants. This call-out capability is the opposite of the assumed call-in model used by HLA’s join federation execution. Independent of whether a call-in or call-out policy is being used, regular participants may leave the conference by issuing a BYE transaction.  Depending on the current conference policy, the conference creator and/or moderator/chair may issue a BYE transaction to close the conference.  If a SIP endpoint is conference-aware, a protocol that manages acquisition and divestiture of the conference floor, called a floor control protocol, would be all that is required to implement open RTI Ownership Management services. Because of considerable Telecom market forces, the IETF XCON working group is currently defining a family of protocols to be used by conference-aware user agents, which includes a floor control protocol.  Thus, an open standards-based solution leading to implementation of an open RTI is imminent. 2. Abstract RTI Implementation Model A component-oriented RTI implementation model is used to discuss an abstract RTI implementation that intentionally allows many possible RTI implementation strategies. The model assumes that an RTI is composed of one or more “components”. An RTI Component (RC) may provide direct support to zero or more federates. Direct support is provided when the RC is linked to the federate’s RTI and Federate ambassadors.Figure 1, shows a federation above an RTI. The federation is composed of federates a thru n, and federates interact with the RTI thru the RTI API. To federates, the RTI appears as a black box hidden behind the API. Federates do not have knowledge of the RTI implementation. The RTI is implemented using RCs 1 thru K. RC1 supports a single federate. RC2 supports multiple federates. RC3 does not support any federates directly, and is present to provide support for other RCs. The implementation model supports a variety of realistic implementations. For example, a centralized client/server implementation might use RC3 as the central server, and the other RCs would be distributed local clients. A purely distributed (peer-to-peer) implementation might have RC3 contain only the RTIexec, and the other RCs would support distributed service algorithms. Other architectures might include additional embedded RC components (such as web services) that do not support federates directly, and there may be varying degrees of distribution among the RCs involved in supporting specific services.3. The Conference ConceptA conference is an infrastructure enabling communication among multiple parties with common interests. Conferences may occur concurrently, and a conference may provide a hierarchy of sub-conferences where parties can communicate about more specific topics. Furthermore, joint conferences may be held to combine groups of interested parties. An individual wishing to communicate in multiple concurrent conferences may wish to delegate attendees to represent the individual’s interests. An attendee at a conference may play the role of a speaker, a listener, or a talker. A speaker may only provide information to listeners and talkers. A listener may only accept information from speakers and talkers. A talker may both provide and accept information.Within a conference, floors are used to announce information to attendees. An announcement from a floor communicates information about a specific topic to all attendees of the immediate conference (an announcement from a floor is not heard in super- or sub-conferences). There may be more than one floor within a conference and listeners and talkers at a conference hear all announcements from every floor at the conference. A floor may be created as either open or owned. An open floor allows any speaker or talker to make an announcement at any time. Only the owner of an owned floor may make an announcement from the floor, and is said to hold the floor. An attendee may own more than one floor. Ownership of a floor may be negotiated between the current owner and a requesting attendee. A conference without a floor holder is unowned and is immediately available to become owned by a requesting attendee.  Attendees may query a conference to discover the floors that exist within the conference.  4. The Open RTI Conferencing ModelThe Open RTI is based on the use of conferences to exchange information. This section presents the model. 4.1 RTI-Specific ConferencingTo support a federation, the RTI must create a federation-specific conference. This federation conference is a “root-conference” and all RTI activity related to the federation is carried out in sub-conferences of the federation conference.  There may be many concurrent sub-conferences of interest, and each RC must send or have sufficient attendees to achieve the required coverage of sub-conferences. In addition to sending or having attendees invited to conferences supporting RTI-specific (as opposed to federate-related) communication, each participant RC will send or have attendees invited to conferences of interest to its supported federates. An attendee at a conference representing specific interests of a federate will be called the “federate’s delegate”.Since this paper is focused on object ownership transfer, the discussion of related conferences will be directed towards this topic. Within a federation conference, the RTI also creates sub-conferences for each object class of interest to federates. The FOM may contain additional (redundant) classes, but only those of interest require communication among federates. Each object class conference is created with an open floor to permit announcements about the creation and deletion of object instances. Within each class conference, an attribute conference is created for each attribute of interest to the federation.A participant RC must send delegates (or have delegates invited) to each conference of interest to each of its supported federates. If a federate only publishes information about a class, then the RC should send a speaker (to announce new instances) as the federate’s delegate to the class conference, and a speaker delegate to the attribute conference of each attribute the federate intends to publish. If a federate only subscribes to information about the class, then the RC should send a listener (to discover instances) as its delegate to the class conference, and a listener delegate to the attribute conference of each attribute the federate will subscribe. If an RC supports a federate that both publishes and subscribes to information about the class, then the RC should send a talker as the federate’s delegate to the class conference, a speaker delegate to the attribute conferences of each attribute the federate will only publish, a listener delegate to the attribute conferences of each attribute the federate will only subscribe, and a talker delegate to the attribute conferences of each attribute the federate will both publish and subscribe. At a conference, an attendee is identified by at least the supporting RC, and (for RCs supporting a federate) also by the federate whose interests the attendee represents (i.e. a federate’s delegate is identified by both the federate and the RC supporting the federate).When a federate registers a new instance of a class, the federate’s delegate to the class conference announces the new instance via the conference’s open floor. A new owned floor associated with the newly registered object is automatically created in each of the class’s attribute conferences. If the registering federate has a delegate present in the attribute conference, then initial ownership of the floor is given to that delegate; otherwise, the floor is unowned initially. The special “HLAprivilegeToDeleteObject” attribute is easily handled in a manner similar to other attributes. An associated attribute conference is created for each class. The only difference in behavior is that this attribute’s ownership is interpreted as a privilege token, and the actual attribute value is never updated. To ensure this attribute is managed correctly, all federates that register instances of a class must send a delegate to that class’s “HLAprivilegeToDeleteObject” attribute conference.The deletion of an object has repercussions throughout the associated class conference. Only the federate whose delegate owns the HLAprivilegeToDeleteObject floor for that object instance may delete the object. The deletion of the object is accomplished by deleting the associated HLAprivilegeToDeleteObject attribute floor, i.e. this conference floor owner sends a SIP BYE message to the conference server. This in turn causes each of that object’s attribute instance floors in each of the attribute conferences to be deleted. To ensure all federates are informed, the deleting federate’s class conference delegate announces the deletion of the object instance from the class conference floor.4.2 Object Attribute OwnershipIn the Open RTI model, the ownership of an object’s attribute floor corresponds to ownership of the attribute by the federate. Only the federate whose delegate owns an attribute floor may update that attribute. When a federate updates the attribute, the delegate announces the update (via the specific attribute’s floor at the attribute conference) to all attendees at the attribute conference. In this way, all federates subscribing to a class attribute are informed of all updates to all instances of the attribute. If a federate would like to acquire the ownership of an attribute, a pull model, it must negotiate with the current owner. This is accomplished by sending a Request_Ownership message to the floor moderator. If the floor is unowned, ownership is immediately granted. If the floor is owned, the message is relayed to the owner and it is up to the owner as to whether to grant the request. In both cases, ownership messages are sent only to the attendees involved and are not announced to all attendees present. If a federate would like to divest ownership of an attribute, it can announce this desire by sending a Divest_Ownership to all attendees.  If an attendee then wishes to obtain ownership, it then sends a Request_Ownership message to the floor moderator (as described above). If a federate resigns from a federation, then all attribute conference floors held by the federate’s delegates become unowned. If the resigning federate owned permission to delete objects, then the way in which the resign is requested will determine whether the objects are deleted (according the HLA specification). When the federation resigns, all of the federation’s delegates leave the conference. Figure 2 shows an example (partial) federation conference structure. Only a single class (Class X) is considered. The federation includes Federate A supported by RC1 and Federate B supported by RC2. Federate A publishes X.a and X.b. Federate B subscribes to only X.a. Since this example only involves federates that either publish or subscribe (but not both) to an attribute, the federate delegates are either speakers (publish) or listeners (subscribe) (ie. no talkers are needed). The delegates appear in the figure as parallelograms, with speakers are coloured blue, and listeners are coloured green. Since Federate A publishes, RC1 sends speaker delegates to the Class X Conference and all of the class X attribute conferences. Since Federate B only subscribes to X.a, it sends listeners to the Class X Conference and the X.a Attribute Conference. When Federate A registers “myX” as an instance of class X, its delegates are assigned ownership of the floors created in the attribute conferences. Floors are represented by ovals in the figure. Federate B’s Class Conference delegate is informed of the creation of the instance myX, and its listener in the X.a Attribute conference will be informed of subsequent updates to myX.a.When a federate initiates a createFederation or joinFederation request, the supporting RC creates the federation-level conference (if it did not previously exist) and sends a delegate of federate specific attendees. The composition of the delegate depends on the federate’s publish/subscribe interests. 5. The RTI Conference Model and SIPSIP provides a protocol for setting up a “session” among users. The SIP signaling messages are sent on the signaling channel, while the session data may be exchanged on an application channel. An application channel is not necessarily the same channel as the signaling channel, and the details of the application channel are negotiated as part of the initiation protocol.Due to the common need to have multi-party conferences, particularly in audio/video applications, considerable work (by companies such as Radvision, Polycom, IPunity, Convedia, Snowshore, Voyant, eDial, and aTelo) has been done to establish SIP-based conferencing frameworks. These frameworks use information available through SIP to help with the conferencing on audio/visual application channels. They extend SIP and/or SDP by defining SIP signaling messages that are used in session management. This allows the SIP signaling channel to carry control information rather than interleaving conference control messages into the audio/visual streams on the application channel. By having a framework, it is possible to encourage interoperability with users who are compliant with the framework.The “session” we are concerned with initiating is intended to support a federation execution. This is an application that is distributed, has shared data, and shared events. SIP manages the session initiation, but does not deal with application-specific RTI content.Our work shares many similarities with previous work on SIP-based conferencing frameworks; however, the conferencing needs of an RTI differ from those of audio/visual conferences. In particular, RTIs do not include streams of audio/visual data that must be mixed and synchronized. Specific federations may include audio/visual streams, but these are federation specific, and not required to support RTI functionality. The application data we need to exchange are messages associated with implementing RTI functionality. There are several directions in which we might pursue a SIP-enabled RTI.A SIP-minimal RTI implementation Strategy  In this approach, we would use SIP to set up a multi-party conference among federates (RTI Components). The RTI messages exchanged to implement RTI services would be viewed as “application data” that is outside of SIP’s concern. The advantage to the RTI implementation is that all of the SIP enabled benefits are present (such as access through firewalls, security, quality of service, etc.). A goal in setting up the session would be to ensure that real-time data exchange (quality of service) would be provided on the application channel to communicate RTI messages.In the simplest case, the use of SIP would not extend beyond the initiation of the session. This would impact the implementation of RTI federation management services; however, all subsequent RTI messaging associated with other RTI services would happen on the application channel outside of SIP signaling. This might allow an RTI to gain the advantages of SIP with only minimal impact on its implementation. Thus this approach is a SIP-minimal RTI implementation approach.A SIP-maximal RTI implementation StrategyAt the other extreme to the SIP-minimal approach is a SIP extension that provides a SIP Conferencing Framework that closely mimics the conferencing requirements for an RTI. This would greatly simplify the implementation of an RTI since existing services could be used to implement RTI services.The advantage of this approach is also its strongest potential disadvantage! The extended SIP signaling messages would use the SIP signaling channel to communicate a subset of the RTI-related messages. This would reduce the gains of a real-time application channel for these messages, and would likely incur overheads associated with the audio/visual concerns of current SIP conferencing frameworks. Since this approach would require significant rework of all RTI services, this is a SIP-maximal RTI implementation approach. A SIP-nominal RTI implementation StrategyThis is an approach that falls in between the above extremes. The approach would establish a conference framework using application channel messaging. Knowledge of the SIP session could be used to help in conference management. The major difference between this and the SIP Conferencing Control Framework is the use of the application channel for conference control and user management policy signaling. In this approach, a standard framework for conferencing is used as part of the application, and the application channel is used for conference and application signaling.Our research is pursuing the SIP-nominal RTI implementation strategy.6. ConclusionsThe future potential for SIP-enabled VoIP strongly suggests that SIP will play a role in network centric warfare and next generation warfighter communication systems. This paper has presented preliminary research towards a SIP-enabled Open RTI. An Open RTI is needed to simplify and encourage integration with other SIP-enabled applications. The Open RTI is based on a conferencing model. The model is helpful as a semantic alternative for discussing RTI services, and provides a path to align the RTI with the extensive use of conferencing in SIP applications. The RTI Object Ownership Transfer services were used as a realistic case study to explore RTI conferencing. Three strategies for mapping the Open RTI to SIP were suggested, and the SIP-nominal strategy was selected as the recommended approach. In this approach, SIP signaling would be used to establish a federation conference, and then the application channel would be used for conference and application signaling. The research is uncovering an exciting potential for an Open RTI to meet ambitious future goals. The research is only just beginning, and the authors encourage anyone interested in joining us in a SIP Modeling and Simulation Framework Study Group.7. References[1] IEEE Standard for Modeling and Simulation (M&S) High Level Architecture (HLA): Federate Interface Specification, IEEE Std 1516.1-2000, The Institute of Electrical and Electronics Engineers, Inc., New York, NY, U.S.A.[2] DISA, DRAFT, “IP Telephony & Voice Over Internet Protocol Security Technical Implementation Guide,” Version 2, Release 0, 30 December 2004.  (Older version) HYPERLINK "http://csrc.nist.gov/pcig/STIGs/VoIP-STIG-V1R1R-4PDF.pdf" http://csrc.nist.gov/pcig/STIGs/VoIP-STIG-V1R1R-4PDF.pdf [3] L. Scott Holben, Robert W. Johnson and Margaret S. Herald, “Converging Software Architecture with Next Generation Distributed Technologies”, 04F-SIW-032, SISO, September 2004[4] IEEE Standard for Modeling and Simulation (M&S) High Level Architecture (HLA): Framework and Rules, IEEE Std 1516-2000, The Institute of Electrical and Electronics Engineers, Inc., New York, NY, U.S.A.[5] IEEE Standard for Modeling and Simulation (M&S) High Level Architecture (HLA): Object Model Template (OMT) Specification, IEEE Std 1516.2-2000, The Institute of Electrical and Electronics Engineers, Inc., New York, NY, U.S.A.[6] IEEE Recommended Practice for High Level Architecture (HLA) Federation Development and Execution Process (FEDEP), IEEE Std 1516.3-2003, The Institute of Electrical and Electronics Engineers, Inc., New York, NY, U.S.A.[7] Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M. and Schooler, E.. Network Working Group, Request for Comments: 3261, “SIP: Session Initiation Protocol,”  HYPERLINK "http://www.ietf.org/rfc/rfc3261.txt" http://www.ietf.org/rfc/rfc3261.txt.  The Internet Society, June 2002.[8] Campbell, B., Rosenberg, J., Schulzrinne, H., Huitema, C. and Gurle, D. Network Working Group, Request for Comments: 3428, “Session Initiation Protocol (SIP) Extension for Instant Messaging,”  HYPERLINK "http://www.ietf.org/rfc/rfc3428.txt" http://www.ietf.org/rfc/rfc3428.txt.  The Internet Society, December 2002.[9] Roach, A. Network Working Group, Request for Comments: 3265, “Session Initiation Protocol (SIP)- Specific Event Notification,”  HYPERLINK "http://www.ietf.org/rfc/rfc3265.txt" http://www.ietf.org/rfc/rfc3265.txt.  The Internet Society, June 2002.[10] Sparks, R. Network Working Group, Request for Comments: 3515, “Session Initiation Protocol (SIP) Refer Method,”  HYPERLINK "http://www.ietf.org/rfc/rfc3515.txt" http://www.ietf.org/rfc/rfc3515.txt.  The Internet Society, April 2003.[11] Niemi, A. Network Working Group, Request for Comments: 3903, “Session Initiation Protocol (SIP) Extension for Event State Publication,”  HYPERLINK "http://www.ietf.org/rfc/rfc3903.txt" http://www.ietf.org/rfc/rfc3903.txt.  The Internet Society, October 2004.[12] Rosenberg, J. and Schulzrinne, H.. Network Working Group, Request for Comments: 3262, “Reliability of Provisional Responses in the Session Initiation Protocol (SIP),”  HYPERLINK "http://www.ietf.org/rfc/rfc3262.txt" http://www.ietf.org/rfc/rfc3262.txt.  The Internet Society, June 2002.[13] Rosenberg, J. Network Working Group, Request for Comments: 3311, “Session Initiation Protocol (SIP) UPDATE Method,”  HYPERLINK "http://www.ietf.org/rfc/rfc3311.txt" http://www.ietf.org/rfc/rfc3311.txt.  The Internet Society, September 2002.[14] Donovan, S. Network Working Group, Request for Comments: 2976, “The SIP INFO Method,”  HYPERLINK "http://www.ietf.org/rfc/rfc2976.txt" http://www.ietf.org/rfc/rfc2976.txt.  The Internet Society, October 2000.[15] Rosenberg, J., Schulzrinne, H.,  Kyzivat, P. “Indicating User Agent Capabilities in the Session Initiation Protocol (SIP),”  HYPERLINK "http://www.ietf.org/rfc/rfc3840.txt" http://www.ietf.org/rfc/rfc3840.txt.  The Internet Society, August 2004.[16] Rosenberg, J., Schulzrinne, H.,  Kyzivat, P.  “Caller Preferences for the Session Initiation Protocol (SIP),”  HYPERLINK "http://www.ietf.org/rfc/rfc3841.txt" http://www.ietf.org/rfc/rfc3841.txt.  The Internet Society, August 2004.[17] Lennox, J. and Schulzrinne, H.  Network Working Group, Request for Comments: 2824, “Call Processing Language Framework and Requirements,”  HYPERLINK "http://www.ietf.org/rfc/rfc2824.txt" http://www.ietf.org/rfc/rfc2824.txt.  The Internet Society, May 2000.[18] Lennox, J. and Schulzrinne, H.  Network Working Group, Request for Comments: 3880, “Call Processing Language (CPL): A Language for User Control of Internet Telephony Services,”  HYPERLINK "http://www.ietf.org/rfc/rfc3880.txt" http://www.ietf.org/rfc/rfc3880.txt.  The Internet Society, October 2004.[19] Handley, M. and Jacobson, V. Network Working Group,   Request for Comments: 2327, “SDP: session description protocol,”  HYPERLINK "http://www.ietf.org/rfc/rfc2327.txt" http://www.ietf.org/rfc/rfc2327.txt.  The Internet Society, April 1998.[20] Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S., Leach, P., Luotonen, A., Stewart, L.  Network Working Group, Request for Comments: 2617, “HTTP Authentication: Basic and Digest Access Authentication,”  HYPERLINK "http://www.ietf.org/rfc/rfc2617.txt" http://www.ietf.org/rfc/rfc2617.txt. The Internet Society, June 1999.Author BiographiesTREVOR PEARCE is an Assistant Professor with the Department of Systems and Computer Engineering at Carleton University, Ottawa, Canada.  His research interests are in embedded real-time systems, distributed simulation, and engineering methodologies.L. SCOTT HOLBEN is an Operations Research Analyst for Advanced Development Programs at Lockheed Martin Aeronautics in Marietta, GA. Scott investigates innovative applications of VoIP technologies for collaboration and distributed M&S over warm persistent cross-enterprise networks.   He is also defining network configurations and management processes that will enable secure collaboration in a distributed, multi-contract, multi-enterprise environment under the Air Force Materiel Command’s Integrated Collaborative Environment (AF-ICE) program.CLAUDE VAN HAM is currently a student in the Department of Systems and Computer Engineering at Carleton University where he is pursuing a M.A.Sc. in Electrical Engineering.  Claude has worked as a systems engineer on the CF-18 fighter aircraft responsible for avionics, computers and electronic warfare systems.  He has also worked in the telecommunications industry in the development of new products and technologies and the implementation of an international VoIP network.  He has a previous M.S. from the University of Hawaii at Manoa and a B.Eng. from the Royal Military College of Canada both in electrical engineering. Note the use of the term “object” in the HLA is not the same as in current object oriented software languages such as Java. Objects in the HLA are defined hierarchically such that subclasses inherit the data attributes of their parents; however, HLA objects define no explicit behavior (they have no methods). Extensions to SIP are allowed through the definition of other methods and headers.  The other methods of importance to this paper are: MESSAGE [8] SUBSCRIBE/NOTIFY [9], REFER [10], PUBLISH [11], PRACK [12], UPDATE [13], and INFO[14]) Figure 1: RTI implementation based on RCsRC3federatenfederatecfederatebRTIAPIRC interactionsRCK……RC2RC1federates see RTI as a “black box” hidden below APIfederateaFederationflooropenownerBAmyX.aX.a Attribute ConferenceAmyX.bX.b Attribute ConferenceAmyXX. HLAprivilegeToDeleteObject Attribute ConferenceFed B delegate listenerFed A delegate speakerRC2Federate Bsubscribe X.aClass X ConferenceFederation ConferenceRC1Federate Apublish X.apublish X.bregister myXRTIFigure 2: An Example of a Federation Conference