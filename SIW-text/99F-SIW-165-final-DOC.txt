TIME MANAGEMENT OF UNSYNCHRONIZED HLA SERVICESRichard M. FujimotoIvan TacicCollege of ComputingGeorgia Institute of TechnologyAtlanta, GA 30332-0280KEYWORDSHigh Level Architecture, Run-Time Infrastructure, Ownership Management, Data Distribution ManagementABSTRACTCertain HLA services are currently not time managed. Data distribution management, ownership management, and declaration management are examples. This paper develops a framework to provide a means for discussing and comparing alternate approaches to realizing time managed versions of unsynchronized HLA services.  Specifically, it is shown how realization of unsynchronized HLA services maps to the classical problem of synchronizing parallel/distributed discrete event simulation computations. It is observed that viewing the problem in this light exposes three general approaches to realizing time managed versions of these services.  Previously published approaches to time managed ownership management and data distribution management services are discussed in this context.The purpose of this paper is not to advocate a specific approach to adding time management to unsynchronized HLA services. Rather the goal is to define a framework that can be used to explain why adding time management is a non-trivial problem, and to provide a vehicle for synthesizing, discussing, and comparing different approaches to adding time management.INTRODUCTIONThe HLA Interface Specification includes many services that perform a wide variety of tasks during the execution of a distributed simulation.  Some service invocations are referred to as being "time managed" while others are said to be "not time managed." This paper is concerned with the services that are currently not time managed, e.g., data distribution management, declaration management, and ownership management. The goal of this paper is to highlight the technical issues that come into play in creating time managed versions of services that are currently not time managed.The distinction between time managed and non-time managed service invocations is largely concerned with the question of when the service takes effect, and the order in which the service takes effect in relation to other services invoked by this and other federates during the federation execution.    "Time managed" service invocations are those with semantics based on logical time. They provide a mechanism for federates to explicitly control the order that services appear to take effect.  "Non-time managed" services make no such ordering guarantees.  Each of these is described next.Non-Time Managed ServicesService invocations that do not operate under the HLA time management system "take effect" whenever the RTI realizes the function implied by invoking that service.  For example, consider invoking the Update Attribute Values service to send a receive-ordered message.  The corresponding Reflect Attribute Values service is invoked when the RTI has transmitted the message through the network, and the destination processor has received it.  If two different processors simultaneously invoke Update Attribute Values to send messages to a single destination federate, the order in which the corresponding Reflect calls are made at the destination federate is indeterminate, and in fact may vary from one execution to the next.  This is one source of non-determinism in federation executions that creates non-repeatable results.In the following, we sometimes refer to wallclock time.  Informally, wallclock time refers to the local computer's approximation to Coordinated Universal Time (UTC), possibly with some offset, that is typically read from a hardware clock during the execution of the federation.Time Managed ServicesTime managed services use an abstraction called logical time to specify when each service invocation is to take effect.  Logical time is a federation defined time scale that models time in the system being simulated.  Each federate using the time management services has a logical time clock associated with it.  Federate advances in logical time may or may not be paced with wallclock time advances.  Logical time advances typically are not paced in an as-fast-as-possible execution.  Alternatively, advances may be paced in other contexts, e.g., in a training exercise or when other federates are using a real-time mode of execution.Each invocation of a service that operates under HLA time management includes a time stamp indicating a point in logical time when the action(s) implied by the service invocation are to occur.  This time stamp may be specified explicitly as a parameter in the service invocation, as is the case in the Update / Reflect Attribute Values services, or it may be implicit. In the latter case the time stamp is often defined as the current logical time of the federate invoking or being invoked by the service.When using time management, the central goal one is after is to ensure the federation execution produces the same results as if all of the time managed services across the entire federation were invoked sequentially, one after the other, in time stamp order.  This does not mean the services must be performed sequentially, only that the end result of the execution is the same as if they were performed sequentially in time stamp order.  For example, consider the case where two federates simultaneously invoke Update Attribute Values to send a time stamp ordered message, and both messages are received by a third federate.  Suppose these messages are assigned time stamps (in logical time) 10 and 20.  The IF Spec guarantees the Reflect Attribute Values service is invoked for the time stamp 10 message before it is invoked for the time stamp 20 message at the destination federate, regardless of the order that the updates occurred in wallclock time.  The two messages may have been physically transmitted through the network in any order, or even simultaneously, but this fact is irrelevant in so far as the federates are concerned.Time management can be used to ensure that repeated executions of the distributed simulation produce exactly the same results.  One need only ensure that (1) the computation within each federate for assigning time stamps is deterministic, (2) no two service invocations are assigned exactly the same time stamp, or if they are, ties are ordered in a deterministic fashion, and (3) the federate does not perform other computations that are not repeatable, e.g., utilizing wa.llclock time in its computations.Update Attribute Values / Reflect Attribute Values is an example of a pair of services that effectively has two versions: one time managed (those resulting in the reception of time stamp order messages) and one that is not time managed (resulting in receive order messages).  Many other services in the HLA such as ownership management only have non-time managed versions.Related WorkTime management of ownership transfer services is discussed in  ADDIN ENRfu [1] in the context of a logistics cargo/port simulation.  The focus of this work with respect to time management is on translating time stamp values derived from different time scales when a federate's local simulation time clock operates at some offset relative to the time scale used by the federation.  This paper also discusses an approach for transferring object data between federates using interactions, a problem also discussed in  ADDIN ENRfu [2, 3].  A follow-up paper compares different approaches to performing object transfers  ADDIN ENRfu [4].  Techniques to address latency, throughput, and fairness problems in realizing ownership transfer in the context of non-causal real-time simulations are discussed in  ADDIN ENRfu [5].  These papers focus on topics that are important, but are largely orthogonal to the focus of this paper, namely ensuring proper ordering and synchronization of ownership transfers, so we do not discuss them further.Time managed ownership transfers are discussed in  ADDIN ENRfu [6].  Similar functionality in the context of a parallel discrete event simulation language is discussed in  ADDIN ENRfu [7]. Time managed data distribution management is described in  ADDIN ENRfu [8-10].  Here, we attempt to put approaches such as these into a common framework in order to highlight the underlying principles used to develop these mechanisms.  We will later discuss how the mechanisms proposed in these papers fit into our framework. Background: Parallel Discrete Event Simulation (PDES)The technical underpinnings for the time management services stem from work in the parallel discrete event simulation community over the last twenty years.  It is important to understand some of the fundamental assumptions normally used in PDES algorithms to understand the issues that arise in making additional HLA services time managed:The distributed simulation consists of a collection of logical processes (LPs).  Each LP includes local state.  An HLA federate can be viewed as a single LP.LPs can only interact with other LPs by exchanging time stamped messages.  There cannot be shared state that is directly or indirectly accessed by different LPs.  In HLA terminology, time stamped messages correspond to TSO messages sent by invoking services such as Update Attribute Values or Send Interaction.  As will be seen momentarily, the shared state assumption is at the core of why adding time management to services such as DDM is a non-trivial problem.In PDES, each message sent between LPs is called an event, so the terms event and message are synonymous. It can be shown that if each LP locally processes events in time stamp order, the entire execution will globally produce the same results as if all events were processed sequentially in time stamp order, the property we seek in the HLA.  Well-known algorithms exist to ensure time stamp order delivery of messages (events) to LPs  ADDIN ENRfu [11].  These algorithms are typically used to implement the existing HLA time management services.At first glance, HLA federations appear to map very naturally into the PDES LP/message passing paradigm.  Each federate is an LP, and TSO messages resulting from attribute updates and interactions correspond to PDES events.  This would suggest that time managed HLA federations should automatically realize perfectly synchronized, repeatable executions.  Unfortunately, this is not the case.  Consider an HLA federation that exclusively sends TSO messages. Suppose the federation uses the unsynchronized declaration management services.  Consider the following sequence of actions. (1) Federate 1 updates an attribute with time stamp 100; (2) Federate 2 at logical time 99 now subscribes to receive updates to the attribute.  In the HLA as currently defined, the Interface Specification does not specify whether federate 2 should receive the message sent by federate 1.  Federate 2 may or may not, depending on RTI implementation details and when the update and subscription services were invoked.  Further, depending on the RTI implementation, federate 2 may receive the message in some executions, but not in others, i.e., the execution will not be repeatable.What should happen in this case?  Recall our goal is to ensure that the same results are achieved as an execution where all the services are invoked in time stamp order.  Using this criterion, a subscription with time stamp 99 suggests the federate expects to receive all updates that occur with time stamp greater than 99.  This implies the federate should receive the time stamp 100 message, regardless of the order in which the update and subscribe services were invoked.PROBLEM DESCRIPTIONWhy does the PDES model break down?  The central problem is we have violated the assumption that "LPs can only interact with other LPs by exchanging time stamped messages."  The problem is there is, in effect, a connection database within the RTI through which federates interact.  This database indicates which federates are to receive messages when a federate invokes the Update Attribute Values or Send Interaction services.  Certain HLA services, cause this connectivity information to change during the execution.  The problem is the services changing the connectivity information are not synchronized with the services resulting in the generation of TSO messages, causing anomalies to occur.Logically, the connection database can be viewed as a list of connection.  Each connection can be viewed as a kind of "virtual circuit" that includes a source federate that can send messages to the connection, and zero or more destinations that receive messages when one is sent to the connection.  For example, each attribute of each object instance can be viewed as having a connection that lists the destination federates that are to receive updates to that attribute.  The collection of these connections make up the connection database.  The connections need not be implemented as described above; we only use this as an abstraction to highlight time management issues.Federates can interact with each other through accesses to this connection database, rather than through time stamped messages, thus violating a fundamental PDES assumption.  Specifically:Federates modify the connection database whenever they subscribe or unsubscribe to information (updates or interactions). Modifying DDM regions or transferring ownership of attributes are examples of such modifications to the connection database.  Federates implicitly read the connection database each time they send an interaction or update an attribute.  The database is read to determine the set of federates that are to receive the message.Specifically, the problems described above in the subscription scenario come about because modifications to the connection database are not synchronized with each other or other time managed operations performed by the federate.  If all accesses to the connection database were performed in time stamp order, these problems could be avoided.For example, in the subscription scenario, the update at time 100, which reads the connection database, was performed before the subscription with time stamp 99.  This is why the update did not take into account the subscription.  Had the two services been performed on the connection database in time stamp order, the subscription would have been completed first, and the new subscriber would have received the time stamp 100 message, the desired result.Using unsynchronized (non-time managed) services in a time synchronized federation execution can result in two types of unexpected behaviors:Missed messages.  If a federate is added to the connection database at logical time T after an update with a time stamp greater than T has read the database, the federate will not receive a message it had expected to receive.  The subscription scenario illustrates this case.  Another example of this problem occurs when an update to an attribute is overtaken (e.g., in the network) by an ownership transfer exchange, as described in [Myjak, 1999 #347].Extra messages. If a federate is removed from the connection database at logical time T after an update with a time stamp greater than T has read the database, the federate will receive a message that it had not expected to receive. Problems with unsynchronized subscriptions can be trivially solved by only performing subscriptions at the beginning of the execution during a "set up" phase of the computation.  That is the current approach taken in the HLA. However, similar scenarios can also be generated using other HLA services such as ownership management and data distribution management.  The dynamic nature of these services precludes a static solution.A Framework for Synchronizing Unsynchronized HLA ServicesThe preceding discussion suggests a general framework for developing solution approaches to the problem of adding time management to those HLA services that are currently unsynchronized.  Our approach is to map the federation execution to a PDES computation.  This suggests several approaches that have been developed in the PDES community to attack this problem.First, we include a logical time specification for each service that is currently unsynchronized.  For example, an optional time stamp parameter could be added.  Alternatively, define the time stamp of each service invocation implicitly as the current logical time of the federate invoking the service, possibly with a lookahead value added.  In the case of services invoked by the RTI, the time stamp could be defined in terms of that assigned to other services previously invoked by a federate. For example the time stamp of Request Attribute Ownership Assumption could be defined to be the same as that of the Negotiated Attribute Ownership Divestiture that caused it to be called.The connectivity database is mapped to one or more logical processes.  These LPs can be distinct from the federates, or they might be viewed as being part of the federate LP. We define these LPs in order to eliminate violation of the shared state assumption, which is at the root of this problem.Each time managed service invocation results in the generation of one or more PDES events with time stamp equal to that specified in the service invocation.  These events are internal to the RTI, and are only used to correctly implement the service.  If the service invocation reads or modifies the connection database, an event is generated to the LP(s) that include the portion of the connection database read or modified by the service invocation.  Similarly, time managed invocations of Update Attribute Values, Send Interaction, and Send Interaction with Region generate events to obtain information from the appropriate connection database LPs.For example, if a federate invokes Update Attribute Values to send a TSO message with time stamp 100, this generates a message to the connection database LP(s) with time stamp 100 to determine the destinations to which the messages should be sent.  The connection database LPs determines which LPs should receive the message, and generates Reflect calls (usually requiring messages to be transmitted) at each destination.  The RTI must ensure the end result of all this is the same as if the connection database LP(s) had processed all of their messages in time stamp order.This approach effectively maps the federation execution to a classical PDES model.  The value of doing so is our task becomes clear: the RTI must ensure that all events, including those internal events sent to/from the connection database, produce the same results as if all were performed sequentially in time stamp order.  This can be accomplished by ensuring each LP in the framework processes its local events in time stamp order.  In particular, the connection database LP(s) must process their events in time stamp order to avoid missed or extra messages.SOLUTION APPROACHESIn the previous section we showed how to map unsynchronized HLA services to the PDES model. PDES algorithms and techniques can now be applied to ensure correct synchronization, i.e., the distributed execution of the federation will yield exactly the same results as if the services were performed sequentially in time stamp order.  At first glance, this might seem to provide a simple approach to adding time management to unsynchronized services.  Unfortunately, things are actually much more complex because important issues concerning performance, ease of use, and implementation complexity come into play.We characterize approaches to synchronizing the HLA services into three categories, following general approaches from the PDES literature:conservative execution with zero lookaheadconservative execution with non-zero lookaheadoptimistic executionEach of these approaches, with examples for data distribution management and ownership management are described next.Conservative, Zero LookaheadThis approach places no restriction on the time stamp assigned to time synchronized service invocations, other than a federate cannot invoke a service with time stamp less than the its current logical time.  In particular, a federate could invoke a service such as subscribing to an attribute with time stamp "now."Implementation of this approach is straight-forward; time managed services can be implemented in a manner similar to that described in Section 5.  To simplify the discussion, let us assume the connection database is mapped to a single logical process, called the connection database logical process (CDLP).  We shall return to this assumption later.  Each service invocation that must access connectivity information must send a message to the CDLP with time stamp equal to that used in the service invocation.  When the CDLP processes this message, it reads and/or modifies the database according to the type of operation that is required, and completes the realization of the operation.For example, consider an invocation of the Update Attribute Values service to send a TSO message with a time stamp of 100.  This results in an internal event within the RTI that is sent to the CDLP.  Let us call that event a request update event (RUE).  When the RUE event is processed by the CDLP, it reads the connectivity database to determine those federates that should receive the message, and sends a message to each one.Consider a more complex operation, e.g., the Modify Region data distribution management (DDM) service.  Invoking this service again generates a message to the CDLP with time stamp equal to that corresponding to the service invocation.  When the CDLP processes this event, it will re-examine overlaps among subscription and publication regions, and change the corresponding connectivity information in the database.  Subsequent update messages sent to the CDLP will utilize this new connectivity information.  This is appropriate because such updates must have a larger time stamp than the Modify Region service invocation since the CDLP processes events in time stamp order.This approach yields a correctly time synchronized execution because the PDES synchronization algorithm will ensure that the internal RTI events in the CDLP are processed in time stamp order.  This is crucial because it means when each RUE event is processed, it will read the correct state of the connection database, i.e., the state corresponding to logical time 100.  This guarantees messages will be sent to the correct set of federates, i.e., those subscribed to receive this information as of logical time 100.  Because events are processed in time stamp order, it is impossible for another event (e.g., a federate subscribing to receive the update) to later arrive with time stamp less than 100.One obvious problem with this approach is the bottleneck created by utilizing a single CDLP.  This can be addressed by distributing the connection information among several LPs.  We do not explore this issue further, but note that realization of such an approach becomes more complex when the connectivity information is contained within the underlying network, e.g., when it is embedded in the composition of multicast groups.  Because the multicast group composition represent shared information between the CDLPs, care must be taken to ensure changes in group composition are properly synchronized.A more fundamental problem concerns the amount of concurrent activity that can occur during the federation execution.  Consider the Update Attribute Values service described earlier.  The problem is the RUE event cannot be processed until it can be guaranteed no other events, e.g., subscription events, will later be generated with time stamp less than 100.  But how do we guarantee that later in the execution some federate at simulation time 99 will not issue a subscription with time stamp 99?  We cannot preclude this until every other federate has advanced to simulation time 100.  Further, no other federate can advance beyond simulation time 100 because that federate may be expecting to receive a message for the updated attribute with time stamp 100.While technically correct, it is clear that there is very limited concurrent execution that can take place with this approach.  Events containing different time stamps cannot be processed concurrently. This is no surprise because this is a well-known problem in the PDES literature.  Note that this problem still exists even if each federate declares non-zero lookaheads for attribute updates and interactions.  The problem is other time managed services, e.g., DDM services, can produce zero lookahead actions that affect the other time managed services.  To summarize, the conservative zero lookahead approach has the advantages that it is relatively simple to implement, and in contrast to the approach described next, it does not impose new lookahead restrictions on federates.  The disadvantage is that it will yield very poor performance because execution of events containing different time stamps must be performed sequentially.  This also implies this approach will not scale to large federations.  Because of these constraints, this is a poor choice for the HLA.  Nevertheless, we include it here to demonstrate that from a correctness standpoint, it is possible to define time managed versions of unsynchronized HLA services.Conservative, Non-Zero LookaheadThis approach constrains each LP to always schedule events, including internal events sent to the CDLP, at least L time units into the future.  L is called the LP's lookahead.  When applied to the above example, we require that federates only issue subscription requests at least LS time units into the future. For example, let us assume there are only two federates and LS is equal to 10.  This means the RUE event can be processed once the subscribing federate has reached simulation time 90, because any new subscription it generates must have a time stamp of at least 100.Lookahead used in this context is largely the same concept as the lookahead notion currently defined in the HLA.  Lookahead offers greater concurrency, but is more difficult to use because it requires federates to know something about the future messages it will generate so that they can be generated early.The approach described in  ADDIN ENRfu [6] utilizes this approach to perform time synchronized ownership transfer operations.  A lookahead constraint is imposed on each step of the owner transfer process, leading to a mechanism where the actual transfer spans a period of simulation time.  We explain this approach in terms of the framework described in this paper.A "push" style ownership transfer where the current owner F1 divests ownership to another federate F2 occurs through a sequence of service invocations.  First, F1 invokes Negotiated Attribute Ownership Divestiture to indicate it wishes to give up ownership.  In the scheme described in  ADDIN ENRfu [6] this service is given a time stamp of T1+L1 where T1 is F1's current logical time, and L1 is F1's lookahead.  In this approach, the connection database is viewed as being distributed among the federates, i.e., each federate LP includes connectivity information.  This service call can be realized by sending a (TSO) message to each federate that might receive ownership of the attribute.  When this message is processed, it results in a Request Attribute Ownership Assumption callback in each federate receiving the message.  F2, the federate that will become the new owner, now invokes the Attribute Ownership Acquisition If Available service, resulting in a TSO message being sent with time stamp T1+L1+L2 to F1.  When this event is processed, F1 is notified that another federate has agreed to resume ownership by a Attribute Ownership Divestiture Notification callback, and the connection information with F1 is update to indicate that it is no longer the owner of the attribute.  Finally, an event with time stamp T1+2L1+L2 is sent to F2 to indicate that F2 can now take over ownership.  When processed, F2's connectivity information is updated to indicate that it is the new owner.  F2 can now generate an update to the attribute with time stamp T1+2L1+2L2.  It is apparent from this description that this approach closely follows a conservative, non-zero lookahead style of execution.The conservative, non-zero lookahead approach has the advantage that it allows greater concurrency, and thus better performance than the zero lookahead approach.  It is also relatively straightforward to implement.  The drawback is that it imposes lookahead constraints on the modeler.  In practice, this can greatly increase the complexity of the model to adhere to these lookahead constraints.  One can, of course, set the lookahead to be a very small value, or perhaps even zero, however, this of course results in the same problems as the conservative zero lookahead approach described earlier.Optimistic SynchronizationThe third approach to synchronizing services is to use optimistic processing techniques.  Here, this means that an error detection and recovery procedure is used rather than strictly avoiding errors, as was done in the previously described approaches.For example, returning to the subscription example, suppose we immediate process the RUE event as soon as it is received by the connection database LP, i.e., we do not force the connection LP to process events in time stamp order.  Instead, we send the update messages based on the state of the database when the RUE event is received.  However, we keep a log that indicates a RUE event was processed within the connection LP.  When a subscription event with time stamp 99 later appears, we observe that the federate issuing the subscription should have receive a copy of the time stamp 100 message, so we retrieve this message from the log and send it to the federate making the subscription.  This is, in essence, the idea used to achieve proper synchronization of DDM services described in  ADDIN ENRfu [8-10].One point worth noting is that this optimistic approach to synchronizing the DDM services exploits the semantics of the DDM services.  This enables one to avoid having to use general purpose rollback mechanism, which can lead to additional complexity.Optimistic execution allows concurrent execution of events, and avoids the inconvenience of requiring the federate to always invoke services that affect the connection database ahead of time.  In other words, zero lookahead interactions are allowed.  The main drawback with optimistic methods is the complexity it introduces in the RTI.  In the example that was just described the RTI must maintain message logs, and provide mechanisms to reclaim storage used by the log.SUMMARYThe purpose of this paper is to define a framework to discuss and compare approaches to add time management to HLA services that are currently not time managed.  By mapping the computation to a classical PDES paradigm, we saw that several solution approaches were immediately apparent.The conservative, zero lookahead approach offers a simple implementation, but does not scale and is likely to lead to very poor performance in many federations.  Thus this approach does not appear to be competitive.  The conservative, non-zero lookahead approaches offers better performance, but may lead to difficult to use mechanisms because of lookahead constraints.  Such an approach has been proposed for ownership transfer.  An area of future research is to define a non-zero lookahead approach for data distribution management services.  Finally, optimistic approaches offer the potential for good performance without the onerous lookahead constraints, but lead to increased complexity in the RTI implementation.  For example, message logs may be required.  Optimistic approaches have appeared in the literature for implementing synchronized DDM services, but we are not aware of this approach being applied to ownership transfer.  Another interesting, related question concerns implementing synchronized versions of these services using the current, unsynchronized version, and time managed interactions to ensure proper synchronization.Still another approach not discussed in this paper is to define semantics that are different than the traditional ones assumed in the discrete event simulation literature.  For example, ordering semantics that are weaker than time stamp order, but provide more functionality than the current, unsynchronized approach.  This is an open area of research.It is hoped that by characterizing unsynchronized HLA services into a well-known, PDES-based framework this will illuminate some of the fundamental issues that arise when trying to realized synchronized versions of these services, and the advantages and disadvantages of different techniques.  As we saw, there is no clear winner in terms of the synchronization method, suggesting additional investigation may be warranted.References ADDIN ENBbu 1.	Li, Z., C.M. Macal, and M.R. Nevins, Ownership Transfer for Non-Federate Object and Time Management in Developing an HLA Compliant Logistics Model, in Proceedings of the Spring Simulation Interoperability Workshop. 1998.2.	Valentino, G.J., et al., An Agent Toolkit to Support Distributed Simulations, , P.o.t.S.S.I. Workshop, Editor. 1998.3.	Myjak, M.D., et al., Implementing Object Transfer in the HLA, in Proceedings of the Spring Simulation Interoperability Workshop. 1999.4.	Li, Z., C.M. Macal, and M.R. Nevins, The Problem of Object Ownership Transfer in HLA-Compliant Logistics Simulations, in Proceedigns of the Fall Simulation Interoperability Workshop. 1998.5.	Roberts, D.J., et al., Optimising Exchange of Attribute Ownership in the DMSO RTI, in Proceedings of the Spring Simulation Interoperability Workshop. 1998.6.	Myjak, M.D., et al., Object Transfer in HLA, in Proceedings of the Spring Simulation Interoperability Workshop. 1999.7.	Bagrodia, R. and W.-T. Liao, Maisie: A Language for the Design of Efficient Discrete-Event Simulations. IEEE Transactions on Software Engineering, 1994. 20(4): p. 225-238.8.	Blanchard, T.D. and T. Lake, A Light-Weight RTI Prototype with Optimistic Publication, in Proceedings of the Spring Simulation Interoperability Workshop. 1997.9.	Tacic, I. and R.M. Fujimoto, Synchronized Data Distribution Management in Distributed Simulations, in Proceedings of the Spring Simulation Interoperability Workshop. 1997: Orlando, Florida. p. 303-312.10.	Tacic, I. and R.M. Fujimoto, Synchronized Data Distribution Management in Distributed Simulations, in Proceedings of the Workshop on Parallel and Distributed Simulation. 1998.11.	Fujimoto, R.M., Parallel and Distributed Simulation Systems. 1999: Wiley Interscience. Here, we ignore the question as to whether or not an update with time stamp 99 should be received by the federate. As an aside we note that extra messages can often be tolerated because they can be filtered at the destination.  Thus, these requirements can sometimes be relaxed, somewhat.