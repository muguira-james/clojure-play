A String-Defined Symbol Construction LibraryDouglas HaanpaaCharles J. Cohen, Ph.D.Steve RoweCybernet Systems Corporation727 Airport Blvd.Ann Arbor, MI 48108734-668-2567 HYPERLINK "mailto:dhaanpaa@cybernet.com" dhaanpaa@cybernet.com,  HYPERLINK "mailto:ccohen@cybernet.com" ccohen@cybernet.com,  HYPERLINK "mailto:srowe@cybernet.com" srowe@cybernet.comKeywords:Symbol, Icon, MIL-STD-2525B, GIS, StringABSTRACT:  Cybernet has constructed a method for the runtime construction of map icons based on an object –oriented semantic similar to object definition within the HLA specification.  The method defines a set of fields that define up the input symbol specification (similar to the attributes defining an HLA object).  It further defines a set of graphical component primitives that can be put together to construct icons.  The system finally defines rules that map combinations of fields to the graphical primitives that are invoked at icon construction.  This software library allows developers to define a string-based symbol specification language and then to tie that to graphical components like text strings and images.  The first major application of this technology was to construct a string syntax, text and image library that follows the MIL-STD-2525B symbology standard, including the string representation.  We have integrated the 2525B symbols into a networked tactical viewer application that is focused on blue force tracking.IntroductionThe Tactical Terrain Viewer (TTV) is an application developed at Cybernet to increase situation awareness of the battlespace.  This application shows 3D moving map that displays elevation, image overlay and vector information.  One of the more recent developments on this project was the addition of a symbol construction and display subsystem.  The symbol set targeted was the MIL-STD-2525B standard, however the system was designed to generate arbitrary symbol sets. The Tactical View Symbol Library (TVSL) constructs symbols/icons based on a string specification language that. Being string based, this representation facilitates unambiguous network transport.  The definition method is composed of three parts/files.  The first of these defines a set of fields that make up the input language.  The second component defines a set of primitives that specifies the library of all graphical and textual components.  The third and final component/file define the rules that invoke the primitives based on the fields in the input language.System GoalsThe main objective of the library was to provide a framework for defining icon languages.  As we set out to design the system, our goals were to:Create a data-driven system whose behavior can be altered simply by changing a text file,Separate the string specification from the generation of graphical content,Support the OpenGL graphics language,Initially support the MIL-STD-2525B standard,Allow icons to have dynamic content and, andSupport callback functionality.These goals became the core of our system requirements, and each drove the development of a corresponding subsystem in the software architecture.System ArchitectureBased on our system goals, we created an architecture that partitioned the required functionality into the following components: (see Figure 1).TVSL ComponentsThe TVSL system is comprised of two interoperating components:  the Icon Factory Library and the Symbol Library.  The Symbol Library is responsible for the parsing of the input definition files that specify a particular symbol language.  The Icon Factory Library is responsible for taking information produced by the Symbol Library and constructing an icon that can be used in the application.  Put simply, the resulting implementation allows the application to create an icon as follows:Application invokes the Symbol Library to create a symbol object by providing an input stringThe application invokes the Icon Factory Library by passing it the symbol created in 1, whereupon the Icon Factory constructs an icon and passes it back to the application.The application can then access the icon to move it around on the screen and change its dynamic values. The two components are described more thoroughly in the following sections.Symbol LibraryThe Symbol Library component contains the software for generating symbol objects from strings.  As mentioned in the previous section the symbol library is data driven and reads three files that specify a particular symbol language.  The first of these files is the Field file.  This file is always named “field.ini” describes a table of fields that make up the input language.  The field table specifies the name of the field, the length of the field in bytes, and a description.Table  SEQ Table \* ARABIC 1: Field TableAe6 "symbol ID - function"Af2 "symbol ID - modifier (AC, R)"Ag2 "symbol ID - country"Ah1 "symbol ID - order"C 9 "quantity"In plain English, the second line of the field table shown in  REF _Ref109457128 \h Table 1 reads: The name ‘Af’ is given to the 7th through the 8th bytes of the input string.When concatenated in the order specified in the field table, the fields together form the symbol string.  The field table shown in  REF _Ref109457128 \h Table 1 describes a string that has 5 components and an aggregate length of 20 bytes (6+2+2+1+9).  This table is read by the system on startup and is stored. Internally.The next file that is parsed is the “primitives.ini” file.  This file contains information about the components that specify graphical entities that are combined together to form symbols.  Each line of the primitive file specifies one primitive.  The format for a primitive line depends on the type, which is the first parameter of the line.  The following is a description of the different types followed by the format for that type:Frame – a texture (Bitmap or Targa file) that is added to the symbol at a certain position and with a specified scale factor.Frame <name> = “<texturename>.tga> + (<x position>, <y position>) + (<x scale >, <y scale>)Modifier and Icon – These two types are identical to Frame.  They were created in order to conceptually separate the primary icon image from surrounding frame and tertiary decoration images.Dtext – a text entity that is added to the symbol at a specified position and scale.  This text is dynamic in that the application can change its value.DText <name> = (<x position>, <y position>) + <font size>Stext – a text entity that is added to the symbol at a specified position and scale.  The format of a SText line is identical to the format for DText.  However, unlike DText, this text is static.The idea behind this layout is that the system will invoke these primitives, thereby constructing complex symbols from these primitive elements.Finally, there must be a connection between the primitives and the fields.  Ths “specs.ini” provides the definitions that link the two.,  This file defines the rules that invoke the primitives based on the fields in the input language.  The specs.ini file contains a number of text lines that describe a rule for invoking primitives based on fields in the symbol’s string.  The format of one of those lines is as follows:<fieldname1> = <string1>, <fieldname2> = <string2>, … : <primitive name>The line begins with a list of field-value pairs.  Each fieldname is a lookup into the field file/table and the string is the required value for that field.  Consider the following example spec:Ae = --abcd , Ah = e: Pending_Space In plain English, this example reads as follows:If the symbol substring described by Ab ends in ‘abcd’ AND the symbol substring described by Ac is the letter ‘e’, then invoke the primitive called “Pending_Space”.  (Note: The dash symbol is a wildcard which matches all characters)This symbol methodology allows us to define a string that is of arbitrary length and whose insides map directly to the construction of graphical entities.In order to actually create a symbol instance, the application simply calls the CreateSymbol function and passes in a string that specifies the symbol.  Alternatively, the symbol library provides a mechanism for building the string based on specifying the fields individually.  The CreateSymbol function will return the requested symbol, which can then be used to construct icons.Icon Factory LibraryAs mentioned in the introduction, one of the key design requirements was to separate the symbol library from the icon generation library.  While these two modules interoperate, they have abstract interfaces that allow one or the other to be swapped out.  I.e., the symbol library can be changed in order to create new symbols and new symbol languages, while the icon factory can be switched out to generate icons for different rendering environments.The Icon Factory Library essentially constructs an icon based on a symbol.  The process of icon construction proceeds as follows:  The Application calls the function CreateIcon with a symbol instance as the main argument.Within the Icon library, functions within the symbol (defined in the Symbol Library) are accessed in order to retrieve the list of primitives (with position and size specification) that are specified by the symbol string.The Icon Factory Library creates graphical entities that are grouped together into an instance of an Icon, which is passed back to the application.The application gets this Icon instance back from the CreateIcon function.  The application can then move the icon, alter it, or delete it.Facilitating Network TransportThis symbol construction system is designed to facilitate the network transport of symbol data.  One application can construct a symbol and icon from a string and then send that string to another application, which can build the same Icon.   At Cybernet, we have demonstrated a system that uses our network abstraction layer based on the HLA (High Level Architecture) specification for all network communication.  Because the Symbols can always be collapsed into a serialized object, we can send that object across the network in a protocol agnostic way.  Upon receipt, the object is de-serialized into a symbol, whereupon the Icon construction process is invoked.  Interestingly, on of the aspects of the symbol/icon definition is that, at least for the application we had originally targeted (tactical military visualization), each icon represents some entity or group of entities that may exist only temporarily.  This implies that we needed a network mechanism that could facilitate the discovery, state change, and destruction of these entities.   Our previous work in creating an HLA implementation called OpenSkies proved to be a perfect fit.  Not only did the HLA standard provide a means to publish, subscribe, discover and remove these icon entities, its object structure allowed us to represent the symbol fields as attributes.  While the structure of HLA is similar to the modularity of the Symbol library, the focus of HLA has historically been towards modeling and simulation.   This is why, in the future, we plan to leverage the system into existing network standards for tactical data transport sush as the Joint Variable Message Format (JVMF). ImplementationThe factors guiding our implementation choices were maximize the efficiency while minimizing cost, and developing technology that would be generally applicable beyond this project.  In this section, we give the highlights of our implementation choices.Implementation languageThe system was developed in C++.  The main reason for implementing the library in C++ was due to the fact that many M&S products, including Cybernet’s, are written in C++.  It exhibits a decent runtime performance, while still allowing a certain degree of cross-platform capability.  Testbed/DemonstrationThe TVSL was leveraged into our Tactical Terrain Viewer software.  This software is a development library and application for displaying geographic and geo-tactical information related information on a range of hardware platforms such as desktops, handheld computers, or PDAs. The purpose of the TTV software is to present geo-related information in a manner that optimizes the perception of three-dimensional topography populated with tactical symbology while looking at a small computer screen.  The TTV utilizes a custom OpenGL GUI toolkit that we developed in-house.  It allows the application to display hierarchical panels, check boxes, slider bars, buttons, and more.  This capability, called GOOEY, was used within the Icon Factory sub-library, to actually generate and manage the icons as OpenGL graphics objects.  Not only does this allow us to place these icons into the 3D environment as small billboards, it also facilitates callbacks into the application when the user clicks on an icon. Strengths of Our ApproachOur approach to designing the system was to be as general as possible.  This generality we believe will yield great flexibility.  Because very little arbitrary structure is imposed on the symbol data model, the system can represent a wide variety of symbols.  The modular nature of both the data model and the library structure (i.e. Symbol vs. Icon) allows arbitrarily complex synbologies to be built and combined with different rendering systems..The icons created by this process are therefore entirely customizable.  Although the symbol/icon system only provides basic GUI components (text and images), it can be easily extended to provide custom display components.  The key strength to our approach is that a simple data model drives the entire construction process.  The symbol/icon author can therefore make the symbol set as simple or as detailed as desired.  Adding more primitives, or more complex field combination possibilities, allows us to support complex symbol sets like MIL-STD-2525B.Weaknesses of Our ApproachThe very simplicity that gives our system its flexibility also causes its main weaknesses.  Because the system was designed in such a general way, it provides very little structure “out of the box.”  We provide tools to create the symbol strings, primitives, and specification rules, but it is the author who must do the hard work of actually creating the symbol construction behavior. This means creating the graphical content for the primitives (i.e. the images and the text) and then writing primitives to position all of these entities correctly within the final icon.   In any graphical content generation process, a certain amount of ground level authoring is necessary, but our system would benefit by including more advanced graphical icon construction tools that allow the user to import graphics and then use click-and-drag methods to position everything correctly.Secondly, the file format for fields, primitives, and specification is prone to error.  Exact spacing and comma placement must be observed to avoid problems.  A next generation toolkit will save these out as XML or similar format.Future PlansAlthough we have no immediate plans for the Tactical Viewer application itself, we do have applications for the graphical infrastructure and tools that we have developed for it, one of these being the TVSL.  Our immediate goals will be to correct the shortcomings that we have already identified in the system.ConclusionWe have presented an overview of a Tactical View Symbol Library (TVSL), which constructs symbols/icons based on a string specification language. This capability was recently leveraged into our a 3D moving map software.  Thereby integrating the generated icons into visualization software that displays elevation, image overlay and vector information.  Originally targeting the MIL-STD-2525B standard, the system was designed to generate arbitrary symbols and icon sets.Author BiographiesCHARLES COHEN has been working in the fields of image processing, robotics, human-computer interaction, and artificial intelligence for over a decade.  He is currently the Vice President of Research and Development for Cybernet Systems Corporation.  He has been the project manager for many projects for the United States Armed Forces (Air Force, Navy, and Army), National Aeronautics and Space Administration, and other government agencies.  Dr. Cohen’s current research interests are in gesture recognition, image processing, estimation theory, system integration, visual communications, machine vision, and perceptually coupled systems.DOUGLAS HAANPAA is currently the technical team manager for Cybernet’s Virtual Reality group.  He is responsible for the management of OpenSkies.  He contributed much of the design of this product as well as implementation of flight dynamics, collision, and force-feedback algorithms.  He also acted as a key designer for many of the OpenSkies subsystems including the terrain parsing/rendering/LOD system, scenegraph, weather model, and parallel thread/timer system.STEVE ROWE is a senior software engineer at Cybernet Systems Corporation.  Besides being well versed in simulation environment, intelligent agents, and scenario development work, he has taught in the classroom and also worked in the development of automated teaching materials at KnowledgeNet Corporation.Figure  SEQ Figure \* ARABIC 2: MIL-STD-2525B Symbols in the Tactical Terrain Viewer EMBED Word.Picture.8  Figure  SEQ Figure \* ARABIC 1: TVSL Subsystem Relationships