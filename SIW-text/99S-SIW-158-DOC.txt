JavelinMichael D. MyjakSean T. SharpThe Virtual Workshop & HLA ProductsP. O. Box 98Titusville, FL  32781< HYPERLINK mailto:mmyjak@imtinc.com  HYPERLINK mailto:Ssharp@imtinc.com mmyjak@virtualworkshop.com>< HYPERLINK mailto:Ssharp@imtinc.com ssharp@virtualworkshop.com>Keith Briggs,HLA Products, Inc P.O. Box 4380 Mountain View, CA  94040<keith@imtinc.com>KeywordsHLA, Real-Time, Java, RTI, M&S, SimulationAbstract: The JAva Virtual Environment Layered INfrastructure (Javelin) is a real-time support environment designed to meet the needs of the distributed interactive simulation community on a wide variety of computing platforms. Javelin supports streaming protocols, real-time communications and embedded network management for embedded systems and web-based applications. Javelin is a requirements driven product, which places real-time performance and platform independence as its core requirement. Javelin is a Java-native application that embraces the OSI initiative and developing standards in the Internet Engineering Task Force (IETF) with Web3D community requirements. This paper presents our first analysis of the infrastructure and Javelin hierarchical design, a status report on our evolving communications path, and some of the advantages gained by using this open architecture.IntroductionPreviously, we detailed our approach to resolving many of the community-perceived system level requirements that a High Level Architecture (HLA) needed to address. We discussed some of the architectural tradeoffs required to satisfy those user community’s goals, and focused on [Myjak, 98] creating an HLA Run Time Infrastructure (RTI) that can operate at scale in a heterogeneous environment.  The Javelin implementation satisfies many of those concerns. We also discussed some of the problems associated with existing implementations of the HLA RTI and their (lack of) support for backward compatibility and interoperability. It is our belief that interoperability cannot be obtained with a closed implementational approach. Architectures and frameworks necessary to support a HLA RTI in a heterogeneous environment cannot be developed in isolation.  These systems need to be brought out into the public’s eye, where they can be peer reviewed.  Our solution to this dilemma was the Java Real-Time RTI product.  The goal of broad platform and network independence is satisfied by the run-time support of the Java Virtual Machine (JVM).  In addition to operation in a heterogeneous environment, we also set three target goals. These were to provide maximum throughput and minimal latency, as well as support for streaming data types and embedded management.  Today the Java Real-Time RTI is no longer just a concept, but a reality.  Performance measurements indicate that this implementation will not only suffice as an answer to HLA’s systemic requirements over heterogeneous networks, but it is also quite capable of supporting real-time federations at the scale of 105 objects. Further, the Javelin framework is not hindered by HLA’s technical narrowness of scope. Javelin implements HLA objects and attributes just like Object-Oriented Programming (OOP) objects (at least in the conventional sense).  For example, the current draft specification [IEEE 1516.1] does not support the advertisement or transference of an object instance’s private state data or behavioral information.  However, Javelin does.  In HLA, unlike classical OOP practice, an object’s public attributes can be transferred from one host to another but without time-managed synchronization.  In the Java Real-Time RTI, the Javelin framework is used to extend this practice from public attributes, to private attributes and behaviors, provided that the latter are serializable. [Myjak, 99] Other fundamental constructs and supporting components were also missing from HLA, such as: performance criteria and scalability; embedded hierarchical infrastructure support; streaming data types; heterogeneity; embedded, distributed network-based management; and standardized file I/O based on Universal Resource Locators (URLs).  When taken together, we found the High Level Architecture to be immature.  HLA in and of itself is insufficient (in its current description and evolution) to support our own requirements: Bringing 3D Virtual Reality to the Web.The remainder of this paper describes the Javelin Infrastructure and component framework.  The next section describes our motivation for building Javelin and the Java Real-Time RTI. A detailed analysis of selected internal components and their implementation is also presented.Web-Based Modeling & SimulationJavelin was designed to bring modeling and simulation to the World Wide Web.  It was designed from the ground up to adequately perform for the live and virtual simulation user, to permit delivery on embedded platforms, and to be 100% compatible with current web-based architectures. For the M&S community, the most important feature of Javelin is its Java Real-Time RTI.  Its architectural design was focused on minimizing the protocol, process, and resource utilization overhead while also improving throughput over shareware versions of the “C” based RTI. Protocol overhead associated with each datagram transmitted over the wire is kept to an absolute minimum. Initial tests indicate that Javelin overhead is about 1/10th of that of the current DMSO RTI v1.3, when compared to that reported in [Wuerfel, 98].  The top of Figure 1 shows the basic format of an Attribute Value update.  In addition to the basic UDP header, each transaction contains a minimum static overhead of only 13 bytes per attribute update, with an additional dynamic overhead of 4 bytes for each length field of each attribute value, plus an additional AttrMap byte for each additional 8 attributes. We recognize that low communication overhead is one desirable feature for both live and virtual simulations and that constructive simulations won’t be hurt by it either. And as mentioned before, the specifications for HLA are still evolving.  One interesting and recent change are developments occurring within the Object Model Template (OMT) specification [IEEE 1516.2].  In this specification, the format of the FED file is being changed to use the eXtensible Markup Language (XML).  In addition, the data length and data type of the various Object Attributes is specified.  In preparation for this advancement, we have undertaken the challenge and implemented our FED file parser to support the new XML format.  In addition, we are currently planning some changes that we believe would further reduce the communication overhead requirements of the most common update types: attributes and interactions.We know that certain (perhaps many) federate class attributes and interactions have a fixed data length.  Since FED table data is stored as part of the RTI’s internal state, we intend to remove the length field from the fixed length attribute and interaction updates. This further reduces the dynamic communications overhead by 4 bytes for each fixed length update.  Only variable length updates will be sent with length information embedded in the message.  When the message is received, a list of the attributes contained in the message would be extracted from the AttrMap cell.  This reduction in communication overhead is not with out some cost, however, as in order to remove the attribute length field, one additional lookup is now required for each attribute or interaction.  (A preferred trade-off towards further reducing communications overhead.)  A return value of zero (or some negative number) would indicate a variable length attribute.  In short, the FED file length data would then be used to parse the remaining part of the message.  This approach will further reduce the dynamic overhead of our message as shown in the bottom of Figure 1.  Additionally, the total length field will no longer be required.In addition to the basic UDP header, each transaction now contains a minimum static overhead of only 9 bytes for each single attribute update message. In compound messages (i.e., datagrams containing multiple attribute updates for a given object) the dynamic overhead is further reduced such that only 4 bytes area now required for each variable length attribute.  The additional AttrMap byte for each additional 8 attributes is still required. Note that the header for time managed messages will be slightly longer to support the transmission of a federation time and optional retraction handle. All environments benefit from fast, efficient systems and protocols.  Whether executed as an applet or an application, Javelin and the Java Real-Time RTI can be integrated both with network aware browser technology, or placed on embedded delivery systems.  The entire range of host applications can be bridged, from low-level real-time delivery vehicles, to real-time operating systems (such as VxWorks or real-time Linux kernels), to standard desktop PCs running Windows NT.  This is the benefit of Java’s “compile one, run anywhere” philosophy.By adapting only pure Java, Javelin does not have to depend on a selection between which “C” class libraries are supported for a given platform, or which libraries should be used in a given circumstance. Operating system specific implementations are also done away with.  Instead of header file management, we end up with a single, transportable environment that runs on a variety of platforms.  Furthermore, we fully intend to offer source code licenses for Javelin, so individual implementers can feel free to extend the architecture or customize it in any way that suits them. Javelin was designed from the ground up to adequately perform in any environment, and it is 100% compatible with current web-based technologies.  Our delivery vehicle will be the World Wide Web.  Clients using Javelin will be able to acquire the latest copy from our source library, whether they require only a piece of the infrastructure, or all of it.  In short, Javelin is being built to support seamless operation with the web.Javelin InfrastructureJavelin is a framework that contains the Java Real-Time RTI, the Virtual Reality Transfer Protocol (VRTP) and the Real-Time Protocol (RTP), all in a native Java v1.2 implementation.  By basing the Javelin infrastructure on Java v1.2, we can achieve the widest possible heterogeneous support, from the desk-top to embedded delivery environments. [Briggs, 99a] Javelin has been developed from scratch, in Java, as a native Java application.  By adhering to pure Java, we overcome interoperability issues caused by any vendor’s desire for extensions to the Java language. Further, limitations associated with interoperability over heterogeneous environments, as previously documented in the media and presented during the biannual Simulation Interoperability Workshops, are also rendered moot.The hierarchical design of the Javelin framework is based entirely on standard Internet Protocol support (Figure 2).  This approach provides heterogeneous end-to-end communication interoperability, a necessary and sufficient requirement of any RTI. On top of IP transport services, Javelin incorporates the RTP protocol suite [RFC-1889] to manage multiple, simultaneous, real-time stream interfaces between joined federates.  On top of RTP sits the Virtual Reality Transfer Protocol.  VRTP is used to manage the various RTP streams and link them with higher level applications, or application layer protocols. Evolving VRTP was necessary in order to support the breath and depth of communication requirements for distributed, shared virtual environments beyond HLA [IEEE 1516.1]. The VRTP framework is also necessary to support the differential service requirements of a broad range of distributed applications and not just simulations that use DIS or HLA. The components used to construct Javelin, (i.e., RTP, VRTP and the Java Real-Time RTI) are described below.RTPThe Real-Time Transport Protocol provides the foundational support for the Javelin framework. Since RFC-1889 was first published in 1996, no less than 11 additional RFCs have been produced.  Further, there are over 25 current Internet Drafts, each based upon the RTP Proposed Standard.  In IETF nomenclature, a Proposed Standard describes a complete, credible specification that has already demonstrated it’s utility.  This is a significant achievement. It indicates that the level of work has achieved a status well above that of work in progress, granted to Internet Drafts.  Note that Proposed Standards have a limited lifetime.  They exist for no less than 6 months before being elevated, but no more than two years, before being elevated, deprecated or recycled.During the next year, we will continue to see changes and recommendations to RFC-1889, both proposed and implemented, as RTP elevates to the level of Draft Standard. An IETF RFC granted Draft Standard status means that multiple, independent, interoperable implementations exist and have been demonstrated.  While operational experience at this stage may still be somewhat limited with respect to the scale of the Internet, existing implementations have demonstrated that the specified protocol works, that it works well, and that experimentation and use is now to be encouraged. [Rosenberg, 98] even recommends that RTP be elevated to and made equivalent with the UDP and TCP transport protocols. This would result in all RTP packets being explicitly labeled as such in the packet header, vastly simplifying the problems of classifying real time streams. Such classification measures could make deployment of RTP header compression, differentiated services, and traffic isolation easier and more efficient.  RTP is, therefore, the right choice to support Javelin, VRTP and the Java Real-Time RTI.The RTP definition also incorporates the Real Time Control Protocol (RTCP).  RTCP is the basis for providing Javelin feedback with streaming protocols.  Further, additional metering is obtained for real-time communications using embedded network management via the Simple Network Management Protocol (SNMP). RTCP provides low level monitoring of the data delivery in a manner that is scalable to large multicast networks, and provides minimal control and identification functionality. SNMP and user defined Management Information Base (MIB) variables are used to meter the distributed Javelin application.  Under the Java Real-Time RTI, SNMP MIBs are used to create the Management Object Model (MOM) interactions required by IEEE 1516.1. Javelin uses these features for supporting both embedded systems and web-based applications that are “network aware.”  VRTPThe Virtual Reality Transfer Protocol (VRTP) is needed to create the necessary underlying network service support to permit building large-scale, shared and immersive virtual environments (i.e., “worlds”) on the World Wide Web.  VRTP design grew from the recognized need to extend and expand upon the capabilities first identified in the Hypertext Transfer Protocol (HTTP).  In the way that HTTP was designed to support interlinked Hyper Text Mark-up Language (HTML) pages, VRTP was envisioned to support distributed, shared and immersive 2, 3, & 4 dimensional virtual environments at large-scales.  Initially driven by the development of the Virtual Reality Markup Language (VRML), VRTP designers now recognize the need to support many different scene generation mechanisms, all of which require similar underlying support network. To HTTP’s point-to-point client-server approach, VRTP adds additional capabilities for many-to-many peer-to-peer communications with embedded, active network management.Java Real-Time RTIDelivery and support for the Java Real-Time RTI will occur over the Internet, and will support a wide variety of platforms. The implementation currently supports JVMs supporting Java v1.2 and Java v1.1.7 on Linux and Windows NT, SGI and Solaris, with many others to follow very shortly.  Since our focus has been to support the real-time community, our implementation will be compatible with real-time operating systems (through Real-Time Java support) and on embedded environments.  We will demonstrate this prototype at the Spring 1999 SIW.Rather than take the approach of a distributed operating system, we chose to implement the Java Real-Time RTI as a distributed Application Layer Protocol [Myjak, 97].  Therefore, the Java Real-Time RTI internal design is vastly different than, and in many respects superior to, previous DMSO versions.  Departure from available shareware includes: distributed RTI state; fault tolerance; distributed RTI service managers; embedded management; and dynamic flow control of multiple differentiated service streams.Distributed RTI StateTo create a high throughput low-latency Federate/RTI interface, we created a distributed RTI that shares internal state across all local RTI instances joined and directly connected in a federation.  This in turn permitted a huge reduction in overall run-time network traffic.  The Federation Management Service handles this process of state information management, most of which is accomplished prior to the start of the federation scenario.Within a federation, one local RTI instance will be designated as the owner of the Federate Manager service.  Thus only the local RTI instance owning the FedManager token is privileged to update the RTIs internal state database. Associated with each table update, is a table serial number, which is always monotonically increasing.  Using a proprietary reliable multicast transport mechanism, all updates to the RTI’s internal state tables are propagated over the network to each directly connected local RTI instance.  A single dedicated RTP stream is used for this purpose, and is given priority over other RTI supported streams, with the exception of the object stream which is used to update Federate object classes and instance attributes. Consequently, most federate/RTI operations can then proceed using locally stored information.  Local RTI instances need no longer consume network bandwidth and accrue additional latency to query a Federation Executive. This provides for superior performance and reduced latency with regards to federate attribute and interaction updates.  In addition, network overhead is reduced, bandwidth is conserved, and overall throughput is improved.Fault ToleranceAlong with reliable transfers comes the desire for fault tolerance.  As mentioned previously, each table update is associated with a serial number. The serial number is used to maintain state and ensure data integrity within the Java Real-Time RTI. Under normal RTI processing, the serial number received in the update is checked against that contained in the RTIs local state table.  Should, in the unlikely event that an update to a particular table become lost or garbled, the serial number associated with that table will recognized as out of date (i.e., will not have been incremented). Thus when an update (either attribute or interaction) occurs which contains an updated serial number, the local RTI instance can recover its lost or out of date state information.  When such an event occurs, the local RTI will momentarily suspend processing of that update, request an update of the current table from the RTI instance holding the FedManager token, process the update to its tables, and then resume processing of the suspended request. It is important to note that table updates require relatively low bandwidth and occur infrequently.  In fact, a similar mechanism is used over the Internet to manage the Domain Name Service.  Therefore, by extrapolation, we know that this mechanism scales quite nicely in both flat and hierarchical RTI topologies.In the future, we will enhance this system further.  Based on our experience within the community, it’s not inconceivable for any given federate’s host to become overburdened, producing lethargic responses, or to crash entirely.  Different affects to the federation can occur, depending upon the responsibilities of the federate or the federate’s local RTI instance.  For example, if the local RTI instance’s response became sluggish, it would at a minimum, alter the performance of the federation.  However, if that happened to be the host holding the FedManager token, the potential loss of the federation would be at hand.  However, we envision a protocol that could be devised to handle the loss of such a component. Though not trivial to implement, the algorithm will allow the remaining RTI instances to barter for the token, then unconditionally divest the attributes associated the deceased federate’s process. This is possible because RTI state information is fully distributed.Distributed RTI ServicesEach service specified in the Federate Interface Specification and implemented within the Java Real-Time RTI can be distributed across any component federate in a directly connected federation.  Since internal RTI state information is distributed reliably and maintained locally, the process of transferring control of any RTI service can be accomplished using a simple time managed token transfer between any two RTI instances. The resultant effect is the transfer of control of the selected service manager between locally connected RTI instances. Initial testing indicates performance to be relatively fast and efficient (e.g., on the order of a few milliseconds) from transfer initiation to completion.However, the current Federate Interface Specification does not specify an RTI service that can load-balance or otherwise dynamically manage resources within the federation.  We believe that this process is essential if RTIs are to scale to support thousands or tens of thousands of objects. The current implementation also provides Federation Execution Data (FED) file variables to direct the initial joined federate in which to initiate a given RTI service.  Therefore, in keeping with the IEEE 1516 draft standard specification, the Java Real-Time RTI only accommodates this transfer operation under manual control and at federation startup. Future releases will however, support this process dynamically.There is little reason to believe that a new service (such as RTI Service Transference) just like object or attribute transference cannot occur dynamically throughout the federation and support real-time performance requirements.  In future implementations, we will extend this capability by creating an additional service extension within the Java Real-Time RTI that manages both process and resource utilization.  This new service will effectively load balance the various services dynamically across the available RTI and federate resources within the federation.  When coupling this resource management service with our active network management, dynamic load balancing of federation objects and attributes will be possible.Active Embedded Network ManagementActive, embedded network management provides Javelin (and its higher level supported applications) with a unique capability: dynamic resource control to optimize performance.  This is a central issue in the design of VRTP. In its elementary form, it permits Javelin to simply throttle each RTP stream based on the current state of the operational environment (i.e., RTI, communication fabric, federate resources, etc.).  In the future, we envision active networking involving the replacement of packets with capsules -- program fragments that are executed at each network router/switch they traverse, [Tennenhouse, 96] ultimately generating a homogeneous Computing Fabric. [Von Schweber, 98] (Just imagine time-sharing CPU cycles from your dish washer, toaster, etc. when surfing the web or playing a VR game in a shared, virtual environment.) The reality of a Computing Fabric however, will likely have to wait until the Next Generation Internet becomes a commodity network.In the mean tme, Javelin uses two different active networking techniques: embedded simple network agents and the Real-Time Control Protocol (RTCP).  These two techniques differ only in that RTCP is receiver initiated.  SNMP employs a periodic polling technique and thus is either initiated by the sender or some third-party management process.  Both of these techniques yield direct, real-time receiver-based feedback.  Further, SNMP agents are not new. They have been around for nearly a decade.  However, the technique of coupling user-defined MIB data; with extensible, dynamic, and potentially distributed cooperative or “sensible agent” technology [Barber, 98] to measure and meter a distributed application is new.Frameworks such as VRTP that employ active networking permit a massive increase in both the sophistication and computation performed within the network. Javelin uses active networking concepts to enable new applications, especially those based on application-specific multicast services, to leverage network-based computation and storage. Furthermore, we believe that active network architectures will continue to evolve.  They are likely to accelerate the pace of innovation by further decoupling network services from the underlying hardware and thus allowing new services to be loaded into the infrastructure dynamically, on demand. differentiated service streamsAs a middleware product, VRTP employs active network management techniques to inject customizable control into its communication streams.  Taken to its ultimate conclusion, active networking can affect the intervening nodes (of the network) over which the individual streams are sent. Javelin takes a step in this direction by incorporating the classification of differentiated service streams.Differentiated services are a new class of communication support services, the definition of which is still evolving within the Internet Engineering community. The current view is that Differential Services will support various types of applications by providing different Quality Of Service (QoS) control flows for individual streams as they traverse the fabric of the network.  Current implementations employ a small, well-defined set of building blocks from which a variety of services may be built. A small bit-pattern in each IP packet header is used to mark the datagram so that  it will receive a particular kind of forwarding treatment (e.g., a per-hop behavior) at each network node. For example, this may translate into a combination of three or four priority bits, and an equal number of delay bits.  The underlying network then determines communication behavior, and ultimately the QoS of the specified stream.  Note that a common understanding about the use and interpretation of this bit-pattern is required for inter-domain use, multi-vendor interoperability, and consistent reasoning about expected service behaviors in a network.  Consequently, this work is still evolving.In Javelin, each stream’s requirements are determined by transport type when instantiated.  In the Java Real-Time RTI, FED data is used to effectively differentiate the support required by each service level stream.  Stream support may be modified using either of the two active networking techniques described above. Control is pursuant to the ability to manage partial closed-loop feed back mechanisms between senders and receivers. The result is that a wide variety of different service classes are available to support the requirements of multiple streams (e.g., high or low bandwidth, throughput regulation, congestion control, reliability and resilience, latency, security etc.). This results in dynamic flow control across the federation.Status ReportThe Javelin framework is real.  Our implementation and work with ownership transfer [Myjak, 99] demonstrates that our ideals and goals can and have been met.  Low overhead communications are possible with HLA using a Java-based infrastructure with the appropriate underlying design.  High throughout can be maintained, even on a Virtual Machine, using desktop hardware.  However, some components are still missing from the HLA.  One in particular is the ability to hierarchically scale to support multiple “component federates” and “component federations.”Component federations, or the inclusion of an entire federation as a component of another higher-level federation, is something we are currently designing toward. We recognize that for HLA to truly scale and support all types of models and simulations, federations of federations must be incorporated into the basic HLA framework.We believe that this can best be accomplished using an RTI Broker-based architecture, such as the one pictured in Figure 3 above.  Brokers are preferred over Federate Bridges because Brokers are not limited to the information contained within the Federate Interface Specification.  Further, we are convinced that certain RTI-to-RTI transactions (e.g., time management, ownership management, etc.) require some internal RTI state information that is not readily accessible from the federate interface’s perspective.In the example pictured in Figure 3, a single Federation supporting a single FedManager token is shown. Each local network segment contains a local NetManager token.  This two-level architecture could easily be extended to support multiple Federations (where each federation supports a different FOM).  The important point shown here is that each network segment being integrated into the mix is using a variety of off-the-shell protocols.  In other words, RTI interoperability is possible over a heterogeneous environment because a clear, 1:1 mapping can be made between local network-based RTI.  The RTI Broker, in this case indicated by the small cubes, is used to broker only the essential state information needed from one networked Federation into another.  In this instance, each federation is assumed to be using the same FOM.  However, this need not be the case.  Just as we can broker internal RTI state information across the wide area network, we can also broker FOM data, where different Federations are concerned.  The second issue we are researching is the development of a dynamic FOM.  With Java, we gain the ability to read in and interpret only the FOM data that is appropriate for the task at hand (building on the BOM/HOM/FOM approach first presented in [Gustavson, 98]).  It is our position that federate interactions can be further enhanced by the dynamic manipulation of FOM data.  Whether the components are managed on a basic level (i.e., Basic Object Model) or whether they are static through out the course of the federation has little affect on the course of the Federation Scenario if the infrastructure can manage the change rapidly enough.  If a federation execution can manage FOM Data dynamically, then the implication is that only the internal data necessary at the time of use is required to pre-load the RTI internal state tables.  A hierarchy of federations, in a dynamic environment; imagine the implications.Bibliography[Barber, 98]	Barber, K. Suzanne, Liu, Tse Hsin, Goel, Anuj and Ramaswamy, Srinivasan, “A Flexible Reasoning Mechanism for the Trade-off of System Versus local goals in Sensible Agents,” http://www.lips.utexas.edu/ and accepted to CAICIM's Rensselaer's International Conference on Agile, Intelligent, and Computer-Integrated Manufacturing, New York, NY, 1998.[Briggs, 98]	Briggs, Keith, “A Required RTI Gateway As A Solution To RTI Interoperability,” Proceedings of the 3rd Simulation Interoperability Standards Organization (SISO) Simulation Interoperability Workshop, 97s-SIW-188, Orlando Florida, March 1998.[Briggs, 99a]	Briggs, Keith, and Michael D. Myjak, “Embedded Javelin,” Proceedings of the 5th Simulation Interoperability Standards Organization (SISO) Simulation Interoperability Workshop, 99s-SIW-155, Orlando Florida, March, 1999 [Comer, 91]	Comer, D.  E., “Internetworking with TCP/IP,” Prentice Hall, Englewood Cliffs, New Jersey, 1991. [Gustavson, 98]	Gustavson, Paul L., Hancock, John P. and Mark McAuliffe, “Base Object Models (BOMs): Reusable Component Objects for Federation Development,” Proceedings of the 4th Simulation Interoperability Standards Organization (SISO) Simulation Interoperability Workshop, 98f-SIW-034, Orlando Florida, October, 1998[Henshall, 88]	Henshall, J., and Shaw, W., “ISO Explained: End-to-End Computer Communications Standards,” John Wiley & Sons, New York 1988.[IEEE 1278.1]	“Standard for Distributed Interactive Simulation - Application Protocols,” Copyright SYMBOL 211 \f "Symbol" 1995 by the Institute of Electrical and Electronics Engineers, Inc. 345 East 47th Street New York, NY 10017, USA[IEEE 1278.2-1995]	“Standard for Distributed Interactive Simulation - Communication Services and Profiles,” Copyright SYMBOL 211 \f "Symbol" 1995 by the Institute of Electrical and Electronics Engineers, Inc. 345 East 47th Street New York, NY 10017, USA. [IFSPEC, 98]	Defense Modeling and Simulation Office (DMSO) High Level Architecture (HLA) Website, http://hla.dmso.mil/ The Draft Federate Interface Specification.[IEEE 1516]	SISO High Level Architecture Standards Development Group, “Draft Standard for Modeling and Simulation (M&S) High Level Architecture (HLA) - Framework and Rules,” Draft specification, http://www.sisostds.org/stdsdev/ Nov. 1998.[IEEE 1516.1]	SISO High Level Architecture Standards Development Group, “Draft Standard for Modeling and Simulation (M&S) High Level Architecture (HLA) - Federate Interface Specification,” Draft specification, http://www.sisostds.org/stdsdev/ Nov. 1998.[IEEE 1516.2]	SISO High Level Architecture Standards Development Group, “Draft Standard for Modeling and Simulation (M&S) High Level Architecture (HLA) - Object Model Template (OMT),” Draft specification, http://www.sisostds.org/stdsdev/ Nov. 1998. [Karlsson, 98]	Karlsson, Mikael, “Experiences from Implementing an RTI in Java,” Proceedings of the 2nd Simulation Interoperability Workshop, 98s-SIW-062, March, 1998. [Myjak, 97a]	Myjak, Michael D., and Sean Sharp, “HLA RTI: An Application Layer Protocol,” Proceedings of the 1st Simulation Interoperability Standards Organization (SISO) Simulation Interoperability Workshop, 97s-SIW-112, Orlando Florida, March, 1997[Myjak, 97b]	Myjak, Michael D., and Raymond E. Giroux, Sean Sharp, “DIS To HLA Integration, A Comparative Analysis,” Proceedings of the 1st Simulation Interoperability Standards Organization (SISO) Simulation Interoperability Workshop, 97s-SIW-131, Orlando Florida, March, 1997[Myjak, 98]	Myjak, Michael D., and Sean Sharp, “Java Real-Time RTI,” Proceedings of the 4th Simulation Interoperability Standards Organization (SISO) Simulation Interoperability Workshop, 98f-SIW-244, Orlando Florida, October, 1998 [Myjak, 99]	Myjak, Michael D., Sharp, Sean T., Shu, Wei Wennie, with Jeremy Riehl, Demarron Berkley, Phuoc Nguyen, Sean Camplin, and Mike Roche, “Implementing Object Transfer In the HLA,” Proceedings of the 5th Simulation Interoperability Standards Organization (SISO) Simulation Interoperability Workshop, 99s-SIW-157, Orlando Florida, March, 1999 [Weatherly, 96]	Weatherly, R.M., and A.L. Wilson, B.S. Canova, E.H. Page, A.A. Zabek, M.C. Fischer, “Advanced Distributed Simulation Through the Aggregate Level Simulation Protocol,” published in Proceedings of the 29th Hawaii International Conference on System Sciences, Volume 1, pp. 407-415, Wailea, Hawaii, 3-6 January 1996. [RFC 1889]	Schulzrinne, H., with Casner, S., Frederick, R.. with Van Jacobson, “A Transport Protocol for Real-Time Applications,” Internet Engineering Task Force Audio-Video Transport Working Group, http://info.internet.isi.edu:80/in-notes/rfc/files/rfc1889.txt, January 1996. [Rosenberg, 98]	Rosenberg, J., with Aboba, B. and H. Schulzrinne, “Elevating RTP to Protocol Status,” Internet-Draft, Work In Progress, http  HYPERLINK URL:draft-rosenberg-rtpproto-00.txt URL:draft-rosenberg-rtpproto-00.txt [Tennenhouse, 96]	Tennenhouse, David L. and David J. Wetherall, “Abstract Towards an Active Network Architecture,” Computer Communication Review, Vol. 26, No. 2, April 1996.[Von Schweber, 98]	Von Schweber, Erick and Linda Von Schweber, “Computing's next wave,” PCWeek, 5 October 1998.[Wuerfel, 98]	Wuerfel, Roger, Lt. Purdy, Steven G., “A Comparison of HLA and DIS Real-Time Performance,” Proceedings of the 3rd Simulation Interoperability Standards Organization (SISO) Simulation Interoperability Workshop, 98s-SIW-188 Orlando Florida, March1998.About The AuthorsMichael D. Myjak Is Vice President of Research and Development and co-founder of The Virtual Workshop, Inc., where his current role is chief architect of the Java Real-Time RTI.  In 1982, Mr. Myjak received two Bachelor of Science Degrees from Clemson University, one in Computer Science and the other in Engineering Technology.  He obtained his Master of Science Degree in Computer Science - Systems from the University of North Texas in 1988 while employed with the Computer Science Laboratory, Corporate Research and Development labs at Texas Instruments. Prior to founding The Virtual Workshop, Mr. Myjak was a Senior Research Scientist with the Institute for Simulation and Training, at the University of Central Florida. Mr. Myjak has been an active participant in Modeling and Simulation standards activities for a number of years, and has recently completed a term of office as Chair of the Run Time Infrastructure and Communications Forum under the Simulation Interoperability Standards Organization (SISO). He currently Chairs the Run Time Infrastructure Interoperability Study Group, and was recently elected Vice Chair of SISO’s Standards Activity Committee (SAC). Mr. Myjak also Chairs the Internet Engineering Task Force’s (IETF) Large Scale Multicast Application (LSMA) working group, and is active in the Web 3D consortium and the Internet Research Task Force’s Reliable Multicast Research Group.Sean Sharp is a recent graduate of the University of Central Florida, where he graduated Magna cum Laude in Computer Science. Mr. Sharp is currently a Senior Software Engineer at The Virtual Workshop where he has principle design responsibilities for Java Real-Time RTI.  He comes to TVW as former research assistant at the Institute for Simulation and Training, where he has several years of experience in simulator networking and analysis. For his contributions to the performance analysis of the Platform Proto Federation, Mr. Sharp received the 1997 Student Researcher Award from IST. Mr. Sharp is working on his Masters Degree in Computer Science.Keith Briggs is a founder and President of HLA Products and iMT Incorporated.  Mr. Briggs is an active member of the SISO community. He is currently serving terms as Chair of the Run-Time Infrastructure and Communications Forum, Research Development and Engineering Users Forum PRP member, Standards Activity Committee member, Synthetic Natural Environment Standards Technical Area Director, and Real-time Platform Reference FOM drafting group member.  Mr. Briggs is currently chairing an Ownership Transfer Tiger Team on behalf of the HLA Standards Development Group.  Mr. Briggs is a graduate of the Massachusetts Institute of Technology.  The term “Directly Connected Federate” refers to a federation in any communication architecture (i.e., networked, shared memory, massively parallel, etc.) where reliable multicast communications are supported. The IPv4 TOS octet or the IPv6 Traffic Class octet.EMBED Word.Picture.8EMBED Word.Picture.8EMBED Word.Picture.8