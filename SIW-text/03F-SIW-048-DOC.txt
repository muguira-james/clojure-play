The Joint Simulation System (JSIMS) Federation Management ToolboxPeter CarlisleThe MITRE Corporation3504 Lake Lynda Drive, Suite 360Orlando, Florida 32817pcar@mitre.orgWilliam BabineauVirtual Technology Corporation5510 Cherokee Avenue, Suite 350Alexandria, VA 22312babineau@virtc.com  Roger WuerfelSAIC5400 Shawnee Road, Suite 110Alexandria, VA 22312rwuerfel@dctd.saic.com Keywords: JSIMS, Federation Management, Simulation, Training, HLA, RTIABSTRACT: JSIMS is an interactive and distributed simulation designed to train Joint Force commanders and their staffs. It uses the High Level Architecture (HLA) as its infrastructure. JSIMS consists of over 30 Service and Agency federates, including Adapter federates that provide simulation driven data to and from real world Service C4I (Command, Control, Communications, Computers, and Intelligence) systems. To help monitor, control, and perform data collection during the execution of a JSIMS federation, JSIMS includes a variety of tools. The JSIMS toolbox provides the Federation Manger insight and control of this federation. This document describes diagnostic capabilities of tools like the Simulation Interoperability Test Harness (SITH), HLA Control, and the Run Time Infrastructure (RTI) console and how they are used together to better understand the operation and performance of a JSIMS federation.1	IntroductionThe Joint Simulation System (JSIMS) Program is intended to support training and education of ready forces by providing realistic, joint training across all phases of military operations for all types of missions. As a joint service and agency training simulation, JSIMS is comprised of numerous components, each developed by a single Development Agent (DA). The JSIMS components consist of Service, Agency, and Joint models; a Synthetic Natural Environment; interfaces with command, control, communications, computers, and intelligence (C4I) equipment; and other applications and tools employing the DoD High Level Architecture (HLA) for Modeling and Simulation (M&S). During JSIMS Exercise Execution, a diverse set of models, representing joint, land, maritime, air and space, and intelligence domains and other components will interoperate with one another at different classification levels. [1] 1.1	ArchitectureThis description of the JSIMS architecture is intended to provide the foundation for a discussion of the federation management toolbox components used by JSIMS and is not intended as a comprehensive description of the simulation architecture. The JSIMS architecture allows some variation in the numbers and types of federates that comprise a given exercise execution of JSIMS. These variations arise from the composition of the scenario being used, including how many battlefield entities, what domains they operate in, and the quantity and type of C4I equipment to be used in the exercise in question. Due to this element of composability, a toolbox of federation management tools has been developed, each of which provide insights into different elements of the exercise execution. This toolbox consists of a mixture of federation-independent tools, some of which are Federation Object Model (FOM) aware and some of which are essentially FOM independent.1.1.1	Phases of OperationJSIMS defines three operational phases - Pre-Exercise, Exercise Execution, and Evaluation and Reporting. For the purposes of this paper, we will only be discussing the Exercise Execution phase of JISMS operations. During Exercise Execution, the system will consist of two enclaves, a lower and an upper, (see  REF _Ref518730046 Figure 1) operating at different security levels. Each enclave will run a separate federation. However, despite restrictions on the flow of data between enclaves, synchronization of particular events (e.g. initialization, time advance, save and restore) is required.  REF _Ref518730046 Figure 1 is reproduced from the JSIMS SSDD Version 31 [1].Figure  SEQ Figure \* ARABIC 1 JSIMS Execution OverviewEach of the domain models and other runtime components in  REF _Ref518730046 Figure 1 will not necessarily map directly to a single HLA federate or even to a single computer. Current practice during verification and validation testing, and the expected design of exercises, utilizes multiple instances of the larger domain federates, running on separate computers. The complex interactions among the large number of federates, spanning multiple machines, introduces opportunities for failure and requires tools designed to support integration and test, monitoring and control, and failure diagnosis and resolution. 1.1.2	High Level ArchitectureJSIMS employs the DoD High Level Architecture (HLA) for Modeling and Simulation (M&S). The HLA establishes a common simulation architecture for the standardization of DoD simulation to facilitate interoperability and reuse of simulation components. The HLA Interface Specification (IfSpec)[2] defines a set of six Run-Time Infrastructure (RTI) services, five of which, Federation Management, Declaration Management, Object Management, Ownership Management and Time Management are employed currently by JSIMS. The remaining RTI service (Data Distribution Management) may be used later in the JSIMS Program lifecycle.Each of the JSIMS runtime components will interface either directly or indirectly to the RTI. There are several ways a JSIMS component can interface the RTI, which can be summarized in three categories:establish a direct connection to the RTI (RTI-direct),using the Common Component Simulation Engine (CCSE) software infrastructure, orusing a C4I Adapter or other piece of intermediate software. 1.2	JSIMS Federation OperationsJSIMS uses the RTI’s Time Management (TM) services to coordinate communications, ensure time causality for attribute updates and interactions being exchanged between federates, and to negotiate the advancement of simulation time.  To serve as an appropriate training environment both from a human interaction point-of-view and to support the C4I systems connected to it, JSIMS’ goal is to run in roughly realtime. Since there are anticipated slowdowns caused by saves, restores, federation load, or even crashes, it will occasionally be necessary to run faster than realtime in order to achieve an overall one to one relationship between realtime and simulation time. Although the TM services can assure the correct causal relationship of events, these services can complicate the execution and management of a federation. Compared to other simulation technologies, such as DIS, failures can have more profound implications on time managed HLA federations because of the potentially strong interdependencies among federation constituents. For example, in a time-synchronized execution, failure of a single federate may impact federation wide time advancement. Therefore, the detection, understanding, and remediation of federate non-responsiveness and it’s contributing factors, such as over burdened computer resources and network problems, is of particular importance in JSIMS. These issues can lead to slow game rates, erratic time evolution, and even outright failure. JSIMS has recognized these issues and has implemented tools to support differing phases (integration and test/performance monitoring, normal training execution, and problem diagnosis and troubleshooting) during the system lifecycle.During the Integration and Test (I&T) / performance-monitoring phase, the challenges facing federation managers include determining “ground truth” when resolving problems, supporting interface and functional testing when one or more components of the system are unavailable or incomplete, and collecting performance information. The normal training execution phase presents requirements for displaying the federation layout and composition, providing real-time federation and federate status information, and providing network information in a manner that supports monitoring and troubleshooting without overwhelming the operator. Finally, when a problem arises during operations – the federation time advance stalls, or slows to the point where training objectives are being threatened – the abilities to determine the federation time management state in detail, to determine whether all federates are ticking correctly and adequately, and to remove an offending federate when their connectivity to the federation is marginal or broken, are vital to restoring proper operation of the JSIMS system in a timely manner.2	JSIMS Federation Management Tools in ActionThe Joint Simulation System (JSIMS) Federation Management Tools provide the JSIMS user unique and powerful capabilities.  As with all tools, to use them effectively, it is important to know when and where to use them during the course of a federation execution.  Many problems can occur during a federation execution and the mapping of symptoms to problems can often be obscure. Understanding existing capabilities and when to use them saves time spent debugging false avenues and aids management decisions.  This section explains some of the problems that can occur during a JSIMS federation execution and the application of JSIMS federation management tools to identify and manage each problem.2.1	The SITHThe Simulation Interoperability Test Harness (SITH) is a tool developed by The MITRE Corporation to provide systems engineers a debug and test capability during federation executions.  The reader can find additional information about this tool in a paper submitted to this workshop by the developer describing the tool, see paper 03F-SIW-027. The SITH has proven to be an invaluable asset to the development and integration of the JSIMS project.  The SITH is a robust tool that offers a wide variety of utilities, provides feedback during execution, and provides a logging capability while remaining unobtrusive during federation execution.  With the SITH, the federation can be stimulated via a script, or via real; time submittal of RTI object or interaction data. The SITH can be used to observe or record the actions and reactions of other federates.2.2	JSIMS tools during InitializationOne of the requirements for a JSIMS federation is, at a minimum, the ability to maintain a one to one federation game ratio In simple terms this means that during execution for every unit of wall clock time, at least the same unit of simulation time should have occurred.  Since all JSIMS federates are time regulating and time constrained, the federation, as a whole cannot proceed any faster in simulation time sequence than the slowest JSIMS federate.  The speed at which a JSIMS federate can proceed in simulation time is related to the amount of wall clock time that federate spends processing data at any given point in simulation time.  To help ease the burden of maintaining a one to one game ratio, the JSIMS federates are allowed a block of time to process all their pre-simulation data during the JSIMS initialization process.  Once the JSIMS initialization process is complete all JSIMS federates should have published or subscribed to any federation objects required for the start of the simulation. The JSIMS initialization process is governed by a series of synchronization points, this process is led by the hlaControl™ federate beginning with the creation of the Fedex and the specification of the scenario and the federates in the federation. This list of federates is referred to as the ‘Wait for federates’ list.  This list can be edited to include or exclude federates expected to join the federation execution.  Once this list has been edited to satisfaction, the federation manger will execute a series of scripts from hlaControl™ that begins the JSIMS initialization process. The JSIMS initialization process consists of two synchronization points: Join Complete and Start.  To achieve the synchronization point Join Compete all federates in the ‘Wait for federates list’, described above, must join the federation and achieve the synchronization point.  Most JSIMS federates achieve the synchronization point Join Compete automatically when they join the federation with the exception of the Security Federation Connector (SFC). The JSIMS federation consists of two separate federations, the Lower Enclave (LE) and the Upper Enclave (UE).  The LE consists of the majority of the JSIMS federates, is classified at the Secret level, and is where all of the war fighting models reside.  The UE consists primarily of intelligence models and is classified at the Top Secret level.  The SFC connects these two federations.   There are 3 components to the SFC: the LSI, Radiant Mercury (RM), and the HSI. The LSI and HSI are federates in the corresponding enclave federations. For security reasons, the HSI and LSI achieve their synchronization points manually when the federation mangers of both the LE and the UE have determined that their respective federations are ready to proceed.  This requires a phone call or other form of communication between the LE and UE federation managers.  The status of synchronization point Join Complete can be obtained from the hlaControl™ script window or the RTI console synchronization manager tool of each respective federation.  If any federate is unable to join the federation for whatever reason, a SITH federate can be joined in place of that federate.  This will allow the federation to continue without starting over, however the functions of that particular federate will not be exercised.  Once the LSI and HSI have achieved synchronization point Join Complete, the federation will continue to initialize.  The hlaControl™ federate then feeds scenario data to the JSIMS federates so they can register objects and publish initial object attribute values in preparation of the start of the simulation. This portion of initialization is a difficult time to determine whether a federate is having problems.  hlaControl™ offers a visual representation to the status of a federation execution including a visual signal when thresholds are exceeded. The thresholds for hlaControl™ are described in detail in this paper. During initialization, JSIMS federates are so busy processing data that many of these thresholds are exceeded and the color indicators display frequently.  This does not necessarily mean there is a problem with the federation, however it behooves the federation manager to monitor the situation. If a status command on the RTI console indicates the federate is not responding to the RTI, it usually means the federate has crashed.  Its best to check with the federate driver, the console and logs of the federate in question to ensure it has indeed crashed before attempting to remove it from the federation.  If the federate has crashed, then all federate processes must be killed and the federate removed using RTI console. Depending on which federate was removed; the federation manager can determine if the federation is worth continuing or if the federation should be restarted.  Once all of the JSIMS federates have processed their data necessary to reach a state in which they can begin the simulation they will achieve synchronization point Start.  When all federates have achieved synchronization point Start, hlaControl™ will display this status in its scenario-initialization script window .  This information can also be obtained from the RTI console synchronization manager tool - this tool will also indicate which federates have not achieved a particular synchronization point.  If a particular federate does not achieve this synchronization point, for whatever reason, it should be noted that hlaControl™ can achieve this synchronization point on behalf of the federate by sending an RTI Manager Object Model (MOM) interaction.  Most of the time this does not work well because the federate had reasons for not achieving the synchronization point, however there are times when this method is useful.  For instance, if nobody is available in the UE and the LE wishes to continue their simulation execution, hlaControl™ can achieve the synchronization points on behalf of the LSI.  Once all federates have achieved synchronization point Start the simulation is ready to begin.2.3	JSIMS tools at Run TimeOnce the federation is ready to operational execution, the federation manger can use hlaControl™ to establish the desired pace for the federation. It should be understood that the pacing variable on hlaControl™ acts as a brake, not as an accelerator.   The federation as a whole will be paced by the slowest federates.  We have found it useful to keep a running log of key federation activities. This helps the federation manger to understand problems with the federation if they should occur.  JSIMS federates have a tendency to crash when they receive bad data.  Logs can help reconstruct the situation within the simulation that caused a crash.  Isolated tests can be run using a SITH federate to monitor and find any offending data.  Certain activities can cause some federates to do heavy processing.  For instance, when the Air and Space federate enters the Air Tasking Order (ATO), that schedules aircraft missions, other federates that are subscribed to aircraft and airbases will process this information.  This can slow federation time evolution, and is expected behavior, however the federation manager may think there is a problem if they are unaware that the ATO has been entered. hlaControl™ provides many tools for gaining insight into the current status of federation operations.  The Federate Runtime Table is a key instrument for finding problems with a federation quickly.  There are many useful columns of information on this table and can be used to find several different problems that can occur.  For instance, the ‘Time Since Last Contact’ column can give an indication if a federate is communicating with the RTI or not.  The ‘LBTS’ and ‘Federate Time’ columns indicate if federates are at the right time in the simulation.   The ‘Time Advancing’ and ‘Time since Last Advance’ columns indicate if federates are time advancing normally.  The ‘Time Advancing’ column consists of two states, Time Advancing and Idle.  Time Advancing means that the federate has requested a time advance and that federate is ready to go to that time.  Idle means that the RTI has granted the federate a time advance and that federate is busy processing and is not ready to go to move ahead in time. Federates that are in an ‘Idle’ state frequently often pace the federation.  Federates that remain in an ‘Idle’ state for a long period of time should be watched closely.   For instance, a federate may have received bad operator input and is now trying to plan a route around the world.  This federate may hold up the federation for several hours or even days.  A decision will have to be made to either restart the simulation, remove the federate, or allow the federate to finish processing.  Once again, logs are critical in helping to make these decisions.  If a federate is not invoking the RTIambassador tick method then it may be holding up the time advancement of the federation because the time advance grant cannot be delivered.  The RTI-NG provides two ways to help a federation manger determine if a federate is ticking or not, the Logging intercept and the TickLogging intercept in concert with the rtiLogger.  These tools are described in the RTI Diagnostics Support section.  If a federate is found that is not ticking for an extended period of time, that federate should be removed from the federation.  Once again, a decision should be made as to whether or not the federation is worthwhile to continue.  There are three ways to remove a federate from the federate from the federation.  If the federate is communicating with the RTI, the federate could resign gracefully, or a RTI MOM interaction can be sent from hlaControl™ which will resign the federate.  If the federate is not communicating with the RTI, then all the federate processes must be killed and then the federate is removed from the RTI console.  If any federates are experiencing problems with time calculations, the RTI console has a very robust tool called the lbts_master.  The lbts_master is discussed in detail in this the RTI Diagnostics Support section.  Another very handy tool in the RTI console is the save manager. This tool gives a status of federates during checkpoint and restore operations.  Common problems during checkpoint and restore operations include improperly set environment variables and permissions on save directories.   Checkpoints should be taken after initialization and at regular intervals throughout the federation.  If anything bad should happen in a federation the federation can be restored to any given checkpoint that was taken.  This can save hours of valuable time.  2.4	Recommendations for JSIMS ToolsAlthough JSIMS already has a very robust set of tools, here are a few ideas that could make the federation manager’s life a little easier. The manual synchronization of the LSI and HSI federates can be slow and cumbersome.  This is required for synchronization points Join Complete and Start, and also for Checkpoint and Restore federations.  Although security requires that no data flow from the UE to the LE , it should be possible for the LSI and HSI to send a signal to Radiant Mercury when they are ready and for Radiant Mercury to send a signal back when both federates are ready to achieve their synchronization points.  This would allow both the LSI and the HSI to achieve their synchronization points in an automated fashion.It would be nice for federation managers to have a federate that would give them insight to the operational aspects of their federation.  This proposed federate would let federation managers know how many aircraft are flying or how many units are moving and their exact location in the game space.  It would also provide a drill down capability on information such as route planning, fuel levels, battle damage, and other important operational information.  This would give federation managers the invaluable knowledge and understanding that the models in their federation are behaving properly.  Imagine how useful it would be for a federation manager to know if an aircraft is trying to take off without fuel, or a ship planning a route over land, or a unit that is buried 100 meters below the earth’s surface.  Another idea would be to create the necessary interface components so that hlaControl™l can remove a federate from the federation whether that federate is communicating with the RTI or not. This modification would also include readjusting any necessary lbts calculations once the federate was removed.  In summary, JSIMS is equipped with some very unique and powerful set of tools.  Understanding the capabilities of tools like hlaControl™, RTI Console, and the SITH is paramount to the success of a JSIMS federation.  It is very important for JSIMS federation managers to know how and when to use these tools and to keep their federations running smoothly.3. JSIMS Federation ManagementThe operation of a federation that consists of numerous JSIMS components and simulation tools:spanning multiple platforms or consisting themselves of multiple federates;executing in multiple federation executions; andmodeling an unprecedented number of battlespace objects; is a complex challenge. The large number of parameters that can be used to characterize the operation of a JSIMS federation and the importance of consistently dependable training highlights the need for an automated tool for monitoring and controlling JSIMS federations. Of particular importance is the ability of a tool to detect and differentiate between federate, federation, computer, and network errors to reduce the time necessary to diagnose and solve potential problems.Virtual Technology Corporation’s (VTC’s) approach to supporting the JSIMS Technical Control/Federation Control Manager (TC/FCM) requirements is based on delivering the commercially supported federation management tool, hlaControl™, and leveraging previous and current development efforts. hlaControl™ is a federation planning, execution, and performance monitoring tool for HLA and provides:Full Life-cycle Exercise Management and ControlVisualization of federates, computers, and the network topologyFull control and management of the federation executionMonitoring of system performance characteristicsRemote launching of federatesVisual alerts and alarms for problemsCorrective action (e.g. remove crashed federates)This section describes some of the JSIMS TC capabilities as a federation monitoring and control tool – additional information is available in [4]. At the outset of this effort hlaControl™ satisfied some of these requirements. VisualizationTC’s network topology has been made the tool’s focal point, since interactive graphics can and has been used to improve the ability to perceive and process many types of complex data rapidly and efficiently. During federation execution it is used as the backdrop for federation status with an immediate and obvious notification of federation inaccuracy or failure. The network topology provides a logical view of the federation and network, providing feedback from the JSIMS federation and environment.  REF _Ref518764116 \h Figure 7 shows a logical view of the federation topology during a recent JSIMS Maintenance Event.Figure 7 Logical JSIMS Federation TopologyThe topology uses a great deal of visual indicators, tables, and popup menus to communicate efficiently with the user. The topology can be decomposed into three sections:Network – network links are highlighted in red when user configurable network thresholds are surpassed, as shown in Figure 8.Figure 8 Network Threshold Exceeded IndicationSystem – the color of each computer icon’s monitor indicates the system load. In addition, a red box around the entire icon indicates a complete loss of connectivity, as shown in Figure 9.Figure 9 Host Overload/Connectivity LossFederate – federates are represented by icons attached below the icon of the computer they are running on. Variants of the federate icon tell if the federate is joined, resigned, not running, or not responding in the federation (not responding is shown in Figure 10).In each case a visual queue on the network topology is an indication to drill down into additional tables of information for more details about a particular problem. Through context sensitive menus the user can issue commands to launch a federate process, resign federates, etc. Figure 10 Federate Not RespondingInitializationWhile not directly a federation monitoring function, one of the management requirements for JSIMS is the ability to initialize a federation execution.  Initialization is a process by which all of the participating federates are coordinated in logical time, scenario data is distributed amongst the participants, and time is evolved in a controlled manner.  The initialization process entails 1) ensuring all federates are present, 2) coordinating all federates with respect to logical time, and 3) distribution of scenario data.  In the paragraphs that follow each of these stages are described briefly in terms of the HLA services required to achieve them, followed by a description of how this is accomplished in a federation independent manner using TC.The HLA provides management level information about currently executing federations via the Management Object Model (MOM).  Among the data provided through the MOM is a list of the set of federates currently present in a federation execution.  In JSIMS federations, a list of required federates is provided to TC as part of the initialization process.  TC monitors the MOM data with respect to this list and will ensure that all required federates are present before it allows initialization to proceed.The HLA offers several services which can be used to coordinate federates’ concept of logical time at the start of a federation execution.  In some federations, and JSIMS is one, it is important that causality be preserved to ensure repeatability of an exercise.  In this case it is crucial that logical time not be allowed to progress until all participating federates are present, have expressed their publication/subscription interests, and are ready to begin processing scenario initialization data.  Synchronization points are used to ensure that this process is coordinated properly among the set of participating federates.JSIMS makes use of two synchronization points during its initialization phase.  The first of these is “JoinComplete”.  The “JoinComplete” synchronization point is registered by hlaControl just after it has detected the presence of all required federates.  Each federate, upon announcement of the “JoinComplete” synchronization point, establishes it’s time management policy, carries out it’s publication/subscription actions, then signals the RTI that it has achieved the “JoinComplete” synchronization point.  Once all federates have achieved the synchronization point, the RTI notifies hlaControl that the federation has achieved synchronization for “JoinComplete”, and hlaControl carries on to the next stage of JSIMS initialization.After the “JoinComplete” phase of initialization, JSIMS federations immediately enter a “Start” phase.  This is another phase that takes place inside of a synchronization point labeled “Start”, and during which the scenario data is distributed.  During the “Start” phase, TC sends time stamped federation-specified interactions that contain scenario data specified through the SG tool.  Each of these interactions instructs one federate to create a domain object.  In JSIMS federations, time stamping these scenario data interactions is important because each the creation of domain objects by one federate may cause reflection of the new objects in other federates, which will in turn register still other objects.  The JSIMS initialization process explicitly accounts for this type of chain reaction, termed depth of consequence [1], by carefully time stamping each of these interactions.Once the entire set of initialization interactions is sent, TC sends an “initialization_complete” interaction, which signals all of the participating federates that they should complete processing of the initialization data and achieve the “Start” synchronization point as soon as possible.  Once the federation has achieved the “Start” sync point, initialization is complete.In order to send initialization interactions with time stamps, TC must be time regulating.  TC is responsible for creating the federation execution, and is always the first federate to join the fedex.  The JSIMS initialization procedure calls for hlaControl to become time regulating and time constrained immediately upon joining the newly created federation execution.  This has the effect of stopping time because after TC becomes regulating, logical time cannot progress unless TC explicitly advances it.Once TC has established its time regulating status, it begins monitoring the list of federates in the execution.  Once all of the federates required by the scenario are present, TC controls the advancement of time throughout the initialization sequence as specified by the scenario.Time ManagementIn addition to carrying out JSIMS time management requirements as part of federation initialization, TC is required to provide a logical time pacing mechanism.  This type of capability has been described in various other federations as a game rate or federation clock feature.  JSIMS federates will, by default, try to advance time as quickly as possible.  This can lead to executions that run too quickly in some circumstances, and in these cases TC will be used to effectively apply a brake, slowing the rate by which logical time is allowed to progress.  TC has a single timing thread that periodically wakes up and takes some action with respect to federation time.  The duration of the sleep cycle is user-configurable, and combined with the desired game rate (which is also user-configurable), is used to calculate the size of time advances. Specifically, upon notification of the end of the sleep cycle, the pacing thread will attempt to advance logical time to the point where it should be based on the amount of elapsed real-time since the pacer was started times the desired game rate. MonitoringTC provides several useful federate monitoring capabilities.  A federate runtime statistics table is provided which shows, in real-time, various MOM data about the state of each federate in the federation.  Among the useful values provided in this table are FederateTime, Lookahead, LBTS, and TSO/RO Queue lengths.  These values provide valuable insights when debugging or diagnosing integration problems. A capability has been added for JSIMS to capture the MOM Manager.Federate.Report.Alert interaction and provide a table showing each of these interactions received from the RTI.  This interaction provides useful information about exceptions that are thrown by federates.  In cases where federates don’t display any output when an exception is thrown, this allows the TC operator to provide insight into integration problems by identifying exceptional behaviors that may cause problems in the federation.In addition, JSIMS has defined a FOM interaction, application_report, which allows a federate to report a detected error directly to the TC operator. Included in this interaction is a severity code and amplifying text string, plus optional parameters identifying the component (sub-federate software) detecting the error, simulation time, and wall clock time.With both the federate runtime statistics and these interactions, the user will be notified of any anomalies visually on the network topology and will be directed to look at the appropriate area of the application for more details. Save and RestoreJSIMS uses TC to initiate federation saves and restores.  For TC this involves invoking and monitoring the HLA save/restore services, saving internal state data and information on the participating federates, and providing feedback to the operator. Some JSIMS components, notably the federates that utilize the Common Component Simulation Engine, need advance notice of federation save requests in order to prepare their state for save.  To support this requirement, TC sends an interaction to signal the Simulation Engine prior to requesting the federation save.3.6	Network Level MonitoringCrucial to the smooth running of any distributed simulation exercise is a stable and efficient Network. One of the best ways to ensure the above is to implement a mechanism that can provide feedback on the current health of the network. Network Monitoring involves the collection, and analysis of network related statistics form the possibly complex and diverse components that comprise the network. Additionally, this collected and analyzed data must be delivered to the end user in a format that’s useful.Before we proceed a few terms should be defined:SNMP – Simple Network Management Protocol is an application-layer protocol for managing TCP/IP based networks.  SNMP runs over UDP, which in turn runs over IP.  NMS – Network Management Station is a device designed to poll SNMP Agents for information.MIB – Management Information Base provides a standard representation of the SNMP Agent’s available information and where it is stored.3.6.1	StatisticsThe key to managing the network is in understanding it. While SNMP can provide us with many different kinds of data, that data by itself would be of very little use to the end user. For example, knowing that the transmit bandwidth utilization on a port on your switch is at 60% is undoubtedly more useful, than knowing the total number of octets transmitted on that port. hlaControl™ therefore takes the raw collected data and using established formulae is able to produce statistics that are more useful to the user.Bandwidth Utilization[5]: knowing which segments or components on the network that are under or heavily utilized can help balance the traffic on segments better. Both the instantaneous transmit (tx) and receive (rx) utilization of an interface can be monitored by hlaControl™. In Addition, the user is presented with Mean and Peak Bandwidth Utilization, thus gaining some measure of historical perspective.Packet Loss[5]: hlaControl™ is able to differentiate between two different types of packet loss:Discard Rate: the number of packets discarded per second due to resource limitations. A high percentage of discarded packets are usually a good indication of a congestion problem, and that more buffer space is required.Error Rate: the number of packets discarded per second due to errors. Essentially it is packet loss due to all reasons other that resource limitations. A high Error Rate may be an indication of a bad cable or some other hardware problem.Just as with Bandwidth Utilization, the Packet Loss statistics are provided for receive and transmit channels separately, giving the user the ability to distinguish the directional flow of data. Collision: Provided the proper MIB is implemented on the component to be monitored, hlaControl™ will return the Collision Rate and the Total number of Collisions registered on that component. By default, network devices with several interfaces (ports) such as switches will normally have this MIB implemented. Latency: The time it takes to send a packet from hlaControl™ to anyone of the remote devices and back, gives the total Round Trip Time (RTT). The latency is for each measured component is calculated every 10 seconds. Latency is a critical network characteristic to monitor, because excessive latency can rob a simulation of its performance.UDP-Statistics: Although not directly related to the JSIMS federation, these protocol layer statistics can prove be a valuable source of information on applications that utilize the UDP. When running DIS exercises UDP statistics can be used to make correlations with PDUs.UdpInDatagrams: gives a count of the total number of UDP datagrams received on an interface.UdpOutDatagrams: gives a count of the total number of datagrams transmitted on an interface.UdpNoPorts Rate: The number of UDP datagrams received per second on an interface for which there were no applications interested.UdpInErrors Rate: The number of UDP datagrams discarded per second due to format errors.   Operational Status:  Gives the current state of the network device. The two most important states are:Up – this network component is currently up and runningDown – this network component is currently down.System Properties: General information about the component being monitoredSysName – name of the monitored componentSysIPAddress – the components IP AddressSysUpTime – How long has the network component of this device been runningSysContact – Name of entity to contact for more information on deviceSysLocation – The location of this device 3.6.2	ImplementationFor a component to be monitored; hlaControl™ expects two things: first the component must have a properly configured SNMP Agent running; and second the component must be reachable from hlaControl™. Today virtually all network capable components (hosts, routers, switches, etc.) come with a built in SNMP Agent. Essentially hlaControl™ acts as a NMS and issues requests to the remotely monitored device’s SNMP Agent. The Agent in turn consults it’s MIB and provides the appropriate response. The data from the responses are interpreted, and the pertinent formulae are applied, producing the statistics described earlier. As stated above, collecting and interpreting the data is only one part of the task in monitoring the device. If the information is to be of any use, it must be presented in an appropriate format, and furthermore, it must seek to alert the user of potential problems and point them in the direction of a solution. hlaControl™ employs a mechanism that uses the network topology, tables, visual indicators, and thresholds to attempt to satisfy the latter requirement.The user can set thresholds for several of the monitored statistics; in so doing, the user is registering with hlaControl to receive notifications/alerts whenever these thresholds are exceeded.  Whenever a Network Threshold is exceeded several things happen: First, in the topology, as depicted in Figure 8, the link connecting the device to the LAN icon goes bold red. This first indicator, at a minimum serves to alert the user that a warning or error condition exists. Second, in the devices panel of the Network Statistics Dialog, the actual interface with the exceeded threshold(s) is highlighted with a red exclamation icon. The ability to produce this level of granularity is especially welcomed on devices such as switches, which have multiple interfaces. A tool tip on the interface shows the statistic(s) that was exceeded, and its value(s). See  REF _Ref518823615 Figure 11.Third, in the table panel of the Network Statistics Dialog the row corresponding to the interface whose threshold(s) was exceeded is highlighted in red. See  REF _Ref518823615 Figure 11.No monitor would be complete without some means of recording or logging of critical data. Logged data can be especially helpful for debugging problems and After Action Review (AAR). With network logging turned on hlaControl™ will record whenever a threshold is exceeded. It captures the current state of the interface, i.e. values of all statistics and the current time. This information can be saved in an XML or text format, for later use.With all these elements working together, hlaControl™ is able to provide a simple yet efficient means of monitoring the network. This proactive approach to network monitoring identifies potential problems; avoids costly simulation downtime; maximize efficiency and productivity to minimize bottlenecks; and capture meaningful performance data. Coupled with hlaControl™’s federation management capabilities, network monitoring enables a federation manager to correlate network problems with federation anomalies. Figure 11 Alert on the Network Statistics4. RTI Diagnostics Support (RTI Console)The HLA specification only makes a limited scope of federation diagnostic information available through the MOM.  This is not necessarily an oversight but a recognition that a fair portion of the necessary information is RTI implementation dependent.This realization obviates the need for a tool that operates outside of the HLA specification to handle the necessary tasks that are not covered by the specification.  One task that becomes obvious during integration is the need to remove federates from the federation if they crash and do not resign from the federation.  The HLA specification is silent on what the RTI should do in this case.  The MOM information also lacks some data that would be helpful for monitoring the execution.  It does not provide enough information about the state of the ongoing time management calculation to help diagnose why time is not progressing.  There is no way to determine which federates have not responded to a synchronization point, what state a federate is in with respect to a save or restore, or if a federate has stopped ticking the RTI.  Therefore, this information is not available to HLA tools such as hlaControl™.The RTI-NG recognized these shortcomings and provides a separate command line driven executable, the rtiConsole, to handle these implementation dependent tasks that are outside of the specification.  The mode of operation of the rtiConsole is based upon the notion of process, federation, and federate level components of the RTI-NG architecture as presented in [6].The rtiConsole does not join in the federation as a federate but instead utilizes the Corba interfaces available in the RTI-NG implementation to communicate with the components of the RTI-NG.  These interfaces allow the rtiConsole to query each component for RTI-NG implementation specific information and display it to the user.  Information is available at the federation level and the individual federate level through various commands.  In any context, all the applicable commands can be listed by using the help command.When the rtiConsole starts it contacts the rtiexec to resolve what federations are being managed  by that rtiexec.  Therefore, the rtiConsole must be started with either a –multicastDiscoveryEndpoint and/or –rtiExecEndpoint command line argument if the rtiexec was started with those parameters.  Once the rtiexec is resolved the rtiConsole can list the federations that are currently active and their status with the list and status commands.  The status command will communicate with the corresponding fedex process and report either “OK” if the fedex process is still responding or “Not Responding” if the fedex process is not able to respond.  If the fedex process is not responding then most likely it has terminated unexpectedly and, depending upon the RTI services the federation uses, the federation may be hung.  At this point the only way to recover is to restart the federation.  This situation has rarely been observed at JSIMS.A more common scenario is that a federate terminates unexpectedly.  When this happens the user will need to go into the federation level context to remove that federate from the federation.  This context is accessed by using the federation command with the federation name or handle as the parameter.  Once in this level the list command will list all the federate handles and names that are joined to the federation according to the maps in the fedex process.  Generally, the user will know which federate has terminated without resigning and can use the remove command giving either the federate handle or name as the parameter.  This will remove the record of the federate from the fedex maps and ask all the other federates to cleanup connections to that federate.  The federation should then be able to continue.A status command is also available in the federation context.  This command will communicate directly with the federate local RTI component (LRC).  If the rtiConsole receives a response from the LRC then it will list the federate as “OK”.  If no response is received the federate will be listed as “Not Responding”.  In general, a status of “Not Responding” indicates that the federate may have terminated.  It could also mean that there was some other problem in communicating with the LRC such as a lengthy delay in the response or a transient error on the network.Another factor to consider when assessing the state of the individual federates with the status command is that with RTI-NG, by default, there is a background process servicing the network.  The status command will be contacting the RTI-NG background thread and not the main federate thread.  It can be the case that the federate itself has hung for some reason but the background thread is still responding.  Therefore, other information may be necessary to determine the true state of a federate and if it is still interacting with the RTI.  This background thread can also continue to update the MOM information for the federate but if the federate is hung then some of the MOM information will be static and can be used as an indication that there is a problem with the federate.Removing a federation from a time managed federate has the side effect that the current LBTS calculation will be thrown out and two new ones will be forced to complete.  These new calculations will be completed even if the message counts do not match [7].  This is necessary to flush any messages that may be outstanding in the network from the removed federate out of the LBTS system.  At this point, the level of repeatability provided by the HLA specification has been violated and the federation manager will need to make a decision if it is worth moving forward with the federation.  This decision is solely based on the objectives of the federation and the affects of repeatability on the validity of the results.The problems caused by a federate terminating without resigning are going to depend heavily upon how the RTI implementation handles federation communications.  If the RTI maintains state on its connections then the RTI will need to implement some way to determine when a federate has terminated without resigning and take the appropriate actions.  The method for determining when a federate terminates depends upon the type of communications the RTI uses.As stated in [8], there are specification services that require reliable connections which implies a maintained state about the connection.  Therefore, at some level all RTI implementations will need to do detection and cleanup based upon the chosen communication medium.  Detection of terminated clients is problematic.  To avoid guessing what proper timeouts should be to determine the difference between a dead federate, and one that is not responding, the RTI-NG rtiConsole allows the user to make that determination and use the remove command as stated previously.The rtiConsole also allows the user to determine the state of the ongoing time management calculation, the state of a synchronization point, and more detailed status about a save and restore.  The federation context of the rtiConsole provides lbts_master, sync_mgr, and save_mgr commands to move to a context associated with the LBTS calculation manager, the synchronization manager, and the save manager states respectively.Within the LBTS master context several commands are available to gain insight into the ongoing time management calculation.  The print_state command will print internal state information to the screen from the centralized LBTS manager, and from each of the federate LRC time management components.  The following is a sample of the information that is provided.LBTS Master state information:================================================================================_LBTS_calculation_requested = True, _calculatingLbts = True, current LBTS calculation color = 6133Current lowest time = 30832.0000000000, lowest lookahead = 1.0000000000, lowest time is NER = False, lowest time is NERlike = FalseCurrent next lowest time = 30833.0000000000, next lowest lookahead = 1.0000000000, next lowest time is NER = True, next lowest time is NERlike = True_countDifference = 0, _numReporting = 22, _countingNodeList.size() = 22Last calculated LBTS = 30832.0000000000, last calculated next lowest LBTS = 30837.0000000000_regulatingMap.size() = 24, _constrainedMap.size() = 24, _pendingConstrainedMap.size() = 0_listOfCountingNodesAwaitingOneMoreCalcBeforeRemoval.size() = 0_countingNodeRemoveQueue.size() = 0, _have_paused_constrained_federates = False_startLbtsForSaveRestore = False, _pausedForSaveRestore = False_doingSave = False, _doingRestore = FalsePacket Counting Node state information for endpoint 192.168.10.9:33012================================================================================Federation Node ID = 7, last reported data: currentNodeLbts = 30840.0000000000, lookahead = 1.0000000000, nextTime = +Infinity, nextLookahead = +InfinitynerLikeLbts = True, isNER = True, nextNerLikeLbts = False, nextIsNER = False_lastReportedColor = 6134, _lastReportedCountDiff = -1_numberOutOfColorPacketsReported = 0LbtsAdvisor 0 data: Federate handle = 21, _currentLbtsTime = 30832.0000000000, _currentLogicalTime = 30829.0000000000, _lookahead = 1.0000000000 _desiredLookahead = 0.0000000000, _lbtsContribution = 30840.0000000000, _lbtsTime = 30832.0000000000, _nextLbtsTime = 30837.0000000000 _changingLookahead = False, _requestTimeRegulationPending = False, _requestTimeConstrainedPending = False, _paused = False, _timeUpdates = 6082 _doesLbtsMasterThinkWeAreRegulating = True, _updateTarget = 0, _lbtsCalcRequested = 0_pAdvanceToTime = 30839.0000000000, _advancing = True, _timeConstrained = True, _asynchronousDelivery = True, _restoring = False, _justDidFQR = False, _doneSendingAtThisTime = False, isTimeRegulating = True, time of next event = 30841.0000000000While a significant part of this data is self explanatory, a full explanation of all of this information is beyond the page limit of this paper.  Reference [7] can be used as a guide for coordinating the information with the time management implementation in RTI-NG.  A sample of utilizing the most important information is as follows.  The LBTS Master state reports _LBTS_calculation_requested = True, _calculatingLbts = True,which shows that an LBTS calculation has been requested and one is currently in progress.  The _countDifference = 1, _numReporting = 22, _countingNodeList.size() = 22shows that there are 22 federates participating in the calculation, 22 have reported, and the counts have not been balanced yet.  Therefore, the calculation is waiting on one other message to be received by a federate.Each federate will have a packet counting node and each will report the state information shown.  This particular report shows that this federate is in the time advancing state and that had asked to go to time 30839.0000000000:_pAdvanceToTime = 30839.0000000000, _advancing = True. The synchronization manager context provides a display of the currently registered synchronization points and allows their status to be displayed.  The sync_mgr command from the federation context enters the sync_mgr context.  The list command will list all the currently registered synchronization points.  Supplying the status command with a synchronization label will list each of the federates and indicate whether they have achieved that synchronization point or not.The save manager context is entered from the federation context by the save_mgr command.  The list_saves and list_restores commands will list all the registered save and restore labels.  The current_save_status and current_restore_status commands will list global information about the save and a status line for each federate as the following shows.save_mgr > current_save_statusType: SaveLabel: TESTPath: DUSTER:c:\RTI\RTI-1.3NGv6.4.3\WinNT-4.0-VC6\bin.Status: SavingRequesting federate handle: 1Requesting federate type: TestFederate1Number of participating federates: 1Start time: Sat Jun 28 12:46:29 2003End time: currently executingFederate handles, types and status:1  TestFederate1  SaveInitiatedThe federates state can be “SaveInitiated” or “SaveSuccessful” and “RestoreInitiated” or “RestoreSuccessful”.  Save and restore initiated means that the initiate call has been received by the federate.  Save and restore successful means that the federate has replied to the RTI that its save or restore was successful.  This information is valuable in determining which federate has not invoked the proper callbacks on the RTI to progress with the save.  One last diagnostic feature that has proved very helpful in a large integration event is the RTI-NG intercepts.  The intercepts are pieces of code that insert themselves in between the federate and the RTI.  The intercepts can then act on RTIambassador or FederateAmbassador calls.  These intercepts are also contained in separate shared object libraries so that new versions can be created and put into an existing installation of the RTI-NG.The Logging intercept that comes with the RTI-NG will provide a detailed account of the interaction between the federate and the RTI.  Each method that is invoked is listed as being invoked and returning along with some information on the parameters to the method.  This information has been essential in determining when a federate has not interacted with the RTI in a long period of time.  In general, if a federate is not busy executing the model or providing data to the RTI it should be invoking the RTIambassador tick method to allow the RTI to deliver callbacks.  In a time managed federation if a model gets hung and does not allow callbacks to take place then the time management calculation will hang because it can no longer determine the lowest value of the timestamps possible from the hung federate.  From the standpoint of data from MOM, it will appear as if all federates are in the time advancing state and time is not progressing.  By turning on the Logging intercept for the federate in question, it can be determined that the federate is no longer interacting with the RTI when there is no output.  The federate can then be removed from the federation with the rtiConsole and the federation execution can progress.The other way to determine if a federate is ticking the RTI is to use the TickLogger intercept along with the rtiLogger application.  This combination allows the user to monitor the number of times a particular federate has called tick during a ten second period. This information is reported to the rtiLogger application which is a centralized logging console. The rtiLogger executable should be started with the same command line arguments as the rtiexec executable that the federates that are using the TickLogger intercept are using. The rtiLogger should be started before any federates that have the TickLogger intercept activated are started and it should be restarted whenever the rtiexec process is restarted  A centralized logger is more convenient for the federation manager to monitor than turning on the Logging intercept on each federate and the finding the stdout of that federate to check its output.The intercepts are accessible on per federate basis in the individual federate context which can be reached with the federate command in the federation context.  The argument for this command is the federate handle or type that is listed in the list command.  The list_available_intercepts will list by name the intercepts that can be activated on that particular federate.  The activate_intercept and deactivate_intercept commands can be used to activate or deactivate an intercept by name.  Intercepts can also be activated in the InterceptSection of the RID file so that they are turned on from the start of the federates execution.5.	References[1]	System/Subsystem Design Description For the Joint Simulation System, Final Version Revision 2, 11 April 2003[2] U.S. Department of Defense High Level Architecture Interface Specification Version 1.3 DRAFT 9, 5 February 1998.[3]	Department of Defense Defense Modeling and Simulation Office High Level Architecture Run Time Infrastructure RTI 1.3-Next Generation Programmer’s Guide Version 3.2 Revision 3, 28 April 2000.[4]	A Comprehensive Federation Management Capability for The Joint Simulation System (JSIMS), Simulation Interoperability Workshop, 01F-SIW-058, September 2001.[5]  Zeltserman, David: “A Practical Guide to SNMPv3 and Network Management”, Prentice Hall, New Jersey 1999.[6] Bachinsky, S., Noseworthy, R., & Hodum, F. (1999). “Implementation of the Next Generation RTI”, Simulation Interoperability Workshop, 99S-SIW-118, March 1999.[7] Hodum, F., Edwards, D., “Time Management Services in the RTI-NG”, Simulation Interoperability Workshop, 01F-SIW-090, September 2001.[8] Hyett, M., Wuerfel, R., “Connectionless Mode and User DDM in RTI-NG V6”, Simulation Interoperability Workshop, 03S-SIW-102, April 2003.Author BiographiesPETER CARLISLE received his BS in Computer Science from Tarleton State University.  Mr. Carlisle is a retired US Army Non Commissioned Officer and has recently started his second career with The MITRE Corporation.  Over the last three years Mr. Carlisle has worked as a Software Systems Engineer for the Army Battlefield Command System (ABCS) and is currently working as an Event Director and Federation Manager for the Joint Simulation System (JSIMS) project.WILLIAM BABINEAU received his BS in Electrical Engineering from Rensselaer Polytechnic Institute and a MS in Computer Science from Steven’s Institute of Technology. He has over twenty-two years of experience in software and systems development in various defense and aerospace applications, including over seven years of experience in large-scale distributed Modeling and Simulation (M&S). The past three years he has been employed at Virtual Technology Corporation (VTC), most recently as the Project Manager responsible for the development of JSIMS’ CCHLA tools, TC and FCM, for the National Air and Space Model (NASM) Program. He has worked on such large-scale distributed simulations as the Joint Simulation System (JSIMS), Joint Training Confederation (JTC), and Joint Precision Strike Demonstration (JPSD).ROGER WUERFEL is a senior software developer in the Distributed Computing Technology Division of SAIC.  He is currently the technical support manager for the RTI 1.3 Next Generation and has been working with the RTI 1.3 Next Generation development team for 5 years.  Mr. Wuerfel has over 14 years experience with simulation, including real-time, human-in-the-loop flight simulation and real-time distributed simulation.  He received his B.S. in Aeronautical/Astronautical Engineering from The Ohio State University and is pursuing his M.S. in Modeling and Simulation from Old Dominion University.Do you mean the simulation user (role players, or the fed manager?)Suggest describing examples of why fed mgr would use the SITH:  honest broker role. Most of the text in this paragraph will not be understood, except by those who know what the SITH is   :-)I not sure of the relevance of the 1:1 discussion with the initialization process, as we do not try to maintain 1:1 then at all. Suggest losing previous para.This is a separate, perhaps related, topic. Will this differ from Bill Babineau’s section on HLA Control?This sounds more like a federate log than a fed mgr log?(This is called a Flying Carpet. I believe there are some ‘protoypes’.)