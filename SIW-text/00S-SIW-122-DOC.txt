The SEDRIS Write API, Reference API Implementation Framework, and SEDRIS Transmittal FormatJesse CamposScience Applications International Corporation12479 Research Parkway, Suite 600Orlando, Florida 32826407-207-2796 HYPERLINK mailto:Jesse.J.Campos@saic.com Jesse.J.Campos@saic.comJohn CarswellReality By Design, Inc.carswell@rbd.comKeywords:  SEDRIS, STF, Write API ABSTRACT: The Synthetic Environment Data Representation and Interchange Specification (SEDRIS) provides a complete (terrain, ocean, atmosphere, and space) data representation model of the physical environment, access methods to that data representation model, and an associated interchange format, the SEDRIS Transmittal Format (STF).  Prior to version 2.5 (or release 2.5), the only manner in which to create a STF transmittal was by using a standard SEDRIS application which had to be linked to a SEDRIS Read API Implementation.  This required that data providers have a working knowledge of the SEDRIS Reference API Implementation Framework (RAIF) to properly provide access to their data.  The RAIF is a standard piece of SEDRIS software that is provided to facilitate access to native data. The advent of the SEDRIS Write API made the creation of STF simpler.This paper provides an overview of the Write API in SEDRIS. It explains the two distinct paths available to a data provider for creating an STF transmittal with an emphasis on the Write API.  The functionality of the Write API is described and general algorithms for creating transmittals, as well as specific examples, are provided. .  The final discussion will center on the functionality that will be added to the SEDRIS Write API in the near future, and how the added functionality will benefit users.IntroductionOne of the goals of the Synthetic Environment Data Representation and Interchange Specification (SEDRIS) is to provide an effective way to interchange the full range of environmental data.  SEDRIS facilitates the transmission and reuse of environmental data through a standard data representation model and interchange mechanism.  It fully represents the environment by capturing all data elements and their relationships and provides a standard data interchange mechanism and format to support the distribution and sharing of environmental data.The SEDRIS Transmittal Format (STF) provides a platform-independent interchange mechanism for SEDRIS transmittals.  As such, it has two distinct components.  The first component is the STF file format.  The STF file format is a binary, non-proprietary, platform-independent format designed to work on both little and big endian platforms.  The second component is the STF software that provides the API access to the format, independent of media or operating system.  This software is  is used to populate transmittals and extract the data.  The STF stores all data associated with the SEDRIS Data Representation Model (SDRM) and the Environmental Data Coding Standard (EDCS). The mechanism for creation of SEDRIS transmittals is through the use of the SEDRIS API.  This paper describes the critical design features of the API, and provides a brief overview of the reference implementation.SEDRIS API OverviewIn order to facilitate data interchange, the SEDRIS API provides a standard and consistent interface into all of the SEDRIS components.The SEDRIS API is divided into the following functional groups: the Conversions API, the Data Representation Model (DRM) API, the Extraction (or Read) API, and the Insertion (or Write) API.  The first three API components will be briefly described, with the remainder of the paper concentrating on the Insertion or Write API.The Conversions API provides the ‘low-level’ functionality to convert coordinate values between spatial reference frames (sometimes referred to as coordinate systems), color values between color models, and measurements for certain units.  The Conversions API is independent of all other SEDRIS APIs.The DRM API provides information about the SEDRIS Data Representation Model classes.  This includes such structural information as the text names of the classes, the number of fields a class contains, the text names of the fields, field types, the text names of the enumerated values, the relationships between objects/classes, and the cardinality of the relationships.The Extraction or Read API is used to find and extract information from one or more SEDRIS transmittals.  There are many implementations of the SEDRIS Read API over a variety of existing formats. One of these is the STF implementation, which provides for the ability to read STF transmittals.   Additional documentation on all of these APIs can be found at the SEDRIS web site:  http://www.sedris.org.Write API OverviewThe Write API is the most recent API and was added in Release 2.5.  This API is an encapsulation of the functionality required to produce SEDRIS Transmittals.  It provides a simple and consistent interface between data provider’s software application and SEDRIS transmittals. The most common method for STF creation will be through the use of the Write API.  The Write API  is the easiest and most flexible manner to create and store SEDRIS data.   It allows the user to structure SEDRIS transmittals in the most efficient manner for their data.  A simplified diagram of the process is provided in Figure 1.  Figure 1.  STF Creation Using the Write API.The philosophy behind this process is to have a data producer control the traversal of their data. The data provider creates an application that traversing their source data and makes calls to the Write API.   This allows the data provider to have total control over the transmittal creation process.  This in turn leads to a more efficient traversal by allowing the producer to take advantage of the organization of their data.  The Write API functions call the underlying STF code, which stores the data in an STF file set.  This allows a data producer to be insulated from any STF changes or improvements.Before the development of the Write API  creation of STF data sets was through the use of a standard SEDRIS application called Traverse.  This application, linked with the data producers implementation of the SEDRIS Read API (over their native format), would traverse an “in-memory” transmittal to create an STF data set.  This required data producers to provide all of the functionality of the SEDRIS Read API, which is more complex than the simple functions of the Write API.  The reason that this occurred was the approach used to bring about all of the SEDRIS components.  The Write API was the last component to be added in order to focus on creating the correct Data Representation Model.  As a result it was necessary to create a process to test the Data Representation Model before the Write API could be developed.  Since Read API implementations existed, the Traverse application was the logical extension.The Write API provides the ability to create transmittals using the full expressive power of the SDRM with a small collection of functions.  Although it provides the full power of the SEDRIS components, it is not intended as an application’s environmental database management system (DBMS).  For example, the first version of the Write API (as provided with Version 2.5 of SEDRIS baseline) provides a basic “write only” functionality with no editing capabilities.  Future releases of the SEDRIS API will include read/modify/write capabilities as well.General Steps to Create a TransmittalThe Write API has a set order in which function calls need to be made.  The reason being that one call builds on another.  And the prerequisite data must be added using the proper calls in the correct order.  First the object is created.  Then the field data of the object is set.  The object is then stored in the transmittal.  Relationships can now be created between the object and other objects already stored in the transmittal.  When all relationships have been created then the object must be freed.  This procedure is repeated as necessary by a data producer’s application to create a transmittal.  Thus, the overall steps to creating an STF transmittal using the Write API is as follows:Step 1: Open the transmittal (returns Synthetic Environment object)Step 2: Set field data for the Synthetic Environment objectStep 3: Store the Synthetic Environment object in the transmittalStep 4: Create a new SDRM object.Step 5: Set field data for the new objectStep 6: Store new object in the transmittalStep 7: Create relationships between the new object and other previously stored objects Step 8: Free the new objectStep 9: Repeat Steps 4 - 8 until done.Step 10: Close the transmittalThe key functions of the Write API that accomplish the above steps are presented in the next section. Write API FunctionsThe actual C definitions of the SEDRIS Write API are defined in the file se_write0.h of the SEDRIS core software distribution.  The discussion in this section will only highlight the functions.  Of importance to note is the naming convention of the functions.  In subsequent releases the Write and the Read API will be integrated Currently, however, this is not the case, and separate overlapping functions, such as those needed to open transmittals (e.g. SE_Open()),  are required.  To resolve this naming conflict the phrase/word/… _Write is appended to the overlapping functions, but this is only a temporary measure.The first function is SE_OpenSE_Write(). This function is used to open a transmittal for writing.  Currently it can only open a new transmittal and cannot edit existing transmittals.  This function will return a Synthetic Environment object to be used as a handle to add other objects to the transmittal(s).SE_FreeObject_Write() is used to free objects once the user has determined that an object will not be used further.  It frees all memory associated with the object, but does not delete the object from the transmittal.  An object must be stored before it is freed or the object will be lost.  The Synthetic Environment object returned from SE_OpenSE_Write() should not be freed with this function.Instead, SE_CloseSE_Write() must be used to free the Synthetic Environment object.   This function is called when a transmittal is complete and no more additions are to be made.  It frees all memory associated with the Synthetic Environment and the transmittal.The SE_CreateObject() is the function used to instantiate SDRM objects.  In order to create an object, seven pieces of information are required.  The first is the object’s SDRM class.  The other six are counts for how many relationships this object will have.  The counts are for: 1) the number of aggregates, 2) the number of aggregates with link objects, 3) the number of components, 4) the number of components with link objects, 5) the number of associations, and 6) the number of associations with link objects.  These are the six standard relationships for an object, as defined in the SDRM.  The counts must be greater than or equal to the number of relationships that a producer will create, otherwise the relationships will not be created.  The SE_CreateObject() function creates an object in memory only and does not store it to the STF files.Once an object is created, its field data must be set using SE_PutFields().  This function adds the fields to the in memory object, but does not store them.  The calling application  is responsible for the memory associated with the field structures.An object is stored to media upon calling SE_AddToTransmittal().  This commits an object to the STF files.  One of the parameters is the Synthetic Environment handle, specifying which transmittal the object should be added to. Once the objects are stored using the above function, relationships can be created between stored objects.  SEDRIS defines three relationships: aggregates, components, and associates.  The relationship between two objects can be described by using a third object called the “link object.” The Write API provides two functions for creation of these relationships.The SE_AddComponent() is used to add one object as a component of another.  In the case where the SDRM defines the relationship to be bi-directional i.e. both objects are aware of each other, then the function will add the aggregate to the component automatically.  A link object can also be passed in if one is present. SE_AddAssociate() is used to add one object as an associate of another.  A boolean parameter is passed to SE_AddAssociate() to determine if the SDRM-defined bi-directional associations are to be made automatically or not.  This allows the user flexibility in controlling when the relationships will be established.  It is important to note that the link object itself is also required to be created and stored prior to being used in calls to SE_AddComponent() and SE_AddAssociate().Within SEDRIS there are two classes that can contain data external to their fields , <Images> and <Data Tables>.  As a result the Write API provides special functions to deal with these two classes.   One of these is the SE_PutImageData() function, which is used to store the actual image data associated with an Image object. In addition, six other functions are used to store the data contents of a Data Table object.  These six functions allow three different data organization schemes, and for each scheme allow either the entire data table to be written or just one element of the data table.  The only requirement with these functions is that all SDRM objects related to the data table must have been created and stored prior to storing the data contents of a <Data Table> object.   The six Write API Data Table functions are:  SE_PutDataTable(), SE_PutDataTableExtent(), SE_PutPackedDataTable(), SE_PutPackedDataTableExtent(), SE_PutElementOfDataTable(), SE_PutElementOfDataTableExtent().Code ExampleThe following is a simple example using some of the Write API functions covered.  main(){  SE_OBJECT      synthEnv;SE_FIELDS       synthEnvFields;SE_OBJECT      ModellLibObj;SE_FIELDS       ModelLibFields; char*	            name = "example.stf";  SE_OpenSE_Write(name, NULL, &synthEnv, SE_CREATE); SE_SetFieldsToDefault(SE_SYNTHETIC_ENVIRONMENT_TOKEN, &synthEnvFields);sythEvFields.u.Synthetic_Environment.name.string_value  = name;sythEvFields.u.Synthetic_Environment.name.string_length = 11;SE_PutFields(synthEnv, &synthEnvFields);SE_AddToTransmittal(synthEnv, synthEnv);  SE_SetFieldsToDefault(SE_MODEL_LIBRARY_TOKEN, &ModelLibFields);// Create a model library component...SE_CreateObject(&ModelLibObj,	SE_MODEL_LIBRARY_TOKEN, 1,   0,  2,  0 , 0 ,0 )SE_PutFields(ModelLibObj, &ModelLibFields);SE_AddToTransmittal(ModelLibObj, SynthEnv);SE_AddComponent(synthEnv, ModelLibObj, NULL);SE_FreeObject_Write(ModelLibraryObj);SE_CloseSE_Write(synthEnv);}The program starts by defining two SE_OBJECTS which will become the Synthetic Environment SDRM object and a Model Library SDRM object.  A fields variable is also defined for each object.  The final variable is the name of our new transmittal, “example.stf”.  The first step is opening the transmittal by passing in our Synthetic Environment variable and the name of the new transmittal.  The rest of the parameters are default parameters at this time and reserved for future functionality.   The SE_SetFieldsToDefualt()  function sets the passed in fields variable to default values.  This is good practice to ensure bad data is not set within these types of variables.  We then set the name and the length of our transmittal name.  The SE_PutFields() then adds the fields to the in memory object synthEnv.  Then the Synthetic Environment is added to the transmittal.  Note that the first parameter is which transmittal it will be added to and the second, which object.  Even the Synthetic Environment object? is required to be stored.  We will now create a Model Library and follow the same steps as before.   Call SE_CreateObject() with the correct parameters, the correct token or tag, and the correct counts.  In this case we are allocating enough for 1 aggregate, no aggregates with links, two components, no components with links, no associations, and no associations with links.  We set the fields, then put the fields, and finally add the Model Library to the transmittal.  Then we add the Model Library as a component of the Synthetic Environment.  The first object is the aggregate, the second is the component, and the third is the link class (since we have no link class we pass in NULL).  We are now through with our transmittal and we free our Model Library and close the transmittal.Write API LimitationsThe Version 2.5 Write API was an initial release and was intended to only provide the most basic write capabilities.  As a result it had some limitations that producers had to work with.  One limitation of the initial Write API was the requirement that objects could not be freed until all relationships had been created.  This could cause excessive memory usage, if too many objects were required to stay in memory.  A second limitation was that producers had to determine a priori the amount of links between objects.  Thus, they had to know how many aggregates, components, and associations an object would have before it was created.  This requires that producers process their native data before creating objects in order to determine the correct counts and thus slowing down the STF creation process.  If the producer does not determine the actual counts, then they pass in very large numbers for these counts. This is discouraged since it causes gross space inefficiency because the STF allocates space for each possible object.  The most important limitation of the Write API was that it provided only a one-time creation capability.  The data producer could only add objects between the call to SE_OpenSE_Write() and the  call to SE_CloseSE_Write().  Since the transmittal could not be edited, this meant that objects could not be removed nor modified.  For example if a data producer wanted to add a model to the model library in a transmittal, then an entirely new transmittal would have to be created.  The next public release of the Write API will resolve all of these limitations.Added Write API FunctionalityThe first added functionality is the removal of the requirement to pre-determine number of relationships for objects.  When an object is created, the counts for each relationship will not be required. Therefore,  SE_CreateObject() will  only require the SDRM class of the object to be created.The second functionality is the addition of symbolic references to the Write API.  This will simplify creating relationships, and will permit the “forward” referencing of objects to be created later.  Instead of requiring objects to remain in memory, a data producer will be able to assign a symbolic reference to a created object.  Then, the data producer will be able to use the symbolic reference to create relationships.  This is an especially powerful functionality for data producers with unique object identifiers.  For example, a data producer has an object that is identified, as “Bob”, which is a component of multiple objects.  The data producer would create an object, and assign the reference symbol “Bob” to it, and then free the object.  From that point forward, every time the object is encountered, the relationships are created using the symbolic reference “Bob”.  Furthermore, assume that the object  has an association to another object and the data producer assigns the symbolic reference “Larry” to the second object.  When the production software traverses to “Larry” then it will not have to traverse for “Bob”.  The Write API will allow the user to make the association between “Bob” and “Larry” without retrieving either object.  This is a powerful functionality because it removes the recall burden from data producer and allows the data producer the use of its own internal identifiers.The Write API will allow users to assign three different types of symbolic references.  First, a data producer can assign strings. Second, an unsigned 32 bit integer can be assigned to objects.   The third reference provides total flexibility by requiring two separate items: a data producer defined structure and a function to sort the structure.  This allows a user to use any symbolic reference to uniquely identify an object.The final functionality is more complex than the previous two.  This functionality is adding the ability to open transmittals for modifications and updates.  This includes modifying relationships between objects, modifying object field values, and removing objects from the transmittal.  The reason this “editing” functionality is more complex is because it uses other parts of SEDRIS, not just the Write API.  The Write API was standalone and could remain standalone with the previous added functionalities, but not with editing capabilities.  In order to edit a transmittal, a data producer must be able to use both the Read API and Write API functionality.  The Read API is used to retrieve the objects requiring modification, and the Write API is used to edit the objects.  For example, assume that a data producer needs to make a change to a transmittal at a later point in time.  Perhaps a new attribute code has been added and needs to be attributed to a group of polygons.  The producer would use the search capabilities of the Read API to retrieve all polygons with certain attributes and then add the new attribute with the Write API.The ability to both retrieve and modify objects is a new functionality to the SEDRIS baseline.  The functionality of simultaneously retrieving and updating objects has not been incorporated into any SEDRIS distribution.  The RAIF represents the unification of both the Read and Write API.  It is a software framework that provides the overall structure to be used by both data producers and consumers to provide access to SEDRIS objects.  It defines an interface in which SDRM objects can be unambiguously transferred and acted upon. The RAIF is an API Implementation Framework because it provides one implementation for the SEDRIS API functionality.  Multiple implementations could be created that would support the same framework in different languages.  It is the Reference API Implementation Framework, because it is the implementation provided by the SEDRIS core team to be used in the SEDRIS core software distribution.  This is a brief description of the reasons behind the RAIF, and not a discussion of the design or inherent funtionality.SummaryThis paper was intended as an introduction to the Write API and its functions and use This paper presented the SEDRIS Write API as it exists today, and provided a brief overview of its functionality in the next release.   The purpose of the Write API was presented, as well as an overview of how it is to be used by SEDRIS data producers.  The general algorithm for adding SDRM objects to a transmittal, as well as creating a complete SEDRIS transmittal using the Write API, was  shown.  The Write API functions were enumerated and discussed. An example C code using the Write API was presented and a step by step description provided.  The limitations of the present Write API were then discussed followed by the remedies required to remove these limitations.  Author BiographiesMr. Jesse Campos is a Software Engineer with SAIC.  He has been working the SEDRIS project for almost three years.  His primary expertise is in software development as it applies to databases.  Mr. Campos graduated from the University of Central Florida with a B.S. in Electrical Engineering and a Masters in Business Administration.  He can be reached at 12479 Research Parkway, Suite 600, Orlando, FL 32826, 407-207-2796, FAX 407-381-8436,   HYPERLINK mailto:Jesse.J.Campos@cpmx.saic.com Jesse.J.Campos@cpmx.saic.com.Mr. John Carswell is a simulation engineer with Reality By Design, Inc. with over twelve years experience in computer image generation applications, synthetic environment representations and database generation systems.  He has been a member of the SEDRIS core development team for four years, and has been the chief architect of the SEDRIS transmittal format.  He has expertise in visual database performance, construction strategies, and interoperability designs.  Mr. Carswell graduated from Stetson University, Deland, Florida in 1989 with a B.A. degree in Computer Science.  He can be reached at carswell@rbd.com. EMBED PowerPoint.Show.8  