A Logical Data Model and Translation Software forScenario Representations in Mission-Level SimulationsJohn F. SchlomanJohns Hopkins University Applied Physics Laboratory11100 Johns Hopkins RdLaurel, MD 20723443-778-0626john.schloman@jhuapl.eduKeywords:HLA, scenario generation, translation, logical data modelABSTRACT: In analyses employing mission-level military simulations, the translation of a scenario description into simulation-specific inputs is a time-consuming task.  This is exacerbated when simulations of different warfare areas are federated for integrated warfare analysis.  A system that would allow analysts to describe precisely a scenario in a single general scenario definition format and then translate the scenario components into the various simulation-specific input formats, while assuring consistency across the federation, would be beneficial.  The single point of entry (SPE) described in this paper is a preliminary step towards just such a tool.The SPE was designed during the development of the APL Integrated Multi-warfare Simulation (AIMS).  AIMS is a High Level Architecture (HLA) federation designed for use in multi-mission warfare analysis.  The 2004 version of AIMS used the Extended Air Defense Simulation (EADSIM) for the air defense warfare area, the Naval Simulation System (NSS) for the surface warfare (SUW) area, and the APL-developed Battle Force Engagement Model (BFEM) for the anti-submarine warfare (ASW) area.This paper describes the development of a logical data model that defines non-simulation-specific scenario inputs to two of the AIMS federates (NSS and BFEM), and the development of an Extensible Markup Language (XML) file format that is able to represent all the elements within this model.  The paper also describes the creation of the SPE translation tool for reading the scenario defined in the XML format, partitioning the data to the BFEM and NSS federates, and translating the data to the appropriate simulation-specific scenario input formats.1.  IntroductionIn the development of a federation, the High Level Architecture (HLA) Federation Development and Execution Process (FEDEP) [1] is very deliberate in assignment of functionalities to participating simulations.  This is with good reason.  Care must be taken to assure that the scenario is modeled consistently when aggregated across the members.  Even in non-federated solutions time must be invested to assure that the scenario is represented consistently across all simulations.In the future work section of “An Interoperable Multi-Mission Warfare Federation for Analysis” [2], a proposed element to the APL Integrated Multi-warfare Simulation (AIMS) was the single point of entry (SPE).  The goal was a common data entry point for the AIMS federation.  Instead of manually integrating changes into each federate, an analyst could instead work through the SPE which would then translate the data from its general format to the proprietary ones of the member simulations.  The gain would be a reduction in the amount of time to set up a scenario and specialized knowledge for using the member simulations.  Additionally, issues of interoperability between simulations in a federation could be encapsulated away from the analyst who would only need to choose which objects would be published by which simulations.2.  Defining a Logical Data ModelIt is important to define the single point of entry clearly, as its domain is very specifically defined in [2]:“Note that this concept is not the same as setting the details contained in the database underlying the scenario objects. It is not the same as ensuring that all the data for a certain aircraft is common across all models’ databases. The single point of entry is concerned with such things as the type and number of which objects are in the scenario.”To borrow from the object-oriented programming paradigm, the single point of entry is interested in the instances within a scenario, not the object definitions of the components.  The SPE applies to the analyst’s scenario entry task, not the definition of the federation simulations themselves.  After meeting with analysts in the JHU/APL National Security Analysis Department, it was agreed that the SPE would encompass three domains of elements:The definition of the scenario.The definition of all component federates, assets, and commands within the scenario.The analyst-defined behaviors of these scenario components.The task of the SPE application would be to reproduce all three of these domains within all the member simulations of a scenario as seamlessly as possible from a single generalized input file.  A benefit of this scenario definition is that it allows for the addition of other federate simulations not currently within the AIMS federation.  The SPE is simulation-independent.  And as long as the proprietary simulation formats being generated eschew federation-specific content, the SPE could be federation-independent as well.  As this would extend the SPE’s utility to many more multi-warfare federations, simulation and federation independence were crucial in translating the above three domains to a model defining the SPE.  The preliminary model was written as a Backus-Naur Form (BNF) grammar and developed by analyzing two member simulations of the AIMS federation for their scenario inputs:  the Battle Force Engagement Model (BFEM) and the Naval Simulation System (NSS).  BFEM is a mission-level simulation that specializes in Anti-Submarine Warfare (ASW).  NSS is a multi-warfare simulation that models warfare at the mission and campaign levels.  These simulations would provide a baseline SPE that would cover several warfare areas at the mission level.  As the project progressed, a more robust logical data model was needed.  The paper “Logical Data Models - Getting Back to Normal(ization)” [3] provides a Logical Data Model definition that alludes to the above features desired in the SPE:  “A model of data that represents the inherent structure of that data, and is independent of both the specific features of individual applications of the data and any software or hardware mechanisms that are employed in representing or using the data.  The structure of the data is comprised of groupings of data, wherein each group contains data elements associated only with the single concept that is the subject of that grouping, and each data element in the group identifies a single attribute of that concept.  The structure of the data also includes any constraints that are specified to relate one grouping to another.  The structure shall not contain any redundant data, and each grouping of data shall be uniquely identifiable.”As [3] also states, Logical Data Models are essential for addressing interoperability and characterizing “data resources available for ‘edge’ user access.”  The SPE BNF was translated to an initial IDEF1X Logical Data Model which then went through several revisions to achieve a concise design that satisfied the above domains of the SPE.  This new Logical Data Model was normalized to 3rd Normal Form in accordance with the suggestions of [3].The resultant Logical Data Model for the SPE is shown piecemeal in Figures 2 through 4 (with the complete model in Figure 5).  The model is written using IDEF1X [4] notation.  Each figure is a branch of the Logical Data Model representing each of the SPE domains as they are currently implemented.   There were several decisions made on this preliminary pass of the SPE.  To speed implementation, it was decided that only simple waypoint-based motion would be defined.  Behaviors of assets would be limited to this motion and simple condition-response tactics.  In future revisions, elements such as communications and weapon layouts could be appended.3.  Design of the SPE file format and translatorThe eXtensible Markup Language (XML) [5] was selected as the format for the Single Point of Entry.  To assure that a scenario defined in the XML conformed to the Logical Data Model, an XML Schema [6] was derived to validate any Single Point of Entry XML (SPML).  Since it was understood that this Logical Data Model was not the definitive final version of the SPE, the selection of XML Schema carried the additional benefit of extensibility.  Enumerated types can be expanded, ranges can be applied or removed from elements, and whole new branches of content can be inserted with ease.  If the changes to the Logical Data Model are significant enough, a XML Stylesheet Transformation (XSLT) [7] could be defined to translate SPML from one version to another.XSLT was used immediately in the first two simulation-specific translators defined for NSS and BFEM.  Each demonstrates the power of the XML family of tools as each has its own text scenario format.  These translators were built as Java classes derived from the abstract class Lingua.To keep the SPE simulation federation-independent, the design of the translator is to be as simple as possible.  The application, written in Java, is a simple aggregator.  It searches the SPML for the simulations used in this scenario.  It then searches for an appropriate Lingua-derived class that handles the correct simulation and version using reflection.  This class is then instantiated, passed the SPML document, and all methods whose names ends with “Processing” are called reflectively.  If no exceptions occur, the translator proceeds to the next federate defined in the SPML.  In pseudo-code the SPE application would work like this:Validate the input SPML file against the SPE XML Schemafor each federate F in the SPML fileFind a class C that extends Lingua where C.simulation = F.simulation and C.minversion <= F.build <= C.maxversionInstantiate class C as object O with the SPML as a Java objectExecute each method in O whose name ends with “Processing”This design abstracts away the SPE from the specific data translation needed for each simulation.  A simulation’s Lingua could generate files from the SPML using XSLT (as we did with our implementations for BFEM 3.0 and NSS 10.0) or read a configuration file and connect to a database to insert new rows.  The design is also modular.  Expanding the number of supported simulations only requires updating the XML Schema, creating a Lingua derived class and including its compiled byte code into the SPE directory.  Finally, this design allows for a federation with multiple federates using the same simulation.  There is no constraint upon the mixture of simulations present within a scenario.4.  Designing the ScenarioAs a proof of concept, a SPML scenario was written to match the design of an August 2004 demonstration of the AIMS federation.  The federation and its BFEM and NSS federates were written in, along with their published and subscribed assets, motion plans, and tactics.5.  Design of LinguaHaving the Java abstract class Lingua as the baseline for all simulation translators had an additional benefit:  a structure for collecting methods that may prove useful across translators.  Methods can be constructed in Lingua and reused among all of its child classes.  The initial thrust of this was for issues of coordinate and range units and the question of depth versus altitude.  To promote simulation-independence, the Environment entity in the SPE Logical Data Model has attributes describing the scenario’s units of measurement (so one scenario might be written in metric units while another in US/Imperial).  This proved complicated for translating to specific simulations as each may have a unique combination of units of measurement.  Because this would be an issue for any simulation translator, measurement translation methods were written into Lingua to convert rates and distances.  These would then be inherited and useable by all Lingua-derived classes.  Future Lingua methods might be created to convert between Above Ground Level (AGL) to Above Mean Sea Level (MSL) and coordinate systems.6.  Design of the BFEM translatorBeginning the simulation-specific translator building with BFEM, a process was outlined that would be repeated for later translators.  First, a catalog of the simulation’s inputs for a scenario would be collected.  In the case of BFEM this was a set of a dozen set-up scripts using a tool-specific scripting language.  Next a decision was made on what would be the optimal tools for the creation of these inputs.  Because the SPE scenario document is written in XML and the BFEM scripts are plain text, XSLT was selected.The class bfemLingua was created, derived from Lingua, and a set of processing methods was made for instantiating the XML stylesheet transformation.  Each BFEM script was given a matching XSLT file that produces the script with the necessary elements from the scenario.  Some XSLT files were used multiple times for a single scenario.  For each alliance in a scenario (e.g., Blue, Red, White, etc.), an appropriate adr_ops file is needed (e.g., blue_adr_ops, red_adr_ops, etc.) describing the tactics and behaviors of that alliance’s member assets in the scenario.  For this, a single XSLT file was used, adr_ops.xsl, with the appropriate alliance passed to it as a parameter.During the development of the BFEM translator, some of the limitations of XSLT became apparent.  Although programming constructs such as conditional statements and recursion exist, XSLT is limited in comparison to other programming and scripting languages.  Variables’ values, once initialized, cannot be reset in the current scope.  There are no for-loops, structures, or built-in methods beyond simple string manipulation.  When some of the BFEM scripts required more complex solutions, it was decided that XSLT processing would be used mainly for the formatting of the SPE text.  Java, as the foundation of the SPE translator application, would be used for more complex programming feats.The first of these was the translation of the waypoint motion plans defined in the SPE to the waypoint system in BFEM.  The simple system in the SPE consists only of a series of latitude, longitude, and altitude points with an associated speed.  When defining an asset, BFEM allows a list of waypoints to be attached.  However, the SPE allows for an infinite loop in its waypoint plans (allowing an asset to circle between two waypoints indefinitely).  To replicate this behavior, these motion plans would need to be handled by creating BFEM scripts.  BFEM’s scripts use a system of waypoints defined with bearings and distances.  This information would then need to be interpreted from the data provided in the SPE scenario file.  It was decided that this could be calculated within bfemLingua and attached to the SPML document as XML elements to be used in the final XSLT translation.  There was concern that these calculations could differ from the way BFEM calculated bearing and distance from latitude-longitude-altitude triplets.  So the C algorithms within the BFEM code were replicated including such things as the BFEM internal definition of Pi.  Calculation of bearing and distance in bfemLingua then mimicked the same calculation internal to BFEM.  These values were then appended to the motion plan elements in the SPML document that was passed to the XSLT transformation.The second Java task was the collation of all asset platforms in the scenario for the BFEM script file ‘dat_clasint’.  As the SPE was not designed as a detailed database of the underlying scenario objects, there is no centralized index of platform classifications in the SPE file.  To get this information, it was necessary to collect all the asset elements from the SPML and extract all unique platforms.  This was accomplished in Java with the Document Object Model (DOM) interface.  This list of platforms was added to the SPML file as a new branch from the root ‘scenario’ element.  This modified file was then passed to the ‘dat_clasint’ XSLT file for processing.  Because each Lingua is passed a new copy of the input SPML file, there is no concern that this modified document would be passed to the other simulations’ translators.The translation for ‘dat_clasint’ also illuminated another task:  how to create necessary data that does not[?] exist in the SPE.  Again the SPE’s focus on the data instances in the scenario instead of their definitions required some engineering when creating the BFEM translator.  In addition to listing the unique asset platforms in the scenario, ‘dat_clasint’ also cataloged such data as a platform’s minimum and maximum speeds and its inventory of assets.  Also, certain classifications of platforms required additional information (e.g., diesel submarines would need to have their battery characteristics explicitly defined).  None of this object type information was defined in the SPE but was necessary for BFEM to execute.  A solution was needed.As a stop-gap measure, case statements were written in the XSLT file based upon the classification and category of the platform.  Specific pairs (say a Red diesel submarine of a certain class) would produce a hard-coded block of “boilerplate” script.  Such boilerplate was written for the assets in the proof-of-concept August Demo SPML file.  In future versions of the SPE, this approximation would be replaced with a more robust and flexible design.The translation of tactics defined in SPML illuminated what could be a difficult area in the future.  The SPE defines the conditions of tactics using the general terms of alliances (e.g., alliances “hostile” or “neutral” to this asset’s alliance) and platform classifications (e.g., diesel submarines or facilities).  There is also a hierarchical priority of tactics (i.e., if the asset’s first condition is true, respond as it dictates; otherwise if the asset’s second condition is true…).  BFEM is much more flexible with its behaviors, allowing the analyst to leverage its scripting language at any time.  To translate the SPE tactics then required creating a chain of BFEM script functions that would either cause an asset to respond or check the condition of the next tactic.  Conditions required interesting solutions as the BFEM detection method used would only operate between two specific assets.  So for a single asset to detect any hostile aircraft within 10 nautical miles a function would have to understand the current asset’s alliance, the alliances hostile to its parent alliance, and all aircraft of those hostile alliances.  A series of conditional statements were then generated of the form (e.g., if distance(asset,red_aircraft1) < 10 … else if distance(asset,red_aircraft2) < 10…).  This did not prove to be difficult with XSLT although the resulting scripts left much to be desired in terms of human readability.The issue of hard-coded boilerplate appeared again when transitioning from running BFEM in a stand-alone simulation (which was used to test the ‘goodness’ of the BFEM scripts being produced) to an HLA federation.  The BFEM function for having an asset engage another was different when BFEM ran stand-alone as compared to running under an HLA simulation.  The solution was simply checking for the number of federates in the scenario and if it was one (i.e., only BFEM was being used) then using the local engagement function, otherwise it was to use the HLA preferred function.The BFEM translator was validated using a variant of the AIMS August Demo SPML file that only included a BFEM federate, producing BFEM scripts that were able to execute the scenario in the simulation in stand-alone mode.7.  NSS TranslatorThe process used in making the BFEM translator was repeated for NSS.  There were two choices for simulation-specific scenario inputs to NSS:  a simple XML format and the verbose SIM [spell out] format.  While translating from SPML to the NSS XML would be a simple task, the format was limited to only defining assets and placing them statically within a scenario.  Translating to the SIM format was then needed.  As this format was a text format, XSLT would be used.  The class nssLingua was created, extending Lingua.  As there is only a single SIM file for a scenario, there was only one single processing method in nssLingua that started the XSLT translation.Once more the inclusion of object definitions became important.  A scenario that mimicked the AIMS August Demo created under the NSS GUI and that was exported as a SIM file was about 30 KB, in comparison to the 2.1 MB SIM file actually used by the demo.  The difference contained the definitions of the objects and other elements stored in the NSS ObjectStore database (Probability of Kill (PK) tables, etc.).  Like the platform definitions in BFEM, this data was more boilerplate that could be appended to the few scenario elements that fall under the SPE Logical Data Model.  This was done for NSS by creating a secondary XSL file, nss_boilerplate that contained the above objects and tables.  This was then appended in the XSLT translation operation by using the xsl:include function.Once more there is a difference between local execution (now under the NSS GUI) and HLA mode.  Unlike the BFEM solution, this might be extensive enough to require two separate translators.  The SIM file format is an object-centric design where all scenario inputs are formatted in a standard block of text.  Interestingly the format appears identical for scenarios designed to run locally and those to be run in a federation.  They, however, have significant differences.  GUI-produced local scenarios cause unexpected “end” faults when run from the HLA command line while HLA scenarios cannot be exported using the GUI SIM import tool.The differences may only be a characteristic of formatting.  Therefore, the solution may be best by having two sets of NSS XSLT files and having the Lingua choose based upon the composition of the federation in the SPML.  This topic will require more research.A successful stand-alone NSS run was performed by using a SIM translated from the August Demonstration SPML.  A mixed HLA execution of BFEM and NSS federates waits for the above NSS HLA scenario issue to be sorted out.8.  Future WorkBeyond the immediate goal of successfully creating a mixed HLA federation scenario of BFEM and NSS federates, the next logical SPE task would be expanding the catalog of simulation-specific translators starting with those simulations within the 2005 AIMS federation (Extended Air Defense Simulation (EADSIM), Surface AAW Multi-ship Simulation (SAMS)).  Yet the SPE need not be limited to those specific simulations.  Its optimal implementation is independent of federations so SPE can support any federation whose federates fall within the set of the supported SPE translators.  Increasing the supported simulation domain should be expedited by both the modular expandability of the SPE application and the expansion of the methods within the Lingua abstract class.Support is also bound by the domain of the SPE’s foundation: its Logical Data Model.  As the BFEM and NSS translators demonstrated, there is still a gap between scenario inputs needed by simulations and those covered by the SPE.  Most of these fall into the range of data objects.  Although the SPE’s domain (and, thus, its Logical Data Model) could be expanded to these objects, the current SPE could also leverage an existing data library.  The “classification” and “category” attributes of the Asset element could easily key into a library of entities covering acoustic signatures, PK tables, etc.  Such an extension would be a minor modification to the data model.  Percolating the change up through the XML Schema and the specific simulation translators would be a more involved effort.  Yet as the XML family of standards used is designed to be flexible and extensible, such changes are not counter to the design of the SPE.Finally a GUI of some sort would be useful to design.  Although writing XML is a moderate task for those familiar with it, and although many XML editing tools exist, a robust graphical application would bring SPE closer to its goal of reducing the need of specialized knowledge to produce a federated scenario.  A well designed GUI would further reduce the technical learning curve for producing scenarios.9.  ReferencesInstitute of Electrical and Electronics Engineers (IEEE) “IEEE Recommended Practice for High Level Architecture (HLA) Federation Development and Execution Process (FEDEP),” IEEE Std 1516.3-2003, April 23, 2003.Kovalchik, J. G., Coolahan, J. E., Saunders, R. “An Interoperable Multi-Mission Warfare Federation for Analysis,” 2003 Fall Simulation Interoperability Workshop, 03F-SIW-012, Orlando, FL (September 2003).Dobey, V. T., Eirich, P. L.  “Logical Data Models - Getting Back to Normal(ization),” 2004 Fall Simulation Interoperability Workshop, 04F-SIW-061, Orlando, FL (September 2004).Institute of Electrical and Electronics Engineers (IEEE) “IEEE Standard for Conceptual Modeling Language Syntax and Semantics for IDEF1X97 (IDEFobject),” IEEE Std 1320.2-1998,  June 25, 1998.World Wide Web Consortium (W3C) “Extensible Markup Language (XML),” http://www.w3.org/XML/, July 13, 2004.World Wide Web Consortium (W3C) “XML Schema,” http://www.w3.org/XML/Schema, June 30, 2004.World Wide Web Consortium (W3C) “The Extensible Stylesheet Language Family (XSL),” http://www.w3.org/Style/XSL/, July 8, 2004.Author BiographyJOHN SCHLOMAN is an Associate Staff Software Engineer at the Johns Hopkins University Applied Physics Laboratory.  He is a developer on the AIMS design team as well as a member of the DMSO sponsored RTI verification effort.  In 2003 he completed his Master's in Computer Science at Michigan State University.  In 2001 he received a degree Cum Laude in Systems Analysis from Miami University in Oxford, Ohio. EMBED Visio.Drawing.6  Figure 3.  The Scenario and Related Metadata in the SPE Logical Data ModelFigure 1.  The Single Point of Entry and the AIMS Federation EMBED Visio.Drawing.6  Figure 3.  The Scenario and Related Metadata in the SPE Logical Data Model EMBED Visio.Drawing.6  Figure 2.  Federates, Commands, and Assets in the SPE Logical Data Model EMBED Visio.Drawing.6  Figure 4.  Behaviors in the SPE Logical Data Model EMBED Visio.Drawing.6  Figure 5.  Single Point of Entry Logical Data ModelCleared for Public Release