Cultural Data within a Large Scale Terrain Database Generation System Steve GiffordTerrain Experts Inc (TERREX)84 W. Santa Clara St.#380San Jose, CA  95113408-293-9977sjg@terrex.com Keywords:Synthetic Environment, Terrain, Triangular Irregular Network, Database Generation SystemABSTRACT: One of the key problems in the generation of large-scale terrain databases for ground simulation is the handling of features such as roads, rivers, tree canopies etc.  These are typically referred to as vector or cultural features and dealing with them effectively presents interesting and complex problems.  In this paper we’ll be discussing our approach to processing complex cultural features at the design level.  Our database generation system is a commercial product so we’ll touch on the usability issues as well.  Letting users control a complex system such as this is always a daunting task, particularly when cultural source data is poorly constrained and can be in a variety of map coordinate systems or attribution schemes.  Our approach takes this into account and we’ll be discussing how this is done is some detail.IntroductionIn this paper we’ll be discussing our approach to processing cultural (vector) data in a large-scale terrain database generation system. Cultural data typically consists of features such as roads, rivers or forests that can be represented as points, linears, or areas on a map. We use the terms vector and culture interchangeably in this paper because features such as roads, which are cultural, are processed in much the same way as features like rivers or forests, which are not. Converting that information into a visual representation along with correlated data for non-visual systems is a challenging problem.There are a large variety of systems in this industry that are used for the generation of terrain databases.  These range from off the shelf products to systems which may only exist as a collection of command line utilities strung together by a knowledgable user or engineer.  Some Database Generation Systems (DBGS’) are made from a combination of the two.  First, we’ll be discussing the basic structure of a DBGS that has a certain range of capabilities.  This will lead into a discussion of the design of our own system, Terra Vista.  From there we’ll be focusing on the design of our culture processing sub-system.Structure of a DBGSMost terrain Database Generation Systems (DBGS’) follow similar designs.  In particular, data flows through them in much the same way.  It’s the details of how that data is routed from one part of the system to another and what is done with it when it gets there that separates one DBGS from another.   The data flow design we follow is shown below.  Similar figures exist for most of the current DBGS’ used in this industry. EMBED Word.Picture.8  Figure 1: Data flow through our systemOur system, like most other systems of this type, relies heavily on automation in database construction.  Very few polygons in a typical database will be hand modeled and most of those are restricted to instanced models such as houses or sites of great interest such as targets.  Because of this, the results of our system depend almost exclusively on the source data that goes into it.Source DataThere are 3 types of input data we’ll consider in this context.  These are as follow.ImageryElevationCultureIn addition to these source data types, a typical terrain database will also make use of geotypical textures and models.  These two data types are very well understood within the simulation community and do not merit further explanation here.Some or all of these 3 input data types are used in a typical terrain database.  For the purposes of this paper, however, we’re primarily interested in the last data type: culture.Culture data, also known as vector or cartographic data, is one of the more versatile data types used by and within our system.  Typical sources for culture data are formats and standards such as DFAD, VPF or even SEDRIS [1].A typical cultural feature, such as the lake shown in the figure below can be divided into two parts.  There is the geometry and the attribution associated with that feature.  The geometry for cultural input data can be viewed as one of three different types.Point – A single point might represent a feature such as a building or tree.Linear – A linear is a collection of points that form a group of line segments.  These are commonly used to represent roads, for example.Areal – This is a list of points forming the outside of a feature.  Optionally, there can be a number of additional lists of points that form holes in that feature. An areal might be used to represent an ocean, or a city boundary, for exampleThe areal data type is particularly useful.  In the lake example shown in the figure below there’s an outer loop that represents the lake boundary and then two inner loops (or holes) to represent islands.We treat each point as a 3D coordinate, consisting of an X, Y, and elevation.  Most data sources only contain the 2D spatial information, but more and more are starting to include elevation as well.  In any case, we make heavy use of the 3D coordinates within our system.FACC TypeBH140Dep (depth)5.0Name“Example Lake"Figure 2:Lake with attributesThe more complex part of a cultural feature is actually the attribution.  This tells you what a feature is as well as information about it.  In our lake example above, the attributes are shown on the right.  This includes information such as the feature type, BH140 in this case, which tells us the feature is a lake.  It also includes information about the lake depth in meters and the name of this specific water feature. The attribution associated with a feature is the information used to build a representation of this feature.  The most obvious representation is visual.  For example, we might build a 3D lake with polygons for the water surface, bottom, and banks.  However, there are other representations to consider, such as ones suitable for a Computer Generated Forces (CGF) exercise or even a radar simulation.  In any case, each of these representations must be developed from the attribution given.  Hence, the more detailed that information is, the better the results will be.  However we may store this we must keep as much of this information as possible.Culture ProcessingThe primary job of the culture processing sub-system in a modern DGBS is to turn the source culture data, as discussed above, into something digestible by the terrain sub-system.  As such, this sub-system is primarily defined by its inputs and outputs.The inputs are simple enough.  They consist of the source data.  For the most part this is the culture data, but elevation and imagery play a role as well.The outputs are even simpler.  They consist almost exclusively of processed culture data.  Any additional information to come out of this process is tied to those processed features as well.The figure below is a simple block diagram of this process.  Inputs are on the left and outputs on the right.  From the perspective of the culture sub-system elevation queries are services, as is something we refer to as the project parameters.  By a service, we mean that a module within the culture sub-system can, for example, ask for an elevation at a certain location.  How one might accomplish that with a variety of input elevation data is outside the scope of the culture sub-system.  It’s enough to simply know that it can be done.The project parameters in the figure below represent all the auxiliary information that goes into culture processing.  This can range from the texture used on a road polygon, for example, to the default height of a tree canopy.  This is information used in the database generation process, but not part of the source data.Figure 3: Data flow for culture processing sub-systemThe outputs from the culture processing sub-system are varied.  The most obvious ones relate to the visual database.  For example, the culture sub-system is responsible for creating road polygons from linear source data.  A typical example would be turning road centerline information into 3D polygons with textures applied.  Visual data is not the only output, however.  Computer Generated Forces (CGF) systems such as ModSAF [2] require additional data to function, as do other systems like radar simulators.  For the culture sub-system this data looks very much like the input culture.  There might be some additional connectivity information and a few new attributes as well.  However, for the most part the output data would look very much like the input.For that reason, pulling the necessary information out of the culture sub-system for a CGF is not all that difficult.  It’s getting data to the terrain processing stage that proves complex.Terrain ProcessingThe terrain processing sub-system of a DBGS is the most readily identifiable.  This is the stage where terrain polygons are generated, usually for visual display, and many of the more familiar issues in terrain database generation come into play.From our perspective, this stage is responsible for a few different tasks.  These include the following.Building the terrain skin – This is the point at which the elevation data, usually in a gridded form, is combined with constraints from the processed culture to form a single, consistent terrain skin.Level of Detail – Often a level of detail scheme is used for the visual representation of a terrain database.  That scheme is put into play here and may result in chopping up the terrain skin as well as organizing it into a displayable scene graph.Placement of constrained features – Objects like fences or trees are placed on top of the terrain skin.  Since the terrain skin doesn’t exist in the culture processing phase, these features aren’t fully formed until the terrain phase. In addition to these tasks, this sub-system must also account for everything it does.  This usually means that correlated auxiliary data is generated along with the main (usually visual) data.  This includes things like the 3D location of trees, as well as individual polygons for the terrain skin itself. The purpose of this auxiliary data is to feed systems that need information about the terrain and placement of features, but not in a visual form.The data flow for the terrain sub-system looks much like the figure below.  Of particular importance at this stage is the elevation data from which the terrain surface will be derived.Figure 4: Data flow through the terrain sub-systemAt this point processed culture from the culture sub-system is seen as a set of constraints and instructions.  For a terrain sub-system that can handle integrated geometry, features like roads and rivers provide constraints around which to build a terrain skin.   The instructions take the form of things to build on or near the terrain skin. The placement of tree models on the surface of the terrain or the draping of fences over the terrain would be good examples.In the figure above, we again refer to project parameters.  These control parameters unique to this sub-system.  This might include things like the number of polygons to include in a terrain skin, the default visual material to use, or the number of terrain levels of detail.The terrain sub-system mixes cultural constraints and instructions with elevation data to produce a finished database, suitable for use in a visual system.  The visual output is usually the most complex and common and so tends to dominate this sub-system.  It’s important to remember, though, that this is not the only output.PublishingThis last sub-system is concerned with collecting output from the other sub-systems and turning them into a form digestible by outside systems.  These include the following types.Visual – A visual system, such as that used in a tank simulator, is the most familiar of these types.  Visual systems typically make use of concepts like textures, polygons, and level of detail nodes. Infra-Red – An infra-red simulation system is similar to a visual system, from our perspective.  The main differences are in the materials.  IR systems typically require material definitions per polygon or per pixel. Computer Generated Forces – CGF systems often require a hybrid representation of data.  For example, the terrain surface is needed to provide elevation information.  However, more abstract data such as tree locations or road centerlines in their vector forms are also needed.  As a result, publishing data for this type of system requires pulling information from both the terrain and culture processing sub-systems. Radar – This type of simulation system often requires a gridded representation of elevation data and an abstract representation of features.  The reason for the latter is that the radar return from a tree or telephone pole is significantly different than anything in a visual system.Map – This type of output is used to generate paper maps correlated to a simulation database.  Most of its data comes from the culture processing sub-system.  A representation of the elevation surface (often gridded) can be needed as well.The categories listed above are rather broad and are given here for illustration.  These are not hard and fast rules.  For example, there are radar simulation systems that consume visual data and attempt to derive the rest of what they need from it.  There are also visual systems that consume a variety of non-visual input data.Up to this point we’ve been discussing terrain database generation systems in general.  Our definition of a DBGS is rather liberal and can include any number of commercial or non-commercial tools.  Systems in use throughout this industry range from the purely commercial to systems used only by a single contractor.   In general, it’s possible to identify each of the sub-systems we’ve discussed in any one of these by following the flow of data.At this point we’ll be switching to a discussion of our own terrain DBGS: Terra Vista.Terra Vista BasicsWe’ll be discussing the terrain and culture processing sub-systems of Terra Vista in some detail.  First however, it’s important to understand some of the basic structures and services within our DBGS.Our DBGS is structured as a group of plugins.  That is, we depend on dynamically loaded modules to implement everything from road model generation to file import.  In fact, the basic framework of Terra Vista has no idea how to generate terrain or import an elevation file.  All of that is accomplished with the plugins.  This approach is convenient both for adding new functionality to the system and for updating existing functionality.To address the scaling problems inherent in dealing with large amounts of input data and large output databases we build in blocks.  A block is just a rectangular area within which to build a section of a terrain database.  All cultural data within a block is processed at once, then the terrain for that block is generated.  Finally, any output data for that block is collected and published.Block sizes can vary widely depending on the type of database.  A typical value for a ground simulation database with a good feature density of roads, trees, and rivers, for example, might be 4km.Although our system can deal with a wide variety of map coordinate systems for input and output data we prefer to work in a single map projection when building culture and terrain.  We refer to this as the working projection.Given the rather dynamic nature of our system it’s necessary to have some central cohesive element to pull it all together.  That element is what we refer to as the project and it stores everything from the data flow of how roads and bridges are generated to the texture used for individual tree billboards.Terra Vista ProjectThe project is a Microsoft Access( relational database.  We impose a tree structure on top of that to provide a way of indexing familiar to the user.  The figure below shows the tree structure and the corresponding record definition for the selected node.Figure 5: Project tree structure and record.The project permeates everything within our DGBS.  For example, instead of assigning textures to polygons we assign pointers into the project, which represent texture records.  The publish stage actually turns these project references into texture references.  The project stores 3 main kinds of data.Source Data – All source data is referenced within the project.  For example, when an elevation file, such as a DTED cell is imported, a reference is made to it in a certain area in the project.  This reference contains extent and map projection information as well as a reference to the actual file.Data flow – The project stores the list of plugin modules to run and their sequence as well as the flow of data between them.Parameters – All parameter information is stored in the project.  This includes things like the number of levels of detail to build into the terrain as well as the map projection in which to build the database.A modern relational database is very flexible.  It’s possible to add and delete data very quickly as well as change the basic structure of the database.  We take advantage of these features and allow our plugin modules access to them as well.  So, for example, a road generation module may build and reference project structures that the main application knows nothing about.  Likewise, two cooperating modules can pass data to each other using this mechanism as well.This flexible philosophy extends to source data.  There is very little structure imposed on culture and imagery data.  Individual files can overlap or be in different map projections.  Overlap resolution and data reprojection is handled by the system before that data gets to individual modules.  In addition, the extents for each group of data (usually a file) are known in the project, so only data in the current area of interest need be accessed.It should be noted here that elevation data support is almost as flexible.  The sub-system that handles merging individual elevation grids into a seamless elevation surface currently imposes some constraints of its own on data overlap.Culture Data in Terra VistaOur data structures for cultural data are much like those described in an earlier section.  These vector data files support points, linears, and areals with holes, just as many cultural data formats do.  What is of interest with our approach is that we support generic attribution.A generic attribution scheme, such as the one used by ESRI shapefiles is implemented as follows.  Each feature, such as an areal or point can have an arbitrary list of attributes.  An attribute simply consists of a name, represented as a string, and a value.  Within our system values can be of the following types.IntegerFloating PointStringColorMatrixReference into the projectAlthough most of these are self-explanatory the last one bears a closer look.  Each node within the project can be referenced with a simple handle, since it’s just a record in a table within the relational database.  This handle can be assigned to vector features.  This lets us associate very complex data with our cultural features. A very common example of the use of a project handle within cultural data is that of a widened road.  When road geometry is generated within our system a material is associated with each polygon. That material is just a record in the project with information such as the texture to use or the base color of the polygon.As another example, let’s take a point that represents a house model.  It would have an attribute called “model” which would contain a handle into the project.  That handle would point to a record that has information about the model file to use as well as the footprint (if it needs to be integrated into the terrain) and the roof line (for intervisibility in a CGF system).  In addition, we can add other forms of information as we like without changing the basic definition of a model. Between the project and our culture data structure it’s possible to represent a wide range of input and processed cultural features.  We make heavy use of this in both the culture and terrain processing sub-systems.  In fact, most of the inputs to the terrain sub-system are represented in culture data form.Terra Vista: Terrain ProcessingThe terrain processing sub-system is run after the culture sub-system for each block.  However, we’re discussing it first here because it provides much of the structure for the culture stage.We won’t go into much detail about the inner workings of our terrain generation or our level of detail scheme [3].  What is important here is the capabilities of this sub-system and the different types of input data it will consume.  The figure below shows how culture data flows into our terrain generation stage.Figure 6: Inputs to the terrain sub-systemOf particular interest are the named buckets on the left side of this figure.  These are collection areas within the project for various types of culture data.  It’s the responsibility of the culture sub-system to fill these buckets with the appropriate data.  When the terrain sub-system is run it looks at these collection points in the project to determine what culture data goes where.Each bucket in the figure above corresponds to a certain operation that the terrain sub-system supports related to culture data.  These are as follows.Integrate – All processed culture that gets cut into the terrain goes into this bucket.  This includes features like lakes or roads that we want the terrain to triangulate around.Stitch – This bucket is the destination for processed culture that doesn’t modify the profile of a terrain surface.  An example would be a dirt road that we want to follow the undulations of a terrain surface.Apply – Any terrain polygon with a center beneath an areal in this category gets that areal’s material.  This is used for large, general areas, such as urban outlines, that contribute something to a visual scene but we may not want to spend very many polygons on.Floating – This category of processed culture consists of 3D geometry that is near the ground, but not part of it.  A common example would be generated power lines geometry.Fence – This is linear data that we want to follow the ground and generate upright polygons of a certain height.  The most common example is a tree line.Canopy – Any areals in this bucket are used to form a surface that hovers above the terrain surface by a certain height.  The ever popular tree canopy is the most common example.Model Instance – This type of data consists of points in 2D or 3D that represent either externally referenced model files or lightweight models.  Lightweight models are typically used for trees and are represented as two polygons with a texture or a rotating billboard.In addition to the basic operations listed above, the terrain sub-system also looks for information within the data in each bucket.  This information is stored as attributes on individual vectors.  Some of it is specific to a given operation, such as the height of a tree canopy.  However, some attributes are used in several of the operations listed above.  The most important are as follows.Material – As mentioned earlier, our material definition is just a record in the project.  A piece of processed culture (usually a polygon) has handle to one of these records to represent a visual (or other) material to be used on output.Texture matrix – We represent our texture mappings as a matrices which are applied to specific pieces of processed (or even input) culture.  This lets us modify the geometry of processed culture without having to worry about texture coordinates.  It’s also convenient for representing more than one texture per polygon.Range Limit – These are project records that tell the terrain sub-system how far a piece of processed culture should be seen.The last operation listed above deserves some additional explanation.  Our terrain sub-system has a notion of level of detail that is geared toward large area databases.  Although it is very convenient, it doesn’t give us very fine grained control over when features appear and disappear.  For example, if we wanted a tree canopy to disappear at a certain range and individual trees to appear in its place, we could not accomplish that with our terrain LOD scheme.We use range limits to accomplish that task.  In short, these are instructions to the terrain sub-system on how to organize (often, chop) non-terrain geometry to have it appear and disappear at certain distances from the viewer.  The most obvious way to do this for trees, for example, is to put one level of detail node over each tree in an output file.  However, that would be very inefficient, so we group them instead.  The instructions for doing so can be complex and warrant a record of their own in the project.In addition to dealing with all of this input data from the culture sub-system the terrain processing stage must also build a representation of the terrain.  The approach we use is a constrained Delaunay [4] Triangulated Irregular Network (TIN).  We build a single TIN per tile (a smaller unit than the block) and enforce edge constraints between the tiles [3].  This approach lets us integrate any geometry we like into the highest level of detail, which is central to much of our DGBS design.  Because the constraints only flow one way, the culture processing sub-system need know very little about how the terrain sub-system does its work.As we mentioned earlier, most of the work in our culture sub-system is involved in feeding the terrain sub-system.  Now that we’ve covered the inputs to that stage we’ll be discussing the design of and data flow within the culture processing sub-system.Terra Vista: Culture ProcessingIn order to explain our culture processing sub-system, we’ll be looking at the data flow through the system and the structure of an individual culture processing module.  First, it’s important to understand the inputs and outputs of this sub-system.  The figure below gives a high level overview of this.Figure 7: Data flow in culture sub-systemThe main source of input data for this stage is cultural data files referenced within the project.  As mentioned earlier, we can deal with data in a variety of map coordinates systems.  These include projections like UTM, Lambert or unprojected systems like Geodetic.  Our software reprojects data as necessary or leaves it in its original coordinate system if possible.  In addition, only the data in or around the current block being built is used.Cultural data is particularly easy to deal with in this way because individual features can be reprojected as needed.  In addition, since we use a generic attribution scheme, it’s easy to merge features from different files.  As a result, individual modules within this sub-system only have to deal with data in a single map projection and do not have to be concerned about individual files.Elevation input data is combined by a module within our DBGS and presented as a single surface from which queries can be made.  This surface covers the current and nearby blocks, so that queries can be answered within a 1 block radius of the current area of interest.The outputs of the culture processing sub-system really fall into two classes.  The first is the terrain sub-system input as discussed in the last section.  The second type falls under the category of correlated output.  This is typically reference information about what the cultural sub-system built.  For example, road centerlines will often be in this correlated output.  This category of output data is used for CGF, Map, or radar output for example.The inputs and outputs of this sub-system are fairly straightforward.  It’s the movement of data within the culture sub-system that’s of real interest.  We identify two main problems as follows.Processing – By this we mean turning raw input cultural data into processed culture.  For example, a road network would be raw input data and 3D areals with textures would be the processed version.  Those polygons would then be chopped up as needed and integrated into a visual database by the terrain sub-system.Routing – Although most of the work goes into the processing of culture, it’s necessary to figure out what culture data goes where before it can be processed.  In the road example, we need to figure out what is a road before it can be fed to the appropriate processing pass.We’ll be discussing each of these in turn.  Right now we’ll be looking at the smallest unit of the culture sub-system: a culture processing module.Culture Processing ModulesAs we mentioned earlier, our system is constructed entirely of plugins.  Just about everything is done via a plugin of one sort of another.  This includes most of the work in the culture processing sub-system.A culture plugin knows very little about its surroundings.  It is defined solely by its inputs, outputs and the function it must perform.  As a result, individual culture plugins are very focused, often quite simple and there are a lot of them.  It is easiest to illustrate this through an example.Road generation is a pretty common function of a DBGS and ours is no exception.  Our road generator plugin takes a road network and produces, primarily, 3D polygons to represent that road.  The figure below shows the inputs and outputs of our road generator plugin.The inputs and outputs appear to a culture plugin as named streams of data.  In our example above there are two inputs and three outputs.Input: Default – This is the standard source data you might expect for a road generator.  It consists of linears that represent road centerlines.Input: Bridge – This is the data over which the road generator should build bridges.  Primarily, it will be the reference output of water generation passes, however it can be just about any areal feature we want a bridge built over.Output: Default – The primary output of a culture plugin is usually called Default.  In this case it consists of 3D areals (polygons, really) with materials and texture mappings.Output: Reference – For the road generator this is just a copy of the input road center lines.  The main difference is that all attribution is explicitly copied into each linear.Output: Bridge – The road generator doesn’t build bridges itself.  Instead it generates a 3D linear feature per bridge and builds ramps up to either end.  Another culture processor can then handle the bridge generation.Other culture plugins handle things like assigning elevation to road vectors, generalizing (simplifying) linears, or building bridges.  The road generator is focused on its one task as defined above.Each culture plugin is expected to work within certain constraints.  The important ones are as follows.Blocks – All culture data in and for a certain distance around a block is processed at once.  For example, this means that the road generator cannot access all the roads in the database at once. Any algorithms must take this into account.Edge constraints – Features that overlap block boundaries will be generated at least twice (once for each block) and must match up.  In the road example, if a single road segment spans two blocks it must be built the same way in block blocks or it will look odd.Working projection – All culture plugins work in the same coordinate system.  Input culture data will always be in this system as will output data from a culture plugin.Reference data – Each culture plugin is required to provide reference data that correlates to what it actually built.  In the road generator example this would be the same road centerlines it saw on input.Error data – Culture plugins are supposed to output error data as well.  This is intended to be vector data that corresponds to features a culture plugin could not process.  In reality we don’t enforce this, so even though the provisions are there for it, very few plugins implement it.In addition to the framework in which a culture plugin must do its job, there are services and utility libraries provided by the main system.  Those most commonly used are as follows.Elevation – Culture plugins can make queries of the current elevation surface.  This includes asking for the elevation at a certain point as well as all the elevation surface points within an area.Topology – Many culture plugins need information about the connectivity of cultural data.  For example, the road generator needs to know where the road junctions are and the attachments between them.  We provide a utility library that supports complex 2D topological queries for this purpose.Project access – A culture plugin has free reign within the project to access any node or record.  The road generator uses this to determine the real world size of road strip textures it applies to processed roads.The structure of an individual culture plugin is only half of the picture.  What makes culture processing work is to string a number of plugins together.Culture Processing OrganizationA single culture plugin doesn’t do all that much by itself.  In the road generator example there is still a lot missing.  For instance, we haven’t addressed how input road data gets assigned elevations or how the polygons for bridges are built.  In fact, other culture plugins perform these functions.  How our system knows what to execute and when is the focus of this section.We covered the design of a culture plugin, with emphasis on its input and outputs, in the previous section.  Those input and output streams need to be connected to real culture data.  Input data needs to find its way into the appropriate streams and output data needs to be routed to its next destination.  In addition, our system needs to be told what plugins to run and in what sequence.  Collectively, we refer to all of this information as the processing passes.A single processing pass is just a record in the project that tells the system a number of important things.Plugin – Each culture plugin has a name that it exports to the system.  A processing pass identifies the plugin to run by its name.Inputs & Outputs – A culture plugin provides a list of named input and output streams to the system.  The processing pass record hooks these streams up to collection points of data within the project.Parameter record – Each culture plugin has a list of attributes it expects to see on every piece of culture data.  The processing pass specifies what the record is. The parameter record will be explained in more detail elsewhere.The table below shows the processing pass for road generation, specifically for those roads we want to be integrated (cut into) the terrain.ModuleRoadGeneratorInput Default*Input BridgeReference;WaterInput Bridge 2Reference;ValleyOutput DefaultGeometry;IntegratedOutput Default 2Reference;Transport;RoadOutput ReferenceReference;Centerlines;Transport;RoadsOutput Bridge*Run RecordFP RoadGeneratorThere are a few fields of interest here.Module – This is the name of the plugin to run for this processing pass.Inputs – The inputs in the above record correspond to the input data streams that a culture processing modules expects to see.  These are typically “*” (discussed below) or a location (bucket) in the project from which to read data.  For example, the Input Bridge stream, which is used to determine where to build bridges, will get its data from the reference Water and Valley buckets.Outputs – Outputs are also either “*” or locations in the project.  In the above example, the Reference output is routed to a central location in the project that can be accessed by other plugins.  The default output for this example goes into the buckets for Integrated geometry for the terrain sub-system as well as a reference area.Feature model record – The last field above specifies the feature model record to use for this processing pass.  Feature models will be discussed in more detail below.The “*” character for outputs is used to mean, roughly: Put this culture back in the data flow to be reprocessed.  For inputs, it means: Pull appropriate culture from the data flow and feed it to this module.This will be discussed more in the next section.As we mentioned earlier, a single processing pass does not perform a complete job itself.  Most rely on other processing passes to perform certain functions.  For example, the road generator expects elevations to be assigned to its input data.There are quite a few of these processing passes and new ones are added with every release of our system.  Users can create new processing passes of their own, using existing culture plugins or they can develop entirely new plugins if they like.  However, most users stick with the processing passes we supply in the default project.  There are 44 of these at the moment and they perform a wide variety of tasks. A sampling of the more commonly used ones is shown below.Set Elevations – Assigns elevations to vector data from the elevation surface within the system.Generalize – Simplifies linear and areal data within a tolerance.Fences – Routes linears that correspond to tree lines and fences to the fence bucket for the terrain sub-system.  Also assigns a few attributes like material and height.Canopies – Works in much the same way as Fences, only it routes to the canopy bucket.Complex Lakes – This processing pass builds lakes and rivers with tops, bottoms, and sides.  Its various output data go to the integrate and float buckets for the terrain sub-system. Integrate Areals – Features like parking lots may need to be cut in flat.  This processing pass assigns basic attributes like material and passes the data on to the integrate bucket for the terrain stage.Build Power Lines – The power line generator takes linears that represent power lines and uses them to instance tower models and string polygonal wires between them.Widen Roads: Integrated – This is the processing pass for the road generator we’ve been discussing.Widen Roads: Stitched – The stitched version of widen roads does exactly the same thing as the integrated version, only its data is routed to the stitch bucket for the terrain sub-system.Build Bridges – This processing pass takes the bridge linears from the “Widen Roads: Integrated” pass above and generators 3D geometry for a unique bridge.Stitch Areals – Much like “Integrate Areals”, this pass assigns a few simple attributes, like material, and passes the output on to the stitch bucket for the terrain stage.Scatter Models – This pass takes an areal feature and randomly scatters models within it.  The reference output of this pass can be processed further and the default output goes on to the model instance bucket for the terrain stage.Scatter Models 2 – This pass is exactly like the one above.  However, it’s used to scatter with different parameters over the same area.  For example, we might use the first pass to scatter trees and this one to scatter bushes.Model Instance – Given a single point, this pass will assign a model (just a record in the project) to it and route it to the model instance bucket for the terrain sub-system.The processing pass list provides the mechanical basis for data movement through the system.  For example, a road centerline could be moved through the following processing passes.Set ElevationsGeneralizeWiden Roads – IntegratedBuild BridgesIn this way culture processing within our system is quite linear.  One culture plugin is run after another until the last one is reached.  This is how we build up the culture for a complete terrain database and still provide a large amount of flexibility.  However, we have not addressed the question of how data is routed to those processing passes.  For example, how we answer the question: “what is a road.” Culture Data RoutingThe processing passes provide a very flexible mechanism for building terrain databases with complex cultural features.  However, there are a couple of important problems the processing passes do not address.  First is the selection of subsets of data.  Clearly, we don’t want to feed road centerline data to the power line generator.  Second is how we pass parameters to the processing passes.  In the last section we never addressed the question of what material was assigned to road output, for example.The mechanism we use for cultural data selection is called a feature model.  Incidentally, it also serves to provide default parameters. As you might guess, feature models are constructs within our relational database.  They consist of a small hierarchy of project nodes and can be broken into two parts.Selector – The selector for a feature model tells our system what subset of the input data it applies to.  It consists of a short comparison function, which can look at the type of data (point, linear, areal) or any attribute.  Attributes can be compared against with operations like “=” “<” or “=sub”.  These operations can be used with string, integer, or floating point data types.Processing Pass parameter records – There is a list of these under each feature model and they serve a dual purpose.  First, if a parameter record exists for a given processing pass that assures any data handled by that feature model will be routed through that processing pass.  Second, the default parameters to feed the processing pass are filled out in the parameter record.  For the “Widen Roads - Integrated” pass that would be, among others, width and textures.This approach gives us a lot of flexibility. The processing pass list is rather hard to modify for a regular user.  It requires knowledge of the inputs and outputs of specific plugin modules, among other things, so very few people change them. However, feature models are rather easy to change.  Creating new ones is just a matter of copying an existing one and modifying it as appropriate.The figure below shows a feature model for a primary road.  The top part shows the project hierarchy that represents the feature model and the bottom part shows the selector for this feature model.For the “Primary Road” feature model we’re selecting all linears (not shown) with a code of AP030.  Code is shorthand for “FACC Type” or one of a dozen other similar identifiers.  AP030 is the FACC type for major roads.The feature model shown above runs its data through 3 processing passes: “Set Elevations”, “Generalize – Roads”, and “Widen Roads – Integrated”.  If we didn’t want the roads generalized in this case, we could simply turn off the “Generalize – Roads” pass for this feature model.  Similarly, if we had a new processing pass we wanted to apply (and we often do) we can just add its parameter record to this feature model.  The selected data would be routed to that processing pass the next time we built a terrain database.In actuality, there are two feature models in the above figure.  The bridge feature model inherits its selector from “Primary Road” and applies its own criteria as well: “bridge = yes”.  Effectively, this means that only linear data with a FACC Type of AP030 and the attribute “bridge” set to “yes” will be selected.  This leads into a discussion of what “*” from the last section.We touched upon data flow a little bit in the processing pass section.  Specifically, we mentioned that “*” refers to the default culture data flow.The flow of cultural data starts with the input source data files.  Individual pieces of culture data are projected into the working projection and sorted by the feature models.  The sorted data is fed to processing passes and the output is either routed to a bucket within the project or dumped back into the culture data flow.  In the “Primary Road” example above, the “Widen Roads – Integrated” pass will pull data from the culture data flow.  When it finds a bridge it will create a linear for it and give it an attribute called “bridge” which is set to “yes”.  It will then put that linear out into the standard data flow and let it be picked up by another feature model.  The “Bridge” feature model is the one that picks it up and actually makes a bridge out of it.This flow of culture data, moderated by feature models, allows us to make processing extremely modular within the culture sub-system.ConclusionWe’ve discussed our culture processing sub-system to some degree.  In addition, we’ve attempted to provide some context for the system in which it lives.  We hope to have provided some insight into our design without going into excruciating detail.  For example, the processing passes contain quite a bit more complexity than we’ve covered, so we picked a subset to discuss.As with all software, terrain database generation systems are becoming more complex.  At the same time, a wider range of users is attempting to build sophisticated terrain databases.  Many of these users have little or no exposure to traditional visual simulation.  This presents a challenge to tool development and has driven much our work. The direction we’re heading in the future is toward higher density cultural geometry.  For instance, we now have a module that parametrically generates building models with a lot of detail.  The amount of geometry generated can be extremely large, but when properly managed has little impact on the performance of a visual system.  We see functionality of this type becoming more common within heavily automated DBGS’.References[1] B. Horan et al., “SEDRIS Past, Present, and Future – Technically Speaking”, Proceedings Simulation Interoperability Workshop,   #99S-SIW-057, March, 1999.[2] http://www.modsaf.org[3] L. Willis, “Who says you can’t teach an old LOD new tricks”, Proceedings 1998 IMAGE Conference.[4] L. Chew, “Constrained (Delaunay) Triangulations”, Algorithmica, pp 97-108, 1989.Author BiographiesSTEVE GIFFORD is a cofounder and software architect at Terrain Experts Inc.  TERREX, as it is commonly known, is a 3-year-old San Jose, CA based software company that specializes in terrain database generation software, primarily for visual simulation.  TERREX released its first product, Terra Vista in spring of 1998.  Steve has also worked as a software engineer at MultiGen and Carnegie Mellon University.Correlated OutputProcessed cultureSource CultureCulture ProcessingProject ParametersImageryElevationProcessed cultureProject ParametersElevationTerrain GenerationCorrelated OutputVisual OutputModel InstanceCanopyFenceFloatingApplyStitchIntegrateTerrain GenerationCorrelated OutputProcessed cultureSource CultureCulture ProcessingProjectImageryElevationDefaultBridgeDefaultRoad Generator ModuleFigure 8: Road culture module data flowBridgeReferenceFigure 9: Road Processing PassFigure 10: Road Feature Model