Design and Implementation of the High Performance Computing RTI for the High-Level Architecture in SPEEDES 0.81Gary E. Blankblank@ca.metsci.comJeffrey S. Steinman, Scott ShupeMetron Incorporated512 Via De La Valle, Suite 301Solana Beach, CA 92075(619) 792-8904AbstractThis paper describes the initial release of a new Run-Time Infrastructure (RTI) for the High-Level Architecture (HLA). Currently under development, the new HPC-HLA-RTI builds upon the Synchronous Parallel Environment for Emulation and Discrete-Event Simulation (SPEEDES) framework. This approach coordinates all HLA services between federates in logical time using the distributed time-management capabilities of SPEEDES, while taking advantage of the high-speed communications available on multiprocessor platforms. This paper shows how the RTI services provided in the initial release were implemented using existing functionality in SPEEDES version 0.81. IntroductionThe latest release of the Synchronous Parallel Environment for Emulation and Discrete-Event Simulation (SPEEDES version 0.81 [8], mid-December of 1999) provides RTI interfaces [1,3,4] for running HLA [2] federation executions within a network environment. In the next release, this will be integrated with support for multiprocessor platforms. In the current version, the most commonly used HLA services [13] have been implemented. This means that HLA federates can use the RTI software available in SPEEDES 0.81 to: create and destroy federation executions; join and resign from executions; publish and subscribe to object and interaction classes; register and discover object instances; update and reflect attributes; send and receive interactions; synchronize with other federates using RTI synchronization points; and run their simulations in time-regulating and time-constrained mode. This paper describes the design and implementation of these RTI functions.BackgroundSince this RTI was constructed using various functional elements of SPEEDES, it will be helpful to understand these "building blocks" before describing the design of the various RTI facilities. In this section we offer a brief sketch of the SPEEDES items used in the RTI.SPEEDES: a software framework for building parallel simulations that coordinates activities occurring across multiple CPUs [9,11]. SpeedesServer: a very general TCP/IP server mechanism. There are a finite number of possible message types that will be sent to the server, and the server has a handler that knows how to respond to each type. A client connects to the server, sends a message and receives a reply.  This repeats until the client disconnects from the server. An example of a SpeedesServer is a database server that answers queries about information in the database.Host Router (or SpHostRouter): a type of SpeedesServer that routes messages into and out of SPEEDES. For example, the host router knows how to deliver a message to a specific object in SPEEDES, or to a specific external module attached to SPEEDES.Host User (or SpHostUser): a client object that interfaces with the Host Router. Instances of SpHostUser are used within SPEEDES. The version of this to be used outside of SPEEDES is the External Module Host User, or SpEmHostUser.External Module Host User (or SpEmHostUser): a client object that interfaces with the Host Router from outside of SPEEDES; that is, from an external module attached to a SPEEDES simulation.RTIserver: a type of SpeedesServer that handles HLA federation executions. It keeps track of created federation executions, the federates joined to the executions, synchronization points, etc.Rti Client (or SpRtiClient): a class that “talks to” the RTIserver.  An instance of the SpRtiClient is contained within the RTIambassador object.  It sends requests to the RTIserver to create/destroy executions, join/resign from an execution, etc.Object Proxy: an object that mirrors the published state of a SPEEDES simulation object.  A subscriber to class X will receive a proxy whenever an instance of class X is created; the proxy contains copies of the published attributes of the new object. When attributes are changed in the class X instance, update messages are automatically sent to all object proxies so that the proxies reflect the state of the actual simulation object.Object Manager: these entities manage the creation of simulation objects of a certain type within SPEEDES.  For example, the federate ghost object manager creates instances of federate ghosts (SpFedGhost) within SPEEDES.Federate Ghost (or SpFedGhost): a simulation object that acts as a representative of an HLA federate within SPEEDES.Federate Object Ghost (or SpFedObjGhost): a simulation object that acts as a representative of an entity that has been registered by an HLA federate.Federate State Manager (or SpFedStateMgr): this class provides the interface between the Local RTI Component (i.e., the RTIambassador and the FederateAmbassador) and SPEEDES. It is reused in both the network and HPC implementations of the RTI.FOM Database: this class maintains information about the federation object model, such as object classes, attributes, interactions, federation name, object handles, attribute handles, parameter handles, etc.  There is a FOM Database contained within the RTIambassador.  It also keeps track of which object/interaction classes the federate has published/subscribed to, lists of which attributes have been published/subscribed to, etc.RTI FunctionalityThis section describes the implementation of the functionality available in the initial version of this RTI; the figures are UML sequence diagrams [7]. It should be noted that all of the following services described below are for federates executing in a network environment communicating through TCP/IP. Though much of the software will be the same, the HPC implementation (available in a future release) will exploit the faster shared-memory communications provided by HPC platforms [12].Figure  SEQ Figure \* ARABIC 1: Creating/destroying a federation execution.Creating Federation ExecutionsThe first step required by HLA is to create a federation execution. Then, the federates involved must join the execution. In order to create a federation execution, a federate invokes the RTIambassador method, createFederationExecution, and provides an execution name and the name of an RTI FED file. In our implementation (see  REF _Ref472057051 \h  \* MERGEFORMAT Figure 1), this calls an SpRtiClient method which sends a create federation execution message to the RTIserver. The RTIserver checks its list of existing federation executions to see if one by that name already exists. If so, it sends back an error status. Otherwise, it creates a FederationObject to represent this execution, and inserts it into the list of federation executions. The FederationObject contains a list of objects representing the federates, a list of objects representing the synchronization points, and the FED file name.Destroying Federation ExecutionsRTIambassador::destroyFederationExecution is called to end a federation execution after all federates have resigned. This method calls SpRtiClient::DestroyFederationExecu- tion, which sends a message to the RTIserver (see  REF _Ref472057051 \h  \* MERGEFORMAT Figure 1). The server searches its list for a federation execution with the given name. If none is found, it sends back an error code. If the execution is found, it is examined to see if all federates have resigned. If federates are still joined, another error code is sent back; otherwise, a success code is returned. When destroyFederationExecution gets an error code, it throws an exception back to the federate indicating either "no such federation" or "federates still joined." Joining Federation ExecutionsTo join a federation execution, the federate calls RTIambassador::joinFederationExecution (see  REF _Ref472057263 \h  \* MERGEFORMAT Figure 2). This results in a message being sent to the RTIserver, causing it to add the federate to the list contained within the federation execution object. If the execution cannot be found or if the federate is already joined, an error is returned, resulting in an exception being thrown back to the federate. Otherwise a unique federate handle (an integer ID) is returned.Figure  SEQ Figure \* ARABIC 2: Joining a federation execution.If no errors have occurred thus far, a message is sent into SPEEDES telling the SpFedGhost object manager (O_SpFedGhost) to create an SpFedGhost. As its name suggests, the SpFedGhost object acts as a "stand-in" or "ghost" representing the federate within SPEEDES. The reason we do this is because SPEEDES has many of the capabilities required by HLA already built into it (e.g. subscribing to object classes, discovering and receiving updates of the state of an object, time management, etc.), and the SpFedGhost provides a simple mechanism for tapping into this functionality. For example, to subscribe to an object class, all that needs to be done is to send a message to the federate's SpFedGhost telling it to invoke the SPEEDES version of subscribe. We will describe this process in greater detail below. A significant role played by the SpFedGhost is to act as a simulation-time "brake" on SPEEDES, thus insuring logically correct time management [5,6] for itself and other time-constrained federates. This means that SPEEDES will not run ahead of the federate. Recall that in HLA, a time-constrained federate agrees to only advance its simulation time when given permission by the RTI; therefore, the federate will not run ahead of SPEEDES.Getting back to the join federation operation: assuming the federation exists and the federate has not already joined, joinFederationExecution proceeds by calling SpExtFedStateMgr::Connect. This is the routine that sends the message into SPEEDES telling the SpFedGhost object manager to create a new SpFedGhost. In order to accomplish this, it first picks a SPEEDES node where the SpFedGhost will reside. This is done using the SpEmHostUser method GetNextNode, which just cycles through the N nodes (thus guaranteeing that the objects generated by this federate will be distributed about the N nodes). Next, the SpEmHostUser method SendCommand creates the CreateFedGhost message and ships it to the host router, which routes the message to the appropriate SPEEDES node. It is the host user (SpHostUser) in the SPEEDES node that actually receives the message. The time management algorithm in SPEEDES periodically checks the host user for external messages and handles them. In this case, it is a command message, so the time management algorithm invokes the CreateFedGhost handler (H_SpCreateGhost) in the SpFedGhost manager. The handler creates a new SpFedGhost instance and initializes it by calling S_SpFedGhost::InitData. InitData does some housekeeping and then starts a SPEEDES process to handle HLA nextEventRequest and timeAdvanceGrants (see [10] for a description of this time management process). This process runs until the end of the execution and insures the logically correct time management of the federate with respect to the execution. It was written using the SPEEDES process model (macro-based facilities that let the programmer write concise code to do things like wait for a specific amount of simulation time or wait until a certain event has occurred). After the CoordinateTime process has begun, a message containing the current simulation time and a triplet identifying the newly-created S_SpFedGhost—node number, object type ID, and local ID—is sent back out (using an SpHostUser). The SpHostUser sends the message to the host router, which routes it back to the SpEmHostUser in the SpExtFedStateMgr (which is still in its Connect method, waiting for a reply). The SpExtFedStateMgr takes the current simulation time from the message and uses it to initialize its TimeGranted and CurrentTime data members. The ID triplet will be stowed away and used to efficiently send messages to the S_SpFedGhost object (e.g. subscribe or nextEventRequest messages).Resigning from Federation ExecutionsA federate calls RTIambassador::resignFederationExecution to resign from a federation execution. This causes a message to be sent to the RTIserver, asking to quit the execution. The server looks for the federate in its list and removes it if it is found (otherwise, it sends back an error indicating that the federate has not joined an execution). Then, it attempts to find the federation object to which it belongs. If it cannot find one, or if the federate is not in the federation object’s federate list, a not joined error is sent back. Otherwise, the federate is removed from the federation object’s list and also from any synchronization points it is participating in. At this point a message is returned to the SpRtiClient informing it of the status of the resign operation. If an error status (federate not joined) is returned, an exception is thrown back to the federate. Otherwise, a message is sent into SPEEDES to destroy the SpFedGhost. The message starts out in the SpExtFedStateMgr, gets sent out via the SpEmHostUser to the SpHostRouter, where it is routed to the appropriate SPEEDES node. The time management algorithm on the node retrieves the message with its SpHostUser, and then invokes the event handler H_SpDestroyFedGhost (which is contained within the SpFedGhost manager). This has the effect of removing the object from SPEEDES. Also, any time management barriers associated with the federate are removed. Meanwhile, various clean-up activities are completed before control is returned from resignFederationExecution: the SpExtFedStateMgr processes any unread messages, and several hash tables, lists, etc. are deleted.Registering Synchronization PointsThere are two registerFederationSynchronizationPoint methods in the RTIambassador for establishing an HLA synchronization point. One accepts a list of federates that will be participating in the synchronization, and the other does not (the latter version assumes that all federates will be involved in the synchronization). In either case, a message is constructed and sent to the RTIserver requesting that a synchronization point be created. The former version includes a list of federate handles in the message, while the latter indicates that the number of specified federates is zero, which is understood to mean that all federates are synchronizing.When the RTIserver receives the message (see  REF _Ref472057564 \h  \* MERGEFORMAT Figure 3), it begins by checking that the execution exists, that the federate has joined the execution, and that there is no existing synchronization point having the same label as the one being registered. If any of these conditions are not satisfied, a reply message is returned indicating the error. Otherwise, a new SyncPointObject instance is created, and a list of participating federates is assembled into its Federates data member. This list will correspond to the list of federates in the register message (if the message contains a list), or else to all federates in the execution. What is actually inserted into the list are pointers to FederateObject instances. This comes in handy now that it is time to send out a synchronization point announcement to each participating federate, since the FederateObject contains a TCP/IP-based CONNECTION object that is linked back to each federate’s SpRtiClient. An announcement message is created, and then we step through the list of participating federates, shipping each one the announcement using the CONNECTION object. When the federate yields control to the RTI (by calling RTIambassador::tick()), the SpRtiClient receives the announcement and invokes the FederateAmbassador::announceSynchronizationPoint callback method.Figure  SEQ Figure \* ARABIC 3: Synchronization points.Federation SynchronizationIn order for an HLA federation to synchronize, all N federates participating in the synchronization point must call RTIambassador::synchronizationPointAchieved, passing in the label of the synchronization point. When all N federates have done this, each will receive notification that the synchronization has occurred via the FederateAmbassador callback method, federationSynchronized.In our implementation (see  REF _Ref472057564 \h  \* MERGEFORMAT Figure 3), calling synchronizationPointAchieved sends a message containing the federate handle and the synchronization label to the RTIserver. The RTIserver first checks to make sure that the execution exists, the federate has joined the execution, the synchronization point has been announced (i.e. there is a SyncPointObject with the correct label in the FederationObject’s list), and that the federate is included in the list of participating federates contained within the SyncPointObject. Assuming all these conditions are met, a counter is incremented. When the counter reaches N, indicating that all N federates have achieved the synchronization point, messages are sent out to all federates (there is a potential bug here if a federate mistakenly calls synchronizationPointAchieved more than once; this will be fixed in the next release by replacing the counter with a checklist insuring that each federate has called synchronizationPointAchieved). As with the announcement process, a synchronization message is created, and we step through the list of participating federates, shipping each one the message using the CONNECTION object. When the federate yields control to the RTI by calling the tick() method, the SpRtiClient receives the synchronization message and invokes the FederateAmbassador’s callback method, federationSynchronized.Publishing Object ClassesTo publish an object class, the federate invokes RTIambassador::publishObjectClass, providing the class handle and a list of attribute handles corresponding to the Figure  SEQ Figure \* ARABIC 4: Publish/Unpublish object class.attributes it wishes to make public. All that needs to be done here is to set a flag (in an object representing the object class) to indicate that the class has been published, and copy the list of attribute handles into a data member of the object so we know which attributes are published (see  REF _Ref472057680 \h  \* MERGEFORMAT Figure 4). If the class handle or any of the attribute handles is not recognized, an exception is thrown.Unpublishing Object ClassesTo unpublish an object class, the federate invokes RTIambassador::unpublishObjectClass, providing the handle of the class that no longer needs to be published. First a check is made to see if the class handle is recognized and if the class has in fact been published; if not, an exception is thrown (see  REF _Ref472057680 \h  \* MERGEFORMAT Figure 4). An exception is also thrown if the class handle does not correspond to a class defined in the FED file. Otherwise, the flag indicating that this class has been published is unset, and the list of published attributes is emptied. Subscribing to Object ClassesTo subscribe to an object class, the federate invokes RTIambassador::subscribeObjectClassAttributes, providing the class handle and a list of attribute handles corresponding to the attributes it wishes to be apprised of. This method begins just like publishObjectClass, by noting that the class has been subscribed to, keeping track of which attributes are desired, and throwing an exception if the class handle or any of the attribute handles are unknown (see  REF _Ref472057832 \h  \* MERGEFORMAT Figure 5).Figure  SEQ Figure \* ARABIC 5: Subscribe object class.The next step is to send a message into SPEEDES to the SpFedGhost representing this federate, asking it to subscribe to the object class. This is an example of what we referred to above as “tapping into” existing SPEEDES functionality: after the federate ghost requests the SPEEDES subscription service, it will discover objects of the type subscribed to and receive attribute updates for these objects. Then it will be a simple matter of sending this information back out to the federate.Unsubscribing to Object ClassesTo unsubscribe to an object class, the federate calls RTIambassador::unsubscribeObjectClass and passes in the class handle. The first thing that happens is a check is made to insure that the class has actually been subscribed; if not, an exception is thrown. An exception is also thrown if the class handle does not correspond to a class defined in the FED file. Otherwise, the object containing this class’s subscription information is retrieved, a flag is unset to indicate that it is no longer subscribed, and the list of subscribed attributes is emptied.Next, we have to inform the SpFedGhost object in SPEEDES to unsubscribe from this object class. A message is sent to this object, invoking the event handler called H_SpFedGhostUnsubscribeObject. This unsubscribes the SpFedGhost from the object class, so it no longer discovers or receives updates for objects of that class.Publishing Interaction ClassesTo publish an interaction class, the federate invokes RTIambassador::publishInteractionClass, providing the interaction class handle of the interaction type it intends to generate. All that needs to be done is to set a flag in an object representing this interaction class, indicating that it has been published. If the class handle is invalid, an exception is thrown back to the federate.Unpublishing Interaction ClassesTo unpublish an interaction class, the federate invokes RTIambassador::unpublishInteractionClass, providing the interaction class handle of the interaction type it intends to stop publishing. First, a check is made to make sure that the federate has in fact published this interaction class. If not, an exception is thrown back to the federate. An exception is also thrown if the class handle does not correspond to a class defined in the FED file. Otherwise, the object representing this interaction class is located, and the publish flag in the object is unset to indicate that the federate is no longer publishing this type of interaction.Subscribing to Interaction ClassesTo subscribe to an interaction class, the federate invokes RTIambassador::subscribeInteractionClass, providing the interaction class handle. A flag is set in an object representing this type of interaction to indicate that it has been subscribed to. If the handle is invalid, an exception is thrown back to the federate.Interaction subscriptions work analogously to object subscriptions: a message is sent to the SpFedGhost in SPEEDES asking it to subscribe to the interaction class on behalf of the federate. The SpFedGhost will do this and send interactions it receives of this type out to the federate.Unsubscribing to Interaction ClassesTo unsubscribe to an interaction class, the federate invokes RTIambassador::unsubscribeInteractionClass, providing the handle of the interaction class to be unsubscribed. First, a check is made to make sure that the federate has in fact subscribed to this interaction class. If not, an exception is thrown back to the federate. An exception is also thrown if the class handle does not correspond to a class defined in the FED file. Otherwise, the object representing this interaction class is located, and the subcribe flag in the object is unset to indicate that the federate is no longer subscribing to this type of interaction.Next, we have to inform the SpFedGhost object in SPEEDES to unsubscribe from this interaction class. A message is sent to this object, invoking the event handler called H_SpFedGhostUnsubscribeInteraction. This unsubscribes the SpFedGhost from the interaction class, so it no longer receives interactions of this type.Sending InteractionsTo send an interaction, the federate invokes RTIambassador::sendInteraction, providing the interaction class handle, a list of (parameter-handle parameter-value) pairs, and an optional simulation time argument. First, a check is made to make sure that the federate has published this interaction class. If not, an exception is thrown back to the federate. An exception is also thrown if any of the parameter-handles is not recognized.If we get past these potential exceptions, a message is created containing the interaction name, the parameter list, and the time (if no time is provided, the interaction will be scheduled for the current federation time). The message is sent into SPEEDES to the federate’s SpFedGhost object, causing an event handler (H_SpFedGhostSendInteraction) to be activated. This event handler schedules the interaction, resulting in the delivery of the interaction and parameters to all subscribers.Receiving InteractionsAs described above, the federate subscribing to an interaction class results in its SpFedGhost subscribing in SPEEDES to that type of interaction. When another federate sends an interaction this type, it gets sent into SPEEDES and delivered to all subscribing SPEEDES objects, including the subscribing SpFedGhost representing the first federate. The SpFedGhost responds by sending a message out to its federate, which results in the FederateAmbassssador callback method, receiveInteraction, to be invoked. This is the chain of events that takes place when one federate sends an interaction to another.Registering Object InstancesTo register an instance of a published object class, the federate invokes RTIambassador::registerObjectInstance, providing the handle of the object class (and an optional character string name for the instance). The first thing that happens is a check is made to insure that the class name is in the list of classes that this federate has published (see  REF _Ref472057941 \h  \* MERGEFORMAT Figure 6). If not, an exception is immediately thrown. The class name is inserted into a message that is sent into SPEEDES, and an instance of SpFedObjGhost is created to represent the object within SPEEDES (the SpEmHostUser method GetNextNode() is used to cycle through the N nodes so that the federate object ghosts are distributed around). The SpFedObjGhost contains an object proxy of the correct type to represent the class of object being registered; this means it contains all the published attributes of class. SPEEDES has the capability of delivering exact copies of a proxy to all subscribers, and of automatically updating these copies so that the subscriber always has a mirror image of the state of the object. This object proxy mechanism makes it easy to implement the HLA register/discover and update/reflect functionality: by creating an object proxy of the registered class type, the SPEEDES declaration management system is activated, delivering copies of the proxy to all subscribers and automatically updating those proxies whenever attributes are changed.Figure  SEQ Figure \* ARABIC 6: Register object instance.Getting back to the nuts and bolts of this process: if the object class has been published, a message is sent into SPEEDES, an SpFedObjGhost is instantiated, and a return message is sent out containing a global ID and the (node number, object type ID, local ID) triple of the ghost object. SPEEDES guarantees that the global ID is unique, and it will be returned from registerObjectInstance as the HLA object handle. The triple will be saved in the SpFedStateMgr and used as an “address” so that object updates can be efficiently sent to the object ghost. After the reply has been received, another object proxy is created for the registered object and stored in the SpFedStateMgr to facilitate object updates (discussed below). So there are two object proxies instantiated for each register—one inside of SPEEDES and one external to SPEEDES, in the SpFedStateMgr contained within the RTI ambassador. After this has been completed, the SPEEDES global ID is returned from the register call as the HLA object handle.Figure  SEQ Figure \* ARABIC 7: Update attributes.Updating Object AttributesTo update one or more attributes of a registered object, the federate invokes RTIambassador::updateAttributeValues. The arguments passed to this method are the object handle, a list of (attribute-handle updated-value) pairs, and an optional simulation time. First, the object handle is checked to see if it is valid; if not, an exception is thrown (see  REF _Ref472058050 \h  \* MERGEFORMAT Figure 7). Then all the attribute handles are checked. If any are invalid, an exception is thrown.Next, the object proxy corresponding to the registered object is retrieved from a list in the SpFedStateMgr, and the attributes in the proxy are updated as specified in the update list. The reason this is done is because the proxy knows how to encode the updates into a special message for use in SPEEDES. This message is sent to the object’s SpFedObjGhost within SPEEDES, causing the E_SpUpdateFedObjGhost event to be activated. This updates the SpFedObjGhost, and utilizes the object proxy mechanism in SPEEDES to distribute the update to all subscribing SPEEDES objects. The federate ghosts that have subscribed to this class will receive the attribute updates. They, in turn, will send a message to the federate that they are representing, causing the FederateAmbassssador callback, reflectAttributeValues, to be invoked. That is how the federates receive the attribute updates for object classes they’ve subscribed to (see  REF _Ref475255368 \h Figure 8).Figure  SEQ Figure \* ARABIC 8: Update attributes.Current Status and Future PlansThe HPC-HLA-RTI is currently undergoing Alpha testing of the services described in this document. This initial test period will be completed in March, 2000. Following Alpha testing, the HPC-HLA-RTI development effort will shift its focus towards executing on multiprocessor platforms. We anticipate this effort to take roughly three months.The remaining work to complete the HPC-HLA-RTI involves (1) providing HLA interfaces for the already functional Data Distribution management services in SPEEDES,  (2) developing ownership management services, and (3) integrating real-time modes of operation with logical time management.Summary & ConclusionsThis paper described the design and implementation of the network portion of the HPC-HLA-RTI effort. This RTI is currently undergoing Alpha testing and will soon begin focusing on supporting multiprocessor platforms. The potential benefits that this RTI provides are:Support for federations executing on both multiprocessor platforms and network environments.Faster communications using shared memory and/or high-speed dedicated communication networks.Rigorous coordination of logical time for all HLA services including DM, DDM, and OWM.The ability to use HLA to parallelize a single federate on a multiprocessor platform with the goal of attaining execution speedup.A side benefit of this effort is to automate HLA interoperability for applications that use the SPEEDES simulation engine directly.AcknowledgementsThe High-Performance Computing Modernization Office (HPCMO) sponsored this work through the Common HPC Software Support Initiative (CHSSI) project. The Space and Naval Warfare (SPAWAR) center and the Naval Research Laboratory (NRL) under the CHSSI Force Modeling & Simulation Computational Technical Area provided overall management.The SPEEDES software development team gives special thanks to Wargame 2000 and the Joint National Test Facility for sponsoring many of the features in SPEEDES Modeling Framework. The SPEEDES team also gives thanks to DMSO for their guidance and technical support.SPEEDES is a government-owned software system, managed by Metron Inc., and licensed by NASA. It currently supports several large DoD simulation projects including Wargame 2000, JSIMS, Parallel NSS, and EADTB. The government has recently formed The PDES User's Group to coordinate further SPEEDES development. Current membership includes (1) the JNTF, (2) SPAWAR, and (3) the JSIMS Enterprise. Metron provides expert technical support for the PDES User’s Group during configuration board meetings.BiographyGary Blank, Senior Software Analyst with Metron Inc., received his M.S. in Computer Science from the University of Virginia in 1988. He has worked on various HLA-related projects, including HLA federations, Metron’s HLA-Integration framework, and the HPC RTI.Dr. Jeffrey S. Steinman, Senior Analyst with Metron Inc., received his Ph.D. in High-Energy Physics from UCLA in 1988. From 1988-1995, Dr. Steinman worked at the Jet Propulsion Laboratory where he developed the SPEEDES operating system. This work resulted in more than 30 publications in the area of high-performance simulation and several patent awards. He is currently providing technical support for several large-scale DoD projects including Wargame 2000, JSIMS, JWARS, NSS, and EADTB. Dr. Steinman was the principle developer of the NSS HLA-Integration framework and was the lead integrator of NSS with the HLA Run-Time Infrastructure for the JTFp (Joint Training Federation Prototype) project. He is also a regular participant in the HLA technical exchanges for Time Management and Data Distribution Management.Scott Shupe, Software Analyst with Metron, Inc., received his B.S. in Computer Science from Rensselaer Polytechnic Institute in 1996.  From 1996 to 1998 he worked at the MITRE Corporation and was involved in producing the C++ and Java versions of DMSO RTIs. ReferencesBachinsky S., Tarbox G., Mellon L., Fujimoto R. 1998, “RTI 2.0 Architecture.” 1998 Spring Simulation Interoperability Workshop, No. 98S-SIW-150.Dahmann J., Kuhl F., Weatherly R. 1998, “Standards for Simulation: As Simple As Possible, But Not Simpler – The High Level Architecture For Simulation.” Simulation, Vol. 71, No. 6, Dec. 1998, Pages 378-387.Defense Modeling and Simulation Office (DMSO) website,  HYPERLINK http://hla.dmso.mil http://hla.dmso.mil.Defense Modeling and Simulation Office, “HLA Interface Specification,” Version 1.3,  HYPERLINK http://www.dmso.mil/projects/hla www.dmso.mil/projects/hla.Fujimoto R. 1998, “Time Management in the High Level Architecture.” Simulation, Vol. 71, No. 6, Dec. 1998, Pages 388-400.Fujimoto R. 1999. “Time Management of Unsynchronized HLA Services” In proceedings of the 1999 Fall Simulation Interoperability Workshop, Paper 99F-SIW-165.Muller P. 1997,  “Instant UML.” Wrox Press Ltd. 30 Lincoln Road, Olton, Birmingham, B27 6PA.SPEEDES website  HYPERLINK http://www.speedes.com www.speedes.com.Steinman Jeff, 1998. “Scalable Distributed Military Simulations Using the SPEEDES Object-Oriented Simulation Framework.” In the proceedings of the Object-Oriented Simulation Conference (OOS’98), pages 3-23.Steinman Jeff, et. al., 1999. “Design of the HPC RTI for the High-Level Architecture”, In proceedings of the 1999 Fall Simulation Interoperability Workshop, Paper 99F-SIW-071.Steinman Jeff, Tran Tuan, Burckhardt Jacob, Brutocao Jim, 1999. “Logically Correct Data Distribution Management in SPEEDES”, In proceedings of the 1999 Fall Simulation Interoperability Workshop, Paper 99F-SIW-067.Van Iwaarden Ron, Steinman Jeff, Blank Gary, 1999. “A Combined Shared memory – TCP/IP Implementation of the SPEEDES Communications Library”, In proceedings of the 1999 Fall Simulation Interoperability Workshop, Paper 99F-SIW-095.Yu L., Steinman J., Blank G., 1998, “Adapting Your Simulation For HLA.” Simulation, Vol. 71, No. 6, Dec. 1998, Pages 410-420.PAGE  9