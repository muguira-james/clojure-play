Computational Complexity of HLA Data Distribution ManagementMikel D. Petty, Ph.D.Virginia Modeling, Analysis & Simulation CenterOld Dominion University7000 College DriveSuffolk, VA  23435757-686-6210mpetty@vmasc.odu.eduKatherine L. Morse, Ph.D.Science Applications International Corporation10260 Campus Point Drive, MS B-1-ESan Diego, CA  92121858-826-5442, 858-826-5112katherine.l.morse@saic.com Keywords:HLA, Data Distribution Management, NP-CompletenessABSTRACT:  Although several assertions about the computational complexity of the processing required for the High Level Architecture‚Äôs Data Distribution Management (DDM) [4][7] services have been put forward, no formal analysis of that complexity has appeared in the literature.In fact, DDM can be decomposed into subproblems whose computational complexities can be evaluated separately and appear to differ from each other.  This paper examines two of those subproblems, detecting region intersections and establishing data connectivity.The first subproblem is shown to be not NP-complete by exhibiting a polynomial time algorithm to detect region intersections.  For the second subproblem, one solution approach, multicast grouping, is given and stated formally as a decision problem.  That problem is then proven to be NP-complete as stated.  The distinction between the NP-completeness of this solution to establishing data connectivity and the computational complexity of the problem itself is discussed.IntroductionHigh Level ArchitectureHLA is an architecture for constructing distributed simulations.  It facilitates interoperability among different simulations and simulation types and promotes reuse of simulation software modules [1].  HLA can support virtual, constructive, and live simulations from a variety of applications domains.  HLA is defined by three documents:The HLA Rules [2], which define interoperability and what capabilities a simulation must have to achieve it within HLA.The Object Model Template [3], which is a methodology for specifying simulation data in terms of a hierarchy of object classes, and their attributes, and interactions between objects of those classes, and their parameters.The Interface Specification [4], which is a precise specification of the interoperability-related actions that a simulation may perform, or be asked to perform, during a simulation execution.The HLA Run-Time Infrastructure (RTI) is an implementation of the Interface Specification, consisting of a set of services.  The RTI provides services to start and stop a simulation execution, to transfer data between interoperating simulations, to control the amount and routing of data that is passed, and to coordinate the passage of simulated time among the simulations.  Within the HLA, a set of collaborating simulations is called a federation, each of the collaborating simulations is a federate, and a simulation run is called a federation execution.  Federates that adhere to the Rules can exchange data defined using the Object Model Template by invoking the services defined in the Interface Specification; those services are provided at run-time by the RTI.Data Distribution ManagementOne category of services defined in the Interface Specification, Data Distribution Management (DDM), is intended to reduce the amount of simulation data delivered to a federate during a federation execution.  To accomplish the reduction, one or more multidimensional coordinate systems, referred to as routing spaces, with axes corresponding to simulation data (simulation object attributes or other data available in the simulation) are defined.  During the federation execution federates specify what simulation data they are going to produce (publish) or interested in receiving (subscribe) by creating rectangular regions, called update and subscription regions, within the routing spaces.  When an update region and a subscription region ‚Äúoverlap‚Äù (i.e., intersect) in a routing space then simulation data should be delivered by the RTI from the publisher to the subscriber.  The data distribution services allow update and subscription regions to be created, modified, and deleted dynamically throughout a federation execution.  Each time a region is created, modified, or deleted, the set of regions it intersects may change and if so the data delivery connections used by the RTI must be changed to reflect the new region configuration.The use of DDM during a federation execution can be decomposed into four conceptual processes. These processes can occur repeatedly and asynchronously during a federation execution.Declaring.  Federates express the data they intend to produce (publish) and/or desire to receive (subscribe) in terms of publication and subscription regions in a multi-dimensional routing space.Matching.  The RTI finds all publication regions that overlap subscription regions in a routing space.  For each such overlap found, data associated with the publication region will be sent from the federate that created the publication region to the federate that created the subscription region.Connecting.  The RTI establishes data flow connectivity between the sending and receiving federates.  The method for doing so depends on the network infrastructure, but using multicast groups is a common approach.Sending.  The RTI and the federation‚Äôs interconnecting network transport simulation data.The use of multicast has met with considerable success in the application to the connecting process.  However, its use to date has relied on a priori knowledge of communication patterns between simulations and static assignment of multicast groups to these patterns. These implementations have achieved good results, but ultimately they are limited in scale because they do not account for changing connection patterns between senders and receivers.  As larger, more complex, and less predictable simulations are built, the need has arisen for more efficient use of multicast groups as they are a restricted resource. The next step in optimization is dynamic multicast grouping that adapts to connection patterns with the goal of optimizing average message delivery time. Related work [8] describes an implementation of online multicast grouping, compares the message delivery time of the resulting groupings against an offline grouping algorithm, and projects the performance impact on a production RTI.  We do not reproduce those results here, but instead focus on the formal problem of forming multicast groups.NP Completeness TheoryNP-completeness theory is concerned with decision problems.   A decision problem is defined in two parts.  The first part is a formal specification of the information (such as sets, graphs, matrices, or numbers) that is the subject of the problem.  The specification is given in precise yet general terms, for example, calling for ‚Äúa graph of n vertices‚Äù rather than some specific graph.  An instance of a decision problem is a specific set of information that complies with the information specification.  The second part of a decision problem is a question, which can be answered ‚Äúyes‚Äù or ‚Äúno‚Äù (hence ‚Äúdecision problem‚Äù), about the properties of or possible processing of an instance.  A solution to a decision problem is with respect to an instance; it is the answer, ‚Äúyes‚Äù or ‚Äúno‚Äù, of whether the instance satisfies the question.  For decision problem A, the set YA is the set of all instances of A for which the solution is ‚Äúyes‚Äù.  For an instance I of problem A, I ( YA means that the solution to instance I is ‚Äúyes‚Äù.In computational complexity theory, problems are categorized based on their upper bound on time O(f(n)), where n is the size of the instance.  Those problems where f(n) is a polynomial function on n (e.g., f(n) = n2) on a deterministic computer belong to set P.  Problems for which the time function f(n) of the best known algorithm is an exponential function on n (e.g., f(n) = 2n) belong to set NP.  (Problems in NP can be solved in polynomial time on a nondeterministic computer.)  Though it remains unproven, it is usually assumed that P ( NP, and we shall make that assumption as well.  NP-complete problems are those problems in NP such that every instance of any NP-complete problem can be transformed into an equivalent instance of any other NP-complete problem by some process that requires O(f(n)) time, where f(n) is polynomial on n.  See [6] for full detail on NP-completeness theory.Given a decision problem B, B can be shown to be NP-complete using this process:(1)	Show that B is in NP, by giving a polynomial time 	algorithm to check a solution for B.(2)	Transform a known NP-complete problem A to B.	(2a)	Define a transformation f from an instance I		of A to an instance f(I) of B.	(2b)	Show that f requires polynomial time in n,		the size of I.	(2c)	Show that I ( YA if and only if f(I) ( YB.Proving that a problem B is not NP-complete is much simpler.  Given the usual assumption that P ( NP, then B can be proven not NP-complete by exhibiting an algorithm to solve B which has upper bound O(f(n)), where f(n) is a polynomial function.NP-Completeness of DDM MatchingWe first consider the NP-completeness of the DDM matching process.  To do so, the DDM matching process must be formally defined.  In the DDM matching process the RTI determines which federates will send data to which other federates by finding overlaps (geometric intersections) among the publication and subscription regions created by the federates.  Geometrically, those regions are axis parallel d-dimensional hyper-rectangles (d-rectangles, for short).  The DDM matching process is here restated formally as the DYNAMIC RECTANGLE INTERSECTION problem.DYNAMIC RECTANGLE INTERSECTION (DRI)Instance: Dimension d ( 1; set R = {r1, r2, ..., rn} of d-rectangles (d ( 1), where initially R = (; and sequence (a1, a2, ..., an) of actions, each a 2-tuple ai = (qi, oi), where qi is a d-rectangle and oi is an operation, oi ( {insert, delete, query}, for 1 ( i ( n.  Problem:  Process each action ai = (qi, oi) in sequence from a1 to an, as follows.  If oi = insert, set R = R ( {qi}.  If oi = delete, set R = R - {qi}.  If oi = query, determine and report all d-rectangles r in R that intersect the query d-rectangle qi, i.e., all r ( R ( r ( qi ( (.The DDM operations of creating and deleting regions each consist of two DRI actions and the query action is included for both.  Therefore DRI is at least a sequence of d-rectangle intersection queries, each of which is equivalent to a single DDM matching operation.  A formal definition of this DRI subproblem is as follows:RECTANGLE INTERSECTION QUERY (RIQ)Instance:  Dimension d ( 1; set R = {r1, r2, ..., rn} of d-rectangles; and query d-rectangle q.  Problem:  Determine and report all d-rectangles r in R that intersect the query d-rectangle q, i.e., all r ( R ( r ( q ( (.For a more detailed explanation of the equivalence of these formal problems to the DDM matching process, see the companion paper [9].  We now use these problems for the result.Theorem 1.  The DDM matching process is not NP-complete.Proof.  RIQ can be solved by the following naive algorithm:  test the query d-rectangle q for intersection with each of the d-rectangles r in set R = {r1, r2, ..., rn}.  Each intersection test requires time in O(d), by the algorithm given in figure 3-1, so the total time required for this algorithm is in O(dn).  However, because d is a constant for any specific instance of RIQ, O(dn) ( O(n), i.e., RIQ ( O(n).  DRI consists of n executions of RIQ, so DRI requires time ( O(n2), which is a polynomial function on n.  Therefore DRI ( P, and under the usual assumption that P ( NP, DRI is not NP-complete.  ‚ñ†Note that O(n) is an upper bound for a single DDM matching and O(n2) is an upper bound for the overall DDM matching process during a federation execution. REF _Ref487280659 \h  \* MERGEFORMAT Figure 31 describes the O(d) algorithm to determine if two d-rectangles intersect mentioned in the proof.  Given two d-rectangles r1 and r2, let ri.aj and ri.bj denote the smaller and larger endpoints, respectively, of the side of ri parallel to axis j.j = 1result = truewhile (result = true) and (j ( d) do    if  (r1.aj ( r2.aj and    r2.aj ( r1.bj) or        (r2.aj ( r1.aj and    r1.aj ( r2.bj)        j = j + 1    else        result = false    endifendwhileFigure  STYLEREF 1 \s 3 SEQ Figure \* ARABIC \s 1 1.  O(d) Algorithm for d-rectangle Intersection CalculationNP-Completeness of DDM Multicast GroupingWe now consider the NP-completeness of the multicast grouping solution for DDM.  Note that we are addressing the NP-completeness of a particular solution to the conceptual process, connecting, not the NP-completeness of the entire connecting problem.Using the conventions of NP-completeness theory, we define the decision problem MULTICAST GROUPING as follows:MULTICAST GROUPING (MG)INSTANCE:  Set of connections C = {c1, c2, ‚Ä¶, cn}, weights w(c) ( Z+ for every c ( C, positive integer m, and positive integer t.QUESTION:  Is there a partition of C into disjoint subsets G1, G2, ‚Ä¶, Gm such that	(	w(c) ( |Gi| ( t  for 1 ( i ( m?	c ( GiThis decision problem represents, in a formal and abstract way, the grouping problem inherent in the multicast approach to establish connections in DDM.  The weights w(c) represent the amount of data sent on each connection, considering data length and send frequency.  Integer m is the number of available multicast groups and integer t is the maximum amount of data that can be sent using a group to each group member before the maximum data send time will be exceeded for some member of the group.We will prove that MULTICAST GROUPING (MG) is NP-complete by a fairly simple transformation from the problem 3-PARTITION (3P), i.e., we will show 3P ( MG.  The problem 3P is defined as follows [6]:3-PARTITION (3P)INSTANCE:  Set A of 3m elements, a bound B ( Z+, and size s(a) ( Z+ for each a ( A such that B/4 < s(a) < B/2 and such that	(	s(a) = mB.	a ( AQUESTION:  Can A be partitioned into m disjoint sets A1, A2, ‚Ä¶, Am such that for 1 ( i ( m,	(	s(a) = B	a ( Ai (note that each Ai must therefore contain exactly three elements from A)?3P is known to be NP-complete (by transformation from 3-DIMENSIONAL MATCHING) [5].  In fact, 3P is NP-complete in the strong sense, which means that there is no pseudo-polynomial algorithm for 3P, unless P = NP [6].Theorem 2.  MG is NP-complete.Proof.  By transformation from 3P, i.e., 3P ( MG.  First it must be shown that MG is in NP.  Given a partition of C into disjoint subsets G1, G2, ‚Ä¶, Gm, check each Gi for 1 ( i ( m to confirm that	(	w(c) ( |Gi| ( t for 1 ( i ( m.	c ( GiTo do so requires accessing and summing each connection c ( G1 ( G2 ( ‚Ä¶( Gm exactly once, along with m multiplications and comparisons.  This process is clearly in O(n), i.e., polynomial in n, so MG is in NP.We now define the transformation f from any instance of I of 3P to an instance f(I) of MG.  Given any instance I of 3P as defined, for f(I), C = A (( n = 3m), w(ci) = s(ai) for 1 ( i ( 3m = n, m (of f(I)) = m (of I), and t = 3B.  The transformation clearly requires O(n) time, i.e., is polynomial in n.It must now be shown that for a given instance I of 3P, A can be partitioned into m disjoint sets A1, A2, ‚Ä¶, Am such that for 1 ( i ( m,	(	s(a) = B	a ( Aiwith exactly 3 elements each if and only if for the transformed instance f(I) of MG, C can be partitioned into disjoint subsets G1, G2, ‚Ä¶, Gm such that	(	w(c) ( |Gi| ( t for 1 ( i ( m	c ( Gii.e., I ( Y3P if and only if f(I) ( YMG.(Only if)  Assume I ( Y3P.  Then A has been partitioned into m disjoint subsets A1, A2, ‚Ä¶, Am such that	(	s(a) = B for 1 ( i ( m.	a ( AiIt must be shown that f(I) ( YMG.  Partition C into disjoint subsets G1, G2, ‚Ä¶, Gm such that G1 = A1, G2 = A2, ‚Ä¶, Gm = Am.  Recall that w(ci) = s(ai) for 1 ( i ( 3m = n and that |Ai| = 3 for 1 ( i ( m.  Then	(	w(c) ( |Gi| = B ( 3 = t for 1 ( i ( m	c ( Gimeeting the condition for a valid partitioning of C.  Therefore I ( Y3P ( f(I) ( YMG.(If)  Assume f(I) ( YMG.  Then C has been partitioned into disjoint subsets G1, G2, ‚Ä¶, Gm such that	(	w(c) ( |Gi| ( t for 1 ( i ( m.	c ( GiIt must be shown that I ( Y3P.  Partition A into disjoint subsets A1, A2, ‚Ä¶, Am such that A1 = G1, A2 = G2, ‚Ä¶, Am = Gm.  Consider the sizes of the subsets G1, G2, ‚Ä¶, Gm.  We will show that |Gi| = 3 for 1 ( i ( m.  Recall that w(ci) = s(ai) and that B/4 < s(ai) < B/2 for 1 ( i ( 3m = n.  Suppose one of the subsets, say Gj, has more than 3 elements, i.e., |Gj| ( 4.  Then	(	w(c) ( |Gj| ( 4B	c ( Gjbecause there are at least 4 weights w(c) in the summation, each weight w(c) > B/4, and |Gj| ( 4 by assumption.  But 4B > 3B = t, which contradicts the assumption that f(I) ( YMG.  Similarly, suppose one of the subsets, say Gj, has less than 3 elements, i.e., |Gj| ( 2.  Then	(	w(c) ( |Gj| ( 2B	c ( Gjbecause there are at most 2 weights w(c) in the summation, each weight w(c) < B/2, and |Gj| ( 2 by assumption.  But 2B < 3B = t, which again contradicts the assumption that f(I) ( YMG.  Therefore, |Gi| = 3, and thus by transformation f |Ai| = 3, for 1 ( i ( m.We now show that	(	w(c) = B for 1 ( i ( m.	c ( GiRecall that that for any instance I of 3P (not just those instances in Y3P)	(	s(a) = mB.	a ( ATherefore, because w(ci) = s(ai) for 1 ( i ( 3m = n,	(	w(c) = mB.	c ( CBy definition, for any instance f(I) ( YMG, it is known that	(	w(c) ( |Gi| ( t for 1 ( i ( m.	c ( GiBut |Gi| = 3 for 1 ( i ( m, so dividing both sides of the summation by |Gi| gives	(	w(c) ( t/3 for 1 ( i ( m.	c ( GiBy transformation f, t = 3B, so t/3 = B, and therefore	(	w(c) ( B for 1 ( i ( m.	c ( GiNow suppose one of the sets, say Gj, was such that	(	w(c) < B.	c ( GjBut there are m subsets G1, G2, ‚Ä¶, Gm and the total weight of all the sets‚Äô elements is mB.  If Gj has weight sum < B as assumed, then one of the other sets, say Gk, must have weight sum > B so that the total will be mB.  This contradicts the assumption that f(I) ( YMG.  Therefore	(	w(c) = B for 1 ( i ( m	c ( Giand thus by transformation f	(	s(a) = B for 1 ( i ( m	a ( AiThis, together with the fact that |Ai| = 3 for 1 ( i ( m, meets the condition for a valid partitioning of A.  Therefore f(I) ( YMG ( I ( Y3P.Thus I ( Y3P if and only if f(I) ( YMG, and therefore MG is NP-complete.  ‚ñ†ConclusionsWe have shown that the DDM matching process is not NP-complete by exhibiting a naive polynomial time algorithm for the process.  We have also shown that the multicast grouping approach to the DDM connecting process is NP-complete by transformation from 3-PARTITION, a known NP-complete problem.It is important to note that approaches to the DDM connecting process other than multicast grouping may be possible, and Theorem 2 does not necessarily apply to those approaches.  The result does not prove or disprove the NP-completeness of the general DDM connecting process.References[1]	Dahmann, J. S., Kuhl, F., and Weatherly, R. (1998).  ‚ÄúStandards for Simulation:  As Simple as Possible But Not Simpler:  The High Level Architecture for Simulation,‚Äù Simulation, Vol. 71, No. 6, December 1998, pp. 378-387.[2]	Defense Modeling and Simulation Office (1998a)  ‚ÄúDepartment of Defense High Level Architecture Rules, Version 1.3,‚Äù February 5 1998, Online document at http://hla.dmso.mil/hls/tech/rules/.[3]	Defense Modeling and Simulation Office (1998b)  ‚ÄúDepartment of Defense High Level Architecture Object Model Template, Version 1.3,‚Äù February 5 1998, Online document at http://hla.dmso.mil/hls/tech/omtspec/.[4]	Defense Modeling and Simulation Office (1998c)  ‚ÄúDepartment of Defense High Level Architecture Interface Specification, Version 1.3,‚Äù April 2 1998, Online document at http://hla.dmso.mil/hls/tech/ifspec/.[5]	Garey, M. R. and Johnson, D. S. (1975).  ‚ÄúComplexity results for multiprocessor scheduling under resource constraints‚Äù, SIAM Journal of Computing, Vol. 4, pp. 397-411.[6]	Garey, M. R. and Johnson, D. S. (1979).  Computers and Intractability, A Guide to the Theory of NP-Completeness, Freeman, New York NY, 1979.[7]	Morse, K.L.; and J.S. Steinman. (1997).  ‚ÄúData Distribution Management in the HLA:  Multidimensional Regions and Physically Correct Filtering‚Äù, Proceedings of the 1997 Spring Simulation Interoperability Workshop, Orlando FL, March 3-7 1997, pp. 343-352.[8]	Morse, K.L. (2000).  ‚ÄúAn Adaptive, Distributed Algorithm for Interest Management.‚Äù Ph.D. Dissertation, University of California, Irvine, May 2000, available at http://www.npsnet.org/~zyda/Theses/Katherine.Morse.pdf.[9]	Petty, M. D. (2000).  ‚ÄúGeometric and Algorithmic Results Regarding the HLA and Data Distribution Management Matching Process‚Äù, Proceedings of the Fall 2000 Simulation Interoperability Workshop, Orlando FL, September 17-22 2000.Author BiographiesMIKEL D. PETTY is Chief Scientist of the Virginia Modeling, Analysis & Simulation Center at Old Dominion University.  Prior to that he was an Assistant Director of the Institute for Simulation and Training of the University of Central Florida.  He received a Ph.D. in 1997, an M.S. in 1988, and a B.S. in 1980, all in computer science.  Dr. Petty‚Äôs research interests include distributed simulation, computer generated forces, and multi-resolution simulation; he has published over 75 papers in these areas.  He is currently a member of the National Research Council Committee on M&S for the 21st Century Manufacturing and Acquisition.KATHERINE L. MORSE is a Senior Computer Scientist with SAIC.  She received her B.S. in mathematics (1982), B.A. in Russian (1983), M.S. in computer science (1986) from the University of Arizona, and M.S. (1995) and Ph.D. (2000) in information & computer science from the University of California, Irvine.  Dr. Morse has worked in industry for over 20 years in the areas of simulation, computer security, compilers, operating systems, neural networks, speech recognition, image processing, and engineering process development.  Her Ph.D. dissertation is on dynamic multicast grouping for Data Distribution Management, a field in which she is widely recognized as a foremost expert. Problems of other types, such as subset selection or optimization, can generally be shown to be no easier than their corresponding decision problems, so proofs about the difficulty of the decision problems apply to the other types as a lower bound.  Surprisingly, in many cases problems of the seemingly more difficult types can also be shown to be no harder than their corresponding decision problems. Because NP-complete is a set of problems it is perhaps more precise to say ‚Äúproblems in NP-complete‚Äù than ‚ÄúNP-complete problems‚Äù.  However, the latter formulation is ubiquitous and we will follow the convention. A more detailed presentation of the problem may be found in [8].