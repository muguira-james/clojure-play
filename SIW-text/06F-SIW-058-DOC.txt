Development of a Testing Environment for the HLA-Evolved Web-based APIChristopher McDonaldJohn SchlomanJonathan LabinJohns Hopkins University Applied Physics Laboratory11100 Johns Hopkins RoadLaurel, MD 20723(443-778-6648, 443-778-0626, 443-778-7111443) 778-6648Christopher.McDonald@jhuapl.edu, John.Schloman@jhuapl.edu, Jonathan.Labin@jhuapl.eduKeywords:HLA, IEEE 1516-EvolvedJohn SchlomanJohns Hopkins University Applied Physics Laboratory11100 Johns Hopkins RoadLaurel, MD 20723(443) 778-0626 HYPERLINK "mailto:John.Schloman@jhuapl.edu" John.Schloman@jhuapl.eduJonathan LabinJohns Hopkins University Applied Physics Laboratory11100 Johns Hopkins RoadLaurel, MD 20723(443) 778-7111 HYPERLINK "mailto:Christopher.McDonald@jhuapl.edu" Jonathan.Labin@jhuapl.edu, WSDL, Web ServicesABSTRACT: A major feature of the High Level Architecture (HLA) Evolved Application Programming Interface (API) beyond those of IEEE 1516-2000 is the availability of a Web-based API utilizing Web Services Description Definition Language (WSDL). As part of our Run-Time Infrastructure (RTI) verification effort at the Johns Hopkins University Applied Physics Laboratory (JHU/APL) sponsored by the Defense Modeling and Simulation Office (DMSO), our work includes preparation for the next generation of RTIs implementing any of the APIs of HLA-Evolved. This paper describes our modeling and development effort, in coordination with Pitch Technologies, in creating a testing environment for the HLA-Evolved Web-based API.IntroductionIn preparation for the introduction of the IEEE 1516-Evolved specification, the Runtime Infrastructure (RTI) verification team at the Johns Hopkins University Applied Physics Laboratory (JHU/APL) is making preparations for the arrival of the first IEEE 1516-Evolved RTI that utilizes the Web Services Description Language (WSDL) Application Programming Interface (API). ThisThis includes preparation consists of gaining an a better understanding of the changes to the RTI Verifier required by using to support web services rather than multicast communication and exploring the policy issues involving involved when introducing web services in a corporate computing environment RTIs.RTI Verifier Design and EvolutionIn order to understand the technical issues introduced by the WSDL API, it is helpful to first understand the current design of the RTI Verifier. The RTI Verifier has three parts: the test controllerTest Controller, the launcherLauncher, and the test federateTest Federate. Test ControllerThe test controllerTest Controller is the Graphical User Interface (GUI) used by the RTI verification team to control select which tests are being to run on against the target RTI, to adjust global settings such as callback and invoke wait times, and to see monitor the success or failure of the tests being run on the RTIcurrently executing. The test controllerTest Controller does not directly interact with the RTI as a federate. It is instead responsible for communicating to directing the actions of the launcherLauncher a when to start and stop the RTI and the test federates, and communicating to the test federatend each of the Test Federates (both described in the following sections). s each step of each test. All theThese messages se communications are sent via Java Remote Method Invocation (RMI) [1]. Although changes will have to be made to the test controllerTest Controller in order to handle some of the features introduced in IEEE 1516-Evolved, no changes are anticipated to specifically support for use with the WSDL API.LauncherThe launcherLauncher is responsible for starting and stopping the RTI and each of the test federateTest Federates. The launcherLauncher process must be running on the machine that hosts the RTI so that it can be started and stopped the RTIon command. The launcherLauncher process must also be running on each machine that will be running a test federateTest Federate for the verification. A slight change may be required to the launcherLauncher so that it can be used for testing a web service RTI. Normally, when an RTI fails a test, the RTI is shut down and restarted to ensure that no internal state is left behind from the test failure. With a web service RTI, it will not be possible for a aconsumer of the web service  client to stop and restart the service it unless it is deployed locally. This will be discussed later. Test FederateThe third part of the RTI Verifier is the test federateTest Federate. Test federates Federates are started by the launcherLauncher and communicate directly with the RTI under the direction of the test controllerTest Controller, which is reading the test scripts. The test federateTest Federate invokes services on the RTI by calling methods on the RTIambassador and receives callbacks from the RTI when through methods are called onof its federateAmbassador [2]. Currently, there areis a Java and a C++ Test Federate class for each of the existing HLA specifications -  four in all.different Test Federate classes. For each previous HLA specification  the first acts as a Java federate and the second acts as a C++ federate.  So far, there are different test federates for each combination of HLA specification and API, with eachEach Test Federate has combination having its own an  RTIambassador/federateAmbassador pair for communicating interfacing with the RTI. All Test Federates are executed as Java processes, but those that interface with C++ RTI bindings use adaptor libraries called “Caps”, which are Code related to adapting ambassadors to non-Java APIs is stored in Java Archives (JARs). called “capsCaps”.The web service API will necessitate the creation of a WSDL test federateTest Federate, new ambassador classes for communicating interfacing with the RTI, and a new capCap. The interaction between the test controllerTest Controller and the test federateTest Federate will remain unaltered regardless of whether thewhich C++, the Java, or the WSDL test federateTest Federate is is being used; only the interaction between the test federateTest Federate and the RTI will differ according to the API-specific ambassador classes used.Communication wwith a Web Service RTIIn all previous HLA APIs,  other than the new web service API, the RTI and the federates communicate via ambassador classes. Each federate invokes services on the RTI by calling methods on its local RTIambassador; the RTI sends callbacks to a federate by calling methods on its the provided federateAmbassador [2]. Although the WSDL API does not technically need to have andis not defined to require the use of an RTIambassador and a federateAmbassador, the RTI Verifier is designed to operate with ambassadors. The WSDL federate used for verification will use ambassador classes that wrap the web service and integrate with the test controllerTest Controller.WSDL RTIambassadorThe design of a WSDL RTIambassador is straight forward. Because the RTI will be a web service, the RTIambassador simply needs to “consume the web services.” In order to do this, the WSDL describing the services provided by the RTI will be used to generate a Java stub class representing the RTI web service. This will be done using the WSDL2java tool provided by Apache Axis [3]. This tool will also automatically create generate classes representing each parameter type, return type, and fault type associated with the services provided by the web service RTI. The new RTIambassador class will simply wrap the generated Java stub and applying the type conversions required for each messages.. generated from the WSDL and provide an interface similar to that of the Java RTIambassador. WSDL federateAmbassadorThe design of the federateAmbassador is not as straight forward as the designslightly more complex than that of the RTIambassador. In other previous HLA APIs, the RTI makes callbacks on a federate according to one of two models: synchronous or asynchronous [2]. In the synchronous callback model, the RTI only makes callbacks on the federateA ambassador when the federate invokes theduring invocations of the evokeCallback or evokeMultipleCallbacks services on the RTIby the federate. This is due to the fact that the federate and the Local RTI Component (LRC) run in the same thread. If the federate does not call evokeMultipleCallbacksone of these services, no CPU time is the thread of control is not given to the Local Runtime Component (LRC) of the RTI to receive process and deliver callbacks. In the asynchronous callback model, the RTI may make callbacks at any time because the LRC runs in its own thread and does not need require that the federate to give up the thread of control to the LRC to receive callbacks. In the web service API, however, there is a difference. Web services use a Service Oriented Architecture (SOA) in which a service requester consumes a web service by calling its services (like methods) on the web service [4]. This architecture does not allow for the web service provider to initiate any sort of interaction with the consumer. Because web services can only respond to calls and provide return values, the  implementation of either of the aforementioned callback models within a web service RTI would not only require the RTIambassador to be implemented as a web service, but the federateAmbassador as well. Otherwise, there would be no way for the RTI to make a callback on the federate synchronously or asynchronously. In order to avoid having requiring federate implementers to develop to implement federates as web services, the new web service API adopts a variation of the synchronous callback model in which the web service RTI will send callbacks to the federate as a return value from evokeMultipleCallbacks [5]. As a result, the WSDL Test Federate will create a child thread that  federateAmbassador will be designed to run in its own thread and continuallyperiodically calls evokeMultipleCallbacks on the RTI web service stub. Each call to the evokeMultipleCallbacks service will return an array of callback objects. The type of callback will be determinedcallback objects will be processed and the data extracted from each callback object will be processed.delivered to the verifier’s implementation of the Java API federateAmbassador.WSDL CapCombined together with supporting classes, tThe code for the new RTIambassador and federateAmbassador will be stored in form the IEEE 1516-Evolved WSDL cap CapJAR file, which will be included in the Java classpath when the WSDL test federateTest Federate is in use.Local vs. Remote VerificationVerification of allBeyond the modifications to the RTI Verifier software, the introduction of web service RTIs opens the door to new processes for verification, since the RTI no longer needs to be on the same Local Area Network (LAN) as the federates.The process of verifying a anon-web service n RTIs has always involved threquirese a vendors sending to send their the RTI to the verification team at the JHU/APL campus. There, t where he RTIit is installed on a private Local Area Network (LAN)network whereand the RTI Verifier runs a series of tests to verify confirm that the RTIit conforms to the claimedapplicable HLA specification (Local Verification).  . However, as web service RTIs do not require any client-side libraries for the execution of federates, remote verification becomes a possibility.  As remote verification poses a distinct shift from the current local verification procedures, the following sections explore the issues involved with each.Now, with the possibility of RTIs running as web services, an alternative to local RTI verification exists. Instead of the vendor sending the RTI to the JHUAPL campus, the RTI Verifier could connect directly to the RTI web service running at the vendor’s location. At JHUAPL, the verification team responsible for testing and verification of RTIs considered this new possibility of remote verification in comparison to local verification at the JHUAPL campus.Local VerificationThe firstOne approach that may be taken to verifyying RTIs usingproviding the WSDL API is to is to have the RTIs sent to the JHUAPL campus to be installed and run locally as beforeprocess them similarly to non-web service RTIs. This allows the verification process to occur on aa private network in a closed laboratory. This approach is consistent with how the other APIs are verified, and gives the RTI verification team full control over the process of installing, running, and and restarting the RTI to clear it of any collected internal state left behind by test failures. This control is also useful if the RTI prints an error message to the screen or to a file. The ability to see the error and know what was being done to the RTI when the error occurred can sometimes be helThis information can be compared to the current output of the RTI Verifier bypful to the verification team to aid in analysis. However, the main drawback of this method of verification is that the RTI is not running in its native environment.  Web services are designed to communicate over the   Iinternet. Furthermore, a vendor may choose not to distribute the RTI software to customers, but instead provide access to its RTI web service running in a single location. Installing such an RTI on a private network at JHU/APL for verification is not the ideal way to test the RTI may not be in line with the vendor’s business model. Remote VerificationThe ability to verify an RTI by the connection of the RTI Verifier to a remote web service RTI seems promising because it allows the RTI to run at the vendor’s location, and in a manner that better simulates the eventual use of the RTI (over the internetRemote verification avoids the above issues by allowing the RTI vendors to control the access to and execution of their web service RTI).  This alternative also has the cost aAdditionally,dvantage that the verification team is no longer responsible for the installation and configuration of the RTI.  The RTI vendor could set their desired configuration for verification.; that responsibility would be back in the hands of the vendor who already has full knowledge of how the RTI should be configured. There are also two potential avenues of managing Rremote verification and the amount of human-in-the-loop intervention needed could be done in one of two ways:  manuall or automated control. Manual Remote Verification	The first option is for the verification team to manually run the RTI Vverifier at the JHU/APL campus upon request by thea vendor. and have itThe RTI Verifier would connect to the RTI web service deployed at the vendor’s site. With this approach the verification team loses the capability to stop and restart the RTI ifwhen an error occurs. With the loss of this capability, an RTI that retains internal state pollution after a test failure could fail subsequent tests as a result, and there would be no convenient way for the verification team to intervene. If the only change to the RTI Verifier is the added capability to consume a web service RTI deployed at the vendor’s site, an awkward circular dependency will form between the responsibilities of the verification team and those of the vendor. The verification team will still be responsible for manually running the RTI Verifier, but the responsibilities of troubleshooting RTI problems or restarting the RTI upon test failures will fall on the vendor. Each time a problem with the RTI occurs, the verification team is stuckcannot make further progress until the vendor can be contacted and their RTI restartedand told to restart the RTI or check the error logs. Synchronization of the RTI verification team and the RTI vendors during verification This could potentially be a very ccostly and inefficient way synchronization of the RTI verification team and the RTI vendors during to verifyication web service RTIs. Automated Remote Verification ServiceAA more desirable alternative is to makellternatively the RTI verifier could be modified to run as its owna a web service in which vendors can select the tests they want to run, and get receive the results back. The responsibility of RRTI troubleshooting would then be verification would be at the control on the of the RTI vendor, which is appropriate since the vendor would be able to see the RTI error logs and the tests that caused them. The responsibility of restarting the RTI if there is an error would also rest on the vendorVendors would have the ability to restart their RTI and re-execute tests as they please. The awkward dependency present in the manual remote verification approach would not be an issue in this automated approach because the vendor would be running the tests and troubleshooting the RTI, wNo communication with the verification team during test re-execution would be neededith no need to wait on the verification team. The verification team’s focus would shift towards  would be responsible forthe  maintaininmaintenanceg of the RTI Verifier software rather than troubleshooting RTI errors. This approach wouldmay need to be tailoredadapted to comply with to matchnondisclosure agreements and the export control policies of the Department of Defense.  Available solutions include may run into policy issues with the sponsor. The RTI Verifier is funded by DMSO for the purpose of verifying RTIs used by the Department of Defense; it is not in their interest to make the RTI Verifier publicly available for all vendors everywhere. Either a password access  would be required for the vendor to have access to the RTI Verifier web service or a proxy server would be used to allow onlyallowing  approved vendors to test their RTIs.Another policy issue that could arise when dealing with remote verification is the fact that vendors could potentially capture all the test scripts as the calls are received by the RTI web service. Under the local verification process already in use for all other APIs, the vendors are already given the scripts for the failing tests in the error reports. If a vendor were to capture the test scripts during the verification of the web service RTI, the only difference would be that the vendor would be able to see the tests that their RTI already passed. With this in mind, these policy issues should not create an insurmountable barrier to RTI Verifier web service approach.If all policy issues can be resolved, the RTI Verifier web service is the superior approach would allow all parties to focus on their primary interests.  RTI vendors would have immediate feedback concerning the current status of their implementation and could integrate it into their development process.  The RTI verification team could focus on enhancements and improved efficiency of the RTI Verifier. If the issues cannot be resolved, or the cost of adapting the RTI Verifier to be a web service and deploying it is too high, the only reasonable alternative is local verification on a private network at the JHUAPL campus.ConclusionThe three presented options of web service RTI verification (local, manual remote, and automated remote) form a scale of increasingly complex features.  There exists a balance between these features and their utilization by the RTI vendor community.  The optimal choice would be the solution that best fits within the interests of the HLA user community involving web service RTIs.As the verification team at JHU/APL prepares for the arrival of the first IEEE 1516-Evolved RTI to be tested, development has begun to prepare the RTI Verifier for the new WSDL API introduced in the new specification. This work involves changes to the RTI Verifier’s launcherLauncher component and the writing of a new WSDL test federateTest Federate to support interaction with the RTIs providing a web service interface API. Depending on cost and policy decisions made by DMSO, a method for remote verification of web service RTIs may be available in the future.ReferencesSun Developer Network (SDN) Java “RMI Specification”, Internet http://java.sun.com/j2se/1.4.2/docs/guide/rmi/spec/rmiTOC.htmlIEEE 1516-Evolved Specification, Draft 2.The Apache Software Foundation, “Axis User’s Guide Version 1.2”, Internet http://ws.apache.org/axis/java/user-guide.htmlWorld Wide Web Consortium “ (2001), Web Services Description Language (WSDL) 1.1”, Internet http://www.w3.org/TR/wsdlB. Möller, Björn:. “Introduction to the HLA Evolved Web Service” Euro Simulation Interoperability Workshop 2006.Author BiographiesCHRISTOPHER MCDONALD is a Software Engineer at the Johns Hopkins University Applied Physics Laboratory where he works in Modeling and Simulation. In 2000, he completed a Bachelor’s degree in Mathematics/Computer Science at Wheaton College in Illinois. He is currently working on a Master’s in Computer Science at the Johns Hopkins University Whiting School of Engineering.JOHN SCHLOMAN is a Software Engineer at the Johns Hopkins University Applied Physics Laboratory.  In 2003 he completed his Master's in Computer Science at Michigan State University.  In 2001 he received a degree Cum Laude in Systems Analysis from Miami University in Oxford, Ohio.   JONATHAN W. LABIN is a Software Engineer at the Johns Hopkins University Applied Physics Laboratory.  Mr. Labin has developed several HLA federations including the Human Exercise Federation. In addition, he has evaluated several commercial RTIs with respect to their compliance with regard to both the compliance of several commercial RTIs with both the HLA 1.3 and HLA IEEE 1516 standards. In 2003, he received a degree Magna Cum Laude in Computer Science at the University of Maryland Baltimore County. Distribution Statement A, Approved for Public Release: Release is UnlimitedWhat does this mean?File? Stream? Does this have a name?True?The paragraph removed here seems to raise an issue and then dismiss it’s own argument as not being too much of a concern.Add Bio