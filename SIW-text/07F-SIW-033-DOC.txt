Employing Future Path Information to Improve Position Accuracy in Distributed SimulationsDavid W. MutschlerNaval Air Systems Command (NAVAIR) Integrated Battlespace Simulation and Test (IBST) DepartmentBattlespace Modeling and Simulation Division (Code 5.4.2) 48150 Shaw Rd.  Bldg 2109, S115, Patuxent River, MD 20670david.mutschler@navy.milKeywords:IBST, ACETEF, JIMM, Path Information, Position, OrientationABSTRACT:  Periodic output of entity position and orientation information can produce errors when the data must be extrapolated for times other than the time of update.  Dead reckoning algorithms can mitigate the problem, but may not be fully applicable in all cases.  If the algorithm for following a waypoint path is well known, then providing that path to interested parties would significantly reduce this type of error since an exact position and orientation can be determined for any specific time.  This paper will discuss an approach for transferring path information used within the Naval Air Systems Command (NAVAIR) Air Combat Environment Test & Evaluation Facility (ACETEF).The NAVAIR Integrated Battlespace Simulation and Test DepartmentThe Naval Air Systems Command’s (NAVAIR) Integrated Battlespace Simulation and Test (IBST) Department conducts ground-based test of naval avionics systems, weapons systems, and platforms.  Within its facilities, simulators and stimulators are used to provide immersive realistic environments to Systems Under Test (SUTs).  These include stimulators for radar frequencies, ultraviolet, various types of communication, infrared, and Global Positioning System (GPS) emissions.  Modeling and Simulation (M&S) is very important to this work.  Modeling and Simulation (M&S) is a necessary component to bring these stimulators together in a coherent environment.IBST is comprised of a number of Installed System Test Facilities (ISTFs) throughout the nation.  These facilities include the Radar Reflectivity Laboratory (RRL) in Pt. Magu, California, the Missile Engagement Simulation Arena (MESA), the Integrated Battlespace Arena (IBAR) in China Lake, California, the Surface/Aviation Interoperability Laboratory (SAIL) and the Air Combat Environment Test and Evaluation Facility (ACETEF) in Patuxent River MD.  These sites are geographically distant and hence interoperate among themselves and other agencies via wide area protocols such as the Distributed Interoperability Simulation (DIS), High Level Architecture (HLA), and the Test and Training Enabling Architecture (TENA).ACETEF itself includes two aircraft-sized anechoic chambers, (the Advanced Systems Integration Laboratory (ASIL) and the Aircraft Anechoic Test Facility (AATF)), eight highly realistic virtual cockpits in the Manned Flight Simulator (MFS), the Warfare Simulation Laboratory (WSL), and a large number of other laboratories.Simulated Warfare Environment Data TransferThe laboratories and facilities within ACETEF often intercommunicate using a reflective shared memory protocol known as Simulated Warfare Environment Data Transfer (SWEDAT).  Each interconnected simulator or stimulator in an integrated exercise employs shared memory.  Whenever one simulator updates their shared memory, the updates are echoed to the other connected stimulators and simulators.Figure  SEQ Figure \* ARABIC 1 -- Reflective Shared MemoryStimulators communicate via SWEDAT either directly or more commonly through interface programs.  Different interface programs can also send and receive information externally to ACETEF using different protocols such as DIS, HLA, or TENA.In SWEDAT, queues are implemented atop the shared memory to allow transfer of messages between interoperating stimulators and simulators (a.k.a. “assets”).  However, position and orientation information is provided given a Cartesian coordinate system within a block of shared memory specific to the platform.  This information is updated periodically.  Interfaces are expected to poll the blocks to obtain changes.  The simulation game time of the last update is provided to allow interfaces to determine if the information has changed.  If the time has changed, then the position update is more recent.Unfortunately, this method allows for a number of different types of errors.First, the data is only guaranteed to be correct for the update time.  Whenever a position is required for a later time, it must be extrapolated from the position, velocity, and acceleration information provided.  Unfortunately, if this data is changing, this can result in a “see-saw” effect where dead reckoning is employed and then the platform “leaps” to a corrected position once the next update in shared memory occurs. SHAPE  \* MERGEFORMAT Figure  SEQ Figure \* ARABIC 2 -- Dead Reckoning and Actual PositionIn SWEDAT, update rates can be made specific to platform types.  However, increasing the update time alleviates but does not eliminate the “seesaw” problem.  For example, high velocity objects are commonly updated in SWEDAT at a rate of 10 Hz.  However, visual generators such as those employed at the ACETEF Manned Flight Simulator may operate at 60 Hz.  Increasing the update to this level is possible.  However, each update results in additional messages and overhead through the network.  Hence, in practice, increasing the update rate of SWEDAT to this level can overly burden the system.  Also, instead of leaping to the corrected position, the platform can be moved gradually from the previously dead reckoned position [1].  However, there are still inaccuracies between the actual and adjusted positions.Another, but less significant source of error is the time required for a simulator controlling a platform’s position to provide an update.  In a local environment such as ACETEF, this is a small but non-zero delay.  However, when platforms in a simulation exercise are controlled by distant facilities, this delay can be significantly larger. Lastly, by design, SWEDAT does not guarantee that updates of position information will be atomic.  Hence, it is possible that interleaving of operations may result in an X and Y position from a new update being read along a Z position from a previous update.  In the early days of SWEDAT development, it was determined that the cost in performance to provide protection for atomic updates was more costly than was warranted by the loss of accuracy.  Moreover in practice, this type of error is very rare.  Even so, it is still possible.In ACETEF, a threat generator known as the Joint Integrated Mission Model (JIMM) is commonly used to simulate platforms in a real-time simulation exercise [2].  JIMM is a general-purpose, real-time, multi-threaded [3], object-oriented discrete event simulator implemented in the C++ programming language.  JIMM has been used for many purposes such as goal-oriented human performance [4], human behavior modeling [5], weather simulation [6], radar simulation [7], and swarms of unmanned air vehicles [8]. JIMM also acts as the SWEDAT controller allocating the shared memory for its own use or for use by other interfaced programs.Employing Future Path InformationWhen using a threat generator such as JIMM, platforms interoperating via SWEDAT are either controlled by the threat generator or controlled by external agents.  When controlled by JIMM, platforms move along paths generated either at the start of the simulation run or along paths generated dynamically in response to a threat or programmed action.  In either case, for these platforms, path information specifying position and orientation at a future time is available.Hence, instead of sending periodic position updates through the shared memory platform block, this future path information could be bundled and sent as a message to the interfaces.  The interface program could then employ this path information to interpolate the exact position and orientation of a platform at a given time.  This would result in improved accuracy.Path information for platforms would be sent to interfaces during simulation initialization.  The information would also be sent when platforms are created in an exercise and when paths change (e.g. when platforms move to attack a recently perceived target).For JIMM and SWEDAT, this approach is facilitated by several factors.  First, position and orientation are provided within two classes: TPathEntry and TOrientElement respectively.  This information could be readily encapsulated in a message and transmitted.  Also, as part of its distribution, JIMM includes a library known as “jimmlib” for use by SWEDAT interfaces.  The procedures used to interpolate information within JIMM could be extracted from its classes and made available to interfaces as part of that library.  In addition, the distribution also includes a number of standalone “example” interfaces.  Though these interfaces act independently, they still show how information transmitted through SWEDAT can be retrieved and how it could be employed.Position InformationPaths in JIMM are constructed for real-time operation.  For this reason and as a compromise between speed and fidelity, paths are constructed as a series of lines and circular arcs.  These are simple and well-known structures that reasonably approximate actual paths but can also provide information with little calculation.Using the JIMM simulator, path information from the TPathEntry class was encapsulated into messages and transmitted via a queue in SWEDAT to an interfaced program.  Information in the message includes the player platform’s global id (for identification) as well as specific data about each of the path waypoints.  This includes position coordinates, the unit direction vector from that position, speed, turn radius, arrival time at the point, departure time, terrain elevation, and flags.struct sh_mem_pathentry {    // location in (m) from center of scenario    double pos_x, pos_y, pos_z;    // unit direction vector    double dir_x, dir_y, dir_z;    double speed; // (m/sec)    double arrive; // in seconds from start of scenario    double depart; // in seconds from scenario start    double terrain_ht; // in (m)    int flags;    int Next;  // next pathentry on Path (as index)}; Figure  SEQ Figure \* ARABIC 3 – Transmitted Waypoint InformationIf the turn radius is zero (0), then the two points are traversed by a straight line.  Otherwise, a platform traverses a circular arc.  In the most common case where the segment is a line or where the arc is short (the angle from the center is less than or equal to 180 degrees), the unit direction vector corresponds to the unit vector of the velocity at that waypoint.  Otherwise, the unit direction vector is the opposite of the unit velocity vector.  Given an initial point, the direction vector at that point, the following point, and the turn radius, the center of the circular arc can be calculated.  From this, the course of the arc as well as the overall traversed distance between the points can also be determined.Separate arrival and departure times are provided for cases where the platform lingers at a point for some time (e.g. a bus at a stop).  The terrain height (terrain_ht) is provided where the z-coordinate of the position is reported Above Ground Level (AGL) vice Mean Sea Level (MSL).  In other words, the platform is coupled to the terrain.  MSL is derived from AGL altitude by adding terrain height.  The use of AGL altitude is indicated when bit zero (0x1) of the flags is set.Determining the Interpolated LocationGiven this information, the exact location interpolated point (pInt) can be derived.  Acceleration (Acc) is first calculated by dividing the difference in speeds of the initial point (init_spd) and following points (nxt_spd) by the difference in the arrival time of the following point and the departure time of the initial point (dTime).  Given acceleration, the traversed distance to the desired position (Dist) along the arc or line given a specific time can be determined.     Acc = 0.5 * (nxt_spd – init_spd);     Dist = 0.5*Acc*dTime*dTime + init_spd * dTime;Figure  SEQ Figure \* ARABIC 4 – Distance Traveled Given Time, Acceleration, and Initial VelocityGiven this distance, if the path is a straight line, determining the position (pInp) consists simply of moving that distance along the unit vector from the initial point (pInit) to the next point (pNxt).  The “.Norm()” function returns the corresponding unit vector, positions are also implemented as vectors, and the scalar product is shown as an asterisk (‘*’).     Vnxt = pNxt – Pinit;     pInp = Vnxt.Norm() * Dist; // when radius is 0Figure  SEQ Figure \* ARABIC 5 – Interpolated Position Given a Straight LineOtherwise, the center of the circle (pCnt) is calculated by first deriving the orthogonal vector (Uorth) using the cross product (^) of the unit direction vector (Udir) and the vector (Unxt) from the initial point (pInit) to the following point (pNxt).  This method is continued by taking that result and using it again in a cross product with the direction vector and then normalizing (.Norm()).  The center is along that vector (Ucnt) given the turn radius (radius).  The angle of the arc given the center (theta) is the length of the arc divided by the radius.  From this data, the vector (V2p) to the point can be derived.     Vnxt = pNxt – pInit;     Uorth = Udir ^ Vnxt;     Ucnt = (Uorth ^ Udir).Norm();     theta = Dist / radius;     pCnt = pInt + Ucnt * radius;     V2p = Ucnt * (radius * (1.0 – cos(angle))) +                 Udir * (radius * sin(angle));     pInt = pInit + V2p;Figure  SEQ Figure \* ARABIC 6 – Interpolated Position Given a Circular ArcIf needed, the velocity vector at the intermediate point (Uvel2) can also be calculated by first calculating the unit vector from the center to the new point (Uc2n).     Uc2n = V2p – Ucnt * radius;     Uvel2 = (Uc2n ^ Uorth).Norm();Figure  SEQ Figure \* ARABIC 7 – Velocity Vector at Interpolated Point on Circular ArcOrientationLike paths which operate in three dimensional Cartesian space, orientation in JIMM is determined assuming a flat plane tangent to the earth at the platform location.  Yaw is determined with east as zero degrees and by rotating counterclockwise for positive change.  Roll is determined looking from the rear to the front and also by rotating counterclockwise for positive change.  Pitch is determined given the plane tangent to the earth and rotating upward for positive change.  Yaw and roll vary from -180 to 180 degrees and pitch varies from -90 to 90 degrees.Using the JIMM simulator, path information from the TOrientElement class was encapsulated into distinct messages and transmitted via a queue in SWEDAT to an interfaced external program.Only changes in orientation are provided.  Otherwise, orientation is constant.  Information in the message includes the initial time for the change, the initial value, rate of change, and duration of change for roll, pitch, and yaw.struct sh_mem_orient_element {    double pitch_value;  /* in radians */    double pitch_rate; /* radians / sec */    double pitch_duration; /* seconds from start */    double roll_value; /* in radians */    double roll_pitch; /* radians / sec */    double roll_duration; /* seconds from start */    double yaw_value; /* in radians */    double yaw_rate; /* radians / sec */    double yaw_duration; /* seconds from start */    double time; /* from scenario start */    int Next; /* next sh_mem_orient_element */}; /* end struct sh_mem_orient_element */Figure  SEQ Figure \* ARABIC 8 – Transmitted Orientation InformationSpecific orientation angles (Yaw, Pitch, or Roll) may be calculated using the initial value (Oinit) and the rate for a given time (Orate).  This time is computed as the difference (dTime) between the current time (Tcurr) and the specified time on the block (Tmsg).  Should the time exceed the duration (dDur), then the change has been completed and the duration time employed to calculate the angle.  Final checks are made to ensure that the angle lies with given bounds.     dTime = Tcurr – Tmsg;     if(dTime >= dDur) Yaw = Oinit + Orate * dDur;     else Yaw = Oinit + Orate * dTime;Figure  SEQ Figure \* ARABIC 9 -- Calculation of YawExperiment and ResultsImplementation was done using a single processor IBM microcomputer running the Linux operating system.  Messages for the path and orientation were implemented in JIMM and given the identifiers 250000 and 250001 respectively.  SWEDAT was implemented atop a UNIX shared memory block.  Messages were received from a First-In First-Out (FIFO) queue implemented in SWEDAT and interpreted by a separate process whose code was adapted from a simple program in the JIMM Acceptance Test Plan (ATP) [8].  The Obruty Final Battle scenario provided with the JIMM distribution [2] was used as the threat environment.  Though the Obruty scenario is used more to demonstrate simulation capability than as an example for realism, it was determined that the generated paths are sufficiently representative of a large number of cases.  Focus was placed on a single platform with long sharp turns and a sudden stop inside the scenario. SHAPE  \* MERGEFORMAT Figure  SEQ Figure \* ARABIC 10 -- Dispatch Test OverviewOnce it was confirmed that path and orientation information was transmitted and received correctly, code from JIMM was ported into the test program.  Then, correct interpretation of path and orientation information was also confirmed.Within the test program, a comparison of positions derived from the path and from the dead reckoning of updates was conducted and the amount of error determined.  Updates were provided every second.  The dead reckoning of position was calculated using both provided velocity and acceleration.  Dead reckoning of orientation angle was computed using only provided rate changes.  The exercise was executed at a speed where simulation time matched wall-clock time.During the test, the error between the dead-reckoned position and the path position was normally small (e.g. about one quarter of a meter).  This error would differ given the complexity of the dead reckoning algorithm.  However, in cases of sudden transition, the dead reckoned position would differ by as much as sixty-five (65.0) meters.  This is a substantial error that employing future path information would avoid.The error in orientation was also determined.  In the most common where orientation did not change, the dead reckoned orientation and the path orientation would match exactly.  However, in the cases of sudden turns, the difference in angle could be extreme.  In the test executed here, the yaw differed by as much as four (4.0) degrees and the roll differed by as much as twenty seven (27.0) degrees.  This later difference occurred because the programmed roll rate in JIMM was extremely fast.Lastly, should path information be used exclusively, then the updates sent through SWEDAT would not be necessary and could be eliminated.  Associated updates of the underlying reflective shared memory and those associated messages on the network would be removed.  For example, if a platform’s path is established at the beginning of the scenario and does not change and if the platform is updated every second, then 3600 updates would be required each hour.  However, by employing future path information, only two messages (one for the path and the other for the orientation) are necessary.  In JIMM, exercises employing a thousand different platforms are common.  Hence, the saving in underlying network processing can be substantial.LimitationsThis approach can greatly improve accuracy for platform controlled by the JIMM threat generator.  However, it will not work in JIMM exercises where platforms are controlled by outside agents.  In these cases, platforms may be controlled by systems where future paths are not generated or for which such paths are not good predictors of future positions.  This includes virtual cockpits flown by human pilots since their future behavior is not predictable.Another shortfall uncovered during the test exercises occurs for platforms that move along the surface.  In JIMM, the altitude of such platforms is reported “Above Ground Level” (AGL) as opposed to “mean sea level” (MSL).  These platforms will require that the interface program have access to the same terrain objects and methods used by JIMM.  In such cases, terrain heights at any given point can be obtained and added to the interpolated altitude to provide actual MSL height.  In other cases however, the “terrain_ht” element of the path information does provide a partial solution.  However, there will normally be terrain perturbations between waypoints.  Hence, there will still be some inaccuracy.In addition, there will still be an error whenever the threat generator dynamically changes a path.  This will be due to the delay in assembling the messages and then transferring the path information to the interfaces.  However, for platforms controlled by simulation, the number of future path updates will be small compared to the number of periodic updates of positions that would otherwise be necessary.Future WorkIn this work, the entire future path was bundled and transmitted.  This approach was simple and straightforward.  However, for platforms where dynamic movement is common, performance may be improved slightly by reducing message size by transmitting only a part of the future path.However, such an approach also has difficulties and associated overhead.  If partial paths are employed, additional events in the JIMM discrete simulation engine will be needed to provide path updates.  This event could be scheduled at a simulation time when a given number of waypoints are traversed.  However, should the path change, these events would need to be cancelled and rescheduled.  This additional overhead and complexity might offset the benefits of a shorter message.ConclusionThis paper has provided an approach for employing future path information to provide position and orientation information.  This information is exact and is more accurate than dead reckoning approaches.  Moreover, fewer messages are transmitted across the underlying network.The approach of using path information and algorithms instead of dead reckoning from updates is suitable in all cases where future path information is available and position and orientation may be obtained without difficult calculation.  It is application for all platforms controlled by the Joint Integrated Mission Model (JIMM) threat generator employed in ACETEF.  The approach is not suitable where future path information is not fully predictable as when virtual cockpits are controlled by human pilots.Though this paper discussed an implementation in JIMM and ACETEF, it is applicable to other simulators and environments where future path information and methods for its use are known, employed, and available for use.AcknowledgementsPeter Lattimore provided the basic design and construction of the path and orientation algorithms.  He is the acknowledged creator of the Simulated Warfare Environment Generator (SWEG), the direct predecessor of JIMM.  Work in SWEG and JIMM has tried to stay true to his vision.  He is also responsible for the most of the terminology used in the JIMM community and reflected in this paper.Extensive work to improve portability of waypoint paths and orientation in JIMM was done by William Brooks.The method of using interfaces as surrogates for test simulators and stimulators was developed by John McMaster.  This method was extended to test messages in SWEDAT and used to develop the example interface suite distributed with JIMM.  The method of interpolating reckoned points with subsequent truth data [1] for position and orientation was provided by Jon Anderson of NAVAIR.Kirk Bonnevier, Michael Chapman, John Dicola, and Heather Earhart provided several corrections and useful comments.References [1] Mutschler, David W.  “Improved Integrated Operation in the Joint Integrated Mission Model (JIMM) and the Simulated Warfare Environment Data Transfer (SWEDAT) Protocol”.  ITEA Modeling and Simulation Conference, Las Cruces NM, December 2005[2] Lattimore, Peter; Mutschler, David W. et al.  JIMM 2.6.2 and JIMM 3.0 Users Guides.  JIMM Model Management Office (JMMO), Patuxent River MD, 2007.  Available from the JIMM Model Management Office at < HYPERLINK "mailto:jmmo@navy.mil" jmmo@navy.mil>.[3] Mutschler, David W.  “Parallelization of the Joint Integrated Mission Model (JIMM) Using Cautious Optimistic Control”.  Proceedings of the 2005 Summer Computer Simulation Conference.  Cherry Hill NJ, Society for Modeling and Simulation International, July 2005 (pg. 145-152).[4] Long, Gordon; Mutschler, David W.; Lohman, Gary.  “Human Behavior Modeling in the Joint Integrated Mission Model”.  2006 Fall Simulation Interoperability Workshop.  Orlando, FL, September 2006[5] Hoagland, David; Martin, Edward; Anesgart, Martin.  “Representing Goal-Oriented Human Performance in Constructive Simulations:  Validation of a Model Performing Complex Time-Critical-Target Missions”.  Proceedings from the Spring 2001 Simulation Interoperability Workshop.  Simulation Interoperability Standards Organization.  San Diego CA.  Paper Number 01S-SIW-137, Spring 2001.[5] Kelly, Michael; Vick, Shon; Schloman, John; Zawada, Frank.  “A Weather Service for Introducing Dynamic Attenuation Factors in the Joint Integrated Mission model (JIMM).  Proceedings from the Simulation Interoperability Workshop.  Simulation Interoperability Standards Organization.  04F-SIW-107, Fall 2004.[6] Worsham, Richard.  “Northrop Grumman Radar Simulation (AVSIM)”.  Proceedings of the 2002 IEEE Radar Conference.  April 2002.  pg 176-186[7] Niland, William; Skolnik, Brian; Rasmussen, Steve; Finley, Kevin;  Allen, Kevin.  “Enhancing a Collaborative UAV Mission Simulation Using JIMM and the HLA”.  Proceedings of the Spring 2005 Simulation Interoperability Workshop, Simulation Interoperability Standards Organization, San Diego CA, Spring 2005.[8] Chapman, Michael D, and Gibson, Ralph D.  “JIMM Acceptance Test Plan”.  JIMM Model Management Office (JMMO), Patuxent River MD, 2007.  Available via the JMMO at < HYPERLINK "mailto:jmmo@navy.mil" jmmo@navy.mil>.Author BiographyDAVID W. MUTSCHLER has worked as a computer engineer for the Naval Air Systems Command (NAVAIR) for twenty-two years.  He has worked at ACETEF in support of JIMM and its predecessor SWEG for twelve of those years.  He served as the JIMM Model Manager from June 2004 to February 2006.  He obtained his Ph.D. in Computer and Information Science from Temple University in 1998 and is an Associate Professor in the Florida Institute of Technology University College.Shared Memory NodesIBM PCTestProgramSWEDATJIMMActual Position(Arc)