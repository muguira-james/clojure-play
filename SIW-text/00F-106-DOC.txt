Legacy Simulators Can Play “HLA”William L. EdmondsMichael Alan GibsonOlen BruceBMH Associates, Inc.5425 Robin Hood Road, Suite 201Norfolk, Virginia 23513-2441757-857-5670 ext 214 HYPERLINK "mailto:edmonds@bmh.com" edmonds@bmh.com ,  HYPERLINK "mailto:gibson@bmh.com" gibson@bmh.com ,  HYPERLINK "mailto:bruce@bmh.com" bruce@bmh.com Naval Air Systems Command (NAVAIR) PMA 205Cindy WesterbekeKeywords:HLA; JSAF; Java; Distributed; Simulators; Legacy. ABSTRACT: Legacy simulators have filled training needs for decades.  A significant drawback to these simulators is the stove piped threat systems that create the training “environment.”  Some or all of the following factors limit these threat systems:  number of threat entities, terrain database, dynamic terrain, emerging threat technologies, and types of threat entities (land, sea, air).  Interfacing these legacy simulators with newer HLA compliant simulations and technologies can eliminate some of these problems and can provide the added benefit of allowing compliant simulators to be networked in a robust threat environment. This paper describes the approach and the software design developed to enable a legacy US Navy F14D Weapon Systems Trainer to become HLA compliant. The objective of the approach was to make no intrusive changes to the legacy F14 Encore processor based Fortran code while insuring that the fidelity of the simulation and training capabilities of the trainer were not compromised. JAVA software was developed to communicate with the 24 Encore processor system and to transmit and receive entity and interaction data. Modifications to the Encore code created a new status value that allowed external data to be entered into the data arrays while preventing the Encore system from taking over control of these elements. The visual, radar and Instructor Operating Station (IOS) systems were used to verify that JointSAF (a DARPA Synthetic Theater of War ACTD product) HLA based entities and interactions were entering the system successfully. JointSAF was used to verify that the F14D “ownship” and its internally generated threats were properly visible to the rest of the HLA simulation. The success of this HLA interface should allow HLA certification of this simulator and provide a robust and easily upgradeable training “environment” (or Joint Synthetic Battlespace). 1. IntroductionEver since the advent of HLA, many modeling and simulation projects have been conducted to connect existing legacy simulators and trainers to HLA compliant technologies such as STOW (Synthetic Theater of War).[1]  Much of the work has been done with simulators that were already networked and that used distributed simulation protocols such as SIMNET or DIS.[2]  This paper describes the problems associated with and the approach taken to make a non-networked simulator into a networked, HLA compliant federate. The legacy system chosen was the F14D WST (Weapons Systems Trainer) located at the Naval Air Station, Oceana in Virginia.  The objective of this work was to make the F14D HLA compliant at least to the point of being able to exchange entity state attributes and to have a minimal capability for missile launch interactions.  The scope of the project was not only limited by time and money, but was also predicated on the fact that the F14D is currently scheduled to be rehosted on a more modern computer platform.  This study paves the way for a more complete conversion after the rehosting. For this study, JSAF utilized the STOW FOM and RTI-s.  The F14D SOM consisted of a small subset of the STOW FOM.2. Assessing the Legacy SystemBefore a non-networked legacy system can be made HLA compliant it must first have some mechanism for exchanging data with the outside world.  In the case of the F14D WST, we needed to find a hardware and software interface solution using readily available tools and one that would not require expensive upgrades to the system. After determining the best mechanism for the physical exchange of data, we needed to understand how the threat data was already handled in the WST. We needed to determine how it would be possible for external threat data to be entered and internal “ownship” data exported without massive changes to WST code.  In the paragraphs to follow, we will describe the hardware architecture of the F14 WST and discuss the three options we discovered that could potentially provide the means for physical connection to the outside world.  We will then discuss how we came to a decision on which option to use.  Following the hardware discussion we will look at how the WST software system was rapidly analyzed to give us clues on how it could be modified to allow data in and out of the system.  Finally we will discuss how we were able to put together an approach that would give connectivity and HLA compliance to a standalone legacy simulator like the F14D WST.2.1 F14D WST Computer Hardware SystemThe host computer system was manufactured by Encore Computer Corporation.  The system consists of twenty-four Encore processors divided into four functional nodes (A, B, C & D) and connected to each other via three Encore Reflective Memory Buses (see fig. 1).  We found two external systems connected to the WST that were our first candidates for our external connection. The first of these utilized an Encore “Surf” card to interface a DEC Alpha computer via a VME cage containing the Surf card connected to the Encore system via an HSD interface card.  The biggest attraction of this method of connection was that it allowed direct access to the Encore Reflective Memory Bus and thus to virtually all the Encore data.  The biggest problem with this alternative was that this system was fully dedicated to the new Digital Flight Control System and we could not expect regular, if any, use of this system.  Thoughts of getting our own copy were quickly dashed by the high cost with our low cost budget.The second candidate was an Ethernet port that was already connected to an SGI Onyx computer used to house an IRST (Infrared Search and Track) module.  The advantages of the Ethernet connection were obvious, but we needed to determine if this particular port located on the “C-3” node of the Encore system would afford us access to the data we needed and do that without great expense in additional hardware or software development.One additional method of connection was briefly considered after talking with an Encore representative and that was to use an Encore  “Bridge Board.”  The Bridge Board provided a means of connecting a PC directly to the Encore Reflective Memory Bus. Just like option one, this would allow data to be written into and/or read from the Encore memory. After discovering the cost, this was no longer an option.Option two, the Ethernet connection, looked like our only viable approach at this point.  Before we could proceed, however, we needed to learn about the F14D software, how it was configured on the four nodes and How it utilized the Ethernet port.Figure 22.2 F14D WST Software SystemThe F14D WST software consisted of approximately 750,000 lines of code contained in over 3800 files.  Most of this was Fortran with a small portion of assembly code.  The Fortran subroutines and their associated “include” files were very well documented and that greatly facilitated the analysis of the software.After we gained access to the unclassified portion of the source code we began analysis on both Unix based and Windows NT based systems.  The approach taken was to identify key variables that described the state of the F14D WST  “ownship”.  Variables such as the x,y and z components of position, velocity, orientation plus the status were discovered and were then mapped to routines where they were either referenced or changed.On the Unix system we used “grep” and related commands to identify the files where key variables were referenced and where their values were changed. Position variables such as RXPOSFT, RYPOSFT, and RZPOSFT, and the entity status variable RSTATXT were mapped to not only subroutines that used them but also to the “datapools” (an Encore facility for sharing common blocks over their reflective memory buses). Using the analysis approach above we were also able to locate all the routines that accessed the Ethernet port.  We discovered that the Ethernet was used to send data from the F14D WST to the SGI Onyx computer in support of the IRST (Infrared Search and Track) capability.  Fortunately most of the data we needed to describe entity attributes was already being sent out over the Ethernet to the SGI Onyx computer.  Following is a list of the data available with a brief description:Status	Entity status in WST systemType	WST entity typeRXPOSFT	Real x position in feet from originRYPOSFT	Real y position in feet from originRZPOSFT	Real z position in feet from originRXVELFT	Real x velocity (ft/sec)RYVELFT	Real y velocity (ft/sec)RZVELFT	Real z velocity (ft/sec)HEADING	Deg. (0=North, 90=East)PITCH	Deg. (0=Tang., 90=Up, 270=Down)ROLL	Deg. (90=Left Wing Up)3.0 The ApproachWe determined that the best approach would consist of the following basic steps:Write a Java program on the SGI Onyx computer to receive, process and display the data described above.Convert the data to a DIS PDU form and send it to a JSAF simulation networked to the Onyx through an HLA/DIS gateway. (see figure 2)Receive data from the JSAF simulation via the gateway and convert it to a form compatible with the F14D WST data listed above.Write a new capability on the Encore “C3” node to receive data from the Onyx.Output the data from the Onyx to the “C3” node.Modify code as needed on the Encore system to accept external entities.We chose Java as the platform for our interface development for a number of very good reasons.  Not only was it available free on many different computer systems, but many of the standard features of Java are not standard at all in other languages.  Some of the features we consider most important in this respect are support for threads, hashtables, byte streams, GUIs and network access.The Java program called “FIT” (F14 Interface Test) was developed in stages according to the outline above. Taking advantage of Java thread capability, we divided the FIT program into four primary parts:Input thread from F14DOutput thread to DIS networkInput thread from DIS networkOutput thread to F14DWe were able to quickly write the input portion of FIT and used it to closely examine the data.  One of the first unexpected problems was that the Encore computers use an unconventional (non-IEEE standard) internal format for floating point numbers.  We had to quickly write our own routines to convert from Encore to IEEE and back.  We were able to use some of the IRST C code that converted Encore to IEEE as a model, but we had to develop the inverse algorithm ourselves. The F14D WST uses a flat earth coordinate system.  To make the positional data useful in the DIS or HLA world we had to convert the flat earth data to geocentric.  In this case we were able to translate to Java some Fortran code from the F14D that converted from flat earth to geodetic coordinates.  We then used geodetic to geocentric conversion code extracted from our Java based Ordnance Server (Java OS) to finish the job.  We were able to make further use of Java OS code to format the data into DIS entity state PDUs and broadcast them on our local network for our HLA/DIS gateway to send to JSAF.  After some initial debugging we were able to view the F14D “ownship” fly around on the JSAF PVD and be detected by entities simulated on JSAF.The reverse process was accomplished in a similar fashion.  We used Java OS code to input DIS PDUs.  We wrote code to convert the data to the appropriate units and to convert those floating point numbers to the Encore internal representation.  The final thread packed the data into records for output to the F14D WST system. On the WST system we wrote a routine that was scheduled at 5 hertz to read data in from the Ethernet port.  Each read could input data for up to twenty entities. The data was stored directly in the Encore datapools that were used for the WST generated threats.  The key to our success in storing data in the same way the WST threats were stored came from the use of the WST RSTATXT variable.  This variable, stored in an integer array, was set to –1 for any slot currently unused in the WST system.  We mapped our entities into the available slots and then marked them as used.  Instead of using a value of 1 for active, as the WST system does, we used a value of 4096.  Then in each conditional clause where the system would check to see if it had an active entity to process, we could let that conditional know that an entity was there; but, that it was an external entity that may not need special internal processing, for example following a mission or performing some tactical maneuver.  The great advantage of this approach was that everywhere the system needed to know that an active entity was, for instance, within radar range, it could detect our external entities as easily as its own internally generated threats. Writing routines and modifying other routines on the Encore system to allow external entity data to be inserted in the datapools was the final big challenge.  We have described the overall process as if it were one step followed by another, but the challenge of getting data into the Encore datapools and having that data be accepted and understood by the system was very difficult.  We actually began work on this phase from the very beginning.  At least the analysis of the Fortran code could be carried out on fast Unix systems with modern tools and editors available.  Development work on the Encore system was highly cumbersome, with few useful tools available.  To make it a bit more challenging, we were only able to get on the system a few times a week, and then only during the night shift!  The system itself was a highly complex real time system with 24 processors dividing priority among 1, 5, 10 and 30 hertz processes in a rigid pattern.4.0 ResultsAs a result of our efforts we were able to demonstrate connectivity between the F14D WST and JSAF through an HLA/DIS gateway.  We demonstrated air entities from JSAF showing up on the visuals and radar screens of the WST and, likewise, the “ownship” and threats generated on the WST showing up on the JSAF PVD (Plan View Display).  We were able to show missile launches and kills going both ways.  Although much was left to be done, we were pleased with the progress made in a relatively short period of time on a very complex system.  This was accomplished by making very selective minor changes to approximately thirty Fortran files on the WST system.  Most of the changes were single line changes.  On the Java side we pulled together a significant amount of code from a previous product and created the necessary new classes of objects to input, output and process WST data.  After originating the Java code on the SGI Onyx we ported it to a Linux platform when the SGI was deemed no longer available.  The only effort required to port the system to Linux was recompiling some of the low-level “C” code used for the raw socket connection.  5.0 Lessons LearnedThe most positive lesson learned was that no matter how difficult a task seems at the beginning, the probability of success is greatly increased by breaking the problem down into manageable steps.  After examining the steps to be accomplished, if the most difficult step can be conquered, the rest will generally fall in place.  There are some things, however, that we would do differently if we were doing a similar task again.  The foremost is to pursue thorough training on the legacy hardware/software system if at all possible.  While we did receive significant help from many people in NAVAIR and others at Oceana, the lack of a more formal training class on the Encore system did cost us time.  On the other side, the people who wrote the original code for the WST deserve a tremendous amount of credit for their thorough documentation of the source code.  Without that documentation we could not have accomplished what we did.6. References[1] Cavitt, David B., et al;  “Integrating STOW and the Navy’s Battle Force Tactical Training (BFTT) System”[2]	Paterson, Daniel J., et al: “An Approach to HLA Gateway/Middleware Development” Author BiographiesWILLIAM L. EDMONDS is the Software Engineering Manager at BMH Associates, Inc., Norfolk, VA.  He heads up a group of more than twenty five software developers who are working on various modeling and simulation projects such as STOW (Synthetic Theater of War), AVCATT (Aviation Combined Arms Tactical Trainer), WARCON (Warfighting Concepts to Future Weapon System Design), and the FBE series (Fleet Battle Experiments).  Mr. Edmonds has been referred to as a living legacy system himself and has been involved in software development since the days of ALGOL 60.  He received his B.S. in Chemistry from the University of Virginia before they had Computer Science Degrees.  Mr. Edmonds’ current passion is Java and he has written a DIS compliant Java based Ordnance Server soon to be HLA compliant.M. ALAN GIBSON is a Senior Software Engineer with BMH Associates in Norfolk, Va. Mr. Gibson received his B.S. degree in Computer Science from Virginia Polytechnic Institute and State University in 1986. He is involved in software development for several military Advanced Distributed Simulation projects. His current task is to integrate virtual simulators into the Synthetic Theater of War (STOW) Battlespace utilizing HLA/RTI technology.OLEN A. BRUCE is a Software Engineer with BMH Associates, Inc., Norfolk, VA.  He received his B.S. degree in Computer Science and Computer Engineering from Christopher Newport University in 1997.  He has three years experience working with modeling and simulation software development and currently is working on the Joint Countermine Operational Simulation (JCOS) for the Fleet Battle Experiment “H” (FBE-H). EMBED PowerPoint.Slide.8  Figure  SEQ Figure \* ARABIC 1