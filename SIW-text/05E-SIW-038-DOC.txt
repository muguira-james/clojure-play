Implementing RTI Data Distribution Management Using SIP ServicesClaude Van Ham, Trevor PearceCarleton UniversityDepartment of Systems and Computer Engineering1125 Colonel By Dr.Ottawa, Ontario, K1S 5B6, Canada (613) 520-2600 HYPERLINK "mailto:cvanham@sce.carleton.ca" cvanham@sce.carleton.ca,  HYPERLINK "mailto:pearce@sce.carleton.ca" pearce@sce.carleton.caKeywords:HLA, RTI, SIP, Conferencing, SMSF, DDMABSTRACT:  The Session Initiation Protocol (SIP) is a control protocol designed for use by applications to carry out the creation, control and termination of network-based communication sessions.  The protocol is relatively simple and highly flexible.  While it is currently mainly used in voice over the Internet Protocol (VoIP) networks it also lends itself for use by any network-based application requiring the establishment and control of communication sessions between two or more end points such as multimedia conferences, multicasts and gaming sessions.  As a result of its growing acceptance as the VoIP protocol of choice, however, it has gained wide approval in the Internet community and is poised to become as ubiquitous as HTTP. The HLA defines an API for a distributed runtime infrastructure (RTI) but does not define the implementation of the RTI.  In order to support a distributed design a communication layer is required to support the RTI.  This paper continues the authors’ work in the development of a SIP-based “Open RTI”.  The objective of this effort is to define and implement an open RTI using SIP services to support the communication needs of the RTI’s distributed components.  Such an implementation will benefit from SIP’s strengths addressing RTI design issues such as firewall traversal and security as they are supported by SIP and from the already large support for the technology.  Such an implementation would also support easier interface to existing SIP-based applications and may ultimately lead to an interoperable RTI architecture.In their earlier work the authors developed an abstract model of a distributed RTI and mappings of some fundamental HLA services and the Ownership Management services onto this model.  Because it is used by various SIP implementations a conferencing paradigm is used.  Initial research indicates the conferencing paradigm may be applied in the realization of HLA Data Distribution Management (DDM) services as well.  This paper concentrates on the development of these mappings.  In addition this paper is intended to continue to show advantages of SIP technology in the support of M & S middleware while encouraging individual and industry participation in this effort possibly through the establishment of a SISO HLA-SIP study group.1. IntroductionThe High Level Architecture (HLA) defines an architecture whose main goal is the creation of simulation applications by combining other simulations together [1].  Individual simulations, called federates, may be combined into a single, larger simulation called a federation.  The architecture allows such combinations to be created flexibly disassociating participant federates so they can be used in other federations as well.The HLA is defined in three IEEE specifications [2,3,4] the second of which defines the Runtime Infrastructure (RTI).  The RTI provides services to federates which allow them to interact as a federation.  It is defined as an interface not an implementation.  As long as the characteristics of the interface and the HLA rules are maintained the RTI may be implemented in any way by its developers.  Federations are often distributed across computers; individual federates run on local machines on top of a (locally implemented) component of the RTI.  To support distributed design RTIs must provide network communication capabilities, however, RTIs are generally not interoperable [5] due to differences in implementation. Therefore federates running on one implementation typically cannot be combined with federates running on another. The Session Initiation Protocol (SIP) is a control protocol that supports the creation, control and termination of multipoint, multimedia communication sessions.  It is becoming the protocol of choice in the implementation of voice over IP (VoIP) networks having largely supplanted the more complex H.323 protocols.  While most frequently used in this arena it is a flexible protocol capable of supporting any application requiring an underlying communication infrastructure.  It provides other benefits as well.  Because it is stateful it supports firewall traversal even using UDP.  It provides security mechanisms to protect its control messaging and to authenticate end points.  Finally, because of its growing popularity in the telecommunications sector, it is gaining increasingly widespread support, which has also resulted in the rapid development of extensions to it while maintaining the simplicity of its core specification (defined in [6]). Inspired by these benefits and the direction suggested by [7] the authors have been investigating the possibility of implementing an HLA RTI on top of SIP.  Applications based on SIP often make use of a multiparty conference architecture.  In previous work [8] the authors developed a conference paradigm-based RTI model capable of representing HLA concepts and mapped some key RTI services onto it including the object and ownership management services.  The intent it to, ultimately, use a SIP-based conference mechanism to implement this model.  This will provide the benefits of SIP just described to an implementation of the HLA leading to an open RTI capable of eventually supporting interoperability of RTI implementations.  This paper continues this work extending the model to support data distribution management (DDM) services.   The rest of this section provides details of the HLA and SIP relevant to the rest of the paper.  Section 2 presents an abstract, component-oriented model of an RTI implementation.  This model can be used to represent a variety of actual implementation approaches.  In section 3, the conference-based Open RTI model is presented discussing how it may be used to implement various key RTI services including DDM.  Section 5 considers approaches to using SIP to realize the resulting model and conclusions are presented in section 6. 1.1 The High Level ArchitectureThe HLA was developed by a consortium of stakeholders (government, corporate and academic) as a result of a U.S. DoD desire to decrease the cost of modeling and simulation development.  The approach is to use a flexible architecture capable of supporting the reuse and interoperability of individual software simulations called federates in larger simulations called federations.  A federation consists of three elements; 1) one or more federates, 2) a Federation Object Model (FOM), and 3) supporting software called the Runtime Infrastructure which provides various services to the federates, enforces the HLA rules and controls, as a running federation is referred to, a federation execution.A federate is a stand alone software application.  To operate as part of a federation its design must adhere to the rules of the HLA as defined in [2].  A federation’s FOM is a unique document and is supplied as a parameter to the RTI on start up of a federation execution.  It is created by the federation designers to convey design decisions to the RTI and federates.   It is, essentially, a database that describes the data that can be exchanged between federates in addition to other static information.  Its syntax is based on the Object Model Template (OMT) [4].  The HLA supports two types of data representations; objects and interactions.  They are defined in the FOM using a class hierarchy scheme chosen by the designers to meet the needs of the simulation. An object class is typically used to represent enduring simulation entities important to more than one federate.  An object class may have one or more attributes which may be updated to represent the state of the entity as the federation execution progresses.  Interaction classes are normally used to convey transient event data to federates.  They may contain one or more parameters.The RTI keeps track of each object instance created (until deleted) identifying its owner and distribution requirements of updates to its attributes.  It does not maintain a record of attribute values.  Each federate must maintain its own internal representation of the objects and attributes it is interested in.  The RTI does not keep track of interactions because they are transient.  Only the distribution information it needs to ensure interactions are delivered to interested federates is maintained.The RTI provides a service API which federates can call and a callback API which federates must implement.  The RTI provides six distinct areas of service and a group of support services. Each is discussed briefly in the following paragraphs.   Coverage is terse intending to give a very high-level understanding of RTI capabilities.  Interested readers are directed to the referenced specifications for more details. Federation management services support the creation of a federation execution and allow federates to join and leave a federation.  Services are also provided to save federation state, set up synchronization points and carry out related chores.Data sharing in the HLA is based on a publication-subscription model that decouples producers from consumers.  Declaration management (DM) services allow federates to indicate their intent to produce (called publish in the HLA) and consume (subscribe) data.  The RTI uses this information to route object instance attribute updates and interactions between federates using the object management services.  Object management services are used to register (create) new object instances and to issue attribute data, via an update, or new interactions, via a send, to federates.  Ownership management services support the transition of the ownership of instance attributes between federates.  Before a federate can update an attribute it must own it.  Conversely, the owner of an attribute is responsible for updating it.  Ownership applies to instance attributes (that is, a federate owns a given attribute of a single object instance), it does not apply to interactions or their parameters.Time management services allow the definition of a common concept of logical time and can be used to manage the progress of a federate in accordance with this concept.Data distribution management services support finer control of instance attribute and interaction routing between federates.  The focus of this paper, they are discussed in further detail in section 1.1.4.Finally, various support services provide a multitude of functions such as setting of various federation-wide switches, obtaining federate, object class and instance handles or names from the RTI for use in other service calls and other support functions.A deeper understanding of how data is shared in the HLA is required to understand the design of the open RTI model and extensions it requires to support DDM capabilities.  This requires further discussion of the creation, distribution, ownership transfer and deletion of object classes and their attributes and the distribution of interactions.  1.1.1 Inter-federate Information TransferAs indicated, the HLA uses a publish/subscribe mechanism to transfer information between federates using instance attributes or interactions.We consider first the simpler case of the interaction.  A federate is said to send an interaction.  Subscribing federates receive the interaction.  Before a federate may send an interaction, however, it must declare its intent to publish the interaction class.  Similarly federates that wish to receive a given interaction class must first subscribe it.  As it represents transitory information, once the interaction is sent to all subscribers it is eliminated by the RTI.  When an interaction is sent the RTI forwards it to all federates who have subscribed to the interaction’s class in a receive callback.Data transfer using class attributes is more complex.  Like interactions, before a federate can produce class attribute data it must declare its intent to publish the attributes it wishes to update.  It may then begin registering object instances of that class.  The registering federate owns the attributes it has indicated it will publish.  Attributes, which have not been identified for publication by the registering federate, are unowned.  Other federates may declare intent to publish the unowned attributes and then request ownership of them.   The owner of an instance attribute may give up ownership.  These topics are discussed further in section 1.1.3.Once published and registered an instance’s attributes may be updated by the owning federate.  The RTI sends attribute updates to subscribing federates; they are said to reflect the new data.  In order to be advised of changes to an attribute a federate must subscribe to that class attribute.  Note that such subscriptions are class-wide, that is, the subscriber will receive updates of all instance attributes of the same class and attribute.  Subscribing federates become aware of a new object instance for which they have subscribed at least one attribute through notification from the RTI when it is registered; they are said to discover the new instance.  Multiple federates may own attributes in an instance but only the owner of a given attribute may update it.  Note that no communication happens directly between federates; all services are carried out by and through the RTI thus disassociating federates and supporting the transfer of a federate from one federation to another.1.1.2 Deletion of Object Instances An object instance may be deleted by the federate owning the special attribute “HLAprivilegeToDeleteObject”.  This attribute is defined in the object class root and, therefore, inherited by all new instances when they are registered.  Its ownership is assigned to the registering federate. The owner of this attribute for a given instance may delete the instance at any time.  Its ownership may be transferred like any attribute and all federates publish it automatically. 1.1.3 Transfer of Attribute OwnershipFederates may give up or transfer ownership of an instance attribute using the related ownership management services.  An owner may offer to divest ownership in which case the first federate requesting will be assigned ownership by the RTI.  This is called the push model of ownership transfer.  A federate may request to acquire ownership of a given instance attribute as well.  It will be transferred if the owner agrees.  This is referred to as the pull model.  In neither case will the RTI force the removal or award of ownership.1.1.4 Control of Data Transfer using the DDM ServicesThe data and object management services provide coarse control of data distribution.  In the case of interactions publishers publish an interaction class and subscribers receive all interactions sent of the class.  Similarly publishers update a class attribute and subscribers reflect all instance attribute updates of the class attribute.Depending on federation requirements, distribution traffic may be reduced with DDM.  Consider a federation in which one federate models ground based radio receivers while another models air-based transmitters (example adapted from [1]).  If class interactions are used to represent a transmission with non-DDM techniques federates implementing a receiver will be sent all transmission interactions by the RTI.  Receiving federates will then have to apply some filtering mechanism to determine on which they must take action; i.e. which transmissions they really would have received given the physical scenario being modeled.  If DDM techniques are used, however, the RTI is provided enough information to carry out this type of discrimination before an interaction is sent to a subscribing federate. Thus, only those of interest to subscriber(s) are sent and traffic is reduced.The general technique behind DDM is that subscribers and publishers associate regions of a pre-defined set of dimensions with the data they subscribe or publish.  Only if an update datum’s associated region overlaps a subscriber’s region of interest will the RTI send the data to the subscriber. To use DDM services all allowable dimensions must be identified in the FOM.  Combined, these dimensions define an n-dimensional inter-federate communication space.  A dimension is defined as a named interval between 0 and some upper bound.  A range is defined as a continuous interval on a given dimension identified by an upper and lower bound.  The FOM identifies the dimensions available to an interaction class or class attribute; they must be a subset of those defined in the FOM for the entity concerned.  Federates may define a region specification identifying a subset of available dimensions and ranges on them and then associate it with an instance attribute for update, with a sent interaction, or with a class attribute or interaction class for subscription.  When such an association is made it is called a region realization.  A set of one or more region realizations may be associated with an instance attribute or used in sending an interaction and is called an update region set. A set of region realizations associated with an interaction class or class attribute is called a subscription region set.  A region set, in effect, defines a set of closed regions in the n-dimensional inter-federate communication space. In creating a region realization, if an available dimension is not specified in the region specification a default range, defined as [0, the dimension’s upper bound], will be used in the region realization unless the FOM indicates the dimension is to be excluded from overlap calculations.  The following paragraphs discuss how these sets are used by the RTI to determine when to send an interaction to a subscriber, i.e. when there is an overlap.Federates, again, first indicate their intent to publish a given interaction.  When an interaction of the given class is sent by a federate the federate associates an update region set with it.  (Note all parameters in the interaction are defined over the same set of regions.)  To subscribe an interaction using DDM a subscription region set is used.  The RTI will compare each region in each subscriber’s subscription region set with each defined in the interaction’s update region set to determine if there are any which overlap.  For each subscriber, if there is at least one overlap, the associated federate is sent the interaction.Two region realizations may be compared as long as they have at least one common dimension though all common dimensions in the pair must be compared and overlap individually.  Consider the simple case of a publisher with an update region set consisting of a single three dimensional region with dimensions ‘x’, ‘y’, ‘z’ and a subscriber with a subscription region set consisting of a single two dimension region with dimensions ‘x’, ‘y’.  As long as both common dimensions have overlapping ranges there is an overlap and the subscriber will receive the interaction.In the case of instance attributes subscribers associate subscription region sets with the class attributes they are interested in and publishers associate update region sets with individual instance attributes.  Overlaps are determined in the same manner as described.Some examples will help in understanding DDM and the concept of overlapping regions.  A simple case is considered first.  Assume the FOM defines two dimensions: D1, D2.  Further, a single object class ‘X’ is defined which has one attribute, ‘a’.  The FOM indicates that both D1 and D2 are available to X.a.  There are two federates, ‘A’ and ‘B’, in the federation.  Federate B subscribes X.a with a subscription region set of two regions named B.1 and B.2 defined in table 1.  Now assume federate A associates an update region set of two regions (A.1, A.2, also defined in table 1) with X.a and updates it.Table 1. Update and Subscribe Regions SetsAssociated with Figure 1.Figure 1 shows the resulting regions.  There are two overlaps in this example; regions B.1 and B.2 of federate B’s subscription region set both overlap with federate A’s A.1 region of its update region set.  As a result of these overlaps federate B will be sent federate A’s update of X.a.  Note one overlap would have been sufficient for the update to be sent to federate B.Figure 1. DDM Region Overlap Example 1Now a more complex example, in which regions of differing dimension sets result from the region realizations and must be compared, is considered.  Assume there are three dimensions defined in the FOM; D1, D2, D3.  A single object class ‘X’ is defined which has two attributes ‘a’ and ‘b’.  The FOM indicates that D1 and D2 are available to X.a and all three dimensions are available to X.b, D3 to be excluded if not specified.  There are three federates, ‘A’, ‘B’ and ‘C’, in the federation.  The update and subscription of  only X.b is considered.  Federate C subscribes X.b with a subscription region set of two regions named C.1 and C.2 defined in table 2.  Federate A (owns and) updates X.b with an update region set of two regions (A.1, A.2) also defined in table 2.Table 2. Update and Subscribe Regions SetsAssociated with Figure 2.Figure 2 shows the resulting regions.  Note that an orthogonal coordinate system has been used in this representation but that the dimensions need not necessarily represent physical space; they can represent whatever the federation developers desire.  In the first two diagrams (a, b) the 2-D regions have been separated from the 3-D region due to the difficulty of representing the third dimension in a two dimensional medium such as this page.  To determine if there is an overlap table 2 must be consulted.  There is one overlap; federate A’s first update region (A.1), which consists of all three dimensions, overlaps with federate C’s first subscription region (C.1), which has only two dimensions the third having been unspecified in the related region specification (as it was for A.2 and C.2 as well) and therefore excluded in the comparison.  This overlap is shown in the third diagram of figure 2 in which the third dimension has been dropped for illustrative purposes. Because of this single overlap federate C will receive the update of X.b sent by federate A.   Figure 2. DDM Region Overlap Example 21.2 An Overview of the Session Initiation ProtocolThe Session Initiation Protocol (SIP) is a session layer (layer 5, ISO/OSI reference model) control protocol designed for use by applications to create, control and terminate network-based communication sessions between two or more participants using various media.  It is intended to be used as an “out-of-band” control protocol; SIP signaling messages move in a different communication channel than that transporting the media of the communication session being controlled.  It is a robust, relatively simple and highly flexible protocol.  Often used for VoIP, it can be used in any situation requiring the establishment of a communication session between two or more end points.  Reference [6] defines the core protocol while other documents define extensions to it and more complex services based on its primitives. The protocol provides five principle functions supporting communication; determination of location of target end user(s), determination if the target user(s) wishes to engage in the session, determination of session parameters (such as codec and media type), setup of the session and, finally, management of the session while it is active.Session Initiation Protocol endpoints are called user agents.  They are usually implemented on a user’s computer but may be implemented in cell phones, PSTN (public switched telephone network) gateways and other devices.  An endpoint is composed of a user agent client (UAC) and a user agent server (UAS).  The UAC sends requests such as invitations to join a session or announcement of the termination of a session to a UAS which sends a response indicating its success or failure in carrying out the request.  An endpoint operates in the mode appropriate for the current function it is carrying out.  User agent client and UAS behaviors are also implemented in SIP proxy servers which are used in the network core to assist in routing requests, find user end points and to provide other support such as billing services.  Successful requests invoke methods on the UAS.  The SIP does not implement any specific services.  It provides method primitives with which services such as two-party communications sessions or conference call set up can be implemented.  Reference [6] defines six methods in the SIP.  Of these INVITE is the most important and is used to initiate a communication session.  The Session Initiation Protocol uses an HTTP-like request-response transaction model.  A transaction is comprised of one request and all responses to it. Transactions are relatively short lived; however, they can be used to set up a stateful peer-to-peer dialog between two user agents which lasts the duration of the session.  A dialog is used to create what is referred to as a SIP session; the associated media channel(s) complementing the signaling channel.  Not all transactions must be part of a dialog.  For example OPTIONS, another core SIP method, does not establish a dialog, simply a short-lived transaction.  Because dialogs maintain state they may be routed through firewalls.The Session Initiation Protocol uses text messages to carry requests and responses between UACs and UASs.  Transmission control protocol (TCP) or UDP transport is typically used under SIP to carry messages.  SIP also supports the Stream Control Transport Protocol (SCTP) providing the speed of UDP with TCP-like reliability.Messages contain a header and header fields to identify, in addition to other information, the method they are requesting or response they are carrying, target and sender network addresses, sequence information and identification information which allow the message to be identified as part of a specific transaction and, where relevant, part of a specific dialog.  Messages may include further session setup (e.g. media type, codec identification etc.) and other information in the message body.  The Session Description Protocol (SDP) [9] is often used; other Multipurpose Internet Mail Extension (MIME) types are supported.User agent servers respond to a UAC request by sending one of a series of possible response codes in a response message.  Response messages are similar to request messages but contain the appropriate response code signifying the result of the request.  The HTTP message authentication technique is used to allow UASs to request UACs authenticate themselves.  Hop-by-hop message encryption using TLS or IP Security (IPSec) or end-to-end S/MIME-based tunneling may be used to protect messages from manipulation, man-in-the-middle attacks, replay attacks and other security threats. Separate techniques must be applied to protect media channels1.2.1 SIP-based ConferencingAs mentioned, various services have been built using SIP primitives and extensions.  A common SIP-based service is multi-media conferencing.  Conference servers are implemented as SIP user agents.  They establish conference policy and set up conferences.  Typically a call-in model in used by an attendee (SIP endpoint) to join a conference by sending an INVITE to the server, however, a call-out model, in which the server sends INVITEs to desired attendees, is also possible.  Attendees may be either conference aware or conference unaware.  Conference aware attendees may change conference policy taking control of the conference floor or acting as conference moderator.  These functions and the conference model in general can be used to implement an open RTI.  2. An Abstract RTI Implementation ModelIn discussion of the Open RTI a flexible, abstract representation of an RTI implementation is referred.  This model is shown in figure 3. Figure 3. RTI Implementation based on RCsFederation federates access services in the RTI through its API, viewing the RTI as a black box.  The RTI is composed of one or more RTI components (RC) which may be distributed.  An RC may provide support directly to one or more federates (as RC1, RC2 and RCk do) while others may be used to provide specific support services to other RCs.This model supports a variety of implementations.  For example, a centralized client/server implementation may use RC3 as the central server while the other RCs act as distributed clients.  A distributed implementation could use RC3 as the RTIexec while the others support distributed HLA algorithms.The abstract model is included to establish the independence of the proposed conferencing model from the federates and from any particular RTI implementation style. In the following discussion of the model, frequent mention is made of the publication and subscription interests of the federates.  However, the conferencing model and the federates' interests are implemented by the RCs that collectively constitute the RTI.  The federates do not have to take any additional actions beyond their normal RTI calls to participate in a conference. The conferencing model is therefore transparent to the federates, and the RTI API is independent of whether the conference model is being implemented. 3. The Conference ConceptWe use a conference paradigm to model RTI functionality.  This section introduces the conference concept and presents vocabulary necessary to discuss it.  The additional capabilities and vocabulary presented here do not affect those discussed in [8] but, rather, add to them in order that the model, which is presented in the next section, can be extended to support DDM functionality.A conference is an infrastructure enabling communication among multiple parties with common interests.  Concurrent conferences may be created at the same level or as sub-conferences.  Sidebars are similar to sub-conferences but have some restraints described below.   Parties interested in a conference or sidebar participate in it as an attendee.  Parties interested in more than one conference or sidebar may send delegate attendees to each.Attendees may play the role of speaker, listener or talker.  A speaker may announce information to listeners.  A talker may act as both a speaker and a listener.  To make an announcement the speaker or talker must use a floor.  There may be more than one floor in a conference and attending listeners and talkers hear all announcements from each.  Announcements in a given conference are not heard in its super or sub-conferences.  A floor may be owned, in which case only the owner may make announcements, or it may be open, in which case any speaker or talker may make an announcement.  Access to open floors is negotiated through the conference moderator.  Ownership of a floor is negotiated with the owner.  A sidebar can have only one floor and will have associated with it a wait zone.   Conference attendees who wish to enter a given sidebar may have to wait in the wait zone until they meet the sidebar’s requirements. These requirements are defined as needed and are enforced by a doorman.  While in a wait zone attendees are referred to as waiters and hear no announcements.  The doorman controls access to a sidebar and continued attendance in it which is based on an attendee continuing to meet the sidebar’s requirements.  Attendees at a side bar only hear announcements within the sidebar and sidebar announcements are not heard outside the sidebar.4. An Open RTI Conferencing ModelThe Open RTI conferencing model was initially presented in [8].  This paper builds on the model presented in that paper integrating DDM functionality into it.  The extensions made here do not detract from the capabilities of the original model. The model begins with a federation conference created by the RTI; all federation RTI activity takes place in this conference. The RTI then creates one sub-conference for each interaction class and each class object.  This is all done based on information in the FOM, which identifies all classes, parameters and attributes.  Mapping of object classes onto this model is discussed first followed by that of interaction classes.The object class conference is the vehicle used to inform federates of new class instances and attribute updates. Federates that publish attributes of a given class send a speaker federate delegate to the associated class conference.  Federates that subscribe to any attribute in a given class attend as listeners so they can discover new instances.  Federates that do both attend the class conference as talkers.  There is one floor in class conferences and it remains open so new instances can be announced by any federate.Within the class conference a further sub-conference is created for each class attribute.  Further, as non-DDM instances are registered, and therefore announced, a floor is created for each in each attribute conference and marked as  owned by the instance attribute owner or left open if there is no owner (i.e. the federate that registered the instance does not publish that attribute). Federates send speaker (or talker, if they also wish to receive updates to a given attribute) delegates to the attribute conferences that they own.  When they update an instance attribute this is announced to the attribute conference.  Federates that only subscribe a given attribute send listener delegates.  As a result of this design subscribing federates receive updates of all instance attributes. The HLAprivilegeToDeleteObject attribute has an attribute conference defined as well; however, no attribute values are associated with the instance floors created in it.  Ownership of an instance floor in an attribute conference is, instead, treated as a privilege token [8].Instance attributes that use DDM to update into an update region set have a sidebar created for them and associated with the owning federate.  Each sidebar has a wait zone and a doorman.  In addition to attending the general conference, subscribers using DDM attend all sidebars after being checked by the doorman.  The check entails comparison of the sidebar owner’s update region set with the subscriber’s region set.  If there is an overlap the subscriber is admitted.  If there is no overlap the subscriber is placed in the wait zone.   When the update region set or a subscribe region set (of an attendee or waiter) is changed the comparison is carried out again and attendees/waiters are removed from the sidebar/wait zone and placed in the wait zone or admitted to the sidebar as appropriate.All non-DDM subscribers also attend all sidebars in order to hear these updates as non-DDM subscribers must hear all published data and they would miss these updates otherwise as they are not announced into the general conference.  The doorman allows immediate access to such delegates.Interactions are modeled using a subset of the above features.  Initially an interaction class conference is created for each interaction class defined in the FOM.  All subscribing federates attend the appropriate interaction class conference as listeners.  Federates sending a non-DDM interaction do so into the general conference.  A single sidebar/doorman/wait zone is created in the interaction class conference to handle publishers and subscribers to the class that use DDM.  All DDM subscribers are placed in the wait zone as they are created because interactions are transient.  Each time an interaction of the given class is sent using DDM, in addition to announcing it in the general conference, the doorman function is carried out on each waiter to determine if it should receive the interaction.   The doorman is provided with the related update region set for each send and receiving subscribers are, in effect, admitted to the sidebar for that single send.  Each non-DDM subscribing federate is also admitted   to the sidebar so it will receive these announcements.Details of object instance deletion and attribute ownership and transfer in this model are covered in [8].4.1 A Non-DDM Federation ExampleFigure 4 provides an example federation conference structure in which the federates are using non-DDM publish/subscribe services.  Because the handling of interactions in this model is a subset of that of instance attributes interactions are not considered.  The following introduces the symbology used in this and the next example.  A conference or sub-conference is represented as a named enclosing box.  An unnamed box with one floor depicts a sidebar.  Wait zones are depicted as a smaller box.  The two are connected by a line bisected by a “  ”, which is the symbol for a doorman.  A heavy horizontal line represents a floor.  The name below it is the instance that the floor represents.  A line to the associated federate’s delegate (a speaker or talker attendee) identifies its owner. Otherwise, the floor is marked as “open”.  Attendees or waiters are identified by the name, in capitals, of the party they represent (e.g. “FED X”).  A subscript identifies their type: ‘S’ for speaker, ‘L’ for listener, ‘T’ for talker.In the example the federation execution consists of three federates; A, B and C.  Only one object class is defined, object class X, which has two attributes:  X.a and X.b.  The RTI and supporting RCs are shown in figure 4 but not considered further in this discussion.Figure 4.  An Example of a Federation Conference using non-DDM Services OnlyFederate A publishes attributes of object class X and, therefore, sends a speaker delegate (FED AS) to the object class X conference.  This will allow it to announce new instances of X.a and X.b.  Federates B and C subscribe this object class and, therefore, have listener delegates at the conference to hear new instance registrations.  Federate A has registered one instance of class X.  As a result, a floor (inst 1) has been created in each attribute conference.  The floor’s owner in X.a and X.b is FED A because federate A publishes both these attributes.  They are speakers so updates can be sent.  The HLAprivilegeToDeleteObject attribute for instance 1 is  also owned by federate A because, when registered, federate A was publishing at least one attribute of this object class.  Finally, federates B and C have listeners at attribute conference X.a as they both subscribe this attribute and federate C has a listener at attribute conference X.b as it further subscribes this attribute.4.2 A Federation Example Using DDMExtending this example to use DDM, figure 5 shows class X’s conference after federate A register’s a second instance which updates into update region sets associated with X.a and X.b.  In addition, federate C has changed its subscriptions to both X.a and X.b to use DDM subscription region sets.  Federate C’s subscription region set for class attribute X.a does not overlap federate A’s update region set for instance 2.   Therefore, federate C is placed in the wait zone for this instance attribute.  However, federate C’s subscription region set for instance 2’s X.b attribute does overlap federate A’s update region set for this attribute.  Federate C’s listener delegate is therefore placed in the sidebar and will hear all updates to this instance attribute.  Note that federate C also has Figure 5.  Details of Class X Conference using DDM delegate attendees in the main conference for each attribute so it can hear the (non-DDM) updates to instance 1, and that federate B, which continues to be a non-DDM subscriber to X.a, is admitted to the instance 2 sidebar. 5. The RTI Conference Model and SIPThere are various ways to implement an RTI on top of SIP.  The SIP core specification [6] was developed to allow extensions to the protocol and many have been defined.  Some of these lend themselves to the implementation of HLA features.  For example, the SUBSCRIBE/NOTIFY [10] and PUBLISH [11] methods, when used in conjunction with an appropriate “event package”, seem tailor-made to support HLA publish and subscribe requirements.  Other SIP primitives and capabilities can be used to support other HLA concepts.  Initially an approach of building an open RTI “from the ground up”, based on these primitives and extensions, was considered.  However, as research progressed it became clear that the conferencing model supports much of the behavior embodied in the HLA.  Further, much work has been done in defining such conference mechanisms (for example the IETF XCON effort [12]) and commercial conferencing software is available from various companies (e.g. Radvision, Convedia, Polycom).  When SIP is used to set up and control conferences SIP messaging (signaling) channels are used to carry conference control data as opposed to interleaving this information with the actual conference data on the conference’s session (application) channels.  In using SIP as the basis for Open RTI communication the “application” data to be carried is not the traditional multimedia data of a human-human conference but, rather, the data required by the RTI to implement the rules of the HLA and services offered by the RTI.  Three approaches to using the SIP to support an RTI implementation were considered.A SIP-minimal Implementation StrategyThis approach simply uses SIP to establish a multiparty conference between RCs to support their communication.  Runtime infrastructure information is transferred using the established SIP session channels.  While federation management services are implemented according to the Open RTI model, the model is not used further in this strategy.   However, the benefits of SIP, such as security and firewall traversal and the ability to provide realtime service and quality of service (QoS) features to the session channels (making communication between RCs fast or, at least, predictable) are obtained.   The approach has a minimal impact on the RTI’s implementation and thus is a SIP-minimal approach.A SIP-maximal Implementation StrategyThis approach represents the other extreme in using SIP.  A conferencing package, which closely, or exactly, supports RTI conferencing requirements, is built and used.  All conferencing control and RTI related communication uses the SIP signaling channels.  While this approach maintains the SIP benefits of security and firewall traversal it would lose the benefits of inter-RC speed of communication and QoS controls as much, if not all, RTI messaging would now move over the SIP signaling channels not the session channels.  It would also require significant rework of existing RTI implementations to make use of the custom built SIP communication infrastructure (and is therefore called a SIP-maximal approach).  A SIP-nominal Implementation Strategy This approach falls between the previous two.  In it standard SIP techniques are used to implement a conferencing framework between RCs and the Open RTI conferencing model is implemented over the resulting session channels to implement RTI functionality. Conference control and RTI communication occurs over the session channels.  Quality of service techniques can be applied to RTI communications over the session channels and the benefits of SIP as an underlying communication protocol are gained.   Our research is pursuing this approach.6. ConclusionsIt is apparent that SIP will bring many benefits to the implementation of an RTI if used as its communication layer.  Technically, it provides built-in security features and addresses firewall traversal issues problematic in today’s RTI implementations.  It also is a simple and robust protocol gaining widespread support in various industries and organizations (telecom, DoD).A conference-based model of the HLA, referred to as the Open RTI conferencing model, can be used to support the complex requirements of RTI data distribution management services in addition to object management capabilities.  Previous work [8] has developed mappings to HLA ownership transfer functions.  The model makes use of a component-based RTI model which supports flexible implementation.  The Open RTI conference model may be transferred to a SIP conferencing implementation using a variety of approaches.  The SIP-nominal approach, in which SIP signaling is used to establish a federation conference after which session channels are used to carry conference and RTI signaling, is the focus of continuing research.This research is exposing some very interesting possibilities in the development of an open RTI that, in addition to the benefits of SIP, will support interaction with other SIP-based applications and may lead to an interoperable RTI specification.  As research progresses the conferencing model continues to gain viability.  Further work will be done and the authors, once again, encourage those interested in joining us in a SIP Modeling and Simulation Framework Study Group.7. References[1] F. Kuhl, R. Weatherly and J. Dahmann: “Creating Computer Simulations”, Prentice Hall, Englewood Cliffs, New Jersey, U.S.A., 1999. ISBN: 0-13-022511-8[2] IEEE, “Standard for Modeling and Simulation (M&S) High Level Architecture (HLA) – Framework and Rules”, IEEE Std 1516-2000, The Institute of Electrical and Electronics Engineers, Inc., New York, NY, U.S.A., 2000.[3] IEEE, “Standard for Modeling and Simulation (M&S) High Level Architecture (HLA) – Federate Interface Specification”, IEEE Std 1516.1-2000, The Institute of Electrical and Electronics Engineers, Inc., New York, NY, U.S.A., 2000.[4] IEEE Standard for Modeling and Simulation (M&S) High Level Architecture (HLA) – Object Model Template (OMT) Specification, IEEE Std 1516.2-2000, The Institute of Electrical and Electronics Engineers, Inc., New York, NY, U.S.A., 2000.[5] T. Pearce and N. Farid: “If RTI’s Have a Standard API, Why Don’t They Interoperate?”, paper 04F-SIW-100, Simulation Interoperation Standards Organization Fall Simulation Interoperability Workshop, Orlando, Florida, U.S.A., 19-24 September 2004.[6] J. Rosenberg, H. Schulzrinne, G. Camarillo, A. Johnston, J. Peterson, R. Sparks, M. Handley and E. Schooler: “SIP: Session Initiation Protocol”, Network Working Group, Request for Comments: 3261,  HYPERLINK "http://www.ietf.org/rfc/rfc3261.txt" http://www.ietf.org/rfc/rfc3261.txt,  The Internet Society, June 2002.[7] S. Holben, R. Johnson and M. Herald: “Converging Software Architecture with Next Generation Distributed Technologies”, paper 04F-SIW-032, Simulation Interoperation Standards Organization Fall Simulation Interoperability Workshop, Orlando, Florida, U.S.A., 19-24 September 2004.[8] T. Pearce, S. Holben and C. Van Ham: “Implementing RTI Object Ownership Transfer Using SIP Services”, paper 05S-SIW-135, Simulation Interoperation Standards Organization Fall Simulation Interoperability Workshop, San Diego, California, U.S.A., 3-8 April 2005.[9] M. Handley and V. Jacobson:  “SDP: session description protocol”, Network Working Group, Request for Comments: 2327, Internet Engineering Task Force, The Internet Society, April 1998.[10] A. Roach: “Session Initiation Protocol (SIP) - Specific Event Notification”, Network Working Group, Request for Comments: 3265,  HYPERLINK "http://www.ietf.org/rfc/rfc3265.txt" http://www.ietf.org/rfc/rfc3265.txt, The Internet Society, June 2002.[11] A. Niemi: “Session Initiation Protocol (SIP) Extension for Event State Publication”, Network Working Group, Request for Comments: 3903,  HYPERLINK "http://www.ietf.org/rfc/rfc3903.txt" http://www.ietf.org/rfc/rfc3903.txt,  The Internet Society, October 2004.[12] Internet Engineering Task Force (IETF) Centralized Conferencing (XCON) Working Group Official Charter.  HYPERLINK "http://www.ietf.org/html.charters/xcon-charter.html" http://www.ietf.org/html.charters/xcon-charter.htmlAuthor BiographiesTREVOR PEARCE is an Assistant Professor with the Department of Systems and Computer Engineering at Carleton University, Ottawa, Canada.  His research interests are in embedded real-time systems, distributed simulation, and engineering methodologies.CLAUDE VAN HAM is a student in the Department of Systems and Computer Engineering at Carleton University where he is pursuing an M.A.Sc. in Electrical Engineering.  Claude has worked as a systems engineering officer on the CF-18 fighter aircraft responsible for avionics, computers and electronic warfare systems.  He has also worked in the telecommunications industry in the development of new products and technologies and the implementation of an international VoIP network.  He has a previous M.S. from the University of Hawaii at Manoa and a B.Eng. from the Royal Military College of Canada, both in electrical engineering. Note that with objects the federate indicates its intent to publish specific attributes not the entire object class. An event package is used to identify state information that can be subscribed to by a SIP endpoint.