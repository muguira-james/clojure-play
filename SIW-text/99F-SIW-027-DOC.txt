Laguna Beach: HLA on Baywatch?Marco Brass√©Wim HuiskampHans JenseLeo BreebaartTNO Physics and Electronics Laboratory.P.O.Box 968642509 JG The Hague, The Netherlands{brasse | huiskamp | jense | breebaart}@fel.tno.nl Keywords:HLA, Legacy Code, Federate Development, RTI Middleware, Code Generation ABSTRACT:  Laguna Beach is a legacy stand-alone flight simulator, developed for demonstration purposes by Silicon Graphics, Inc. The Simulation group at TNO‚ÄìFEL was able to successfully, and with only a modest amount of effort, convert this legacy application into an interoperable, HLA-compliant multi-aircraft federation. This rapid migration was achieved by using the RCI (Runtime Communication Infrastructure), developed by TNO‚ÄìFEL in the Simultaan project. The RCI is a code-generating middleware layer that abstracts simulation applications from the underlying interoperability standards (such as HLA or DIS). In the case of HLA, the RCI takes HLA object models as input, and from these the RCI code generator produces the necessary RTI communication and administrative framework.The first phase of the Laguna conversion process consisted of a FEDEP-based design cycle focused on analysing the code and data structures, identifying the required federates, and mapping the entities and state representations to HLA objects and interactions. The second phase consisted of using the RCI to generate the federation framework from the Laguna SOM created in the first phase. In the third phase the original application was then attached to this framework. TNO‚Äôs experiences with the Laguna Beach conversion show that a middleware-based approach to simulator migration is a highly successful one that can significantly decrease the time and effort necessary to achieve HLA-compliance for legacy simulators.1. IntroductionOf considerable interest to various user communities in the simulation world is the question of how well HLA supports the migration and re-use of existing simulators that communicate using a different communication standard, or that may not even be interoperable at all ([4], [5]). This paper describes a project in which Laguna Beach, a legacy stand-alone flight simulator, was successfully, and with only a modest amount of effort, converted into an interoperable, HLA-compliant multi-aircraft federation. This conversion made use of the RCI (Runtime Communication Infrastructure), a code-generating middleware layer that abstracts simulation applications from the underlying interoperability standards. The RCI concept was developed by TNO-FEL in the Simultaan project [1].2. The Simultaan Project and the RCISimultaan is a 2.5 years project which brings together knowledge and experience in the area of simulators and distributed simulation from universities, research institutes and industry in The Netherlands.Simultaan aims at the development of a generic simulator architecture, facilitating the interoperability of a wide range of simulators, including manned mock-ups of vehicles, high-fidelity flight simulators and unmanned simulators.In Simultaan, each federate consists of a number of components such as a visual system, a motion system, a dynamic model, and a mock-up server. Two types of communication can be distinguished: communication between components (local communication) and communication between federates (global communication). Both types of communication are supported by the architecture. For the communication between federates international standards for simulator interoperability are used. This means the Simultaan architecture supports, for instance, both DIS and HLA by providing one common interface.Two major results of the project were the Simultaan Simulator Architecture (SSA), which is the common high-level architecture for simulators and tools developed by the Simultaan partners, and the Run-time Communication Infrastructure (RCI), which is an implementation of the SSA. The SSA shields the interoperability standards from the component or federate developer by presenting an abstraction layer (or middleware).The RCI provides the run-time interface services for communication between components in a federate and between federates in a federation, according to the SSA Interface Specification. The RCI is a protocol-independent interface to the simulated environment. It uses OMT files as a basis for generating C++ code that interacts directly with the underlying interoperability standards. EMBED Word.Picture.8  Figure  SEQ Figure \* ARABIC 1. The RCI Operational ConceptFigure 1 shows the operational concept of the RCI. For more information on Simultaan, the RCI, and their history, we refer the reader to [1] and [2].3. Laguna BeachLaguna Beach is a legacy stand-alone flight simulator, developed for demonstration purposes by Silicon Graphics, Inc. In Laguna Beach a single player controls an aircraft (either F14, F16, or Su35), while the application takes care of running any number of additional ‚Äòbogey‚Äô aircraft in auto-pilot mode.3.1 Why Laguna Beach?Laguna Beach was chosen as a test-case for our HLA experiments because it fulfills a number of useful requirements:It is a good example of a true legacy simulator: Laguna Beach was written without the intent of hooking it up to other simulators. Adding interoperability to an entirely stand-alone application makes for a challenging test case of the RCI.Laguna Beach was developed by a third party, so the code was truly unfamiliar and new to us. We could not rely on prior knowledge of the implementation.Laguna Beach is a demo application, not a production-level simulator. It has the dual advantage of being complex enough to go beyond being a trivial toy program, yet having an implementation that is still relatively straightforward. Consequently, working with the code does not consume too much time and effort of its own account.Because of its SGI demo roots, Laguna Beach is a visually appealing, fun test case that can be freely demonstrated to others. We are not bound by the restrictions often attached to the applications that are developed in-house or for customers. 3.2 The original code Laguna Beach consists of about 10.000 lines of C code, spread out over some 40 source and header files. The relatively small size of this code base is made possible by the heavy use of Iris Performer for all aspects of the visualisation, and by the fact that, as a demonstration application, the simulator is not intended to be complete or entirely realistic. Laguna features a mature flight model, but only basic support for sensor- and weapons systems.3.3 Platform and ToolsLaguna Beach runs on an SGI Onyx 2. Compilation uses the MIPSPro C++ compiler 7.2.1.3m and version 1.0 of the RCI. The visuals require Iris Performer 2.2.2. The Laguna FOM was developed with OMDT 1.3.3.13, and the final program executed against the RTI 1.3v5.4. Migration to HLAThe development of the Laguna federation was done using the standard, iterative six-step Federation Development and Execution Process Model (FEDEP) [3] as a guideline. However, as we were not developing a new federation from scratch, but rather converting an existing model not developed using any formal methodology, the extent to which the FEDEP could be followed accurately was limited.4.1 Define Federation ObjectivesThe primary objective in developing the Laguna federation was to add interoperability to the original application, so that aircraft simulated in different instances of the Laguna federate would be able to interact with each other in the virtual world through HLA.Of particular interest to us was the question of how much time and effort a bare-bones migration to HLA would take. Furthermore, we wanted to obtain estimates of the performance penalty associated with using the RCI, and of the extent to which the original implementation would have to be adapted.4.2 Develop Federation Conceptual ModelAs we wanted to touch the existing code as little as possible, we opted for a conceptual model identical to the one used by the original Laguna implementation.This meant analysing the existing Laguna data structures and functions, and mapping these one-on-one onto Federate objects and interactions, without trying to improve on the original design.This led to a conceptual model consisting of a single monolithic Aircraft object, with engines and weapons subsystems modeled as attributes of the Aircraft, rather than as federates or Simultaan components in their own right.4.3 Design FederationThe design of the federation, like the conceptual model, followed trivially from the requirement that the HLA Laguna should have identical functionality to the original Laguna. No enhancements or changes were desired. This led to a simple federation consisting of just a single federate type: the Laguna aircraft. In other words: the federation FOM is identical to the federate SOM.4.4 Develop FederationUsing the object model resulting from step 4.2 in conjunction with the OMDT application, a Laguna SOM file was created that served as input to the RCI. As was mentioned in section 4.2, our SOM was designed to be a field-by-field equivalent of the original monolithic Laguna aircraft data structure. This led to an equally monolithic object model, a part of which is shown in Figure 2.Figure 2. The Laguna Aircraft SOMUsing the SOM as input, our RCI-tool next generated the C++ classes that implement the objects and events constituting the Laguna federate. These classes interface with the HLA RTI in areas such as attribute publishing/subscribing and data type encoding/decoding, and release the application programmers from having to implement this low-level functionality themselves. The remaining task was the grafting of the generated code onto the original Laguna application. This involved three steps:Writing conversion routines that copy state from an Aircraft structure (original Laguna) to the corresponding AircraftObject structure (RCI), and vice versa.Find entry points in the Laguna initialisation code to attach the RCI start-up code to. Have the RCI‚Äôs call-back methods take over the formerly self-contained Laguna main event loop, while executing the appropriate conversion routine from step 1 before and after aircraft updates.This process can be illustrated by the following ‚Äòbefore‚Äô and ‚Äòafter‚Äô pseudo code.The original, non-interoperable Laguna main event loop:void runLaguna(){  Aircraft *me = new Aircraft();  initSimulation(me);  while (exitFlag == false)  {      updateSimulation(me);  }}The main event loop with RCI integration added:     // utility function: copy internal Aircraft     // state to HLA‚Äôs AircraftObject, using     // RCI-generated accessors.void fromLagunaToRCI(Aircraft* a,                      AircraftObject* ao){  ao->setNumberOfMissiles(a->nMissiles);  ao->setHeightAboveTerrain(a->hat);  ao->setVelocity(a->v);    // etc . . .}  // Similar to the previous function,   // but now in the other direction:void fromRCIToLaguna(AircraftObject* ao,                      Aircraft* a){  a->nMissiles = ao->getNumberOfMissiles();  a->hat = ao->getHeightAboveTerrain();  a->v = ao->getVelocity();    // etc . . .}  // Receive state changes from other  // federates.void updateobject(RCIEvent* evt){  AircraftObject *aRemote =       evt->determineObject();  Aircraft *aLocal = mapAircraft(ao);  fromRCIToLaguna(aRemote, aLocal);}  // Update myself, and pass the  // state changes on to RCI/HLA void sync(RCIEvent* evt){  if (exitFlag == true)  {    env.quit();  }  else  {    updateSimulation(a);    fromLagunaToRCI(me, meRCI);  }}runLaguna(){	// create the RCI environment  static HLACommunicationServer server;  static Environment env(&server);    // create internal Aircraft data structure  Aircraft *me = new Aircraft();  initsimulation(me);    // create and join HLA federation    // (through RCI ‚Äòenvironment‚Äô methods)  env.createFederation("Laguna");  env.joinFederation(federateName, 20.0);    // register the ‚Äòupdateobject‚Äô function    // as an RCI callback object  FunctionCB* syncCB = new FunctionCB(sync);  env.subscribe(SyncEvent());  env.addCallBack(SyncEvent(),syncCB);    // register the ‚Äòsync‚Äô function    // as an RCI callback object  FunctionCB* updateobjectCB =       new FunctionCB(updateobject);  env.subscribe(UpdateObjectEvent());  env.addCallBack(UpdateObjectEvent(),                  updateobjectCB);    // publish and subscribe attributes  AircraftObject::Init();  env.publish(AircraftObject());  env.subscribe(AircraftObject());	// create and register Aircraft HLA object  AircraftObject *meRCI = new AircraftObject();  env.registerObject(*meRCI);    // give control of the process to RCI  env.control();     // resign and destroy federation  env.resignFederation();  env.destroyFederation();}Our rather brutal ‚Äúcopy all attributes during an update‚Äù approach was intended as a first approximation, but never replaced because it was already fast enough. In future, optimised versions of Laguna Beach, we can make use of the more sophisticated RCI features that allow us to communicate only the attributes that were actually changed between updates.4.5 Integrate and Test FederationAs the Laguna federation consists of only a single user-defined federate, integration and testing was relatively straightforward, and mainly involved making sure the application still functioned as before, but that multiple Laguna federates in the same federation could now indeed interact with each other.The tests were performed both in-house and during three-days of ‚Äòlive‚Äô demo sessions with SGI at the ITEC ‚Äô98. Figure 3 shows the federation architecture of the system that was used for these tests.Figure 3. Laguna Beach Federation ArchitectureThe RTI and the Federates run on one or more Onyx machines connected over a 100 Mbit Ethernet link. User input is handled by a flybox directly connected to the machine running the federate, or by a flybox-emulating PC that allows the use of more conventional PC-type joysticks and control systems, such as the F16 Thrustmaster. Sound is handled for individual federates by including one or more PCs running TNO-FEL‚Äôs sound servers over TCP/IP.4.6 Execute Federation and Analyze ResultsExecution tests showed that the use of the RCI middleware layer caused no noticeable performance penalties in a system containing up to three federates.When analysing the results, we also concluded that running the Laguna Beach simulator is great fun as well as an educational HLA exercise.5. ConclusionsOur experiences with the Laguna Beach HLA migration experiment indicate that the middleware approach taken by the Simultaan RCI works well. Using the RCI to generate an HLA-interfacing layer of code frees the programmer from much repetitive grunt work, while increasing the portability and stability of the application in question.The answers that were obtained for the questions identified in section 4.1 are all quite positive. The development of the HLA-compatible Laguna version took less than a month, and much of that time was spent mastering the intricacies of the original code. Even for an application that was in no way optimised for efficiency or communication speed, the performance turned out to be adequate for at least a three-federation system. And finally, integrating the RCI-generated code with the original implementation took less than a few dozen additional lines of code.5.1 Future PlansNow that we have reached our basic goal of proving RCI feasibility in an HLA migration context, a number of interesting other avenues have opened up for possible exploration.We can now, for instance, let go of our requirement that the original code base should remain as intact as possible, choosing instead to develop Laguna (or parts of it) into a more mature federation. This could e.g. be done by splitting off the weapons- and sensor systems of the aircraft and developing these as HLA federates or Simultaan components in their own right. It would also be interesting to have RCI-supported federates like Laguna take part in larger federations.Last, but not least, it would be interesting to investigate the performance aspects of Laguna Beach more thoroughly, gaining a better insight in the limitations and overhead penalty introduced by use of the RCI.6. AcknowledgementsThe Laguna Beach project would not have been possible without Paul van Gool (formerly of TNO-FEL, currently with Illgen Simulation Technologies, Inc), who did much of the RCI development and implementation, and who was responsible for the initial HLA migration of the Laguna Beach simulator.The authors would also like to extend their gratitude to M. J. van der Marel and his colleagues at Silicon Graphics Inc, for making the Laguna Beach code base available to us, and for their enthusiastic support of this project in general.7. References[1]	Marco Brass√©, Wim Huiskamp and Olaf Stroosma, ‚ÄúA Component Architecture for Federate Development‚Äù, (99F-SIW-025, submitted), 1999 Fall Simulation Interoperability Workshop, Simulation Interoperability Standards Organization. [2]	Robert-Jan Elias and Wim Huiskamp, ‚ÄúAdvanced Simulation Framework: A Generic Approach to Distributed Simulation‚Äù, Proc. ITEC ‚Äô97, The 8th International Training and Education Conference, Lausanne, Switzerland, 1997.[3]	Department of Defense, ‚ÄúHigh Level Architecture Federation Development and Execution Process (FEDEP) Model‚Äù, Version 1.4, June 9, 1999.[4]	Barham, P., Barker, R., Beckwith, R., ‚ÄúImplementing a Simple HLA Federate: Lessons Learned from a DIS Perspective‚Äù (98S-SIW-120), 1998 Spring Simulation Interoperability Workshop, Simulation Interoperability Standards Organization.[5]	Lois C. Yu, Jeffrey S. Steinman and Gary E. Blank, ‚ÄúAdapting Your Simulation for HLA‚Äù, SIMULATION 71:6, 410-420, December 1998.Author BiographiesMARCO BRASS√â is a member of the scientific staff in the Command & Control and Simulation Division at TNO-FEL. He is a project member for several projects in the area of distributed simulation. He holds an M.Sc. in Computing Science from Eindhoven University of Technology and a Master of Technological Design (MTD) in Software Technology, also from Eindhoven University of Technology. His research interests include parallel and distributed computing, software architectures, and design methodologies. WIM HUISKAMP is a research scientist in the same division. He earned an M.Sc. degree in Electrical Engineering at Twente University of Technology, The Netherlands. He works in the field of High Performance Computing and Networking and specialises in design and implementation of distributed computer architectures. His research interests include system architectures, real-time visual simulation and multi-media technology. Wim was the project lead for Simultaan.HANS JENSE is a senior scientist in the Command & Control and Simulation Division at TNO-FEL, and is currently the head of the Simulators Group. He holds a Ph.D. in Computer Science from the Leiden University. He recently spent a year as principal investigator in a virtual reality environment technology project at the NASA Ames Research Center. His research interests are in general VE and distributed simulation technology, its application in the defense and aerospace fields, information visualisation and the relationship between technical and human factors issues.LEO BREEBAART is a research scientist in the same division. He earned an M.Sc. degree in Computer Science at the Leiden University. His research interests include compiler technology, high performance computing, and interface design.