System Composition in OneSAFDerrick J.Franceschini, Kurt R. Hawkes, Stephanie Graffuis Science Applications International Corporation12901 Science DriveOrlando, FL 32826-3014321-235-7687derrick.j.franceschini@saic.comGene McCulleyCuspy Engineering Solutions, Inc.Keywords: Composition, OneSAFABSTRACT: One of the major differences that sets OneSAF apart from other CGF systems is composability.  According to its Operational Requirements Document, OneSAF must support the end user’s ability for Battlespace Composition, i.e., construct new units, entities, behaviors, and representations of the environment, as well as System Composition, i.e., construct new applications and systems out of those composed applications.  This paper describes the OneSAF System Composition Approach, its characteristics, and its implications on software components, developers, users, and the System.  The current implementation status of the System Composition approach is described, including describing the number and types of OneSAF Software Components currently in place, a description of the tools and technology that makes System Composition in OneSAF possible, as well as future challenges for OneSAF System Composition.IntroductionOneSAF is being developed as the US Army’s next-generation Computer Generated Forces system.  OneSAF is intended to satisfy the requirements of and to be used across the three Army modeling and simulation domains of Advanced Concepts and Requirements (ACR), Training, Exercises, and Military Operations (TEMO), and Research, Development, and Acquisition (RDA).  In order to satisfy the broad requirements of the different domains, OneSAF is being developed as a composable product line.  The OneSAF Product Line approach is described in detail in [3].  Specific instances of the OneSAF are called ‘System Compositions.’  As shown in  REF _Ref30478242 \h Figure 1, System Compositions are combinations of specific executable instances of products from the product line.  These executable instances of products are called ‘Application Compositions’.  Application Compositions are made up of Software Components and Software Services.  Figure  SEQ Figure \* ARABIC 1 System Composition BreakdownOverviewThe System Composition Approach in OneSAF is responsible for both Software Application Composition and System Composition, i.e., building executable applications from software components and building coherent groups of applications from available applications.  System Composition describes the constituent software components and software applications that are available for execution within OneSAF.  Software Application Composition describes the constituent software components, compositions, and their relationships that make up an executable software application available for execution within the system.  Essentially software development creates OneSAF Software Components, and those Software Components can then be composed together to create more complicated software components and/or executable software applications.  Specific groups of Software Applications can then be collected into a System Composition.  A System Composition can be deployed as a tailored set of tools for a specific purpose, e.g., a Leader and Staff Training System Composition.Software Developers create software components and initial versions of software application compositions, and initial system compositions.  System Administrators and Model Composers use the System Composer to tailor those applications and system compositions to their specific needs.  Software Application Composition Capabilities The following sections describe capabilities that the OneSAF System Composition approach must provide to satisfy user requirements.  These capabilities establish policies and criteria for software components and the Composition Architecture, which is independent of the selection of the composition approach.Software Component Discovery In order to minimize the user burden of adding new software components and software compositions to the OneSAF system and the maintenance burden of locating and packaging software components, it is important to establish a discovery policy for software components and compositions.  This policy provides information on how the OneSAF system, including other software components, finds out about software components.  This is achieved through the use of consistent naming conventions, consistent software component and composition locations within the OneSAF system, and consistent software component format.Software Component Decoupling To facilitate software component reuse, software components should rely on as few other software components as possible.  In other words, software components should be decoupled from other software components.  A software component that is strongly decoupled from the system has few dependencies on other parts of the system, so it may be brought into a composition without bringing in all other parts of the system with it.  Strongly decoupled software components are especially important at the lowest level of the layering diagram, as those should be the software components that are reused most.  This allows different implementations of lower-level software components to be used to achieve different quality or functional characteristics of the system.  Higher-level software components potentially will have several dependencies on lower level software components.Decoupling is achieved through interface design and the design of functionality boundaries.  For example, interfaces that rely on events for communication are typically more strongly decoupled than interfaces that rely on direct method invocation.  However, direct method invocation interfaces can be made decoupled by keeping the scope of the functionality the interface describes compact.Software Component Certification Software component developers must ensure that their software component provides the functionality that it advertises and does not adversely affect the remainder of the system.  To satisfy this, OneSAF developers are required to provide unit tests that exercise their software component’s functionality and certify that their software component abides by its interface specification.  Developers are required to provide appropriate, descriptive meta-data that abides by the software component meta-data schema (see  REF _Ref31340430 \r \h 5.2 for a description of the meta-data).  Tools to support enforcement of these policies include tools to test convention (e.g., naming conventions are followed), conformance (e.g., appropriate meta-data and tests are provided), and specification (e.g., where possible, the correct meta-data was supplied).   Once certified, software components can be digitally signed, i.e., electronically sealed, to ensure that post-distribution modification is obvious.  This aids in determining if they should trust using this component in their application.  It is envisioned that signing will become part of the OneSAF distribution process.Software Application Composition ValidationFinal OneSAF Software Application validation will be conducted at the user level once a software application is composed.  Tools will be utilized to help find problems early.  User-modifiable composition rules will be provided.  For example, it could be required that only validated software components can be used in an exercise or that software applications are made of models with similar fidelities.  Tools are provided to test the software applications against these rules and provide warnings of any software application inconsistencies.  Automated build and test tools to ensure software applications operate correctly on supported platforms will be provided.  These tools allow for the cost-effective distribution of source and pre-built software components while also reducing product line maintenance costs.System CompositionUsers create a new system composition description using the System Composer Application with existing Software Application Compositions.  Compositions are stored as composition files in the System Composition Repository (SCR) for later use.  They contain meta-data that describes their characteristics and constraints. As an aid to users, the System Composition Application provides Composition Rules to help filter the pallet of available software components and compositions.  As an additional aid for Users, the System Composer Application provides Composition Templates.  These templates are essentially incomplete compositions: the structure of a System Composition without all required software component dependencies satisfied or the fully developed functionality for the composition developed.  As a result, System Composition is fundamentally an activity of packaging existing Software Application Compositions into a consistent suite of tools representing a System.Software Application CompositionSoftware Application Composition is fundamentally a process of binding or connecting software components in meaningful ways.  Software development knowledge is required to fully use this capability, although only basic knowledge of OneSAF software component relationships is needed to create simple compositions.  When composing new software applications, users create a new Software Application using the System Composer Tool based on existing software components and compositions.  Software Application Compositions are stored in the SCR for later use in future System Compositions.   Software Composition ToolsA collection of tools is necessary to support System and Software Application Composition approach.  Aside from the System Composer Tool, these tools include a Component Manager, Component Checker, Composition Validator, and Runtime Loader.Component ManagerThe Component Manager is a runtime and design time tool.  It handles creating instances of the software components that make up compositions.  It performs reference bookkeeping on software component instances and manages references between software components.  This is used to manage software component unloading and singleton instances of software components within a composition.Component CheckerThe Component Checker is an important, separable part of the composition services. It verifies that software component meta-data is consistent with the software component it represents.  This is a necessary maintenance tool to ensure software components abide by their descriptions.  The Component Checker is used by the Component Manager, and is used during the software component build process.Composition ValidatorThe Composition Validator is another separable part of the composition services.  It verifies that Component and Composition dependencies are satisfied before making a software component or composition available at design or run time.  The Runtime Loader and the Component Manager use the Composition Validator to help ensure system stability.Runtime LoaderThe Runtime Loader provides the services that allow a composition execution.   It can be thought of as the ‘main’ method for all composed OneSAF Software Applications.  The Runtime Loader loads and executes Software Application Compositions.  It contains a Component Manager to manage inter-component references and Composition Validator to ensure dependencies are satisfied.  Additionally, Runtime Loader loads a core set of ‘bootstrap’ software components common to all Software Applications (e.g., the Repository Services).System Composer ToolThe System Composer Tool provides a Graphical User Interface for creating Software Applications and Software System Compositions.  As shown in  REF _Ref31426168 \h Figure 2 the System Composer Application provides users a graphical interface for constructing Software Applications and System Instances.  The user is given a palette of Software Components that can be combined together on the working canvas, to create an executable composition.  The user can also inspect properties of components and compositions, and view any components and compositions that have unsatisfied dependencies, making them unavailable for composition.  Compositions can be saved, opened, and executed with the System Composer.  The System Composer Application also includes an extensive on-line help capability.  It uses all of the aforementioned tools to help the user create valid compositions. Figure  SEQ Figure \* ARABIC 2 System Composer ToolComposition Design ApproachTo support the flexibility and extensibility required, the OneSAF System Composition Approach is designed as an extension of the JavaBeans [1] Framework.  The key distinctions of this approach from a pure JavaBeans approach are the inclusion of meta-data that defines specific characteristics of a software component or composition within OneSAF’s context, and the support for network transparency for data and code.  OneSAF software components and compositions are stored in the SCR to enable component and composition discovery.  They are consistently constructed in the following manner:Each software component is contained in a component file, which is implemented as a Java Archive (JAR) file.Each software composition is contained in a composition file, which is implemented as a JAR file.  Because components and compositions are built out of several files, an archive file format is used to make configuration management and transport easier.  The JAR file format was chosen as this format because it is already supported by the Java language APIs, it supports signing, and it is a well known standard that can be served up by web browsers, attached to email messages, and manipulated by standard tools (e.g. WinZip).Each software component is compliant with the JavaBeans specification.Each software component provides its composition specific meta-data through a metadata.xml file contained within the component file.  Also, all software components, compositions, composition templates, and their associated metadata will be stored and accessed through common repository functionality.  Because software components are consistently constructed and stored in a consistent location, the Runtime Loader and the System Composer can dynamically discover components.As shown in  REF _Ref15959191 \h  \* MERGEFORMAT Figure 4, software components must provide:A single Java-Beans compliant software component interface class, Any Java or native (non-Java) compiled code that implements that interface, Any data resources that are not typically going to be changed by users (e.g., the default icon that represents “file open” in a GUI menu), The meta-data file that contains characteristics of the software component such as dependencies,The manifest file that contains the index of files contained in the component file.Figure  SEQ Figure \* ARABIC 4 Component File ContentsSoftware components are contained in component files, which are implemented as JAR files.When Components are combined and specialized into a composition via the System Composer Application, they can be saved out into a Composition File.  As show in  REF _Ref30910078 \h Figure 5, the Composition File is stored in a JAR format.  It contains references to the components that make it up, stored component relationships, and meta-data describing characteristics of the composition.Figure  SEQ Figure \* ARABIC 5 Composition FileSystem Compositions are contained in a similar structure.  As shown in  REF _Ref30493155 \h Figure 6, System Composition Files are contained in JAR files, and contain references to Application Compositions.Figure  SEQ Figure \* ARABIC 6 System Composition FileComposition ContextAs shown in  REF _Ref16567467 \h  \* MERGEFORMAT Figure 7, the Runtime loader instances a composition by reading a pre-existing Composition Specification and requesting the Component Manger to instantiate the software components that it references.  The Component Manager manages all the relationships between software components.Figure  SEQ Figure \* ARABIC 7 Composition ContextThe Component Manager can manage software components and compositions based on their meta-data, such as security, fidelity, use of native code, etc.  This management includes ensuring user goals for particular software component characteristics are matched.  For example, the Component Manager ensures that a software component that depends on native code built for Windows is not loaded under Linux.To support user composition, the user can use the System Composer to create new compositions or edit existing ones.  The System Composer accesses composition specifications in the System Composition Repository.  Support for Non-Java ComponentsSoftware components that have functionality implemented in languages other than Java are considered native software components.  Examples of these software components in OneSAF include the Environmental Runtime Component, a reuse component from WARSIM that is written in C++.  Because of the portability constraints introduced with native code (e.g., native code must be compiled specifically for the platform on which it is to be executed), software components that contain native code have special markings in their meta-data files to inform the Component Manager that this software component has execution constraints.  The meta-data marking denotes that not only is this a native software component, but also the list of platforms that can execute this software component, and whether the native code is required for execution of this software component (i.e., some software components might get additional benefit from native code, but still might function without it).   For example, Component Manager will not load a software component that contains required native code on a platform that is not supported by that software component.   Other than additional meta-data markings, native software components are structurally equivalent to pure Java software components in that:They must provide a  JavaBeans[1] compliant software component interface,They must interface with other software components through appropriate interface mechanisms,They must contain built code that is executable on all platforms they claim to execute on.Current Status/Lessons LearnedThere are currently sixty OneSAF Software Components available.  These components range in size and complexity from a simple random number generator and scheduler algorithms, to the complex and large Environmental Runtime Component.  The overwhelming majority of OneSAF tools have been converted over to using and relying on Software Components.  The OneSAF Development Environment has been extended to check for incomplete and inconsistent components at build time, so that developers get early feedback on changes that are made.  An interesting benefit of the composition approach, and specifically the approach that requires each component to describe its dependencies, is that maintenance of the system has become simpler.  Before the System Composition Services were available, developers were forced to maintain complicated and brittle scripts that described dependencies.  These scripts would be copied for each executable, so reacting to a dependency change was cumbersome.The approach of using JavaBeans and staying within the native implementation language of the OneSAF Architecture (Java) for the Composition framework has allowed further leveraging opportunities.  System Composition Services are now able to take advantage of XML serialization for saving out component relationships and component properties in a composition.  This allows component relationships within a composition to evolve as the system changes over time.Future ChallengesA fundamentally composable system overcomes many roadblocks of monolithic systems, but also presents whole new challenges.  One of the remaining challenges that the Architecture and Integration team is facing is to provide mechanisms to combine component information into meaningful data within a composition.  For example, each component might describe what data it is capable of producing for Analysis activities.  Those pieces of data need to get combined together, potentially at the time of composition, to describe that Composed Application’s or that Composed System’s Instance Analysis Data Model.  Similarly documentation describing the use and maintenance of each component must be combined to ensure that the User’s Manual and Maintenance Manual are tailored to the specific System Composition being deployed.  ConclusionsThe OneSAF System Composition satisfies the OneSAF ORD’s [2] requirements for System Composition.  It allows users to graphically combine and customize components into executable Software Application Compositions, and allows users to graphically group particular Software Compositions into Systems.  The System Composition tools and services are in place in OneSAF, and there are currently over sixty OneSAF components available. AcknowledgementsThe work described in this paper was carried out on the Architecture and Integration Task Order for the Objective OneSAF System.  The author wishes to express thanks to our customer, PEO-STRI.References [1]	Sun Microsystems, JavaBeansTM Component Architecture,  HYPERLINK "http://java.sun.com/products/javabeans" http://java.sun.com/products/javabeans[2] “OneSAF Operational Requirements Document (ORD) Version 1.1”, 21 May 2001,  HYPERLINK "https://www.onesaf.net" https://www.onesaf.net[3] A. Courtemanche, R. Wittman: “OneSAF: A Product Line Approach for a Next-Generation CGF”, 11th-CGF-079, 11th Computer Generated Forces and Behavioral Representation Conference, May 2002.Author BiographyDERRICK FRANCESCHINI is the Common Services Lead on the OneSAF Architecture and Integration Task Order.  Mr. Franceschini has ten years of experience in virtual entity simulations utilizing Computer Generated Forces. Mr. Franceschini has served as the ModSAF Project Engineer, and was the original Project Engineer for the OneSAF Testbed Baseline (OTB) project.GENE MCCULLEY is a Software Engineer in the Common Services team on the OneSAF Architecture and Integration Task Order.  Mr. McCulley has ten years of experience in simulation, including the CCTT SAF, ModSAF, and OTB projects.KURT HAWKES has been a Software Engineer in the Common Services team on the OneSAF Architecture and Integration Task Order for the last two years.  Mr. Hawkes has over twelve years experience in software development.  STEPHANIE GRAFFUIS has been a Software Engineer in the Common Services team on the OneSAF Architecture and Integration Task Order for the last two years.  Prior to that, she worked in the area of embedded systems.