ESCADRE-5.1 : a SSE For Low Cost HLA ComplianceDominique Canazzi Philippe AnnicCS-SI, France+33 141 804 250dominique.canazzi@c-s.fr, philippe.annic@c-s.frNathalie Le RestJean-Louis IgarzaDGA/DSP/CAD, FranceKeywords:HLA IntegrationObject Oriented Design in a SSEABSTRACT: In 1999, the CAD (Center for Defense Analysis of the French MoD) subcontracted CS-SI (Communication & Systèmes) to develop ESCADRE-HLA, an HLA-enabled version of the ESCADRE Simulation Support Environment (SSE). This contract followed a feasibility study conducted in 1997-1998.The ESCADRE-HLA project terminated in June 2000 and produced an industrial SSE, ESCADRE-5.1, that allows the rapid development of HLA compliant federates. ESCADRE-5.1 is now used as a development tool in several large-scale projects.Following papers [1] and [2], this paper focuses on the technical choices made, mainly concerning:the merge of the HLA paradigm with the ESCADRE Actor design pattern,the representation of the HLA services within ESCADRE,the synchronization of the internal ESCADRE time with the HLA Time Management,the automatic code generation and the marshalling services.We conclude with some lessons learned as well as possible evolutions of the product.Design ApproachThe ESCADRE ModelESCADRE may be considered as a Run-Time Infrastructure operating within a federate or a standalone simulation. This “RTI” allows models to interoperate.Nevertheless, to avoid confusion, we will restrict the use of the term “RTI” to the HLA RTI in the sequel.The base element of ESCADRE V5 is the Actor model. An actor can be seen as an object class. V5 supports both the derivation (inheritance) and aggregation (composition) of Actors. An Actor may be abstract, meaning that parts of its behavior are just specified as abstract methods, to be implemented by derived actors. INCORPORER Word.Picture.8  Actors Hierarchies in ESCADRE V5The above picture shows a hierarchy of actors in ESCADRE V5. The ESCADRE basic libraries provide the abstract actors Root_Actor and Movable. Root_Actor brings all the basic instance management functions (creation, deletion, status management, etc.). Movable adds to it drawing capabilities and requires primitives giving the position and velocity.Practically, an ESCADRE Actor is the union of four fundamental Ada tagged types:Rec_Data represents individual local instance data. Operations of Rec_Data allow instance status manipulation and information gathering. Some primitives of Rec_Data allow the developer to perform specific operations such as  start, stop, display, etc.Rec_Init handles initialization data for individual instances. One primitive allows to read them from a file. Rec_Init is passed from the ESCADRE kernel to the actor, along with Rec_Data, during the instance start.Rec_Tno (Tno stands for technology) is used to handle constant data shared by some instances of the actor. Some primitives allow to read it from file, to display it and allocate the instance individual data (Rec_Data).Rec_Class usually carries no data, but allows important actor-wide “bootstrap” operations like Rec_Init and Rec_Tno allocation and Scenario and Replica (run) initializations.In addition, ESCADRE offers some abstract types, to be derived and associated with actors, to handle:Continuous variables and integrate them (using the Runge-Kutta algorithm),Events: any instance can plan future activities by posting events ahead in time; when such events are triggered, these activities are executed making the instance evolve; in some sense, events rhythm the life of instances,Interactions between instances that are not in the same composition hierarchy,Interactive operations on instances.The ESCADRE Root Actor provides abstract bases for all these types (Root_Data, Root_Init, Root_Tno, etc.).An ESCADRE application must register  actors at the ESCADRE kernel by providing prototypes of his derived types. Some extra generic packages are provided to ease this task.The HLA ModelThe HLA description model is very simple as it does not attempt to describe any actors behavior as well as no aggregation or, composition relationships between them, but only data inheritance hierarchies of object and interaction classes.How can these two models join?HLA Object ClassesThe correlation between ESCADRE actors and HLA object classes is quite intuitive. We say that, if an ESCADRE actor “publishes” a HLA object class for a given technology, a HLA object will be registered each time an ESCADRE instance is created in the technology.Reciprocally, an ESCADRE actor may “subscribe” a HLA object class with some technology. This means that, each time a HLA object of the subscribed class is registered by another federate, an ESCADRE instance of the subscribing actor will be created in the given technology.Of course, a HLA object class may be “subscribed” in such way only once (creation of multiple ESCADRE instances for one remote HLA object does not make sense).Practically, HLA object classes are represented by tagged types derived from the base type Root_Hla_Object_Class.HLA objects are represented by tagged types derived from Root_Hla_Object. The class type is used for publications and subscriptions, and as a factory for the object type. The object type has primitives for attributes reflection and update request.The parallel hierarchies of class types and object types represent exactly the FOM.HLA interaction classesIn HLA, interactions are from one federate to several federates. However, in the real world, interactions are always from one object to one or more objects.Therefore, in ESCADRE, any actor may “publish” and/or “subscribe” any HLA interaction class.Publication means that any instance of the actor is allowed to send interactions of the published class.Subscription means that all instances of the actor may be notified of incoming interactions of the subscribed class. We will see below how this notification may be restricted to one instance only.The practical Ada type scheme is quite identical for interactions and objects.All this declarative code in automatically generated form the FOM DIF (Data Interchange Format) file (see below).HLA within an ESCADRE applicationThis section shows how the HLA features have been integrated into the ESCADRE toolkit and engine. An important effort has been done to make this integration as transparent as possibleThe ESCADRE-HLA applications developer shall not know about the RTI Interface. He only has to use a given set of four abstract types and a dozen of primitives and operations.All incoming HLA events (attributes reflections, objects removals, interaction receptions, update requests, etc.) are turned into ESCADRE kernel events, so they can be delivered to Actor instances just in time, and when it may be done without any problem.Declaration ManagementIn ESCADRE-HLA, all the HLA declarations are static (subscriptions and publications are made once, just after the ESCADRE federate has joined). Object classes are always published and subscribed with all attributes.For object classes, a configuration file describes the potential associations between HLA object classes and {Actor, Technology} pairs. Effective declarations must take place during the elaboration of the actors and are checked against this configuration.All the developer has to do is:Make a final derivation of the class and object types corresponding to the HLA class he wants to publish or subscribe,Implement the object allocation primitive,In case of subscription, implement the “reflect” primitive.Call the publication and/or subscription operation during the actor’s elaboration.The scheme is quite identical for interactions.Object discovery, Attributes Updates & ReflectsPublication: Attributes UpdatesThe interface is very simple: the generated code offers per attribute “set” operations on the HLA object types. The ESCADRE kernel collects all these operations and performs the effective Update Attribute Values before time advances. The corresponding timestamp is set to the current ESCADRE date plus the federate lookahead.HLA objects are registered as soon as Actor instances are created. They are deleted when Actor instances are stopped.Subscription: Discovery and ReflectThe situation is a little more complex here: of course, one can create an Actor instance as soon as a HLA discovery happens, but we cannot start it without consistent initial data (Rec_Init).Therefore, the developer will use the first calls to the Reflect primitive for building initial data for the Actor instance. Once this is done, he can start the instance. The subsequent Reflects will be used to update the instance data (Rec_Data).Attributes values are obtained via the attribute operations “is valid” and “get”, provided by the generated code.Such an Actor instance is automatically stopped when the corresponding HLA object is removed from the federation.Interactions emission and receptionInteraction emissionThe generated code provides for each parameter of each interaction class in the FOM an operation to set the value, and ESCADRE-HLA provides a general “send” operation. The timestamp of the emitted interaction is set to the ESCADRE current date, plus the federate lookahead.Interaction receptionInteraction receptions are notified to subscribing Actor instances by the reception primitive of the interaction occurrence type. For each parameter some operations are provided by the generated code to access the parameters’ value.An optional filtering mechanism has been added: if an incoming interaction contains a special parameter named “Initiator_Name” and if this parameter has been set to the name of a remote HLA object, then the interaction is delivered only to this Actor instance (if it exists in the ESCADRE federate).Attribute Ownership transferAny Actor instance associated with a HLA object (registered or discovered) may exchange the Ownership of any attribute of the HLA object (including privilege to delete) with another federate.To  this aim are provided the “acquire”, “divest” and “is owned” operations by the generated code, for each attribute of each object class of the FOM.The effective Ownership transfer is implemented in ESCADRE-HLA by using the RTI non negotiated transfer mechanism.Data Distribution ManagementWe did not implement any DDM feature in ESCADRE-HLA, for the following major reasons:DDM is not very useful for the application range of ESCADRE-HLA (Technico operational studies generally with small federations),For our application range, better data flow optimization is achieved by a correct allocation of models or parts of models among the federates,The DDM Interface Specification is subject to important changes from version 1.3 to IEEE P1516,Finally, we think that the DDM interface specification should be more abstract: the notion of Dimension might disappear, and Regions might be an abstract type with user-defined construction and intersection primitives and a few other miscellaneous operations for the naming and association with object attributes. Such a more abstract DDM definition would alleviate its integration by high level SSE like ESCADRE.Synchronization issuesESCADRE-HLA supports any Time Management mode (i.e. Time Constrained, Time Regulating, both or none).However, in the application range of ESCADRE-HLA (that are deterministic and causally correct simulations), only the coordinated mode (both regulating and constrained) makes sense.Starting togetherThe federations in which ESCADRE-HLA federates participate are often “as fast as possible”. If they have to be wall clock synchronized (with a man in the loop, for example), this is achieved by having all federates in coordinated mode an only one of them running at real time.This mode of operation implies that we can prevent the first joining federates (mainly the first one) from starting independently. We achieve this by a three steps mechanism.First step: Time Management InitializationThis is one of the first things that an ESCADRE-HLA federate does, as soon as it has joined the federation. In most cases, it becomes time-coordinated.Second step: Quorum checkBy subscribing the Manager.Federate MOM class, a HLA federate can be notified of other federates having joined , and can get their type. ESCADRE-HLA allows to block the execution of the federate until some specified federates quorum is reached. This quorum may be simple (i.e. on the number of federates) or complex (i.e. on the number of federates per type of federate).Third step: Synchronization pointOnce the quorum reached, the ESCADRE federate initiates a HLA Synchronization point with the federate set obtained from the previous step.When this step is completed and the federation is synchronized, one can be sure that all the participating federates have initialized their time management, such that no one advances in an undesired way.For an ESCADRE federate, all this process is automated and transparent for the developer. Only a couple of lines in the configuration file are necessary.Of course, non ESCADRE federates willing to synchronize in the same way must implement the process, which is quite easy.Advancing properly in any federationThe ESCADRE simulation engine advances its logical time by examining the scheduled ESCADRE events. The standalone process is as follow:Set Next_Date to the lowest event date,If Next_Date > Current_Date, process integration steps up to Next_Date,Set Current_Date to Next_Date,Process and suppress event,Loop.When integrating the HLA time synchronization, the process becomes:Set Next_Date to the lowest event date,Collect and execute Attribute Updates,Execute NERA (Next Event Request Available) to Next_Date,Wait for Time Advance Grant (T) (ESCADRE events may be scheduled, due to incoming HLA events),Set Next_Date to T,If Next_Date > Current_Date, process integration steps up to Next_Date,Set Current_Date to Next_Date,Process and suppress event,Loop.The use of NERA allows correct advancing whatever the other federates use.Moreover, it allows zero lookahead and multiple exchanges at the same date. This is not good for performances but sometime useful for complex behavioral modeling and causal correctness.Hiding complexityCode generationFrom the FOM DIF file, the Code Generation tool, Fomgen, generates two hierarchies of Ada packages that are the images of the object class hierarchy and of the interaction class hierarchy.On top of these hierarchies, Fomgen generates a package, having the Federation’s name, and that is a child of the ESCADRE package Simu.Hla. Therefore, all private parts and bodies of all the hierarchy have visibility on the private parts of Simu and Simu.Hla, i.e. on the core specification of the internals of ESCADRE-HLA. INCORPORER Word.Picture.8  Example of a generated packages hierarchy(the gray packages are part of ESCADRE)The top package Simu.Hla.Federation1 offers:The enumerated data types of the FOM, represented by private types with sets of constants,The complex data types of the FOM, represented by Ada records exclusively made of OMT data types or other complex data types.The HLA object class packages offer successive abstract derivations of the abstract types Root_Hla_Object_Class and Root_Hla_Object, with a set of operations for the object type. In Simu.Hla.Federation1.Flying_Actor.Aircraft, for example, we find:type Aircraft is abstract new Flying_Actor with private;type Aircraft_Class is abstract new Flying_Actor_Class    with private;procedure Set_Location   (This : in out Aircraft’Class;    Item : in     Location_Type);procedure Get_Location   (This : in     Aircraft’Class;    Item :    out Location_Type);function Is_Valid_Location (This : Aircraft’Class) return Boolean;function Is_Owned_Location (This : Aircraft’Class) return Boolean;function Is_Update_Requested_Location   (This : Aircraft’Class) return Boolean;procedure Divest_Location (This : in out Aircraft’Class);procedure Acquire_Location (This : in Aircraft’Class);procedure Request_Update_Location (This : in out Aircraft’Class);The set of 8 operations shown above is given for each attribute of the object class.The interaction classes packages offer successive abstract derivations of Root_Hla_Interaction_Class, and successive concrete derivations of Root_Hla_Interaction.They offer a set of 3 operations per parameter: Set, Get and Is_Valid.Private parts and bodies of the generated packages completely hide low level things like handles, data marshalling, all accesses to the RTI API and interaction with the ESCADRE kernel.Data Marshalling servicesIn addition to the automated code generation service, we offer the following basic data marshalling conventions:XDR (Xerox Data Representation) is quite universally supported. This is the default for Fomgen and we strongly recommend its use,CDR (Corba Data Representation) is the external representation used by Corba,RAW_BIG_ENDIAN (a.k.a. Network Data Representation) is zero cost on big endian machines as Sun and costs bytes swaps on little endian machines like Intel ix86,RAW_LITTLE_ENDIAN is zero cost on little endian machines but costs bytes swaps on big endian machines,RAW_LAZY_ENDIANNESS: encoding is zero cost, a leading byte indicating the endianness of the emitting machine. The receiving machine does swap bytes or not, according to its own endianness,TEXTUAL is human readable and useful for debugging purposes.All these conventions, except XDR, are fuzzy at some places (such as string representation, aggregates and arrays alignment, etc.). That is why we recommend XDR.Use casesDIMUNDS 2000DIMUNDS 2000 is a preliminary development for the NATO PATHFINDER experimentation (see [4]).The federate SAXOPHONE, modeling air warfare and part of the DIMUNDS 2000 federation, was developed with ESCADRE v5.1 by THOMSON-ISR.DEA 1200Under the auspices of the DEA 1200, an experimental HLA federation is under development. This federation involves WARRIOR (TRAC Monterey) and ELYSA (French MoD/CAD). ELYSA is an ESCADRE V5.1 application.The first steps of the FEDEP are now completed. Implementation and test of the federation is scheduled for Spring 2001.RICOSRICOS is an experimental distributed simulation network developed by CS SI for the French MoD. The objectives are:HLA/FEDEP evaluationSecurity issuesPerformance measurementStarted in January 2001, RICOS is a two years project. In its final version, the network will interconnect 4 nodes:CAD (MoD, Arcueil)CASI (Airforce HQ, Paris)CROSAT (Army HQ, Paris)ANPROS (Navy HQ)Three of the four federates in the experimental federation will be ESCADRE 5.1 applications.ConclusionsESCADRE 5.1 is now an industrial product, with an industrial support. It works with any RTI which has a 1.3 compliant C++ API or a 1.3 compliant 1.3 Ada 95 API. It has been tested and used with DoD RTI 1.3 NG v2, RTI NG v3.2 and yaRTI.Supported platforms are Windows NT/2000, Solaris 5.6 or higher, Linux RH 6.x. On all platforms, ESCADRE 5.1 development requires the free GNAT Ada 95 compiler.ESCADRE 5.1 allows, at a very low cost:The prototyping development of new HLA federates. A typical federate developer code is about 80% model code, 15% ESCADRE specific “glue” code, and 5% distribution specific code.The HLA integration of an existing standalone ESCADRE applications. The integration mainly results in code additions, the existing event-driven models in most cases not being broken by the implementation of HLA requirements.Future evolutions of the product include:IEEE P1516 conformant RTI integration, when such RTIs are availableDesign and integration of a “good” DDM abstractionESCADRE-level negotiated attribute transferESCADRE-level save and restore features.ReferencesJean-Louis Igarza, Christian Sautereau, Philippe Annic, Dominique Canazzi, Emmanuel Berry: Development of a HLA compliant version of the French ESCADRE SSE: lessons learned and perspectives. SIW Paper 98S-SIW-028 dated March 1998.Dominique Canazzi, Philippe Annic, Jean-Louis Igarza, Daniel Girardot: ESCADRE-HLA : an Operational Simulation Support Environment (SSE) for HLA Compliant Simulations Development. SIW Paper 98F-SIW-088 dated September 1998.Jean-Louis Igarza, Major Theodore Dugone: The WARRIOR/ELYSA Experience: A FEDEP Use Example. SIW Paper 00S-SIW-142 dated March 2000.Richard A. Briggs, Joost Hamers: Experiences in the NATO pre-pathfinder DiMuNDS 2000 Federation. SIW paper 99F-SIW-189 dated September 1999.