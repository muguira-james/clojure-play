Using Extensible Markup Language for Composability of C4I Devices in Warfighter's Simulation 2000Jude AnthonyScience Applications International Corporation12479 Research ParkwayOrlando, FL 32826407-306-4328jude.j.anthony@saic.comKeywords:High Level Architecture (HLA), C4I to Simulation Interoperability, Extensible Markup Language (XML)ABSTRACT: Warfighter's Simulation 2000 (WARSIM) is a High Level Architecture (HLA) simulation meant to replace the Army's current Corp Battle Simulator (CBS) and represent the Army in the Joint Simulation System (JSIMS).  WARSIM decided to use Extensible Markup Language (XML) to represent much of its data, including Scenario Generation (SG) data.  The developers therefore must use XML to represent each unit and abstract object in the simulation.This paper describes the XML used to describe C4I devices and compose Tactical Operation Centers (TOCs) in WARSIM's SG data.  Some WARSIM C4I Interface (C4II) design and Common Component Workstation (CCWS) functionality is also presented.OverviewAs a JSIMS federate, WARSIM must interoperate with other JSIMS federates, such as NASM (representing the Air Force) and NATSIM (representing the Navy).  To ensure interoperability, JSIMS has mandated that all federates will operate under an HLA architecture and use a common set of simulation tools.  These tools include a Common Component Workstation (CCWS), acting as both an SG workstation to create initialization data and a simulation controller‚Äôs workstation to interact with running models.To accommodate the variety of initialization and run-time data its federates required, the JSIMS consortium agreed on a two part solution.  The first part is a data store defined cooperatively by the federates.  Since JSIMS is an HLA simulation, this is the JSIMS Federation Object Model (FOM).  The second part is a method to describe how the data can be organized and combined, called ‚ÄúMetadata‚Äù.  While each federate defines the metadata describing its own models and entities, the CCWS developers define the rules, or schema, for creating the metadata.  This paper will demonstrate how the WARSIM C4I Interface (C4II) used the JSIMS schema to define the metadata describing a composable interface to the Army‚Äôs TOCs.  WARSIM C4II ArchitectureIntroductionTo comprehend how the WARSIM C4II uses the JSIMS metadata, it is first necessary to understand how the WARSIM C4II works.  Each simulated TOC in WARSIM may interface with a live Training Audience (TA) through a C4II.  One C4II is instantiated for each live TOC.  When the live TOC connects to WARSIM, it must connect to the C4II hardware.  This hardware intercepts all the live TOC‚Äôs communications, ensuring that WARSIM processes all incoming communications and receives all outgoing communications.  The C4II software translates the TOC‚Äôs messages into a format understandable by the simulated units, and vice-versa.  Since the hardware configuration is mostly fixed, and the metadata does not include hardware configuration, this paper deals almost exclusively with the C4II software. The C4II incorporates standard DIICOE tools, such as the Common Message Processor (CMP), to parse and format Army messages.  The C4II can handle any USMTF or JVMF Package 11 message through CMP, although the WARSIM behavioral models only accept and generate a subset of these messages.The Software ModulesThe C4II facilitates communication between the TA and the simulation by running software in each environment.  Within the TA‚Äôs TOC, security considerations prevent installation of software on the TA‚Äôs C4I devices.  Instead, C4II runs software in the C4II hardware connected to the TOC.  The software is written in Java, for easy networking and portability.  The software within the simulation interfaces with the simulation through its native methods; in the case of JSIMS, this means C++ ‚ÄúElements‚Äù and ‚ÄúHandlers‚Äù that handle the HLA objects and interactions.  It must also interface with the C4II software running in the TA environment, so Java components are necessary.  As shown in Figure 1, a simplified C4II implementing the interface between WARSIM and a C4I device would consist of only a C4iHandler and C4iiRemoteInSim in the simulation environment.  The TA environment would include many modules.  An InterfaceManager would coordinate a JsimsInteractionManager and TAInteractionManager (such as a MailInteractionManager).  The TAInteractionManager would use communications modules including a Translator, CmpInterface, BomDeterminator, and UsmtfDeterminator.  These modules form a communication chain between a single C4I device and the simulation, each translating, formatting, parsing, or passing along messages according to its purpose.  Since the simulation has no way to directly communicate with modules in the TA environment, all initialization, configuration, and control must pass through the modules in the simulation environment.  The C4iHandler is the module that directly interfaces with the simulation.  During initialization, the C4iHandler creates its C4iiRemoteInSim, sends initialization data to the TA environment, and creates the InterfaceManager.  The InterfaceManager creates the JsimsInteractionmanager and the TAInteractionManager.  The TAInteractionManager creates its own Translator, CmpInterface, BomDeterminator, and UsmtfDeterminator.  After initialization, the C4iHandler translates outgoing messages to a Java object and passes them to the C4iiRemoteInSim.  The C4iiRemoteInSim passes the Java object to the appropriate JsimsInteractionManager.  The JsimsInteractionManager passes the object to the TAInteractionManager, which uses its Translator and Determinators, and CmpInterface to format the Java object into an Army message.  Finally, it sends the message to the C4I device.In the other direction, the TAInteractionManager intercepts incoming messages and encapsulates them, unchanged, as part of a Java object.  It then sends the Java object to the JsimsInteractionManager.  The JsimsInteractionManager forwards it to the C4iiRemoteInSim, which queues the object for the C4iHandler.  The C4iHandler polls the C4iiRemoteInSim to retrieve the object, then translates it, if possible, into a simulation message.  Finally, the C4iHandler sends an event with the message in Army and simulation formats to the simulated TOC.The ComponentsTo be composable, software must consist of components that can be arranged into new configurations.  The C4II supports composability by arranging its software modules into components imitating the structure of a TOC.  The TocHandler component represents the TOC itself.  It consists of the actual TocHandler and associated modules for communicating with software running on the C4II hardware.  This component provides a single point for initialization of all the communication chains.  A C4iHandler component is a C4iHandler and its associated modules in the simulation.  A C4iHandler must represent each C4I device in the TOC.  It is the communication endpoint for all messages in and out of the live TOC.An InterfaceManager and associated modules define the InterfaceManager component.  This component handles a single method of communication between the simulation and the C4I device.  This allows reuse of components for C4I devices with identical communications methods.With these components, WARSIM can connect to the supported equipment in any live TOC.  All that is required is proper initialization data.The Data StoreThe data store for JSIMS is its FOM.  Each item in the FOM is a Federation Object (FO).  A FO may represent a one-time event, such as a message (an interaction) or a collection of persistent data (an object).  The object FOs are used to represent an entity.  A simple example of an entity would be a single platform such as a tank.  A tank might be modeled with one object FO indicating its location and speed, another indicating its general health, a third specifying the sensors available for its use, and a fourth detailing the weapons mounted on it.  Together these FOs represent the tank entity.  Note that entities are not software; they are concepts.  They are represented by FOs, which are manipulated by software models [1]. A C4II entity represents a challenge for this implementation, as it does not represent a physical thing in the simulation.  There is a model that represents the TA‚Äôs TOC, and includes all the location, health, and equipment FOs necessary to represent the training audience, but this model is treated like any other physical unit.  The C4II is purely software.  Since it requires initialization data to configure itself, we decided to use the FOs containing the initialization data to represent the C4II.Each software module requires its own initialization data, so each has at least one FO in the FOM.  The FOs are organized hierarchically, allowing for a kind of single inheritance.  Therefore, the initialization data for the C4iHandler resides in the initialization.land.c4i.c4i_handler_p FO.  Other C4II initialization FOs also fall in the same hierarchy and are similarly named.  The only exceptions are the c2_artifacts.land.state FOs, one each for a toc_handler and a c4i_handler, which were placed under a different hierarchy for historical reasons and were never moved.The Metadata SchemaOverviewTying together the software models and the data store is the job of the metadata.  It is an XML file therefore, it has a schema.  The schema defines a metadata file that:Defines entities and software modelsClassifies groups of interchangeable entitiesDetermines where lists of children and associated objects are enumeratedAssociates software models with entitiesAssociates FOs with software modelsThe schema also allows certain other functions, such as attaching verbose labels to items that are difficult to understand.  However, the functions above are the ones that are necessary to initialize software models within the simulation.  Each has its own section in the metadata file, delineated by an XML tag.Defining EntitiesTo define an entity, one creates an <EntityType> block within the <EntityTypes> section of the Metadata.  A unique name must be supplied for the entity, along with the FO type that will be used to principally represent the entity.  This FO is called the master FO, or master object, and it is specified in the <MasterObject> block.  Each master object type must uniquely represent an entity type.  However, actually creating an individual FO for each type of unit in the Army would involve a great deal of replication in the FOM.  To avoid conflicts, some combination of attribute values in the master object may be used to specify the entity type.  In this case, the attributes and values making this master object type uniquely represent a single entity type must be specified in the <Attributes> block of the <MasterObject>.  Refer to figure 2 for an example of an <EntityType> block.Defining Software ModelsModels are defined in the <ModelTypes> block with a <ModelType> tag.  Each requires a unique name.  Submodels are specified in the <Submodels> block by a <SubmodelSimulationRule> tag.  Each submodel referenced in the <Submodels> block must be defined elsewhere in the <ModelTypes> block.  Figure 3 is a diagram of a <ModelTypes> block.Classifying Groups of Interchangeable EntitiesAny entity may be a member of one or more groups.  This circumvents requiring an individual entity for each variation of equipment in an entity.  For instance, instead of defining an entity for a company with three tank platoons, and another entity for a company with two tank platoons and a dismounted infantry, we can define a single entity for a company with ‚Äúmilitary units‚Äù and add both tanks and dismounted infantry to the military units group.Valid groups are enumerated near the beginning of the file, in a <Groups> block.  Each group is represented by a <Group> tag that specifies its name.  If an entity is a member of a group, a <Groups> block with a <Group> tag for the name of each group it is a member of must be included in its <EntityType>.  Enumerating Children and Associated ObjectsIf FOs other than the master FO are required for an entity‚Äôs representation, one attribute of its master object must contain an array of FO ids indicating the appropriate objects; this attribute is specified within its <EntityType> block by the <LinkToSlaves> tag, as shown in Figure 2.  There are also some entities that may include other entities, much like a tank platoon includes tanks, or a battalion includes multiple companies.  These included entities are said to be children of the entity that includes them.  A <Children> tag indicates that an entity will have children.  A link to the ID of each child‚Äôs master object must be included in some attribute of the parent‚Äôs master object; the attribute is specified with the <LinkToChildren> sub-tag.  Each valid kind of child is indicated inside a <Child> block with the <EntityTypeName> sub-tag, and constraints on the number of each kind of entity may be specified with a <SupportedQuantity> block.  These tags are also shown in Figure 2.Associating Software Models and EntitiesTo make the jump from concept to running software, the entities must be tied to the models in some way.  The <SimulationRules> block, depicted in Figure 4,  associates models and software.  Each <SimulationRule> includes the name of a model in its <ModelTypeName> tag, the name of an entity in its <EntityTypeName> tag, and an initialization order in its <BlockName> tag.  A simulation rule specifies that whenever an entity of the appropriate name is added in the SG tool, a model of the associated name must be added to the scenario in the specified block.  Associating FOs and Software ModulesThe FOs that a model expects to be represented by are referenced in an <ObjectClasses> block within the model‚Äôs <ModelType> block, as shown in Figure 3.  The <ObjectClasses> block is simply a list of <ObjectClass> tags, each specifying one object used by the model.  Naturally, the master FO is necessary, so each model‚Äôs master FO must be included in its <ObjectClasses> block.When an entity is added to a scenario by the SG tool, it actually adds all the models associated with the entity and assigns all the FOs created with the entity to its models.  If a FO is assigned to a model that does not reference it in its <ObjectClasses> block, an error is generated.  However, if some FO referenced by the model is not assigned to it, a warning is generated.One artifact of simulation that must be handled by the models is the possibility of ‚Äúsubsuming‚Äù other models.  For instance, when an airplane is on the deck of an aircraft carrier, the carrier‚Äôs model may perform all the aircraft‚Äôs modeling.  In fact, no aircraft software may exist while the aircraft is on the carrier; however, its representation (in the form of its FOs) will continue to exist.  The carrier must be ready to manipulate these FOs for as long as the aircraft is ‚Äúsubsumed‚Äù by the carrier.This capability is particularly useful for the C4II.  Only handlers may be associated with FOs, so the entire InterfaceManager component cannot receive FOs.  (It is Java software, not running within the simulation, and with no handler of its own.)  By requiring the C4iHandler to subsume the InterfaceManager‚Äôs FOs, all the FOs are assigned to the C4iHandler, where they can be used for initialization.  To specify that a model subsumes the FOs of another model, a metadata file would include the <SubsumedEntityTypes> block in the <ModelType> block of the subsuming model.  All the FOs of the subsumed model must also be listed in the <ObjectClasses> block, along with the FOs native to the model.  The <SubsumedEntityTypes> block is also shown in Figure 3.ShortcomingsThe metadata schema is not perfect.  In particular, there is no way to place constraints on both individual members of a group and the entire group simultaneously.  For instance, the metadata schema cannot specify that a unit must have three different kinds of radios.  The alternatives are to specify three radios, but not restrict the number of a particular type; or to specify either zero or one of each individual type of radio, without restricting the total number of radios.The metadata schema also does not specify the FOs to be created with each entity either.  This was originally included in the metadata schema, but the functionality was transferred to the template data the SG workstation uses to enhance composability (the ‚Äúbattlespace templates‚Äù).  This change made metadata files much shorter, so it is not truly a shortcoming, but rather a design tradeoff.  The battlespace templates are essentially partially completed FOs.  Individually, they must follow the structures outlined in the FOM, but collectively, they must follow the rules of the metadata.The C4II MetadataOverviewThe C4II software is split into components, as indicated earlier.  The C4II metadata defines an entity for each component: the ‚ÄúC4II‚Äù entity corresponds to the TocHandler component, the ‚ÄúC4I Device‚Äù entity corresponds to the C4iHandler component, and the ‚ÄúComm Path‚Äù entity corresponds to the InterfaceManager component.  The entities also correspond to TOC equipment and functionality:  the C4II represents a TOC, the C4I Device represents (unsurprisingly) a C4I device; and the Comm Path represents a method of communication used by a C4I device.  The C4II metadata defines the relationship between the C4II components and the entities; an SG analyst must make the association between the entities and a physical TOC.Since there is only one kind of C4II, it is defined as a simple entity; but since there are many kinds of C4I Devices, and many methods of communication, the C4I Device and Comm Path are groups.The members of the C4I Device group include all the devices currently supported by WARSIM:  the MCS, ASAS-RWS, AFATDS, FAADEO, AMDWS, and CSSCS.  WARSIM supports communications via Email, via Commserver, and via UDP (for FDL messages); these are the members of the Comm Path group.The basis of C4II metadata is the conceptual makeup of a live TOC.  A TOC must have at least one C4I device, which may have one or two methods of communication.  Therefore, the C4II metadata states that each C4II must have at least one C4I Device child, and that C4I Device entity must have at least one, and possibly two, Comm Path children.  The SG workstation loads battlespace templates that indicate the actual elements of the software.  While WARSIM originally considered using generic battlespace templates modifiable to represent any TOC, this required too much data entry for the SG analyst.  Instead, the battlespace templates characterize the TOCs available for a particular exercise.  WARSIM will consider generic battlespace templates for its Initial Operating Capability (IOC).  A Simplified C4II Metadata FileA portion of the C4II metadata file is reproduced here.  In the interests of space, the headers have been removed, along with portions of the file not relevant to the discussion.  Some highlighting has been added to emphasize important points.<Metadata>	<Groups>		<Group>C4I Device</Group>		<Group>Comm Path</Group>	</Groups>	<EntityTypes>		<EntityType>			<Name>C4II</Name>			<MasterObject>				<Class>c2_artifacts.land.state.toc_handler</Class>			</MasterObject>			<LinkToSlaves>associated_fos</LinkToSlaves>			<!-- Each TOC must have at least one C4I device -->			<Children>				<LinkToChildren>child_master_fos</LinkToChildren>				<Child>					<EntityTypeName>C4I Device</EntityTypeName>					<SupportedQuantity>						<Min>1</Min>						<Max>5</Max>						<!-- MCS, ASAS-RWS, AMDWS, AFATDS, FAAD EO -->					</SupportedQuantity>				</Child>							</Children>		</EntityType>		<EntityType>			<Name>MCS</Name>			<MasterObject>				<Class>c2_artifacts.land.state.c4i_handler</Class>				<Attributes>					<Attribute>						<AttributeName>entity_type</AttributeName>						<String>MCS</String>					</Attribute>				</Attributes>			</MasterObject>			<LinkToSlaves>associated_fos</LinkToSlaves>			<!-- Every C4I device has at least one way to communicate -->			<Children>				<LinkToChildren>child_master_fos</LinkToChildren>				<Child>					<EntityTypeName>Comm Path</EntityTypeName>					<SupportedQuantity>						<!-- USMTF/CommServer, JVMF/UDP(outbound) -->						<Min>1</Min>						<Max>2</Max>					</SupportedQuantity>				</Child>			</Children>			<Groups>				<Group>C4I Device</Group>			</Groups>		</EntityType>		<!-- The ASAS-RWS, AFATDS, AMDWS, and FAAD EO are similar to the MCS.  -->		<EntityType>			<Name>via Email</Name>			<MasterObject>					<Class>initialization.land.c4i.interface_manager_p</Class>				<Attributes>					<Attribute>						<AttributeName>entity_type</AttributeName>						<String>via Email</String>					</Attribute>				</Attributes>			</MasterObject>			<LinkToSlaves>associated_fos</LinkToSlaves>			<Groups>				<Group>Comm Path</Group>			</Groups>		</EntityType>		<!--The via UDP and via CommServer are similar to the via Email. -->	<SimulationRules>		<SimulationRule>			<ModelTypeName>JclBundle.C4II</ModelTypeName>			<EntityTypeName>C4II</EntityTypeName>			<BlockName>DomainConcrete1</BlockName>		</SimulationRule>		<SimulationRule>			<ModelTypeName>JclBundle.C4IDevice</ModelTypeName>			<EntityTypeName>C4I Device</EntityTypeName>			<BlockName>DomainConcrete2</BlockName>		</SimulationRule>	</SimulationRules>	<ModelTypes>		<ModelType>			<Name>JclBundle.C4II</Name>			<Submodels>				<SubmodelSimulationRule>					<ModelTypeName>LNMC::TOCHandler</ModelTypeName>				</SubmodelSimulationRule>				<SubmodelSimulationRule>					<ModelTypeName>LNMC::TOCElement</ModelTypeName>				</SubmodelSimulationRule>			</Submodels>		</ModelType>		<ModelType>			<Name>JclBundle.C4IDevice</Name>			<Submodels>				<SubmodelSimulationRule>					<ModelTypeName>LNMC::C4IHandler</ModelTypeName>				</SubmodelSimulationRule>				<SubmodelSimulationRule>					<ModelTypeName>LNMC::C4IElement</ModelTypeName>				</SubmodelSimulationRule>			</Submodels>		</ModelType>		<ModelType>			<Name>LNMC::TOCElement</Name>		</ModelType>		<ModelType>			<Name>LNMC::TOCHandler</Name>			<ObjectClasses>				<ObjectClass>c2_artifacts.land.state.toc_handler</ObjectClass>				<ObjectClass>initialization.land.c4i.c4ii_remote_in_sim_p</ObjectClass>				<ObjectClass>initialization.land.c4i.communications_manager_p</ObjectClass>			</ObjectClasses>		</ModelType>		<ModelType>			<Name>LNMC::C4IElement</Name>		</ModelType>		<ModelType>			<Name>LNMC::C4IHandler</Name>			<ObjectClasses>				<ObjectClass>c2_artifacts.land.state.c4i_handler</ObjectClass>				<ObjectClass>initialization.land.c4i.c4i_handler_p</ObjectClass>				<ObjectClass>initialization.land.c4i.c4ii_remote_in_sim_p</ObjectClass>				<ObjectClass>initialization.land.c4i.interface_manager_p</ObjectClass>				<ObjectClass>initialization.land.c4i.jsims_interaction_manager_p</ObjectClass>				<ObjectClass>initialization.land.c4i.translator_p</ObjectClass>				<ObjectClass>initialization.land.c4i.mail_interaction_manager_p</ObjectClass>				<ObjectClass>initialization.land.c4i.commserver_interaction_manager_p</ObjectClass>				<ObjectClass>initialization.land.c4i.fdl_interaction_manager_p</ObjectClass>				<ObjectClass>initialization.land.c4i.cmp_interface_p</ObjectClass>				<ObjectClass>initialization.land.c4i.bom_determinator_p</ObjectClass>				<ObjectClass>initialization.land.c4i.usmtf_determinator_p</ObjectClass>			</ObjectClasses>			<SubsumedEntityTypes>				<EntityTypeName>Comm Path</EntityTypeName>			</SubsumedEntityTypes>		</ModelType></Metadata>When the SG analyst wants to add a C4II to a scenario, he will simply select an appropriate automated unit (AU) and C4II from the list of available templates to the list of entities in the scenario.  For instance, if the 4th Infantry Division (4ID) will be trained, it must have a representation in the simulation (the AU) and an interface to the simulation (the C4II); a 4ID AU and 4ID C4II must be added to the list of entities in the scenario.  The SG workstation will import the battlespace template for the 4ID C4II, along with all the battlespace templates for its associated FOs and children‚Äôs FOs, and create the software models specified by the metadata.  Before writing the new scenario to a file, the SG workstation will compare the scenario contents to the metadata file and issue any errors or warnings.When the scenario runs, WARSIM will create a TocHandler component, which will initialize a C4iHandler component for each device in the TOC.  The C4iHandlers will initialize an InterfaceManager component for each interface to its C4I device.  The modules within the InterfaceManager component will send the appropriate messages from the TOC to the simulation, and vice-versa.  ConclusionThe metadata schema, the JSIMS FOM, and the C4II software embody a system allowing any supported live TOC to interface with WARSIM.  The composability of C4II software facilitates the interface by mirroring the composability of a TOC.  The metadata schema uses XML to define the set of entities making up the interface.  The JSIMS FOM defines the data store that corresponds to the software models and the metadata entities.  This represents a general strategy that could be extended or used by other simulations.AcknowledgementsThis work was done under a contract from STRICOM. The author would like to thank WARSIM C4I representatives from STRICOM for their support in developing and implementing the XML / C4I  concept. References [1]	Berggren, Peter: ‚ÄúMetadata Orientation‚Äù  Presentation to WARSIM developers, 01/11/2001.Author BiographiesJUDE ANTHONY is an SAIC Software Engineer working on the WARSIM.  Jude graduated with a Bachelor of Science degree in Computer Science from the University of Central Florida.  As a member of the WARSIM 2000 C4II CSCI, Jude is responsible for designing WARSIM C4II‚Äôs metadata, as well as developing C4I device interfaces.Figure 4: Depiction of the SimulationRules Block EMBED PBrush  Figure 3 : Depiction of the ModelTypes Block EMBED PBrush  Figure 2: Depiction of the EntityType Block EMBED PBrush   EMBED Word.Picture.8  