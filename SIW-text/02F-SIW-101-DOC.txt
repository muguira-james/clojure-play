Efficient Interoperability and Execution of Logistics Modules in the Integrated Consumable Item Support (ICIS) Model Gary KratkiewiczRenu Kurien BostwickDistributed Systems & Logistics DepartmentBBN Technologies10 Moulton StreetCambridge, MA 02138617-873-2476, 617-873-4543kratkiewicz@bbn.com, renu@bbn.comGeoffrey S. KnauthBAE Systems2361 Jefferson Davis Highway, Suite 706Arlington, VA  22202570-326-9405Geoffrey.S.Knauth@baesystems.comKeywords:Logistics, modeling, data, efficiency, DLA, ICISABSTRACT: DLA's Integrated Consumable Item Support (ICIS) Model is a software system designed to measure DLA's ability to satisfy wartime requirements for DLA managed items and to identify potential problem items before they become problems. ICIS and its data were described at Simulation Interoperability Workshops in 1997 and 1998. Since that time, ICIS became one of the first operational Web-based systems in the U.S. Department of Defense (DoD). The system runs as a DII COE compliant application over the DoD's secret version of the Internet (SIPRNET). Use of the ICIS system has resulted in savings of over $100 million in prepositioned food and bulk fuels. ICIS uses a number of server-side modules for modeling demands and sourcing for various commodities and military services. These modules are written in a variety of computer languages and must work together to generate an ICIS analysis. ICIS analyses often involve over a gigabyte of data; analyses that are similar to one another can contain much duplicated intermediate data. ICIS's Web-based distributed desktop user interface allows ICIS data and computations to reside on central servers, while providing wide accessibility and use on almost any computer platform. To eliminate recomputation of identical intermediate results and duplication of data storage between analyses, ICIS utilizes a novel data and computation management system. This system controls the execution of modules, invoking only those modules that will generate intermediate results not previously computed. This system utilizes data and module version traceability, storage of file and computation dependencies, a description-based file system, and a script-based means of wrapping legacy modules.This paper provides an overview of the current ICIS system, reviews an example logistics module within ICIS, and describes its data and computation management system.Overview of ICISThe Need for ICISThe Defense Logistics Agency (DLA) originally supplied low-cost, non-critical items to the US military services. Its responsibilities greatly increased in 1990’s; it assumed logistics roles previously handled by the military services, including assuming management of warehouses and supply depots previously managed by the services,  parts, and management of contracts worth $900 billion. Its mission was now to ensure personnel & equipment readiness in humanitarian & wartime military operations.One issue that DLA faced was that it lacked visibility into potential logistics problems during future military operations. This included the ability to answer the following questions:When will I run out of stock?What should I buy today for tomorrows needs?Do I have adequate sources & transportation?ICIS was developed to help answer these questions.What ICIS DoesICIS models the logistics aspects of simultaneous or overlapping future military operations, for both combat and humanitarian operations. It also accounts for competing normal activities performed by the portions of the military forces not involved in these operations. To do this, it ties together a variety of data. Starting with the operational plan (OPLAN) or plans from one or more military commands, it uses logistics data from DLA and equipment & personnel data from the services to identifies potential logistics problems.There are four steps in an ICIS analysis. First, the user lays out the set of planned military operations using the ICIS user interface to select the OPLANs and competing demands (this set is called an ICIS composite scenario). Next, ICIS computes demand for the operations using the operational and service data. This includes the time-phased schedule and intensity of consumers (tanks, people, aircraft, ships, etc.) and the failure and consumption rates of parts and items. ICIS then sources the demands for these items and identifies the potential problems. To do this it uses the logisitics data, such as inventory and backorder information, and ordering, production, shipping lead times. Finally, ICIS presents the results back to the user in the user interface.ICIS and its data were described in greater detail at Simulation Interoperability Workshops in 1997 [1] and 1998 [2], and elsewhere [3].The Data ChallengeThe ICIS development team encountered a number of challenges during the development of ICIS. The major one was the magnitude of data required to run ICIS.The computations are fairly simple, but the magnitude of the data is the issue. ICIS requires a large amount of data in files: 800-1000 input files, in 200 different formats.Obtaining data on a timely basis from many military organizations can be a challenge. Managing the gigabytes of input data that ICIS uses, and the gigabyte of data per analysis that ICIS generates can be difficult. Presenting the large amount of results data back to the user is also a challenge.Evolution of the ICIS DesignStandalone ICISDevelopment of ICIS software started in October 1994 using a rapid prototyping approach. The development team was given high-level requirements, but no specific ones. Many iterations of the software were produced during the first few years as the developers built a prototype, presented it to DLA, and modified the prototype based on the feedback from DLA. The original ICIS was developed as a standalone Unix-based system running on a Sun workstation. It was developed using the Tcl/Tk programming language largely due to its fast GUI-building capability and extensibility. As ICIS grew, its computation modules were soon moved to C++ for performance.Real use of ICIS began in June 1996 when it was installed on the SIPRNET, the military’s secure version of the Internet. At this point it could be used with real operational, logistics, and service data.There were a number of limitations of the Unix-based version of ICIS. Remote performance was unacceptable; to be usable, ICIS software and data had to be installed on a local workstation. Such a system was often not available at a user site, and prospective users could not be expected to purchase a system just to test ICIS. Installation of requires a detailed configuration and is not as simple as installing PC software. Finally, maintaining a large amount of data on many systems would be a logistical nightmare.To try to meet some of the accessibility issues, some simple Web-based utilities were developed. However, these could not be well integrated with the main system.Additionally, the ICIS system was limited by data and computation issues; its design was not adequate to handle the scale of data involved.ICIS On the WebTo address the accessibility issues with UNIX-based ICIS, the development team began working to move ICIS to the Web. This became possible with the release of Netscape Navigator 3 in August 1996, with its usable Java and JavaScript.Shifting priorities on the project limited time for Web development. Parts of the user interface were moved to Web from 1996 to 1998, The Unix-based Tcl/Tk user interface was soon completely dropped. Users would now set-up an analysis using a Web tool, telephone a support person at the server site who would launch the analysis via the Unix command line, and then view the results using a Web tool when the analysis was done. This was awkward, but provided ICIS access to a greater audience.Finally, a full Web-based release of ICIS was made in February 1999.Even though the Web version of ICIS addressed the issues of access to the software, limitations remained. Some issues were due to its heterogeneous implementation. For example, on the server side Perl CGI scripts would call C++ executables to generate a mix of HTML code, JavaScript code, and Java applets for the client side. The large number of languages involved raised maintainability and extensibility, user interface performance and appearance, and multi-platform appearance issues. Also, there were limitations with passing data between pages in the user interface.But more importantly, the data and computation issues had not be addressed by this redesign. Of course, these were not important if no one could use the system, but now that this issue had been resolved, they needed to be addressed.Redesign for Improved Ease-of-Use and EfficiencyThe development team made greater use of Java technology to address the dual issues with Web-based ICIS [3]. They attacked both the client side to improve GUI ease of use and the server side to improve data and computations efficiency.On the client side they reimplemented key portions of  the user interface using Swing via the Java Plug-In. On the server side they used Java and Jscheme-based modules to implement a data management system to prevent duplication of data and computations.The details of this redesigned version of ICIS are covered in greater detail in the remainder of this paper.ICIS ArchitectureICIS employs a Web-based client/server architecture. Data storage and processing occurs on the server. All user interaction occurs on the client via a Web-based user interface.  REF _Ref12357076 \h Figure 1 shows the ICIS architecture.Raw input data for ICIS comes from the military commands (CINCs), the military services, and from DLA. ICIS includes a set of utilities for manually preprocessing some of the raw data before it is ready for use by ICIS. After preprocessing, the ICIS data on the server exists in flat files and in relational databases. EMBED PowerPoint.Slide.8  Figure  SEQ Figure \* ARABIC 1:  ICIS ArchitectureThe Data Set Manager (DSM) performs data and computation services. For each module it provides the location of input/output files and the values of the input parameters. During an ICIS run, it executes modules when necessary and reuses prior module results when possible to perform the analysis quickly and efficiently. During an ICIS run, the DSM launches various processing and analysis modules as required by the definition of the composite scenario. These logistics modules project demand, source the demand, and compute metrics and problem information.The ICIS user employs a Web-based user interface to interact with ICIS. It has the following main components:Composite Scenario Wizard: Allows user to define a composite scenario; it then writes the composite scenario description and launches the analysis on the server using the DSMEditors: These allow the user to edit some data on the client side, shortening the loop for quicker analsyses.Main ICIS user interface: This allows the user to view information about the composite scenario and results of the analysis.User InterfaceICIS utilizes a Web-based user interface that runs in a Web browser. This maximizes accessibility to users and reduces installation requirements on their computers. The ICIS user interface acts as the client side of the ICIS client-server architecture.The user interface utilizes a heterogeneous mix of technologies. It consists of HTML pages that are generated by either static HTML files or Perl CGI scripts (which themselves may call C++ executables to generate the HTML). The HTML contains Java 2 applets (which require the installation of the Java Plug-in in the browser), Java applets (which use the browser’s built-in Java), and JavaScript code. The use of Java 2 in ICIS V4 resulted in greater ease-of-use in the user interface, especially in its editing capabilities.The user interface has two major pages: the Welcome Screen and the Main User Interface Page. The ICIS Welcome screen (see  REF _Ref12357099 \h Figure 2) serves a number of purposes. It greets the user, identifies the version and build of ICIS, displays the government use-of-system notice, allows the user to specify the resolution of his or her monitor so that ICIS can appropriately size its displays, utilizes a small Java 2 applet implementing a Continue button that forces the Java Plug-In to load (and gives early warning if it does not), and checks for various incorrect conditions and displays a warning if found.Figure  SEQ Figure \* ARABIC 2:  ICIS Welcome ScreenThe Main User Interface Page contains the other major components of the user interface: the Composite Scenario display, the Repair/Replacement Parts results display, the Fuels Results Display, and the Subsistence Results Display.  REF _Ref12357128 \h Figure 3 shows the main areas of the Main User Interface Page. The Data Frame is the main work area; it displays the information selected by the user. The Status Frame shows information about the currently loaded composite scenario. The Tabs Frame allows the user to navigate between the major components of the user interface. The Control Frame allows the users to open composite scenarios, launch some of the editors, and perform operations on the currently loaded composite scenario.Figure  SEQ Figure \* ARABIC 3:  ICIS Main User Interface PageThe ICIS editors launch from this page: the Composite Scenario Wizard, the Force Deployment Module, and the OPTEMPO Editor. In ICIS V3, the Composite Scenario Wizard and the Force Deployment Module were implemented in JavaScript; although usable and functional, they were hard to navigate, hard to understand, and slow. In ICIS V4, these editors were redesigned and the OPTEMPO Editor newly designed using Java 2, specifically to use its powerful Java Foundation Classes/Swing graphical components. These components led to greater ease-of-use and versatility for users, along with the bnefits of reusability and easier maintenance for the software developers.The Composite Scenario Wizard allows users to lay out the set of operations and competing demands known as a composite scenario, define parameters, and launch the analysis. The Force Deployment Module allows users to plan the deployment and in-theater movements of forces for operations that do not yet have a TPFDD or for “what-if” purposes. The OPTEMPO Editor allows users to define the OPTEMPO (operation tempo, or intensity of fighting) for forces involved in the composite scenario (see  REF _Ref12357151 \h Figure 4).Java 2 provides other advantages besides its powerful graphical components. It provides a common Java platform to all users, so that the user interface looks and operates the same regardless of the version of operating system and browser on the user’s desktop computer. Java 2 Web-based systems are a good match for desktops with restrictions, where you need permission is required to install anything, such as in the military. This approach requires only the industry standard Java be installed on the desktop. The system can be upgraded without touching the desktop by updating the applets.Figure  SEQ Figure \* ARABIC 4:  OPTEMPO EditorLogistics ModulesOverview of ModulesICIS uses a number of logistics modules on the server to compute demand, sourcing, and problem projections. These modules are written in a variety of computer languages. Most of these modules were built by the developer of ICIS (BBN Technologies), but one was built by DLA and was in fact a legacy program initially developed for other purposes.The B8/TPFDD Processing Module processes the JOPES B8 files that contain time-phased weapon system density information.The Repair/Replacement Parts (DLA Stocked Items) Module covers those items stocked by DLA: critical repair parts, depot repair parts, clothing, construction and barrier items, JCHEM defensive chemical gear, and packaged petroleum.The Repair/Replacement Parts Module contains a series of sub-modules for projecting the demand for the different classes of supply fuels based on the OPLANs and force lists in the composite scenario. A final sub-module combines the demand into a single demand file and adds competing peacetime demand.The Repair/Replacement Parts Sourcing Engine takes the aggregated demand and sources it against available and expected inventory.The Repair/Replacement Parts Metrics and Problem Items Computation Engine takes the sourced demand, and computes performance metrics, problem items, and various inventory information.The Bulk Fuels Module (Class IIIB) module computes the demand for bulk fuels based on the OPLANs and force lists in the composite scenario, then sources the demand and determines transportation.The Subsistence Module computes the demand for food fuels based on the OPLANs and force lists in the composite scenario as well as on feed plans, the sources the demand against inventory and expected production. REF _Ref12357463 \h Table 1 provides a complete list of the various logistics modules within ICIS. The next section describes an example module in greater depth.ModuleLanguageDeveloperB8/TPFDD ProcessingBBNBulk Fuels Demand & SourcingCBBNSubsistence Demand & SourcingC++BBNCritical Repair Parts DemandC++BBNDepot Repair Parts DemandC++BBNClothing DemandC++BBNConstruction and Barrier DemandC++BBNDefensive Chemical Gear DemandJavaBBNPackaged Petroleum Parts DemandC++BBNPeacetime DemandC++BBNRepair/Replacement Parts SourcingCDLARepair/Replacement Parts Problem Items Computation EngineC++BBNTable  SEQ Table \* ARABIC 1:  ICIS Logistics ModulesExample Module: Bulk Fuels The primary ICIS Fuels functions are Requirements and Sourcing. Requirements cover the demand side, answering the basic question, "How much of what fuel is needed by whom, for what equipment, when and where?" Sourcing addresses supply issues, "How do I get what I need where it has to be on time, using what sources, transportation methods, and potential substitute products?" Sourcing also explores the unexpected, such as, "What if the mission changes, a tanker sinks, or I lose refinery capacity?" Sourcing has more computational complexity than computing requirements. Sourcing presents variations of the traveling salesman problem with time-varying constraints, while computing requirements is merely a task of locating the correct values to multiply and add. The simulation runs on a day clock, and schedules just-in-time arrival of fuel shipments to maintain user-defined levels of stock. Sourcing policies can be set at the level of geographic area, country, or location.The Bulk Fuels Module was initially designed for "deliberate planning," that is, evaluating the overall logistics capability of sustaining two major regional conflicts simultaneously. For deliberate planning, staffs at many levels spend months, even years, developing contingency plans for possible scenarios, and data sets are more static. In recent years, however, the world has seen surprises demanding increased mobility, pushing first the Bulk Fuels Module, and then the rest of ICIS, to handle crisis planning tasks. The ICIS data sets for both deliberate planning and crisis action are designed to be compatible, the difference being that in crisis action, instead of employing a TPFDD (Time Phased Force Deployment Data file), users create their own deployment data. The crisis action tools allow users to move equipment or units between locations on a timeline and to vary OPTEMPO profiles. The main effort has been to build interfaces that meet the needs of the two planning communities while ensuring uniformity of data handling when computations begin.From its inception, the Bulk Fuels Module was conceived as a module whose result set could be recomputed by making small changes to input data sets and repeatedly evaluating a function in search of an optimum solution. In 1996, it was envisioned that The Bulk Fuels Module computations would be combined with genetic algorithms at a later stage. This is still part of the vision, however in most cases so far, the first run of a bulk fuels assessment has been sufficiently informative to satisfy users' questions. Users now put priority on maximum interoperability with other systems. For example, the Bulk Fuels Module produces JOPES-compatible non-unit records that can be read into military software already programmed to optimize sealift tanker scheduling. ICIS is building bridges to systems such as JTAV, FAS, JFAST and others.The Bulk Fuels Module reads dozens of input files and presently produces thousands of output files, mostly static web pages with links to precomputed answers to tens of thousands of potential user questions. This has given the user fast response at the expense of disk space. However, most users view only a small percentage of the answers available, so current research is leading to greater database storage of results to provide OLAP capability while increasing interoperability with other tools. CSV files are already produced with this in mind, but as more DoD systems adopt standard schemas, keeping data in databases (vs. files) becomes more important, and where files are still needed, XML files are increasingly replacing their CSV counterparts. The module records its deliberations and calculations in log files so that users can monitor its decision-making processes and identify rapidly the source of any errors.The Bulk Fuels Module was first written as a large C program in the interest of performance. Since then, Java virtual machines have become faster, therefore parts of the module are being converted to Java whenever code can be simplified without sacrificing speed. Perl has been used for ad-hoc CGI queries, and Java has made certain screen updates more dynamic in what-if explorations. Java provides a link to the mapping tool OpenMap [5], and to a rich choice of third-party graphing packages. The Bulk Fuels Module communicates with the Data Set Manager via a Jscheme interface. The C program makes extensive use of lists, tuples, arrays and hash tables, leading to promising experiments with Python and Jython. Since half of the C code implements data manipulation features that are naturally part of Python syntax, Python code is considerably more compact and modular while remaining readable.Overall, ICIS Fuels is moving to an enterprise Java architecture because evolving web services standards often meet the needs of the military user as well as those of the commercial e-commerce provider. Security protocols, site and user certificates, and application deployment within specific containers help administrators focus on questions of access privileges and configuration management, releasing application developers to focus on their modules. Robust J2EE-compliant servers provide scalability through task and thread management, and reliability through persistent storage and replication. But probably the greatest impact of e-commerce techniques in the field of military logistics is in the raised expectation of the user. Most users have had the experience of ordering books or other goods online, and demand a user interface that is as intuitive and natural as that developed by the most successful pioneers in industry.Data Set ManagerSolution to Legacy Code and Data IssuesThe ICIS Data Set Manager was designed to address ICIS’s data issues and to provide efficient interoperability and execution of its logistics modules. In order to run an assessment of DLA readiness, ICIS uses large amounts of data from different agencies received via flat files. ICIS users need to run experiments (assessments) to model what-if scenarios, where they vary input parameters such as current inventory, the number of tanks in a particular battalion, etc. and explore many variations on a single problem. They need to be able to describe which data should be used for these runs, and they also need to be able to quickly re-run with modifications in such a way that unnecessary re-computations are not performed. The volume of data that ICIS uses makes running and managing ICIS assessments non-trivial.The ICIS Data Set Manager (DSM) is the infrastructure that simplifies ICIS data management and allows for the efficient interoperability and execution of ICIS’s legacy logistics modules. It replaces the notion of a directory-based filesystem with a description-based filesystem and keeps track of file and computation dependencies. Its features can be compared to those of CVS (code revision control system) for version traceability and to those of make (UNIX utility for code compilation, linking and managing code dependences) with respect to capturing ICIS module and input dependency information. The DSM keeps track of what went into an ICIS simulation. Furthermore, by tying into the file opening process, the DSM is able to interoperate with all the legacy logistics modules that are written in many different programming languages. Where before the modules themselves would compute the file name to be opened and read, now the DSM will compute the file name. The legacy modules can then refer to the files by description rather than by exact location.The heart of the difficulty in keeping track of what went into an ICIS simulation lies in the fact that the data ICIS uses is vast. Approximately 800 to 1000 inputs files are used in an assessment. The data comes in approximately 200 different formats. Data files are received from many different agencies. These data files are regularly updated, and users need visibility into when relevant files have been updated for their simulations. Data files often need to be moved around to free up disk space.The following specific problems are addressed by the DSM architecture:The Data Refresh ProblemThe What-Ifs ProblemThe Multi-Machine ProblemThe Data Refresh Problem refers to the need to maintain data traceability for assessments. In other words, the users need their assessments to be kept consistent with respect to the data that was used to run it, regardless of whether or not the set of data has been subsequently updated. On the other side of the coin, users need visibility into when their assessments become 'stale' and will need to be re-run due to a data set having been updated or when a new release of ICIS is available. The What-Ifs Problem refers to the need to describe which data should be used for different what-if scenarios. The user should be able to quickly re-run with modifications to a set of data. In order for the what-if assessment to be done quickly, ICIS needs to prevent unnecessary re-computations, whenever possible. If some parts of the underlying data for the assessment have not changed, then those parts of the assessment should not be re-run. The Multi-Machine Problem refers to the need to move data and assessments from one machine to another to free up disk-space. The data and assessment dependencies, however, must not be lost on moving the data to a new machine. The naming and placement of data files should not be an issue when moving data to a new machine. The purpose of the DSM is to address these three specific problems.DesignSome terminology that will make understanding the design of the DSM is presented next. A module is the definition of a previously self-contained piece of code (an executable or a script) that takes a defined set of input files and input parameter settings and calculates output into a set of output files. A computation is one particular execution of a module with a specific set of inputs and which produces a specific set of outputs; it is an execution of a module in a specific context, where the context is the input files and parameters. An assessment is a specific set of computations that have been run in order to create the final set of needed outputs.  REF _Ref12356668 \h Figure 5 shows how the processing and analysis modules make up an assessmentFigure  SEQ Figure \* ARABIC 5: Processing and Analysis ModulesOne concept that lies at the heart of the DSM design is that ICIS modules should not have to use a directory-based file system to access files. By using a description-based file system, the modules may refer to input and output files via predefined descriptions rather than via the named directories & files themselves, and ICIS can thus address several of the intertwined problems described above. A directory-based file system is based on the storage of data (e.g., the location of the file). In such a system, the data and computation dependency information is maintained via directory hierarchies and file and directory naming conventions. The difficulties with a directory-based file system are several: a directory-based file system is too closely tied to physical disk structures; relating the directory and file names to the actual uses of the data is difficult; and maintaining visibility into updated data is difficult. A description-based file system, on the other hand, is based on the description of data (e.g., the contents of the file rather than the location of the file). In such a system, description matching allows access to the files. Multiple descriptions may exist for a single file. Data and computation dependency information is decoupled from the storage of the data, as shown in  REF _Ref12356727 \h Figure 6. EMBED Word.Picture.8  Figure  SEQ Figure \* ARABIC 6: Description-Based File SystemThe DSM architecture provides a description-based file system for ICIS so that all modules within ICIS may refer to sets of data via descriptions rather than via full path and filenames. The storage of data sets is separated from the identifiers of data sets and from the descriptions of data sets. This separation of functionality in accessing data allows machine-independent characterization of data sets, allows data traceability (multiple descriptions may be present for the same data set), and allows the use of multiple versions of the same data set. Searches can be done among the existing data set descriptions to find the appropriate file to use for a computation.Throughout the DSM design, we use MD5 message digest computations for unique identification codes. Message digests are secure one-way hash functions that take arbitrary-sized data and output a fixed-length hash value. The MD5 message digest is a 32-byte unique calculation of data, regardless of the size of the data. It is like a checksum but cannot be reversed to get back to the contents of the file. The Java package and class that is used for the MD5 algorithm is java.security.MessageDigest. Using MD5 codes allows for unique identification of files across systems and allows for having just one copy of a data set on the system, thus allowing ICIS to save disk space.In designing a description-based file system that ICIS modules could use, the identifiers of data sets are separated from the descriptions of data sets. The identifiers of data sets are called File Objects, and the descriptions of data sets are called File Specs. ICIS modules use File Specs to describe files, rather than using fully specified paths, as shown in  REF _Ref12356763 \h Figure 7. File Specs get bound to File Objects when a user registers a new file of data or when a module is run.Figure  SEQ Figure \* ARABIC 7: File Specs and File ObjectsFile Objects are implemented as an Oracle table called FileObject. Every FileObject refers to a specific data set content. See  REF _Ref12356799 \h Figure 8. The FileObject table contains the columns FileObjectId, OnlineFileName, RegisterDate, and UserName. The unique FileObjectId field is an MD5 message digest computation on the contents of the file. The OnlineFileName specifies the full path to the location Figure  SEQ Figure \* ARABIC 8: File Object (FileObject fields)of the data set. The RegisterDate specifies when the FileObject was created for the specified file. The UserName field specifies the user who (first) registered the file. Subsequent registrations of the same file will use the pre-existing FileObject.File Specs are implemented as two Oracle tables called FileSpec and FileSpecAtt. The FileSpec table provides fields that are used often by the DSM architecture. The FileSpecAtt table provides generality so that file descriptions can be specified and extended as needed by the DSM modules. The information contained in the FileSpec and FileSpecAtt tables together makes up file descriptions, as shown in  REF _Ref12356824 \h Figure 9.Figure  SEQ Figure \* ARABIC 9: File Spec (FileSpec and FileSpecAtt fields)ICIS modules use the description-based filesystem, implemented by File Objects and File Specs, to preserve dependency information. In order for the DSM to keep track of dependency information, every module must specify what its inputs and outputs are and where they come from. This specification is called a Module Spec, as shown in  REF _Ref12356852 \h Figure 10. Module Specs define the intent of a computation. Combined with the state of the DSM, they determine the actual computation. The definition of a Module Spec must imply the definition of all modules that produce its input. A computation, therefore, is a tree structure of individual modules. By having formalized Module Specs, the DSM allows ICIS to maintain module and data dependency.When a Module Spec is provided with a specific module version, a set of input parameters, and a set of input files, the computation is fully specified. When a File ObjectFigure  SEQ Figure \* ARABIC 10: Module Spec Defines a Computationthat meets the requirements of the input file description is found and then bound to an input File Spec for a computation, it is called a File Binding, as shown in  REF _Ref12356872 \h Figure 11. Once the DSM finds all the input File Bindings, the executable associated with the DSM module can be run. A Module Invocation is an executed Module Spec.Figure  SEQ Figure \* ARABIC 11: Module Invocations = ComputationsModule Specs, which imply the definition of all modules that produce its input, have a tree structure. In the process of executing a Module Spec, all the modules that make up that Module Spec are computed as needed. The computational tree for these calculations is strung together by File Bindings, i.e., by input and output File Specs and their shared File Objects as shown in  REF _Ref12356899 \h Figure 12.Figure  SEQ Figure \* ARABIC 12: Computational TreesSince computations that calculate an output are completely specified by the module version, the set of input parameters, and the specific input files used, computations can be memoized. By storing information about what inputs went into which output calculations, the DSM provides ICIS with the feature of computation re-use. Also, the dependency information is now not machine-dependent, since File Specs and File Objects (with Module Versions) specify the dependencies and not fully specified directories and paths. Computational trees can be built by running only those modules that need to be run and re-using whatever results of modules that have been previously run. See  REF _Ref12356942 \h Figure 13.Figure  SEQ Figure \* ARABIC 13: Computations are StoredModule Invocation IDs are unique identifiers of computations that are used in input File Specs and output File Specs to identify the producers and consumers of data. The ReferencedBy field in the FileSpec table, shown in the previous  REF _Ref12356824 \h Figure 9, is filled in with a Module Invocation ID, as shown in  REF _Ref12356995 \h Figure 14. The Module Invocation ID is the MD5 calculation of a list composed of the FileObjectId of the executable associated with the module of the specified version, the input parameters, and the binding groups. The specific version to use and the input parameters are specified by the composite scenario description generated by the ICIS Composite Scenario Wizard.Figure  SEQ Figure \* ARABIC 14: Module Invocation IDs Identify Computations.Use of SchemeThe application-specific language used to define Module Specs is based on Scheme syntax. The Module Spec definition language needs to have programming language facilities like if-then and loops. Since application-specific languages are easy to write in Scheme and because defining and traversing tree structures are built into Scheme, it was the natural choice for defining Module Specs. Using Scheme for the basis of the Module Spec definition language, we can define individual Module Specs that compose into a tree without producing a complete tree by hand.The specific implementation of Scheme we used is Jscheme [6]. Jscheme is written in Java and provides a Scheme interpreter. In addition, it provides a scripting language for Java with a simple interface. Being able to access the richly defined set of utility classes and functionality of the Java language enhances the Data Set Manager design greatly. Jscheme allowed the powerful use of Java classes for much functionality but also allows seamless integration with the application-specific language needed to define Module Specs. Other features of Jscheme that the DSM does not currently use include a compiler to Java and an interpreter applet.The communication between ICIS modules and the DSM is done through socket-level communication to a DSM server that must be running on the ICIS server. DSM server APIs have been defined for the programming languages Perl, C, Java, and Scheme. The DSM server is implemented as a Scheme interpreter with DSM code loaded in, listening on a socket for requests. ICIS modules use the DSM server API functions, which resolve to Scheme expression requests to the DSM server. The Scheme expressions that are interpreted by the DSM server resolve to JDBC calls to access information stored in the DSM's Oracle database.ResultsICIS has been a highly successful system. It was one of the first operational Web-based systems in the US Department of Defense. More importantly, it has provided significant cost savings and enhanced capabilities to the US military.It has saved over $100 million by computing reduced needs for stocking fuels and food, which is a tremendous return on its investment in software development. For example, a major military command saved $12.7 million over two years in reduced inventory requirements, and the Army decreased their requirements for prepositioned subsistence inventory, thereby saving $75 million.An ICIS analysis that runs in less than a day replaces calculations that previously took several months to perform. This fast analysis allows multiple analyses to be made for many situations; this “what-if” capability leads to better decisions. For this reason, ICIS’s role expanded from solely a deliberate planning tool into also a credible crisis action tool.ICIS was identified in 1999 as a viable tool in the Joint Strategic Capability Plan. In 2000, it was documented in the Joint Bulk Petroleum Doctrine.ICIS has provided decision support, been used to assess readiness, or compute operational requirements in major real world military crisis action operations such as Hurricane Mitch relief, DESERT FOX, SOUTHERN WATCH, and the Kosovo campaign. It has also been used in many exercises.ICIS’s compatibility with other military software tools has saved their users time and effort. Use of ICIS has identified missing equipment in military databases. ConclusionThe ICIS system provides a successful example of efficiently interoperating and executing logistics modules.Moving ICIS’s user interface to the Web allowed it to gain tremendous benefits, such as far wider accessibility and use on almost any platform, while retaining the advantages of a central server for its massive data and computations. Redeploying portions of the user interface with Java 2 via the Java Plug-in improved many aspects of the user interface.Implementing a Java and Scheme-based Data Set Manager eliminated recomputation of identical intermediate results and duplication of data storage between analyses. It also allowed virtually any legacy module to be added to the system if desired.These techniques are applicable to a wide range of software systems.ReferencesJ. Gunshenan, G. Kratkiewicz, R. Cashon, “Inte-grated Consumable Item Support (ICIS) Model,” Proceedings of the 1997 Spring Simulation Interoperability Workshop, Orlando, March 1997J. Gunshenan, A. Halteman, R. Hughes, G. Knauth, G. Kratkiewicz, H. Perry, M. Walczak, “Data Lessons Learned from DLA's ICIS Program,” Proceedings of the 1998 Spring Simulation Interoperability Workshop, Orlando, March 1998J. Codispoti, "The DLA Integrated Consumable Item Support Model," Air Force Journal of Logistics, Volume XXIV, No. 1, Spring 2000, Maxwell AFB, Alabama, USAG. Kratkiewicz, G. Knauth, R. Bostwick, “ICIS: Redeploying a Military Logistics System to the Web,” JavaOne 2002 Conference, San Francisco, March 2002OpenMap Home Page, http://openmap.bbn.com/Jscheme Home Page, http://jscheme.sourceforge.netAuthor BiographiesGary Kratkiewicz has served as lead engineer on several logistics projects for the past seven years at BBN Technologies. He drove the transformation of the ICIS project from a standalone UNIX-based system to a Web-based system using Java. The team received a GTE Chairman’s Leadership Silver Award for this effort. Mr. Kratkiewicz has spent 13 years developing applications using object-oriented and knowledge representation technologies. He holds an S.B from MIT and an M.S. from Stanford University. He has made presentations at the JavaOne and the Council of Logistics Management annual conferences.Renu Kurien Bostwick has led the development of the Java-based Data Set Manager project for the past several years at BBN Technologies. This software helps the server side of the ICIS system manage its many data files and computations that often involve gigabytes of data. Ms. Bostwick has eight years of software development experience. She holds an S.B. from MIT and an S.M. from Duke University. She has made numerous technical presentations to clients and has given several technical seminars at BBN.Geoffrey Knauth began programming in 1975, holds an A.B. degree from Harvard College, and is treasurer of the Free Software Foundation. Mr. Knauth developed fuel logistics applications at BBN Technologies and BAE Systems. He used Java on the ICIS Project for the Defense Logistics Agency to improve interactivity, ease of use, development time, and platform independence. He also worked with Cougaar distributed agents and OpenMap. Mr. Knauth co-chaired a Free Software Conference in 1993 and participates in Harvard's Industrial Partnership. 