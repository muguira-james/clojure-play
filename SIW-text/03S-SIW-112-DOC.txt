Open, Message-Based RTI Implementation - A Better, Faster, Cheaper Alternative to Proprietary, API-Based RTIs?Kevin MullallyGary HallGeneral Dynamics12424 Research Parkway, Suite 390Orlando, FL 32826Kevin.Mullally@gd-decisionsystems.com, Gary.Hall@gd-decisionsystems.com,Don GordonBlue Sky Computer Systems Incorporated 4270 Aloma Avenue, Suite 124 PMB 60C Winter Park, FL 32792Barbara PembertonChuck PeabodyU. S. Army PEO STRI, ATTN:  EC12350 Research ParkwayOrlando, FL 32826-3276Barbara_Pemberton@stricom.army.mil, Chuck_Peabody@stricom.army.milABSTRACT: Facing requirements for better, faster and cheaper modeling and simulation products, our recent HLA development has highlighted some of the shortcomings of current RTI solutions, characterized by an API-Based interface to a vendor proprietary RTI application.Proprietary RTIs hinder developmentcan cause difficulties for federate developers, with numerous and costly hours spent troubleshooting, requesting support and reverse engineering.The centralized nature of API-Based RTI applications often presents a single point of failure that can bring an entire federation to a halt when an error occurs.  Interoperability is not prevalent between RTIs from different vendors or even between different versions of a single vendor‚Äôs RTI, continually forcing expensive rework of federate applications.Performance and scalability are limited because of RTI application overhead and have not met the needs of large, real-time federations.A Message-Based RTI implementation has been developed as an alternative solutiona solution to these limitations.  .  Using an open message protocol to implement RTI services, control is de-centralized, with each federate executing RTI service functions in accordance with the protocol specification.  This approach has many benefits.Each federate implements their own source code for RTI service functions, which has an initial development impact, but ultimately reduces cost, because the software is more reusable and easier to maintain.Individual developers are empowered to create optimal solutions, unbounded by platform, operating system or programming language.Interoperability is unconstrained by different RTI versions and vendor implementations.Performance and scalability are not limited by a centralized, proprietary interface.General Dynamics has created a reference implementation of the Message-Based RTI protocol as part of the S2Focus‚Ñ¢ simulation tool suite, currently being used by the Intelligence and Electronic Warfare Tactical Proficiency Trainer (IEWTPT) program under the U.S. Army Program Executive Office (PEO) Simulation, Training and Instrumentation (STRI).  This paper analyzes the issues surrounding API-Based RTIs and how a Message-Based RTI provides an alternative to these issues.  Laboratory performance measurements of the Message-Based RTI reference implementation are presented and proposed future development and standardization of the Message-Based RTI protocol is discussed.IntroductionHigh Level Architecture (HLA) technology development is at a critical point.  With the commercialization of the Defense Modeling and Simulation Office (DMSO) Runtime Infrastructure (RTI) and a market dominated by legacy systems, gateways and bridge solutions, simulation programs are faced with growing risk and uncertainty.  These risks are increasingly beyond the control of simulation programs.  New approaches are needed that improve development options and empower developers to create better solutions.  An open, message-based approach to HLA RTI implementation is proposed presented as an alternative to currentthe proprietary, Application Programmer‚Äôs Interface (API) based approach currently mandated in the HLA Interface Specification [2].RTI‚Äôs.  The message-based alternative is not intended as a replacement for the current RTI products and standards.  It is intended alternative solution to meet simulation requirements, taking into account risks associated with current RTIs.BackgroundThe need for a message-based RTI was first identified in the development of S2Focus‚Ñ¢, a suite of simulation tools produced by General Dynamics.  It was desired to have the ability to distribute the control of the S2Focus‚Ñ¢ tools such as the Viewer (2D and 3D Display), Analyzer (AAR), Recorder (Logger) and Mission Planner (Scenario Generator).  Engineers determined that the best approach for distributed tool control was to use HLA as the communication architecture, defining control interactions in a Federation Object Model (FOM) for a special Tool Federation.  However, the use of one of the current API-Based RTIs was assessed to have the following risks:Proprietary RTI software is expensive to troubleshoot and maintain.There is a high potential for rework due to non-interoperable RTI versions.Reliability of the RTI application is reduced with its centralized control presenting a single point of failure.Performance overhead of the RTI application is under little control of a federate developer.After considering these risks, an alternative was conceived and the development of a message-based RTI implementation commenced.  An open message protocol was developed to define how message-based RTI services are communicated and executed by each federate.  HLA Direct‚Ñ¢ was developed and released in 2002 as part of the S2Focus‚Ñ¢ tool set, serving as a reference implementation of the message-based RTI.  Facing similar risks associated with the RTI and a requirement to support greater than 25,000 entities, the Intelligence and Electronic Warfare Tactical Proficiency Trainer (IEWTPT) program under the U.S. Army Program Executive Office  (PEO) Simulation, Training and Instrumentation (PEO STRI) is now using the message-based RTI reference implementation for their internal communication infrastructure.Centralized vs. De-Centralized Control Within the message-based RTI implementation, control is de-centralized, with each federate sending and receiving RTI messages and executing RTI services in accordance with the protocol specification.  This contrasts with the API-based RTI approach, which is characterized by a central arbiter exhibiting control over the entire federation.  The centralized approach presents a single point of failure, where a problem injected by a federate or network component has been known to bring down the entire federation, losing valuable data and training time.  The federation must then be completely re-started, losing the tempo of battle.  Any time a federate rejoins a federation, all its unique object identifiers are reassigned, making it difficult to associate the newly created objects with the objects from its previous execution.  This affects the continuity of the exercise and the After Action Review (AAR).When a problem with a federate or network component is encountered in the message-based RTI implementation, each federate handles the exception individually and continues executing the federation.  If a federate crashes, the federate application is reconstituted without having to report to a central application and begins processing RTI services in a seamless fashion without detriment to the entire federation.A consideration of the de-centralized approach of the message-based RTI is that all federates must develop their own functions for executing the RTI services in accordance with the protocol, which may have an initial cost impact.  This impact is mitigated through software reuse and the implementation of commercial interface tools.  To ensure uniformity in RTI service execution, more protocol level testing is needed, which would be greatly enhanced by the use of protocol testing tools.Proprietary vs. Non-Proprietary ApproachOne of the most resounding complaints about current, API-based RTIs is the difficulty in troubleshooting and maintaining federate functions that are so closely coupled with the proprietary functions of the RTI application.  Numerous, frustrating and costly hours are spent by developers getting federate software to work properly with the RTI software.  It is often difficult to determine if the cause of a problem is the RTI or the federate‚Äôs use of the RTI.  RTI vendor support is heavily relied upon to resolve these issues.  This dependency is undesirable when problems are encountered against a deadline or during an ongoing exercise where RTI vendor support isn‚Äôt may not be readily available.RTI performance is generally viewed as an uncertainty within the simulation community.  Benchmark programs are available to measure RTI performance, and very large simulation programs have reported good results.  However, methods for improving RTI performance in a federation are typically done in a trial and error fashion.  Some guidance exists, but ultimately, improvements in RTI performance are heavily dependent on the availability of RTI vendor support.The message-based RTI implementation is an open standard that would enjoy the benefit of improving technology through involvement of the simulation community at large.  In this environment, federate developers have ultimate control of their source code and its performance.  Troubleshooting costs are greatly reduced and creative solutions can be implemented, unconstrained by a coupling with the RTI application.  Overall federate performance can be managed through benchmarking and monitoring individual federate performance in an open forum.  Tools for monitoring federation message traffic can be implemented as passive listeners that do not affect performance of the federation, as they would in subscribing to an API-based RTI.RTI InteroperabilityInteroperability is not prevalent between different RTI vendor applications and even between versions from the same RTI vendor.  The Simulation Interoperability Standards Organization (SISO) is addressing the issue of standardizing the use of APIs to create an environment where different RTIs can be dynamic link compatible.  This would ensure that a federate application compiled against a standard API would be able to use any RTI that has implemented the standard API without having to re-compile.  However, the current trend is that after a federation comes to agreement on which RTI application version to use, federates are required to re-compile their simulation code against the new version of the RTI API.  This is a costly and time-consuming process, which is compounded by the different development schedules of each federate.Since no central RTI application is required when using the message-based RTI implementation, there is an inherent level of federate interoperability.  Issues of compatibility between different versions of the open message protocol can be handled in an open forum, supporting the majority of simulation developer‚Äôs interests.Message-Based RTI Reference ImplementationThe HLA Direct‚Ñ¢ reference implementation of the message-based RTI incorporates a subset of HLA interface capabilities, allowing for:Creation and deletion of a federation executionCreation and deletion of objectsUpdate of object instance attributesTransmission and receipt of interactionsThis subset can be augmented to include other capabilities such as Time Management and Data Distribution Management given an interest in future development of the protocol.For ease of reuse, HLA Direct‚Ñ¢ was developed to be dynamic link compatible with DMSO RTI 1.3NG V6, only requiring a replacement of two shared libraries.RTI 1.3 Ambassador Services SupportedThe list below describes the current support for various RTI Ambassador services identified in the HLA specification.  The service category is listed for each section followed by the service or API call that is currently supported by the protocol.Federation ManagementcreateFederationExecutiondestroyFederationExecutionjoinFederationExecutionresignFederationExecutionDeclaration ManagementpublishInteractionClasspublishObjectClasssubscribeInteractionClasssubscribeObjectClassAttributesunpublishInteractionClassunpublishObjectClassunsubscribeInteractionClassunsubscribeObjectClassObject ManagementdeleteObjectInstancelocalDeleteObjectInstanceregisterObjectInstancerequestClassAttributeValueUpdaterequestObjectAttributeValueUpdatesendInteractionupdateAttributeValuesAncillary ServicesgetAttributeHandlegetAttributeNamegetInteractionClassHandlegetInteractionClassNamegetObjectClassgetObjectClassHandlegetObjectClassNamegetObjectInstanceHandlegetObjectInstanceNamegetParameterHandlegetParameterNametickFederate Ambassador Services SupportedThis section identifies the Federate Ambassador service categories implemented by the protocol.  The service category is listed followed by the Federate Ambassador callbacks.Object ManagementdiscoverObjectInstanceprovideAttributeValueUpdatereceiveInteractionreflectAttributeValuesremoveObjectInstanceProtocol ConventionsThe following protocol conventions were used for the reference implementation.  These conventions are offered starting point for further discussion and improvement.Federate File ParsingThis section identifies the rules for parsing the federation file, which contains the definitions for object and interaction classes.  It is essential that each member federate refer to the same schema defined in the federation file.  The schema associates unique handles (numbers) for object classes, interaction classes, attributes, and parameters.  The handles used by federates is the identifying key and must be consistent across all federates in a federation.The parsing rules, shown in Figure 1, identify the algorithm for assigning unique handles to each schema category.  Handles always begin at one and increase upwards until the maximum number is reached.  Attribute and parameter handles are unique in the federation and are not repeated, or renumbered, inside an object class.Schema ItemRangeParsing RulesObject Class1 .. Maximum Object Class CountObject classes are numbered sequentially from the first object class encountered in the file until the last class in encountered.Interaction Class1 .. Maximum Interaction Class CountInteraction classes are numbered sequentially from the first interaction class encountered in the file until the last class in encountered.Object Class Attributes1 .. Maximum ObjectClass Attribute Count Object class attributes are numbered sequentially from the first attribute encountered in the file until the last attribute in encountered.  Each handle is unique in the federation.Interaction Class Parameters1 .. Maximum Interaction Class Parameter CountInteraction class parameters are numbered sequentially from the first parameter encountered in the file until the last parameter in encountered.  Each handle is unique in the federation.Figure 1 - Object Model Schema Handle GenerationFederation UniquenessFederation messages are communicated over a unique UDP address and port number.  Federation uniqueness is guaranteed by unique combinations of UDP send/receive address and UDP port number.Federate Handle UniquenessA unique federate handle is required for each federate.  For the reference implementation, a special algorithm was used to generate the federate handle.  This is an area that needs further exploration.  One suggestion is to use the IP address from the packet header in combination with a unique identifier assigned at the workstation.  The algorithm used to generate the federate handle shall be processed by each individual federate in a de-centralized fashion.Object Instance Handle UniquenessEach object created in the federation must have a unique handle.  The handle used in the reference implementation, shown in Figure 2, contains 32 bits, with the upper 12 bits representing the federate handle and the lower 20 bits representing the object number.Field Name# BitsPositionLimitFederate Handle1220..314,096 federatesObject Number200..191,048,576 objects/federateFigure 2 - Object Instance HandleAttribute OwnershipAttribute ownership is not presently implemented.  Conceivably, any federate may update the attributes of any object, though practically, only the owning federate should update the object instance attributes.CommunicationCommunication packets shall be bundled and sent via UDP broadcast.  Bundled messages shall fit within the maximum size of a communication packet.  No fragmenting and re-assembly of packets shall be required.  While UDP was used in the reference implementation, other network protocols may provide additional benefits, such as TCP and Multicast.The bundle header, shown in Figure 3, precedes one or more bundled messages.  There is exactly one bundle header for each network packet.  The bundle header designates the version of the protocol, the handle of the originating federate, and the number of messages in the bundle.  The originating federate handle field is a convenient way to discard messages sent by the local federate, since broadcast UDP packets are received by the sending program.Field Size(bits)Bundle Header fields16Signature16-bit unsigned short ‚Äì A unique bit pattern identifying this protocol.  Ensures non-protocol traffic is not processed.  Also determines the byte ordering of data.16Version 16-bit enumeration ‚Äì Version of this protocol16Number of Bundled Messages16-bit unsigned short ‚Äì Number of messages to follow this header.16Bundle Sequence Number16-bit unsigned short ‚Äì Incrementing counter for each message sent by each federate.  Used to re-transmit missing messages.16Originating federate handle16-bit unsigned short - Designates the unique federate handle of the federate sending this message.16Destination federate handle16-bit unsigned short designating the unique federate handle of the destination federate.  If this field is zero, all federates should decode this message.Figure 3 - Bundle HeaderBundling is a means to minimize small message fragments on the network at the cost of some message latency.  This latency should be configurable to allow tradeoffs between latency and network bandwidth.Error HandlingUDP broadcast is inherently unreliable.  Dropped messages are detected by missing bundle sequence numbers.  If a message is dropped, the protocol shall request a message re-send.  Federates receiving messages monitor the sequence number.  The order of messages must be delivered in the same order that they were sent.  This is a safe assumption provided there is only 1 hop between computers.  If a message is received that contains a non-contiguous sequence number, the receiving federate sends a message to the originating federate requesting a re-send of the message.  The originating federate receives the request and re-transmits the message.  The originating federate must retain a queue of previously sent messages.  The number of messages stored in the queue is determined either by the quantity of messages or by the amount of previous history specified in seconds.Federate Heartbeat and TimeoutA federate heartbeat is periodically required to ensure member federates are responding to the federation.  The default federate heartbeat value is 60 seconds.  Provided at least one message from the federate is sent at least every 60 seconds, the heartbeat requirements are met.  If no messages are sent during this period, then the originating federate shall send a federate heartbeat message.  If a message has not been received from the originating federate during the specified heartbeat period, then the other member federates shall wait two times the heartbeat period (120 seconds) plus a network latency period (5 seconds) for a total of 125 seconds.  If no messages have been sent, the remaining federates assume the federate has resigned and invoke the resign message handler for the federate.If a timed-out federate begins re-sending messages, the receiving federates will allow the federate back into the federation.  The first message that is received will be considered the equivalent of a join message.Class Promotion and Attribute/Parameter TrimmingClass promotion is required to provide the proper object or interaction classes to the receiving federate based on the subscription list.  If an object or interaction class is received in a message, the federate must look at the class handle and if no subscription is found, attempt to promote the interaction class until a subscription match is found or the root class is encountered.During the class promotion process, attributes and parameters shall be dropped from messages based on the promoted class.  If a class is promoted, the attributes or parameters in all classes below, or derived from the new class, are removed from any message data.Message Transmission ControlThe intersection of the publication and subscription list between a originating and receiving federates determine which messages are sent by the originating federate.  If at least one federate is subscribed to an object or interaction class that a federate is publishing, then the message is sent.  Otherwise, the member federate does not send a message since no federates have expressed interest in the published informationMessage HeaderA fixed size and format message header, shown in Figure 4, precedes each message.  The message designates the time the message is sent, the total length of the message, not including the message header, and the message type enumeration.Field Size(bits)Message Header fields32Time Stamp32-bit floating point ‚Äì The time this message was sent.  The time is the number of microseconds past the current hour.  16Length 16-bit unsigned integer- The length of the message, in bytes, including this header.8Message Family8-bit enumeration - The family of message to follow the header.8Message Type8-bit enumeration - The type of message to follow the header.Figure 4 - Message HeaderThe message types are categorized into message family, shown in Figure 5.IdentifierFamily1Protocol Administration2Federation Management3Declaration Management4Object Management5Ownership Management6Time Management7Data Distribution Management8Ancillary Services9Vendor Specific Services10Experimental ServicesFigure 5 - Message FamilyThe message type enumerations are shown in Figure 6.IdentifierMessage1Resend Message2Create Federation Execution3Destroy Federation Execution4Join Federation Execution5Resign Federation Execution6Publish Object Class7Publish Interaction Class8Subscribe Object Class9Subscribe Interaction Class10Discover Object Instance11Remove Object Instance12Reflect Attribute Value Update13Provide Attribute Value Update14Send InteractionFigure 6 - Message TypePerformance ComparisonPerformance comparisons were conducted between the DMSO RTI 1.3NG V6 and the HLA Direct‚Ñ¢ reference implementation of the message-based RTI, using two Pentium¬Æ 4, 1.8 GHz workstations, running Microsoft Windows 2000‚Ñ¢ on an isolated network.  The first workstation ran the rtiexec and a Computer Generated Forces (CGF) federate.  The CGF federate created, updated and deleted objects as scripted from a database.  The second workstation ran a Performance Monitor federate that captured and displayed statistics for received objects and interactions.  Performance was measured for 1000, 5000, 10000, 15000 and 20000 objects.  The elapsed time to create and delete all objects was measured as shown in Figures 8 and 9.  After all objects were created, object were updated every 5 seconds consistently and CPU, memory and network utilization were measured using the Microsoft Performance tool, as shown in Figures 9, 10, 11 and 12.  When testing the DMSO RTI, after creating 15000 and 20000 objects, an RTI error occurred in the Performance Monitor federate, prohibiting further object update and deletion testing.Further performance testing will be conducted and presented at the Spring 2003 Simulation Interoperability Workshop (SIW), including object and interaction update rate, latency and scalability tests.SummaryThe message-based RTI implementation has been presented in comparison to the API-based RTI.  Capabilities and risks have been assessed and the message-based RTI approach has proven to be a viable alternative, with more developer control, low maintenance costs, strong reliability, good performance and a high level of interoperability.The message-based RTI reference implementation has been successfully demonstrated as a private communication mechanism.  It is recommended that this approach be evaluated and improved for use as an external communication mechanism, and considered for adoption as a SISO standard.  The resulting SISO standard would allow the simulation community to advance the state of HLA technology, creating a greater set of development options, soliciting better involvement from the Simulation Interoperability Workshop (SIW), and allowing for more creative Modeling and Simulation (M&S) solutions.Figure 7 - Object Creation TimeFigure 9 - Object Update Memory UsageFigure 11 - Object Update Network BandwidthFigure 8 - Object Deletion TimeFigure 10 - Object Update CPU UtilizationFigure 12 - Object Update Network Update RateReferences‚ÄúIEEE Standard for Modeling and Simulation (M&S) High Level Architecture (HLA) - Framework and Rules‚Äù IEEE Std 1516-2000, September 21, 2000.‚ÄúIEEE Standard for Modeling and Simulation (M&S) High Level Architecture (HLA) - Interface Specification‚Äù IEEE Std 1516.1-2000, September 21, 2000.‚ÄúIEEE Standard for Modeling and Simulation (M&S) High Level Architecture (HLA) - Object Model Template (OMT) Specification‚Äù IEEE Std 1516.2-2000, September 21, 2000.‚ÄúS2Focus‚Ñ¢ White Paper‚Äù General Dynamics, December 1, 2002.‚ÄúMessage-Based RTI Implementation - Draft Protocol‚Äù General Dynamics, October 1, 2002.TrademarksS2Focus is a trademark of General Dynamics.ModIOS is a registered trademark of General Dynamics.HLA Direct is a trademark of General DynamicsPentium is a registered trademark of Intel Corporation.Windows 2000 is a trademark of Microsoft Corporation.Author BiographiesKevin Mullally is a Software Engineer for General Dynamics Decision Systems and has been involved in the simulation industry for over ten years. Mr. Mullally holds a BS degree in Electrical Engineering from the University of Central Florida and formerly chaired the SISO-SIW Testing Forum.Gary Hall is the Lead Systems Engineer at General Dynamics Decision Systems, Orlando, FL.  He has been involved in the distributed simulation industry for over twelve years.  He has a M.S. in Computer Engineering from the University of Central Florida.Don Gordon is president of Blue Sky Computer Systems Inc. with offices in Orlando, FL.  He has been involved in the simulation industry over 10 years and provides consulting in systems and software development for DIS and HLA distributed simulations.  He is presently developing software for IEWTPT system and recently has helped develop software for General Dynamic's ModIOS¬Æ and S2Focus‚Ñ¢ suite of products.  Mr. Gordon has a B.S. degree in Mechanical Engineering and M.S. in Computer Science from the University of Missouri.Barbara J. Pemberton is the Lead Systems Engineer for the Intelligence and Electronic Warfare Tactical Proficiency Trainer (IEWTPT) for the Army's Program Executive Office for Simulation (PEO STRI).  Prior experience includes Lead Software engineer for IEWTPT, and an architecture framework experiment for Army constructive simulations.  Navy training systems acquisition and research experience includes distributed software, expert systems for scenario initialization, and software development processes using object oriented methods.  Her experience also includes hands on software development for General Electric (Conduct of Fire Trainer), and Martin Marietta.   Ms. Pemberton has a Bachelor of Science in Mathematics from the University of Tennessee and a Masters of Science in Management from Rollins College.Chuck Peabody is a Software/Systems Engineer for the Army's Program Executive Office for Simulation, Training and Instrumentation (PEO STRI) and has worked on the operational and development side of DoD simulations for the last twelve years. Mr Peabody has a BS in Business from the University of New Hampshire and an MS in Computer Science from the Naval Postgraduate School.