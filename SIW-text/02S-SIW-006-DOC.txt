XML in Distributed Simulation for DATA Management and Architecture DescriptionMartin R. Stytz, Ph.D.Sheila B. Banks, Ph.D.Air Force Research LaboratoryAir Force Research LaboratoryWright-Patterson AFB, OH  45431Orlando, FL  32828 HYPERLINK mailto:mstytz@worldnet.att.net mstytz@att.net,  HYPERLINK mailto:mstytz@acm.org mstytz@acm.org HYPERLINK mailto:sbanks@calculated-insight.com sbanks@calculated-insight.comKeywords:XML, synthetic environments, distributed simulation, interoperability, computer generated actors, actor state representation, knowledge base, re-usability, C4ISRAbstract:  The High Level Architecture (HLA) provides a solid foundation for the design and development of distributed simulations and mandates a documentation set that describes how the data must be exchanged, its accuracy, and its frequency.  For many of the interactions within a distributed simulation, basic compliance with the HLA documentation is sufficient to insure that the interactions within the simulation environment are successfully and accurately completed.  However, the HLA documentation does not address issues related to data interoperability or data representation.  It is in these two areas that the Extensible Markup Language (XML) can make its contribution to distributed simulation by providing an interoperable and open format for data representation; thereby, supporting data interoperability, actor migration, and data representation.XML is a meta-language that supports the customized definition of the components of a language (syntax, data types, vocabulary, and operators) needed to support the interchange of data for a particular application environment.  XML provides a basis for the development of data transmission formats that are transmitter and recipient independent and that can be completely self-describing and self-contained.  These inherent XML capabilities permit federates to be added to a federation with a minimum of software development and with high confidence that information exchanged between federates will be accurately represented, transmitted, and received within the federation.  In combination, the HLA provides the high level specifications needed to support interactions; XML permits the simulation community to move to a deeper level of specification by providing data definitions and formats that are flexible, independent, and comprehensive.In the paper we address a number of topics.  We will provide an introduction to XML and describe its capabilities.  We will discuss in depth the potential uses of XML in simulation environments.  As a counterpoint to the discussion of uses of XML, we will also discuss the things that XML can not accomplish and the tasks for which XML would be inappropriate.  We conclude the paper with a brief summary and some suggestions for further exploitation of XML’s capabilities for distributed simulation.1.  IntroductionThe High Level Architecture (HLA) provides a solid foundation for the design and development of distributed simulations and requires a documentation set that describes how the data must be exchanged, its accuracy, and its frequency.  For many of the interactions within a distributed simulation, basic completion of the HLA documentation is sufficient to insure that the interactions are successfully and accurately completed.  However, the HLA documentation does not address issues related to data interoperability, actor migration, or data representation.  It is in these three areas that the Extensible Markup Language (XML) can make its contribution to distributed simulation by providing an interoperable and open format for data representation and be of special use in the development and maintenance of computer-generated actors (CGAs).As is becoming more evident, complex military distributed virtual environments (DVEs) require computer generated actors (CGAs) that exhibit realistic, human-like behaviors.  For our purposes, a useful definition for a CGA is that it is an entity capable of operating alone or as a member of a group or collective, has defined goals and specific metrics of success/failure associated with them, can make decisions, understands the consequences of its decisions, has a language (ontology) providing effective communication with its environment and other agents, and has a consistent model of self and its environment and the impacts that each has on the other.XML is a meta-language that supports the customized definition of the components of a language (syntax, data types, vocabulary, and operators) needed to support the interchange of data for a particular application environment.  Each application-specific definition is contained within a Document Type Definition (DTD).  The DTD describes a vocabulary and syntax for the data to be transmitted.  XML provides a basis for the development of data transmission formats that are transmitter and recipient independent and that are completely self-describing and self-contained.  These inherent XML capabilities permit federates to be added to a federation with a minimum of software development and with high confidence that the information will be accurately represented, transmitted, and received within the federation.  In combination, the XML and HLA provides the external documentation needed to determine the frequency, accuracy, data type, and measurement units for data and XML permits the definition of the exact sequence and type for data within a transmission in a way that hides the complexities of the transmission from both the transmitter and recipient federates.  The HLA provides the high level specifications needed to support interactions; XML permits the simulation community to move to a deeper level of specification by providing data definitions and formats that are flexible, independent, and comprehensive.The notion of using XML to aid in interoperability and to aid in reuse is neither new nor an academic exercise.  Lacy [9] reports on the use of XML to represent select behaviors from the Close Combat Tactical Trainer (CCTT) Semi-Automated Forces (SAF), Modular Semi-Automated Forces ModSAF, and Warfighter’s Simulation 2000 (WARSIM2000).  In that project, the researchers categorized the common data elements and developed a set of logical data models.  They then developed an XML representation of the data model and documented the model.  To complete the project, the research team translated selected portions of behaviors from the three systems into XML.  Once the data was formatted in XML, they could use commercial tools to manipulate the CGF behaviors.A different thrust in the use of XML has been the use of XML as an intermediate format that enables the translation from a broad-based database format into a specialized format for use within a given simulation environment as discussed by Lacy and Dugone [10]. They present a survey of previous approaches to using XML to represent behaviors and describe how they could use XML to assemble a set of behaviors for re-use in OneSAF.  In their work, they reached a number of conclusions:  1) each CGA should have its own XML-based behavior representation format, 2) there is the capability for translation between XML formats, conversion of existing formats into XML may promote re-use, and 3) new CGF systems should consider using XML as the basis for their representation formats.  Their work demonstrates the capability for XML to provide a neutral data interchange format and promote reuse and interoperability.  Another application of XML has been in its use as an interface to retrieve real-time data tracks from a variety of systems, as reported by Yanni and Lewis [27].  Their project developed a web-style interface to real-time data streams for different air tracks using XML.  In research reported by Kitahara [4], they used XML to describe scenarios for use in aircraft simulation environments.  They also used XML to specify the airplane pilot’s logic.  Their work demonstrated that a scenario specified in XML can be readily shared among simulations and may serve to reduce the cost of simulation development.  Given these and other successes in using XML for CGAs, we believe that XML may also be useful for the C4ISR community [16-27]In the next section, we present an introduction to CGAs.  Section Three contains an introduction to XML.  Section Four contains a discussion of the potential uses of XML in distributed simulation, with a particular emphasis given to the use of XML for CGAs.  Section Five contains a discussion of the shortcomings of XML and of the capabilities that XML lacks.  Section Six contains our conclusions and recommendations for further research.Computer-Generated ActorsIn this section we present a brief discussion of CGAs and discuss why XML is particularly useful for CGAs as well as for other uses in simulation.  This discussion is relevant to the overall topic of this paper because it is for CGAs that XML holds a significant potential for increasing interoperability and decreasing costs.  The section closes with a discussion of the major research areas for CGAs as they relate to XML.2.1 Computer-Generated Actor BackgroundIn general, CGAs provide distributed simulations with a number of capabilities; however, to be useful in a distributed simulation the CGA must have a number of properties [1-15].  CGAs require modifiability for their knowledge bases and constituent software.  They also require high fidelity representations of the synthetic environment.  More importantly, the CGAs must have adaptable decision mechanisms so that they can produce behaviors capable of operating at varying levels of fidelity depending upon the scenario, skill, and upon demand.  Therefore, CGAs must have a variety of skills levels for both their reasoning capabilities and their manual skills.  Finally, CGAs generally require a terrain reasoning capability and a capability to reason about mission accomplishment in light of their mission, external factors, and their skill in addition to other influences on their behavior.As commonly discussed, modifiability is the ability to enhance existing CGA capabilities and properties and includes the ability to rapidly expand a domain-specific knowledge base, change the software in the CGA via a flexible software architecture, possess the capability to operate on a variety of hardware, and finally, retain independence from other software.  The requirement for knowledge base modifiability addresses the need for the CGA to incorporate new strategies, tactics, and maneuvers as they change in the real world.  This requirement also addresses the need to maintain the CGA in the field and supports improvement of the system’s performance by permitting well-encapsulated changes to the knowledge base.  A flexible software architecture likewise insures that the CGA can readily adapt to meet new performance, interface, and communication protocol requirements.  Hardware and software independence addresses the need to be able to move a CGA to new, more capable computer hardware platform with minimum rewrite of the application code.  The need to remain independent from external software supports the need to allow the system to take advantage of software that can improve its performance.High fidelity representations in a CGA are achieved by enabling CGA operation using accurate world representations, dynamics for vehicle motion, sensor and weapons models, and models of human behavior.  The world representations are based upon surface representations composed from primitive data elements organized within a hierarchical representation of the terrain data.  However, since CGAs do not operate in isolation, their world representations must correspond to the world representations used by the manned systems and the other CGA systems that they interact with.  The issue of implementing correct dynamics for vehicle motion is another aspect of achieving a high fidelity representation.  Correct vehicle dynamics insures that the vehicle only moves according to its capabilities and does not achieve a level of performance that is unrealistic given the terrain, weather, and atmospheric conditions.  Likewise, the weapons and sensor models must use the same sensitivity, field of view, and range as their real-world counterparts.  This level of fidelity must span the variety of sensors from the eyesight of the CGA operator to the RADAR and Infrared sensing systems of the CGA  This requirement is discussed further in Stytz [13, 14].The next basic consideration is the need for adaptable decision mechanisms; mechanisms that allow the CGA to exhibit a degree of flexibility in dealing with situations that occur in the distributed simulation environment.  The CGA’s decision mechanisms must adapt to the amount of information that is available and allow the CGA to maintain robust, credible behavior at run-time under a variety of external circumstances and at different levels of operator skill.  The need for robust, credible behavior is necessary so that a CGA can act and react even when confronted by conflicting or incomplete information and when under crisis conditions.  Without a foundation that permits robust, credible behavior, the CGA will fail or have a scripted pattern of behavior.  As a complementary capability, CGAs should be able to operate at varying levels of fidelity and a variety of skills levels.  The first component of this requirement addresses the need to conserve computational power by allowing only those CGAs that require high fidelity behaviors to operate at that computational level and are correspondingly allowed to consume a greater amount of computational resources.  Irregardless of the level of fidelity, each CGA should also be available in a range of skill levels.  Multiple skill levels allow the CGA to be tailored to the requirements of the simulation environment.  The skills can be realized by varying manual skills, by varying the range of options available to the decision making component, by varying the knowledge about friendly and enemy tactics available to the decision making component, and by permitting the decision making component to forecast the impact of each available option on its ability to perform its mission.In addition to these requirements, a CGA should exhibit a number of additional characteristics to enable it to perform its tasks and allow it to operate robustly within a simulation environment.  These characteristics serve to augment and amplify the requirements discussed above and further illuminate the requirements for a CGA.  Firstly, much like humans, a CGA should be able to make informed and reliable decisions in the face of a dynamically changing environment.  A CGA must be able to compensate for reduced operational capabilities, changing context, reduced support, changing weaponry, changing mission, etc.  Additionally, the CGA must be able to make decisions on its own or as a member of a collective or group. A CGA should be able to makes these decisions without outside intervention or assistance. These decisions could be made using a decision mechanism that is as simple as if-then rules or could be more extensive reasoning capabilities that require Bayesian and other inductive logic techniques.  Additionally, the CGA should be able to respond to those things that it knows (associative behaviors), those things that have been learned and also be able to respond in the face of uncertainty (non-associative behaviors), and exhibit complex emergent behaviors that can evolve over protracted periods of time.CGAs also require an internalized model of self (goals and tactics), of the environment, and of the models’ effects on each other.  The self-reference model takes the inputs from the other models as well as the historical component of its knowledge base, and uses this information to anticipate changes and generate corrective recommendations. The environmental model should include not only the effects of environmental changes on the CGA but also the effects of the military operations on the simulation environment as well. Furthermore, the CGA should incorporate a concept of self-sacrifice.  The CGA must also be agile in its ability to sense context changes in its operational domain and make adjustments in its goals and tactics accordingly.  As an adjunct, contained within the CGA’s reasoning system must be an ability to suspend current beliefs about a situation and consider alternatives that may be counter to its current reasoning.As a further consideration and since most military activity occurs within the context of group or team activity, a CGA must be reliable to be effective. To be reliable, the group of CGAs must have confidence that each member CGA can be trusted and behave in a reasonable fashion.  Finally, each CGA should possess a consistent set of truths/models that are invariant in the environment. Examples of accepted truths would be the presence of gravity, energy, momentum, etc.  This set of truths/models provides a consistent bound on reasoning and helps in establishing points of reference from which logical decisions can be made and for the exchange of information. In light of the needs and requirements addressed above and in light of current CGA capabilities, there are a number of important research issues that arise.  These issues are discussed in the next subsection.2.2	CGA Research IssuesBecause CGAs require a number of crucial capabilities in order to operate in a highly realistic and high fidelity manner in a simulation environment, a number of important research issues arise.  In our view, one of the most crucial needs for CGAs is the development of a language for communication between CGAs.  For communication to occur, there must be agreement on CGA language syntax. Similar to our human language language, a CGA must be able to present and understand data and information (what is being said or asked) very clearly and concisely. There can not be any ambiguity in the discourse between collaborating/communicating CGAs. Developing these constructs will require the development of standards and protocols. Development of a common CGA ontology is another crucial CGA research issue.  Syntax alone will not guarantee clear communication and consistent reasoning.  What will be necessary is an agreed upon set of terms and definitions for CGAs. This agreement will ensure that agents use the same terms or descriptors for common concepts.  We can not emphasize this point strongly enough, at the current time there is a pressing, almost overwhelming, need for a clear, consistent ontology that is applicable across CGAs and automated reasoning systems.  This research issue is crucial not only to enable communication but also to enable any re-use of information between CGA systems.There are two additional important research issues.  One issue is that there is a need for research to develop  interaction protocols for CGAs. This research will provide a basis for interaction between CGAs within a group and an effective means for groups to interact among themselves.  For example, by using these protocols a commander can issue a directive and be assured that every CGA has a common understanding of the directive and will respond appropriately no matter who developed the CGA.The final issue is research into the development of an architecture for individual CGAs and for multi-CGA systems. Pursuit of a robust, scalable architecture for CGAs holds out the promise of enabling software re-use, faster application development, improved operation and security, and correct, high-fidelity operation in a real-time environment.2.3 Architecture Description LanguagesIn this subsection we will present a brief overview of some of the more popular architecture description languages.  Some would argue that architecture description languages eliminate or subsume XML (as indeed some base their technology on XML).  While these approaches to architecture design and documentation, they are not a replacement or alternative to XML. Instead, they have a different role to play in distributed simulation design, which we will briefly discuss after this short introduction.  Before delving into the discussion, allow us to point out that architecture description languages were, by and large, designed for us within systems that do not operate on the scale of the typical distributed simulation so they may need to be adapted and extended to meet the needs of the distributed simulation environment.  As will be seen in the following few examples, architecture description languages concentrate on describing desired performance, the constituent parts of a system, the data that moves between tha parts, and the timing for the data movement.  As we will illustrate below, the languages do not, in large part, address issues related to the semantics of the data, data meaning, interoperability, or reuse.The first, and currently most popular, architecture description language that we will discuss is the Unified Modeling Language.  The Unified Modeling Language (UML) is a standard graphical language for developing and composing software blueprints for software systems (28-43).  UML focuses on the conceptual and physical representation of a system and permits models of a system to be developed from a variety of perspectives.  The UML provides a complete language for capturing and expressing knowledge about a subject, contains a large, useful set of predefined constructs, and is extensible. UML provides a means for visualizing the components of a system, for specifying and documenting the building blocks of a system, for visualizing the system, and for documenting a system. UML also provides support for new high-level software concepts such as collaborations, frameworks, design patterns, and components and allows a software modeler to model classes, objects, sequencing, constraints, and packages as well as components.The vocabulary of the UML consists of three types of building blocks: things, relationships, and diagrams.  Things are the major abstractions in the model, relationships tie things together, and diagrams portray aspects of the model.  There are four types of things:  structural, behavioral, grouping, and annotational.  In addition, there are seven types of structural things: classes, interfaces, collaborations, use cases, active classes, components, and nodes.  Behavioral things are the dynamic parts of the model and there are two primary types of behavioral things: interactions and state machines.  Grouping things are the organizational parts of the UML, and are described using packages.  Finally, annotational things are the explanatory parts of the UML and are comments applied to a model to describe or remark about an element.There are four types of relationships in UML: dependency, association, generalization, and realization.  A dependency is a semantic relationship between two things wherein a change to one thing causes a change to the other thing.  An association is a structural relationship that describes the connections (links) between things/objects.  A generalization is a relationship wherein the objects of the specialized element are substitutable for objects of the generalized element.  Finally, a realization is a semantic relationship between classifiers, wherein one classifier specifies a contract that another classifier guarantees to execute.  These building blocks are used to build the UML diagrams for a system.In the UML, there are nine types of diagrams:  class, object, use case, sequence, collaboration, statechart, activity, component, and deployment.  A class diagram shows a set of classes, interfaces, and collaborations and presents the static design view of the system.  An object diagram shows a set of objects and their relationships, and simply presents a snapshot of a class diagram while the objects in it are performing a particular activity.  A use case diagram shows a set of use cases and the actors involved in the case(s).  In general, a use case shows how the system and a number of users/actors and/or classes interact to accomplish a task.  Interaction diagrams, which can be either sequence or collaboration diagrams, show a set of objects, relationships, and the messages passed between them.  An interaction diagram presents a view of the system in operation.  A statechart diagram presents a view of the system as a state machine.  A statechart diagram is used to describe the event-ordered behavior of a system.  An activity diagram shows the flow from activity to activity within a system.  A component diagram presents the organizations and dependencies among the classes, interfaces, and collaborations in a system as it has been implemented.  A deployment diagram shows how the system software is allocated among the computer systems.By using the diagrams discussed above, UML provides the means for viewing and analyzing an architecture from five points of view.  These five points of view are the design view, the use case view, the process view, the implementation view, and the deployment view.  The use case view describes the behavior of the system from the point of view of the users/actors; in other words, the view describes the actions and activities that the user can “observe.”  The use case view is described using use case diagrams.  The design view is comprised of the classes, interfaces, and collaborations in a system.  The design view shows how the functional requirements of a system are met.  The design view is presented using interaction, statechart, and activity diagrams.  The process view describes the threads and processes that comprise the system and primarily focuses on performance and scaleability.  The process view uses the same diagrams as the design view.  The implementation view of a system defines the components and files that are used to assemble the system (or federation in the HLA).  The deployment view presents the system's software and hardware topology.  The components within a system are typically documented within the component and deployment diagrams.The second architecture description language we will examine is the project for Template-based Assurance of Semantic Interoperability in Software Composition (TBASSCO) being developed at the University of Southern California. The goal of this project is to develop a maintainable, understandable metadata  framework for describing software components, and support useful comparison of components.  The comparisons are based on the components’ relative abilities to perform desired functions, the degree of modifications needed to handle data exchange between components, and the relative performance of the systems they will test.  In using TBASSCO, developers specify how components interoperate by specifying the data flows between components.The third example architecture description language we will review is xACME. The Acme specification is based on XML and its DTDs and has three levels of increasing detail in its specification.  These three levels are the Topological level, the Constraints and Dynamism level, and the Types, and Families level.  They can be used directly to represent architectures using Acme’s generic view of architecture as attributed, constrained graphs of components and connectors.  These levels can also be extended with additional structure to support style-specific and domain-specific architecture description languages by introducing new namespaces.  The Topological Level contains only structural information, such as connectors, roles, components, ports, properties, representations, and system instances (graphs of components and connectors). The constraints and dynamism level extends the topological layer with an abstract syntax for specifying constraints.  This level allows a designer to express properties of a system that are invariant (ie. must always be satisfied) and heuristic (ie. should be satisfied, if possible) dynamism is anticipated to be required this level, but is being investigated. The third level is the types and families level, which extends the constraint layer with types for connectors, roles, components, ports, and properties.  Families, on the other hand, represent architectural styles and are also be defined at this level.  A family is just the type of a system (architectural instance).Before turning from this discussion of architecture descriptions, allow us to briefly address the topic of the representation of dependencies between the consittuent parts of a system.  In this approach to describing a portion of the architecture for a system, the driving concept is to indicate where and to the degree each part of a system, usually objects, depends on each other part of the system.  Dependencies come in a variety of flavors, such as using, generalization, aggregation and association (particularly in UML).  The dependencies can be described using a number of techniques, such as statistical tchniques, mostly Bayesian networks. In a Bayesian statistical model, the probability of failure of a component in linked to other components via probabilistic factors, so that a particular component’s failure probability is a function of other components’ failure probabilities.  While these approaches do undertake to meet the demands to illuminating dependencies between the parts of a system, they do not attend to the demands of documenting the data that must be exchanged between the system’s parts, data types, semantics, meaning, timeliness, or accuracy.  XML can address all of these shortcomings.3.	Introduction to XMLXML is a general-purpose, meta-markup language used for documents containing structured information.  XML supports the definition of customized markup components [27, 44-54].  The customized markup components, called tags, are documented within a Document Type Definition (DTD).  The DTD describes a vocabulary and syntax for use within a document to be transmitted.Several factors indicate that XML will continue to grow in popularity and usage.  First, XML is a flexible approach to formatting documents.  The XML capability to define and use custom tags and the minimal requirements imposed by XML on the markup language being designed give us great confidence that we can express the transmission format robustly within the boundaries of the language.  Second, XML is widely used and is standardized; therefore, the basic components of the language are stable and well understood.  Third, XML is precise, it has a well defined set of rules for describing a document containing the markup components and for ordering the contents of a document but does not specify semantics.  As a result, XML provides the basis for developing a common data format that is robust in the face of data corruption, self-describing in terms of tag meaning, and extensible to accommodate unforeseen data requirements. Fourth, because XML supports the definition of custom tag-sets and custom document structures that are completely contained within the document, an XML-based specification for CGA state can be automatically searched and categorized by computer programs instead of manually.  Finally, XML supports the creation and use of multi-part, distributed documents and supports interchange of data between applications.  These two capabilities further support transmission and reconstitution of the CGA state information when a CGA migrates.   Clearly, XML provides the flexibility needed to create a robust and flexible specification of a format for storing information.An XML-based markup language representation has three parts, the XML document, the Document Type Definition, and the XML Stylesheet.  The stylesheet only addresses appearance issues, so we will not discuss it further.  An XML-based document has a standard format and pre-defined tags.  An XML document consists of one or more elements, marked as shown in Figure 1.<Start>Element text to be transmitted</Start>Figure 1:  XML Document Element FormatAn element consists of two tags, an opening tag ( < > ) and a closing tag ( </ > ), with the name of the tag appearing between the < and the >.  The nesting of the tags within the XML document must correspond to the nesting specified within the DTD.  An XML document always begins with the XML language declaration in the following format, <?xml version=”1.0” standalone=”no”?>.  The declaration specifies the version of XML used and whether or not an external DTD is required.  This particular specification indicates that an external DTD is needed by a parser to understand the structure of the document; alternately, saying yes means that a DTD is embedded within the XML document.  The second line defines the root element of the document and the location of the DTD.  The remainder of the document contains tags defined in the DTD and the corresponding data to be transmitted.The Document Type Definition specifies how the elements (contents) of a document must relate to each other.  Each element is defined using a <!ELEMENT> declaration in the following format: <!ELEMENT elementname rule >.  There are a number of keywords that can be used to define the rule, including the keywords ANY and #PCDATA.  The ANY keyword indicates that any character data or keyword can appear within the element.  The keyword #PCDATA indicates that only general character data can appear within the element.  To indicate that multiple elements must appear in a specific sequence, commas are used to separate the instances.  Parentheses are used to group declarations.  Within a declaration, one of three operators can be used to specify the number of occurrences of an element.  The ? operator indicates that the element must appear once or not at all.  The + operator indicates that the element must appear at least once.  The * operator indicates that the element can appear any number of times or not at all.  Within the DTD, attributes can be defined for any element.  An attribute is defined using the <!ATTLIST> declaration, which has the form <!ATTLIST target_element attribute_name attribute_type default>.  Data types include character data (CDATA) and enumerated data, as well as the keywords #REQUIRED, #IMPLIED, and #FIXED.  Using these components with a set of topic-specific keywords as a basis, a document type can be defined.  XML has additional capabilities that are discussed in a variety of resources [27-37].Based upon our own experiences and the reported work in the simulation community and coupled with knowledge of the strengths and weaknesses of XML, we believe that we can offer some insight into the uses of XML.  Of equal importance, there is some guidance that we can offer into what XML can not do in the simulation world and to address the requirements for CGAs that were discussed above.  These topics are addressed in the next two sections.4.	Why Use XML?Before turning to a discussion of XML and its role in distributed simulation, allow us to briefly assess the general characteristics of XML. First and foremost, XML is customizable by end users, groups, and organizations.  Domain or application specific semantics can be defined.  Because of its flexibility, XML offers a community of users the opportunity to document and store information in a manner that is developer independent, re-usable, self-documenting, and comprehensive in addition to being able to permit the definition of a format for the data that addresses the specific needs of the community.  This flexibility presents both potential opportunities and potential pitfalls.  The flexibility affords the community to define and adopt a format that addresses its unique needs, permits re-use and interoperability of data, insures the long-term viability and access to data stored in an XML-based format, and insures that a community or user is not trapped by a format.  The pitfalls are that the flexibility also permits unique customizations and extensions that hinder the exchange of data and discovery of errors and can be resource and time consuming to detect and resolve.  XML is not brittle.  A document or knowledge base defined in XML can adapt to change.  The key to success when using XML is to insure that consensus is achieved when defining formats, that a common ontology and lexicon are developed and agreed upon, and that a clear means of identifying extensions is developed and enforced in the community.  A final note about the general use of XML and one that is, we believe, of particular importance to the CGA community. XML is flexible and can represent almost any type of information; however, the representation is, by and large, not computable.  Therefore, it must be converted into another representation for use within a computing system. XML offers a number of advantages to the simulation developer and simulation environment developer.  One of the greatest contributions that XML makes is that it helps prevent the user and the designer from being locked into a format for information or knowledge representation.  XML can form the basis for long term re-use of the information/data that is captured and represented in XML.  XML also has a role to play in the design and documentation of simulation environments.  XML can be used as an interoperable and developer-independent specification for Simulation Object Models (SOMs) and Federation Object Models (FOMs); as well as for the specification of the contents, operations, fidelity, fidelity options, and characteristics of a simulation environment. XML’s open availability and customizability can be an aid in interoperability, if XML is used properly.  A key in this regard, in addition to the items mentioned above, is the use of the tools that are available to aid in assembly, examination, and editing of XML-based documents.  Within federations, XML can be used to define scenarios in an application independent manner and can be interpreted into any form needed by an application to execute the scenario.XML can aid in the verification and validation of information and knowledge bases because it is both human and computer readable.  XML supports linking between documents and supports linking to external documentation; thereby, helping to insure that sources and authorities are closely tied to information.  Of equal importance with XML’s ability to tie information closely to documentation is the ability of XML to support the specification of both hierarchy and network schemas for information and knowledge storage.XML also does have a role to play in the software development and federation development process.  XML can be used to define a software architecture in a way that is application and tool independent.  In addition to its use in defining software architectures, XML can support and be used with rapid prototyping, aspect oriented programming, extreme programming, spiral software development, and other software development processes because XML is software development process neutral.  Additionally, XML can aid in the use of rapid prototyping since it helps the designer/implementer postpone commitment to a representation until the point of implementation.  Within an application, XML can support inter-object communication and inter-entity communication in an application neutral, open manner that enables re-use and experimentation.  Finally, XML can be used in an application’s data logging system to maintain a record of activities that is application neutral and transportable.XML has a significant role to play in the description of simulation environments and the systems that comprise them via its employment as an architecture description language (ADL).  In this role, XML is used as the foundation for the textual description capability needed in the architecture description language.  Note, XML is not used directly to describe the architectures or as the ADL; it is one component of the ADL and is used to define a precise semantics for the ADL.Finally, as regards supporting CGAs and their use in simulation environments, XML can be used to capture and represent actor state, entity state, sensor state, and also used for transmission of commands.  XML can also be used to transmit actor and entity state and also aid in supporting the migration of CGAs from host to host.5.	What XML Can’t DoFor all of the capabilities and potential that XML possesses, there are many things XML can not provide.  Generally, these shortfalls are to be found in the areas of standardization and planning for information representation.  Simply put, XML is not a silver bullet.  Like any other computer language, the effective use of XML is based upon knowledge about the domain’s requirements development, analysis, and design followed by an implementation.  First, and foremost, XML is merely the basis for a standard data representation or format for use in a domain or environment, it is not itself a standard.  There are too many options that XML makes available; therefore, effort must be devoted to developing a consensus for any specification put forth that is based on XML.  Secondly, and just as important, XML is not a substitute for determining the requirements for a system or a domain.  XML can be used to document those requirements, but it does not serve as a substitute for assessing them in advance of development and implementation.  XML is also not a substitute for analysis, for software architectural specification, or for design effort; XML can not make up for poor design choices. XML is not a substitute for a sound process for design and architecture creation or for software development; it can be used to document the artifacts of those efforts but it can not replace them.  Additionally, XML will not guarantee interoperability, but can be used to promote interoperability.  XML is not sufficient to achieve interoperability without the proper process and design efforts that support XML’s use.XML, as a language, has some shortcomings that can make it difficult to use.  XML lacks an inherent debugging capability, which makes it difficult to determine the location of an error in a knowledge base or document.  Also, XML has no support for logic processing or management control flow through a knowledge base or document other than simple links between documents.  XML provides only a very coarse grained approach to linking information and describing associations and can lead to a plethora of documents in a knowledge base.  In general, these shortcomings can be addressed through the use of XML-specific software tools but the user should be aware of the potential for unmanageability of a knowledge base.  XML does not have language constructs such as if, case, loop, etc. for procedural control.  Furthermore, XML can not support relational knowledge bases or relational information.  XML can be used to access these databases, but it can not currently be used to implement them.  XML has no execution trace facility and has no inherent capability to allow a user to examine the path of execution.  Additionally, XML does not have an inherent capability for the representation of temporal relations and any such representation must be layered onto the language. Because any semantics can be defined in XML, the careless use of XML can lead to confusion and hinder interoperability.  For this reason, we suggest that standardization and consensus concerning representations and formats should be developed and should not be left to the discretion of each developer.As regards the needs of CGAs, there are a number of significant shortcomings inherent to XML that must be addressed before XML can be fully exploited.  First, XML is not a substitute for the development of a ontology and lexicon for an environment or domain.  The ontology and lexicon should be developed before the XML representation is developed.  Additionally, XML will not insure that the semantics for an environment are correct.  The task of insuring correct semantics must be performed independently of XML; XML’s proper role is in the representation of the semantics.  XML is not a substitute for the knowledge engineering process and can only serve to capture the results of the process.  Furthermore, since XML is interpreted, we believe that it is not a suitable basis for developing an executable knowledge base representation.  Finally, XML lacks strong data typing.  Data typing can be added into a representation format, but the manner in which it is added and the format must be part of a standard or at least a consensus concerning the proper representation of the data.The use of XML does not guarantee that a format or knowledge representation is robust and able to adapt to change or incorporate new knowledge.  Simply using XML will not insure that a knowledge base is manageable, is expandable, or is maintainable.  XML is not a basis for translation of knowledge bases from one type into another, but it can serve to help in the translation from one format into another.  A proper role for XML would be to serve as a baseline for a common representation for a single type of knowledge format for a given decision making approach/technique.  The choice of a representation for knowledge has to satisfy a number of criteria, not the least of which is the performance of the representation for reasoning within a domain.  To simply change from one representation type into another potentially sacrifices performance advantages in pursuit of some sort of potential re-use and may be counter-productive.6.	Conclusions and Future WorkIn this paper, we discussed some of the advantages and pitfalls that are inherent to the use of XML and suggested what the role of XML in distributed simulation should be.  As a backdrop for our discussion, we provided an introduction to XML and described its capabilities.  We then discussed the potential uses of XML in simulation environments and its inherent advantages for information storage and knowledge representation.  Then, to help insure that XML was presented in its proper perspective, we turned to a discussion of the things that XML can not accomplish and the tasks for which XML would be inappropriate.We have a few recommendations for further work regarding XML.  A this time, we believe that further experimentation with XML in a variety of domains is needed.  The results of these experiments should provide further guidance concerning the appropriate uses of XML in distributed simulation and in the development of the ontologies and lexicons that will be needed.  These ontologies and lexicons should be developed in conjunction with the experiments, which would allow them to be tested as they are developed.  Our final suggestion is that the Simulation Interoperability Standards Organization initiate a track dedicated to XML and its usage in distributed simulation environments.  A final area that should be investigated is the combination of the UML, the HLA, and XML into a single architecture definition and specification tool for the design and documentation of distributed simulations.  Our work in this area will be reported in the Fall Workshop.ReferencesCGABharat, K. & Cardelli, L. (1995) “Migratory Applications,” Proceedings of the ACM Symposium on User Interface Software and Technology, Pittsburgh, PA, Nov. 14-17, pp. 133-142.Miller, G.J. & Filipelli, L.J. (1999) “An XML Representation of HLA Object Models,” The Spring Simulation Interoperability Workshop, Orlando, FL, 14-19 March, pp. 565-570.Sagan, D.P.; Kersey, D.E.; and May, P. (2000) “Conceptual Modeling Lessons Learned from WARSIM 2000,” The 2000 Spring Simulation Interoperability Workshop, Orlando, FL, 26-31 March, pp. 312-323.Brabbs, J. and Hope, K. (1999) “Computer Generated Forces Requirements for an Embedded Simulation System,” The 1999 Fall Simulation Interoperability Workshop, Orlando, FL, 12-17 September, pp. 868-873.Dompke, U.K.J.; vonBaeyer, A.; and Heineken, E. (1999) “Problems of Validating Human Behavior Models,” Proceedings of the 1999 Fall Simulation Interoperability Workshop, 12-17 September, pp. 151-153.Dompke, U.K.J.; vonBaeyer, A.; and Heineken, E. (2000) “Problems of Validating Computer-Simulations of Human Behavior,” Proceedings of the 2000 Spring Simulation Interoperability Workshop, Orlando, Florida, 26-31 March, pp. 830-833.Kitihara, N.; Higuchi, T.; Kinoshita, T.; and One, M. (2001) “The Fighter Simulation Using SAF and XML,” The Spring Simulation Interoperability Workshop, Orlando, FL, 25-30 March, pp. 349-356.Lacy, L.W. & Tuttle, C. (1998) “Interchanging Simulation Data Using XML,” The 1998 Fall Simulation Interoperability Workshop, Orlando, FL., 13-18 Sep., pp.1110-1119.Lacy, L.W. and Pearman, G.M. (2000) “Computer Generated Forces Behavior Representation and Reuse Using the eXtensible Markup Language (XML),” The Fall Simulation Interoperability Workshop, Orlando, FL., 17-22 Sep., pp.926-932.Lacy, L. and Dugone, T.D. (2001) “Representing Computer Generated Forces Behaviors Using eXtensible Markup Language (XML) Techniques,” The Proceedings of the 10th Conference on Computer Generated Forces, 15-17 May, Norfolk, VA, pp. 171-176.Lacy, L.; King, D.; and Burnett, K. (2001) “Equipment Characteristics and Performance Data Interchange for Simulations Using XML,” Proceedings of the Spring Simulation Interoperability Workshop, Orlando, FL, 25-30 March, pp. 173-179.Roberts, D.W.; Mitchell, C.M.; Thurman, D.A.; and Chappell, A.R. (1999) “Computational Models of Team Decision-Making,” The 1999 Fall Simulation Interoperability Workshop, Orlando, FL, 12-17 September, pp. 993-1000Stytz, M.R. & Banks, S.B. (1999) “Robust Computer Generated Actor Migration,” Proceedings of the 1999 Fall Simulation Interoperability Workshop, Orlando, Florida, 15-20 September, pp. 695-703. Stytz, M.R.; Banks, S.B.; Hutson, L.J.; and Santos, E. (1998) “An Architecture to Support Large Numbers of Computer-Generated Actors for Distributed Virtual Environments,” Presence: Teleoperators and Virtual Environment, vol. 7, no. 6, December, pp. 588-616, MIT Press.Tamucci, M.S.; Timian, D.; and Burnett, K. (2000) “Conceptual Modeling of Foreign Command Decision Processes,” Proceedings of the 2000 Spring Simulation Interoperability Workshop, Orlando, Florida, 26-31 March, pp. 100-109.C4ISRAnthony, J. (2001) “WARSIM 2000 and C4I Device Initialization,” The 2001 Spring Simulation Interoperability Workshop, Orlando, FL, 25-30 March, pp. 86-90.Barry, M.; Peace, J.; McGowan, J. (2000) “CJAM-Assessing the Force-Level Impact of Tactical ECM on C4I Systems Through Distributed Simulation,” Proceedings of the 2000 Fall Simulation Interoperability Workshop, Orlando, Florida, 17-22 September, pp. 556-567.Brennan, J.M. and Smith, E.B. (2001) “M&S-C4ISR Interoperability/Synchronization Issues and Potential Solutions,” The 2001 Spring Simulation Interoperability Workshop, Orlando, FL, 25-30 March, pp. 672-683.Krusche, S. and Tolk, A. (1999) “A Shade Approach for Coupling C4I Systems and Simulation Systems,” The 1999 Fall Simulation Interoperability Workshop, Orlando, FL, 12-17 September, pp 47-56.Lacatera, J. and Timian, D. (2000) “Interim Report out of the C4I Study Group,” Proceedings of the 2000 Spring Simulation Interoperability Workshop, Orlando, Florida, 26-31 March, pp. 368-374.Lacatera, J.; McConnell, J.; Riehl, M.; Hoang, T.; and Tafoni, T. (2000) “A Model for Interfacing a C4I System to Tactical Communications Simulations,” Proceedings of the 2000 Fall Simulation Interoperability Workshop, Orlando, Florida, 17-22 September, pp. 518-525.Lacy. L.L.; King, D.; and Burnett, K. (2001) “Equipment Characteristics and Performance Data Interchange for Simulations Using XML,” The 2001 Spring Simulation Interoperability Workshop, Orlando, FL, 25-30 March, pp. 173-179.McCall, M. (1999) “Application of Distributed Simulation to C4ISR Test and Evaluation,” The 1999 Fall Simulation Interoperability Workshop, Orlando, FL, 12-17 September, pp. 781-786.Newcomb, M.; Gustafson, J.; and Nguyen, P. (1999) “The WARSIM 2000 C4I Interface,” The 1999 Fall Simulation Interoperability Workshop, Orlando, FL, 12-17 September, pp 241-248.Rausch, D.M. and Johnston, S.C. (1999) “The Coordinated Spiral: Concurrent Modeling and Simulation Development with C4ISR Systems,” The 1999 Fall Simulation Interoperability Workshop, Orlando, FL, 12-17 September, pp. 538-548.Smith, F.G.; Maier, M.; and Dunstan, A. (2000) “Development of a C4I Collection Management System to an Intelligence Sensor Simulation System,” The 2000 Spring Simulation Interoperability Workshop, Orlando, FL, 26-31 March, pp 750-758.Yanni, P. and Lewis, M (2001) “An XML Interface to the Rosetta Realtime Track Server,” The 2001 Spring Simulation Interoperability Workshop, Orlando, FL, 25-30 March, pp. 240-246.UMLAlbir, S.S. (1998) UML in a Nutshell, O'Reilly Press, Sebastopol, CA.Bell, A.E. and Schmidt, R.W. (1999) "UMLoquent Expression of AWACS Software Design," Communications of the ACM, vol. 42, no. 10, October, pp. 55-62.Booch, G. (1998) The Unified Modeling Language User Guide.  Addison Wesley, Reading, MA.Booch, G.; Rumbaugh, J.; and Jacobson, I. (1999) The Unified Modeling Language User Guide, Addison Wesley, Reading, MA.D'Souza, D. and Willis, A.C. (1998) Objects, Components, and Frameworks in UML: The Catalysis Approach, Addison-Wesly Reading, Mass.Fowler, M.; Scott, K.; and Booch, G. (1999) UML Distilled; A Brief Guide to the Standard Object Modeling Language, 2nd Edition, Addison-Wesly Reading, Mass.Gomaa, H. (2000) Designing Concurrent, Distributed, and Real-Time Applications with UML, Addison-Wesly Reading, Mass.Henderson-Sellers, B. and Unhelkar, B. (2000) Open Modeling with UML, Addison-Wesly Reading, Mass.Kobryn, C. (1999) "UML 2001: A Standardization Odyssey," Communications of the ACM, vol. 42, no. 10, October, pp. 29-37.Kulak, D.; Guiney, E.; and Lavkulich, E.  (2000) Use Cases:  Requirements in Context, Addison-Wesly Reading, Mass.Larman, C. (1998) Applying UML and Design Patterns, Prentice Hall, Cambridge, MA.Larsen, G. (1999) "Designing Component-Based Frameworks Using Patterns in the UML," Communications of the ACM, vol. 42, no. 10, October, pp. 38-45.Page-Jones, M. (2000) Fundamentals of Object-Oriented Design in UML, Addison Wesley, Reading, MA.Reed, P.R. and Reed, P.R. Jr. (1999) Developing Applications with Visual Basic and UML, Addison Wesley, Reading, MA.Richter, C.A. (1999) Designing Flexible Object-Oriented Systems with UML, Macmillan Publishing, New York, NY.Selic, B. (1999) "Turning Clockwise: Using UML in the Real-Time Domain," Communications of the ACM, vol. 42, no. 10, October, pp. 46-54.XMLCopenkus, A. & Hoodbhoy, F. (1999) Applied XML:  A Toolkit for Programmers. John Wiley and Sons: New York, NY.DuCharme, B. (1998)  XML:  The Annotated Specification. Prentice Hall: New York, NY.Garingo, G. & Augins, J.S. (1999) “XML to Facilitate Interoperability Between Repositories,” The Spring Simulation Interoperability Workshop, Orlando, FL, 14-19 March, pp. 1106-1111.Harold, E.R. (1999) XML Bible.  IDG Books Worldwide: Foster City, CA.Harold, E.R. (1999) XML: Extensible Markup Language. IDG Books Worldwide: Foster City, CA.Leventhal, M.; Lewis, D.; & Fuchs, A. (1998)  Designing XML Internet Applications.  Prentice Hall: New York, NY.McGrath, S. (1998) XML By Example:  Building E-Commerce Applications. Prentice Hall: New York, NY.Megginson, D. (1998) Structuring XML Documents. Prentice Hall: New York, NY.Simpson, J.E. Just XML. (1998) Prentice Hall: New York, NY.St. Laurent, S.; St. Laurent, S.; & St. Laurent, S. (1999)  XML:  A Primer. 2nd edition.  IDG Books Worldwide: Foster City, CA.St. Laurent, S.; St. Laurent, S.; & Biggar, R.J. (1999) Inside XML DTDs: Scientific and Technical.  McGraw Hill: New York, NY.Author BiographiesMartin R. Stytz is in the Air Force Research Laboratory and is a retired Lieutenant Colonel in the U.S. Air Force.  He received a Bachelor of Science degree from the U.S. Air Force Academy in 1975, a Master of Arts degree from Central Missouri State University in 1979, a Master of Science degree from the University of Michigan in 1983.  Stytz received his Ph.D. in Computer Science and Engineering from the University of Michigan in 1989.  He is a member of the ACM, SIGGRAPH, SIGCHI, the IEEE, the IEEE Computer Society, AAAI, and the Society for Computer Simulation.  His research interests include virtual environments, distributed interactive simulation, modeling and simulation, software architecture, intelligent agents, cyberwarfare, and computer-generated forces. Sheila B. Banks is in the Air Force Research Laboratory and is the past president of Calculated Insight.  Dr. Banks received her Bachelor of Science from the University of Miami, Coral Gables, FL in 1984 and a Bachelor of Science in Electrical Engineering from North Carolina State University, Raleigh, NC in 1986.  Also from North Carolina State University, Raleigh, NC, she received a Master of Science in Electrical and Computer Engineering in 1987 and her Doctor of Philosophy in Computer Engineering (Artificial Intelligence) from Clemson University, Clemson, SC in 1995.  Her research interests include artificial intelligence, intelligent computer generated forces, associate and collaborative systems, distributed virtual environments, intelligent human computer interaction, and man-machine interfaces. An architecture consists of a number of elements (such as components), the form for the elements (how they are connected together), the rationale for the particular set of elements and connections in a domain/application, and dynamism, which expresses when interactions occur and the content of the interactions.PAGE  