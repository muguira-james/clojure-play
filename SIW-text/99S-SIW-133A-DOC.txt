The distributed mission training integrated threat environment system architecture, rules and design overviewLt. Colonel Martin R. Stytz, Ph.DSheila B. Banks, Ph.D.Air Force Institute of TechnologyCalculated InsightWright-Patterson AFB, OH 45431Orlando, Fl  32828mstytz@afit.af.mil, mstytz@acm.orgsbanks@calculated-insight.comKeywords:  software architecture, distributed simulation applications, high level architecture, object-oriented architectureAbstract: The development of software for large-scale High Level Architecture (HLA) applications poses challenges for software development, architecture, and implementation.  To address these challenges we investigated a number of architectural paradigms and approaches and incorporated the strongest points of each into our architecture.  However, for these systems the most critical and common drawback was poor performance in the quite common case where system requirements are unknown or poorly defined at the start of the project and are uncovered and refined over the course of system development.  Because the chief characteristic of current modeling and simulation systems development is the discovery of requirements over the course of the project, this lack of useful development paradigms and approaches is a concern.  In response to the need for a useful system development paradigm, we developed an approach, rules, and architecture to support HLA environment software development.1.	IntroductionThe Joint Synthetic Battlespace described within the Department of Defense modeling and simulation master plan requires a distributed virtual environment (DVE)12 wide consistent threat environment to achieve the described aircrew mission rehearsal and training capability.  To achieve this objective, the aircrew threats must appear at equivalent levels of fidelity for all the actors in the DVE and they must interact with human-operated and computer-controlled actors in a realistic fashion.  Achieving this level of realism for aircrew training in a DVE is not currently possible for two reasons.  First, each primary aircraft simulator training system developer has its own threat system and has made proprietary modeling decisions to support a specific user for a select few missions.  Second, the individualized nature of current threat systems precludes the possibility of introducing coordinated threats into the training DVE.  However, the threat system interaction on a distributed network requires coordination to achieve many training and mission rehearsal requirements. The run-time challenges for a CGA arise from the need to compute human-like behaviors and reactions to a complex dynamic environment at a human-scale rate of time.  In addition, the CGA’s behavior must be realistic and accurate enough so that other CGAs and human participants react to its behaviors as though the CGA’s avatar were human-controlled.  The Distributed Mission Training Integrated Threat Environment (DMTITE) Project was undertaken to develop an effective solution to these issues for aircrew training.The DMTITE project13,14,15,16 is identifying the requirements for a distributed aircrew threat environment and assembling a prototype High Level Architecture (HLA) compliant computer-generated actor (CGA) threat system to provide realistic threats for aircrew training.  To achieve this objective, DMTITE must be able to insert surface threats, air threats, ground threats, and jamming threats into the distributed training environment.  Each DMTITE CGA application is intended to exhibit believable human-like behaviors, such as described by Calder4, Laird7,8, and Tambe18.  For DMTITE threats to operate and behave properly, DMTITE requires threat models, knowledge bases, and appropriate human behavior models for every type of DMTITE actor.  Decision making for each type of DMTITE actor may be accomplished using a variety of decision making techniques such as fuzzy logic or case-based reasoning.  To achieve realistic human behaviors, we incorporated a combat psychology model2,3.  DMTITE has realistic sensor models, aerodynamics models, and weapons models for each threat system so that we could achieve the highest possible fidelity for each threat.  Crucial but implicit in providing these capabilities is the development of the software required to instantiate the threats and to manage the operation of the DMTITE software in the HLA DVE.In light of the need for DMTITE to be a large-scale High Level Architecture (HLA) application, we had to address the challenges HLA poses for software architecture, design, prototyping, and implementation.  To address these challenges we investigated a number of paradigms and approaches1,5,10,11, but all failed to adequately address the challenges posed by HLA and DVEs.  For the DMTITE project, the most serious and common drawback was poor performance when specific system requirements are unknown or poorly defined at the start of the project and are subsequently uncovered and refined during system development.  As a result, we developed the Rapid Evolutionary and Exploratory Prototyping (REEP) approach17, which parallels work by Davis5 and Pitman8, to manage the requirements discovery and solution process.  To support software development in REEP and HLA, we evolved the rules, architecture, and software design described in this paper.In the next section we present the definitions and background requirements for the DMTITE project.  In section three we describe DMTITE’s CODB architecture, its components, their functionality, and our design approach/philosophy.  Section four contains the rules and procedures required by the architecture.  Section five describes our use of containerization in DMTITE.  Section six presents the high-level DMTITE software design.  Section seven contains conclusions and suggestions for further work.2.	BackgroundWithin the DMTITE architecture, the following terms are defined.  A container is a permanent, unvarying data structure that holds data that is exported from an object.  Containers are comprised of pallets and slots.  A pallet is a major category or data type in a container.  Pallets can be nested hierarchically.  The data for an individual entity is assigned to a pallet in the container by type, and within a pallet each entity has its own, semi-permanent position, or slot, that holds all of its data.  An entity has only one slot and can be placed into only one pallet.  An incoming data stream is composed data that has arrived at the RTI and is destined for an entity.  An outgoing data stream is composed of data that originated at a local entity and is headed for the RTI. An inbound container is a container that is carrying data into a CODB or entity that the CODB/entity must read.  An outbound container is a container that is carrying data away from the CODB or an entity and the CODB/entity must write the container.  An inbound container will always be an inbound container, an outbound container will always be an outbound container.  Inbound/outbound are information stage centric designations.  Data movements between the major objects are called information streams.The high-level requirements for DMTITE fall into several categories.  We determined that the following requirements must be met by DMTITE:  1) availability of a wide variety of threat systems, such as acquisition radars, sound and infrared detection systems, and aircraft, 2) support for software modifiability, 3) high fidelity representations of motion and human behavior, 4) adaptable decision mechanisms, 5) variety of threats at varying levels of fidelity, 6) a number of skills levels for each actor, 7) terrain reasoning capability, and 8) support for entity migration.  The next few paragraphs elaborate upon a few of these requirements for DMTITE, which are discussed in greater detail elsewhere15,16.For DMTITE to be useful for operational training, it must be capable of inserting a variety of threat systems into the DVE.  Modifiability is the ability to expand upon existing capabilities and includes the following:  1) the ability to expand a domain-specific knowledge base, 2) a flexible software architecture, and 3) the capability to operate on a variety of hardware.  High fidelity representations are achieved by using accurate:  1) world representations, 2) dynamics for vehicle motion, 3) sensor and weapons models, and 4) models of human behavior.  Adaptable decision mechanisms allow a CGA to exhibit a degree of flexibility in dealing with a variety of DVE situations.  Adaptable decision mechanisms permit the system to maintain robust, credible run-time behavior under a variety of external circumstances and at different levels of operator skill.DMTITE must be able to provide aircrew training threats at varying levels of fidelity and a variety of skills levels.  The first component of this requirement speaks to the need to conserve computational power by insuring that only those threats that require a high fidelity representation are allowed to consume a correspondingly greater amount of computational resources.  Regardless of the level of fidelity, each threat should also be available in a range of skill levels to allow the training to be tailored to the abilities of the human participants.  The requirement for support for migration arises from the necessity of reducing latency between source and recipient of data across the network. Currently, the best way to minimize latencies is to migrate one or more of the participants in an interaction to a host computer system whose interaction latency is acceptable.3.	The DMTITE ArchitectureThe DMTITE architecture, called the Common Object DataBase Architecture17, (CODB) is a data-handling architecture that uses classes, containers, and a central runtime data repository to store and route data between the major objects in DMTITE.  The CODB/container combination is used to insure low coupling between major DMTITE objects and components.  The CODB architecture reduces the coupling by reducing the amount of information that a class must maintain about other classes.  To acquire public data from one or more objects in an application, an object must only access the CODB because that is where the information resides.  The CODB architectural approach provides two important capabilities.  The CODB Architecture inherently supports multiprocessing and distribution of the resources required for effective execution of large, complex, distributed virtual environments.  Also, the CODB Architecture enables rapid switching between avatars and dynamics models with minimal impact on performance or operation.The logical view of the DMTITE architecture is shown in Figure 3.1.  In the architecture, the Network Interface and Network component is responsible for the transmission of information between DMTITE and the other computers that are instantiating the DVE and this component encapsulates the Run-Time Infrastructure (RTI).  As information arrives, it is forwarded from the Network Interface software to the World State Manager (WSM).  The World State Manager maintains the complete state of any portion of the DVE subscribed to by any of its actors.  The WSM is responsible for dead reckoning entities in-between receipt of data for the entity.   As a result, when Figure 3.1: DMTITE System Architecture using the Common Object DataBase.the CODB requests an update from the WSM, the WSM has a container with the current DVE actor state information ready to be dispatched.  Once in the CODB, the data is available to all the actors at a DMTITE host location.  The DMTITE architecture shown in Figure 3.1 uses a main CODB and has provision for multiple, specialized sub-CODBs that can be used to route information to a select subset of the actors hosted at a DMTITE location.  Sub-CODBs are shared by their serviced actors and have the same protection mechanisms and containerization associated with them as the main CODB.  Once the DVE state information reaches the CODB, the data is repackaged into outgoing containers for either individual actors or for a single actor class.  The repackaging is performed by methods in the CODB.  Once the DVE state reaches a sub-CODB, the data is dispatched from the sub-CODB in containers to the serviced actors.  The containers that depart the CODB or a sub-CODB for a recipient are customized for the recipient to satisfy its data needs as specified in the HLA Simulation Object Model (SOM).  The operation of the DMTITE containers is discussed at length in section five.  The CODB, and all of its sub-CODBs, are used to store and forward state information from actors hosted by a DMTITE to the DVE through the WSM.In the CODB architecture, each threat is composed of a Physical Representation Component, a Skills Component, and a Cognitive Representation Component.  The Physical Representation Component (PRC) contains the description of all of the physical attributes and properties of the individual CGA and has two major sub-objects, the Dynamics Model and the Sensor Model. The implementation of the PRC object allows us to encapsulate one or more physical models for the operation of a dynamics unit or sensor within a single package and also allows each actor to have access to one or more dynamics units or sensor models.  The PRC also maintains the state of actor-specific properties, performance capabilities, the weapons load, the damage assessment, and the actor’s physical status.Within an individual DMTITE system, the actor’s knowledge is contained in a shared knowledge base that was assembled specifically for its actor type.  However, while the knowledge bases for an actor type are shared by all of the actors of that type, not all of the actors of a type utilize all or even the same aspects of the knowledge base’s information.  The fidelity level and skill level specified for the actor determines the information accessed from the knowledge bases by an actor.  Each actor’s decision mechanisms belong to the actor, they are not shared.The decision making system in the architecture consists of two components (Figure 3.1): a Skills Component (SC) and a Cognitive Representation Component (CRC).  The SC consists of those portions of the CGA that vary between individual entities within a type and class.  This component serves to model the skills and ability of the operator of an entity.  The CRC contains the intelligent decision making processes and the knowledge required by them. The knowledge stored here includes the overall mission, goals and objectives, plan generation, reaction time, and crisis management ability.  In the architecture, the CRC has three reasoning engines: the Long-term Decision Engine (LTDE), Mid-term Decision Engine (MTDE), and the Critical Decision Engine (CDE).  These engines perform long-term, mid-term, and immediate reasoning operations for the CGA.  The Arbitration Engine (AE) arbitrates between decision engine outputs and applies operator skills and combat psychology parameters to the selected output. To determine the skill and combat psychology modifiers to apply, the AE accesses information held in the SC.When an actor has computed its new state, this information must be provided to the other actors at the local DMTITE location as well as to the other actors in the DVE.  To accomplish this data transfer, the actor places its state information into a container that is dispatched on its outgoing information stream to the CODB (possibly via a series of sub-CODBs) for relay to the WSM and to other local actors.  Once the new actor state data is in the CODB, the actor state data is passed on to the WSM and is repackaged into outbound containers by the CODB for the local actors.4.	The DMTITE Architectural Rules, Operational Procedures, and AffordancesThe DMTITE architecture is based on several assumptions.  We assume that the costs of system development must be minimized and that system requirements at all levels will remain fluid throughout a project.  Therefore, the architecture is highly compartmentalized, actively combats entropy and change propagation, supports both large-grain and fine-grain code re-use, and is designed to support rapid prototyping.  Additional assumptions are that object-oriented development practices will be followed and that DMTITE will be used in a HLA environment.4.1	RulesThere are six rules we developed for the DMTITE architecture.  The first of the rules is that global variables are not allowed.  The second rule is that only shallow inheritance hierarchies with single inheritance are allowed.  The third rule is that each entity, sensor, or dynamics model is permitted to use its own internal coordinate system.  The fourth rule is that pointers are not to be used in the CODB or any other major architectural system component; pointers are permitted only within completely encapsulated, non-architectural components such as sensor models.  The fifth rule is that data is not allowed to move between major system components unless it is routed through the CODB and transported via containers.  Direct communication, or indirect communication using pointers, between major system components is not permitted.  The sixth rule is that the source of data determines the availability of a slot in an outbound container and determines which slot in the container holds the data.4.2	Operational ProceduresTo insure the proper use of the capabilities of the CODB architecture and that the architecture is adhered to throughout development, we specified six procedures that must be followed.  The procedures specify how public data, information routing, entity appearance, container availability, container typing, and Sub-CODBs must be managed.Public data.  All data moves between major DMTITE objects in containers.  The data in the containers are routed by the CODB.  Since all public data moves through the CODB, an object must export its data to the CODB in a container, and from there another container transmits the data to the recipient.  The CODB/container combination is used to insure low coupling between DMTITE application objects.  Each information stream between system objects is served by a set of containers, the main CODB, and possibly one or more sub-CODBs.  Containers in each information stream are available in a double-buffering scheme.  Each information stream has a set of incoming containers and a set of outgoing containers.Information routing.  The CODB has the sole responsibility for providing information to an entity in the type and format that the entity requires the data.  For example, the CODB holds the methods that perform coordinate conversion.  Upon receipt of data in an inbound container, the CODB converts the data into the type(s) required by the objects that receive the data.  The CODB has this responsibility so that the recipient objects can remain ignorant of all other DMTITE components; all the recipient object needs to know is where its data lies in the container.  The recipient object does not need to know about external coordinate systems or format conversion since the CODB guarantees that the data arrives at the recipient in the proper format.  As a result, changes to an object do not affect any other objects in DMTITE except for the CODB and sub-CODBs that are upstream from the changed object.  Furthermore, the format of incoming data on an information stream can be changed and there is no affect on the recipient object.Entity appearance.  Whenever a new entity appears in the environment, and is subject to the restrictions of the active Federation Object Model (FOM) and SOM(s), the CODB is informed of this event by the WSM via a message from the WSM.  When the CODB is informed, the WSM must supply the entity ID, alliance, type, class, and location in addition to the container, pallet, and slot where the new entity will be assigned.  Then the CODB determines its outbound containers that require information about this new entity and makes the appropriate container assignments and instantiates a new container, if necessary.  When an entity is removed from the environment, the WSM informs the CODB.  The CODB passes on the removal notification and frees up any of the slots in its outbound containers used by the entity. Container availability.  Each container has a semaphore to signal the data source that the container can be written.  No container is ever available for reading and writing at the same time.  If a container is being written, readers must use the other container on the information stream for data.  For each inbound container on an information stream, the CODB has a container-specific method to read the data and transfer/route the data into the appropriate outbound containers that service its actors.  The outbound container for every information stream for every entity class contains the union of all the data required by every SOM in which the entity class it serves participates.  The set of outbound containers from the CODB to the WSM contains only the data required by the current FOM.  The set of inbound containers from the WSM to the CODB contains all of the information required by each active entity under the current FOM.Container types.  Each entity type has only one container that serves instantiated entities of that type, the contents of the single container are an amalgam of the information provided by the six inbound containers that carry data from the WSM to the CODB.  The main CODB has six types of inbound containers: 1) actor, 2) phenomenology, 3) emissions, 4) transient, 5) control, and 6) migration.  This information comes in from the RTI via the WSM or, in the case of a control container, the control information comes from a DMTITE object.  The actor container holds state information for all actors in the distributed simulation called for by the SOM.  The phenomenology container holds information about all phenomenology in the virtual environment except for sensor emissions; weather information is contained in the phenomenology container.  The emissions container holds all sensor emission data such as radar, infrared, sound, etc.  This container holds information concerning sensor status (on/off), operational wavelength, orientation, power, etc.  All of the sensors in the virtual environment are represented in this container at all times, changes to this container will be caused primarily by changes in sensor status.  The only cause for a change is when a sensor is destroyed, at which time its slot is emptied.  The transient container holds information about transient events such as missile launchings, weapon firings, or other actions that are known to have a brief existence within the environment.  The control container holds information concerning filtering or other object control information that is being passed from one object to another within a single DMTITE application or across the network.  The migration container holds information concerning the state of an actor that is either migrating to or from a DMTITE host.  The CODB has five types of outbound containers that carry data to the WSM: 1) entity, 2) phenomenology, 3) emissions, 4) transient and 5) migration.  The functionality of the outbound containers mirrors the functionality of the corresponding inbound containers.Sub-CODBs.  Sub-CODBs are used in the DMTITE architecture.  A Sub-CODB has the same functionality and purpose as a CODB, but it is specialized to serve a single type/class of entity.  All of the CODBs on an information stream, except for the main CODB served by the WSM, are considered sub-CODBs.  Each sub-CODB has double-buffered incoming and outgoing containers.  Incoming containers contain data coming from the CODB and that is going to actors.  Outgoing containers contain data that is bound for the CODB and originates from the actors.  When an incoming container arrives, the sub-CODB repackages the data into an outgoing container for access by its actors.  When an actor produces data, it places the data into its outgoing container.  Each actor has its own set of double-buffered outgoing containers for communication with its sub-CODB.  When the container is full, the actor informs the sub-CODB that the container is ready.4.3	AffordancesWithin the DMTITE operational environment each entity has perfect knowledge about the state of all of the entities in the DVE, which does not reflect the real-world operational environment.  The inaccuracy arises from the fact that known sensor limitations are not imposed upon the data; therefore, each sensor has, in effect, unlimited visibility coupled with unlimited sensitivity.  As a result, the CGAs within DMTITE may have knowledge about the state of the DVE and the entities in it that is unavailable to their real-world counterparts under similar environmental and sensor conditions.  To increase the fidelity of the operation of DMTITE actors within the DVE, each actor within a DMTITE system has its information restricted by filtering the incoming data using sensor models, as a result the CGA operates only upon a realistic set of information.  The sensor models restrict the information provided to the actor so that the information available to the actor mirrors that provided to a real-world counterpart system.  After filtering, the data is used in conjunction with the knowledge bases by the DMTITE Decision Engines for their decision-making computations.5.	Containerization for CommunicationContainerization is the use of containers to hold and transport data between DMTITE objects and to transport data from the CODB to the WSM.  There are four issues in the DMTITE design addressed by containerization.  The first issue is moving the remote entity data from the network to each DMTITE actor via the World State Manager and the CODB.  The data movement between the World State Manager and the CODB has the greatest data transport volume in the system (numbers of bytes per second) and must be performed efficiently.  DMTITE is expected to function within large-scale DVEs and will have to receive, process, and manage large amounts of data received over the network.  Unless properly managed, these elementary tasks can consume a significant percentage of the computing resources for the host.  The Figure 5.1:  Detail of a Container Used to Transport Data Between the World State Manager and the Common Object DataBase.second issue is that each of the actors in DMTITE can have different requirements for DVE data.   A third issue is maintaining separation and minimizing coupling between the major components of the architecture while minimizing the cost of transferring data between components and obtaining optimum performance.  The fourth issue is the desire to be able to readily adapt to changes in the HLA standard.The solution we developed for these issues involves the maintenance of the virtual world’s description by the World State Manager and transferring this data en masse from the World State Manager to the CODB in six different containers, each structured to group related information together, as shown in Figure 5.1.  We developed containerization because it minimizes the volume and frequency of data copying.  Because the size and structure of the container are static, a single operation can move the data from the World State Manager to the CODB data space.  To make the data transport more efficient, we move the data between the World State Manager and CODB using a double-buffering scheme.  Double buffering allows the World State Manager to maintain the state of the virtual environment and load an outbound container without contending with other DMTITE objects for the data structures that hold the virtual environment’s state. When the CODB finishes with the old container, the CODB switches to a newly filled container of data from the World State Manager after the World State Manager signals that the new container of data is ready.  Because all the components on the CODB side share the same copy of the virtual environment’s state, we insure that they access a consistent description of the world.  This approach effectively decouples the operation of the WSM from the CODB.The containers are composed of pallets and each pallet is composed of slots.  For example, in the container shown in Figure 5.1 there are two major pallets, one for Blue (friendly) forces and one for Red (opponent) forces.  Within each of these two pallets are additional pallets, one each for ground and aircraft actors.  Within the Blue aircraft pallet there are three additional pallets, one for F-15, F-16, and C-17 aircraft.  In each of these pallets are slots that are used to hold state information for each actor of that type within the DVE, the type being Red Aircraft SU-31 and Red Aircraft MIG-31.  Each type of actor (air, land, surface, subsurface, and space) as well as each sub-type for each type has a dedicated, pre-allocated portion of the container, its slot.  Each pallet has a pre-allocated number of slots and sub-pallets.Whenever a new actor appears in the virtual environment, the World State Manager (as the source of the data) determines if a slot is available for the actor within the actor container.  If a slot is available, the World State Manager notifies the CODB of the presence of a new actor and the slot assigned to the new actor.Because an object’s public data may be required by several objects, we use containers to transmit data between DMTITE components via the Common Object DataBase.  To fulfill this function, the Common Object DataBase holds all the exported data from all system components and functions as a routing mechanism for data movement between components.  Each component updates its portion of the CODB (via a container) asynchronously. When an actor must transmit data to the DVE, the actor uses a container to transmit the data to the CODB.  All information streams use outbound containers to transmit information back upstream to the DVE and to other objects in the DMTITE application.Given the importance of the container approach to the architecture and its efficient operation, we will examine its operation in greater detail by examining the flow of data along one information stream, as shown in Figure 5.2.  In Figure 5.2, the writer can be any source of data, including the CODB; likewise the reader can be any destination for data, including the CODB.  The CODB in the figure can be the main CODB in the architecture or any sub-CODB.   One point that should be emphasized is that the CODB is an object in the DMTITE architecture with unique properties and responsibilities.  The purpose of the CODB object is to receive inbound information for all of the data streams it services, hold the information arriving on those streams, and respond to requests for data as it becomes available.  Since we are dealing with objects, the sources of data as well as the sinks have their own local and private data structures and methods.  In an information stream, the reader’s sole responsibility is to read data from a container and operate upon it; the writer’s sole responsibility is to write data to a container.  As shown in the figure, the data stored within a stage’s data structures are local and optimal for the particular stage.  The methods at each stage have two responsibilities toward the information flow.  The first responsibility is to retrieve information from the inbound container, place it into the format required by its recipient, and insert it into the appropriate slot in the recipient’s data area.  The second responsibility is to place the data from the local data area into all of the outbound containers that require the data, which may require copying the information into a number of different containers.Conceptually, the insertion of the data into a container occurs continuously and when a reader requests data the container is sealed and dispatched.  An information recipient signals its need for new data by setting a Figure 5.2: Detailed View of the Data Movement From a Writer to a Reader in DMTITEsemaphore (not shown).  Once the upstream CODB or sub-CODB recognizes that the semaphore is set, the CODB or sub-CODB insures that its current outbound container has data and signals the recipient that the new container is available by resetting the semaphore.  Note that each container has only one slot for the data for each entity.  If new information for an entity arrives before the previous information has been accessed by the recipient in the next stage of the information stream, it is simply overwritten.  If several recipients access the same container, then a semaphore-protected counter is used in the container to indicate the number of readers remaining to be serviced.  When the counter reaches zero, then the reader that set the counter to zero also sets the semaphore to tell the upstream CODB that a new container of data is needed.  If a sub-CODB is a recipient of data, then by definition it is the only recipient of the data from the container that serviced it.  Multiple sub-CODBs do not feed off of the same container.  If multiple information streams need to fan out from one data source then the sub-CODB on the stream is responsible for dispersing the data from its inbound container to all of the outbound containers.  Fan-out occurs as a result of the operation of the methods for a sub-CODB on the contents of the information stream.6.	System DesignThe operation of the CODB is crucial to the effective performance of DMTITE because all incoming and outgoing DVE and object data is maintained by and routed through the CODB.  In the design of the CODB, the most important issues were insuring uncorrupted access to the data in the containers and structuring the CODB and containers to hold the information.  To simplify the data management process, we maintain a strict separation between the containers on an incoming data stream and those on an outgoing information stream.  When information comes to a recipient, the data arrives in an inbound container that is read-only for the recipient and write-only for the sender.  When information is being dispatched on an information stream, the data is write-only for the sender and read-only for the recipient of the outbound container.In the design of the container class, we differentiated between persistent and non-persistent data.  Persistent data is data tied to an entity that has a relatively long life-span in the DVE, however some components of the entity’s data may change over time.  For example, the existence of an actor in the DVE is a relatively persistent piece of data even though its velocity and location, and hence its state, may be continuously changing.  Non-persistent data, on the other hand, is usually a singular event, has a relatively brief life-span, and is needed by a DMTITE actor only once.  An example of non-persistent data is the release of a munition by an airplane.  For persistent and non-persistent data containers, the readers are monitored.  When all readers of a persistent data container have accessed the container, the container is updated with new information.  In the case of a non-persistent data container, once all the readers have accessed the container, the container’s contents are discarded and the container becomes available to hold information about the next transient DVE event that occurs.A persistent container holds DVE entity state data, data that specifies the type of container (actor, phenomenology, etc.), and additional fields that specify where in the container the information for the destination object is stored.  The additional fields provide the actor with a map of the data in the container, so that the location in the container of the pallets of information and even individual actor’s state data are specified.  The CODB obtains the information concerning the types of information each actor requires when the actor is initialized.Mirroring the architecture in Figure 3.1, each actor in DMTITE has three main objects: the Physical Representation Component, the Skills Component, and the Cognitive Representation Component.  Each of these three components is in turn composed of a variety of additional objects.  The Physical Representation Component (PRC) has two major sub-objects, the Physical Model and the Sensor Interface.  The Physical Model contains the dynamics models and entity state information.  The implementation of this object allows us to encapsulate one or more physical models within a single package for the actor, and each actor can use one or more Physical Models during the course of an exercise.  The other component of the PRC is the Sensor Interface.  The Sensor Interface is a CODB object and is responsible for extracting information from the incoming container and providing each sensor model with the information that it requires to function.Each DMTITE actor contains four Decision Engines.  Each of the four Decision Engines contain a set of Knowledge Base IDs.  The Knowledge Base IDs identify the Knowledge Bases that the actor will use for decision making.  Each of the Decision Engines can use a different type of reasoning mechanism for its operation, the choice of decision mechanism for an engine is completely independent of the type of decision making mechanisms used in the other three engines.  The only requirement that we impose upon the decision engines is that their decision making systems be completely self-contained.  The knowledge bases are also constructed independently of the Decision Engines.In the design, objects that share common structure and behavior, such as the decision engines, are represented hierarchically.  Since the structure of a CGA is defined by this architecture, we can implement decision engines to support specific inferencing strategies without concern as to how the engine will be used.  Additionally, existing physical models can be incorporated into a CGA.  Since the physical model software is itself modular in design, minimal effort will be required.Finally, the design supports the architectural decisions made concerning how state information moves throughout a CGA.  The CRC can not “go outside” this model to obtain information directly from the DVE or even from another local DMTITE actor.  The architecture does allow physical models to retrieve state information from or pass state information to their servicing containers, thereby providing a consistent means for transmitting data and aids us in achieving our objective of loose coupling.7.	Conclusions and Future WorkIn this paper we described the software architecture that we developed for DMTITE.  The architectural solution is based on the CODB architecture and combats software entropy and minimizes coupling between system components and objects.  The architecture guarantees the isolation of reasoning components from knowledge base components and permits multiple threats to be instantiated within a single DMTITE system.  The architecture allows the system to restrict at runtime the available information to a model, ideally the restriction mirrors the information available to the corresponding entity in the real world.  Finally, the architecture allows a DMTITE system to insert multiple threats of many different types into a DVE.  After describing the architecture, we presented the rules, procedures, and affordances of the architecture and addressed the operation of an actor’s sensors within DMTITE.  We then discussed our use of containerization in DMTITE and described in detail how the CODB/container combination operates to achieve our DMTITE and architectural objectives.  Finally, we presented the high-level DMTITE design that supports the architecture in all respects.Our next steps for the DMTITE architecture and design will be evaluation and continued refinement.  We are firmly convinced of the benefits of successive refinement for both architecture and design improvements, and we are now at the point where further improvements can best be realized via continued development of actors, knowledge bases, dynamics models, and sensor models. ReferencesAppino, Perry A.; Lewis, J. Bryan; Ling, Daniel T.; Rabenhorst, David A.; and Codella, Christopher F.  “An Architecture for Virtual Worlds,” Presence, vol. 1, no. 1, pp. 1-17, Winter 1992.Banks, S.B.; Stytz, M.R. and Hutson, L.J.  "Interoperable Synthetic Players For Aircrew Training:  The Distributed Mission Training Integrated Threat Environment Project," Royal Aeronautical Society Conference on Networking in Simulation and Training - Realizing the Benefits, London, England, 11-12 pp. 17.1-17.14, November 1998.Banks, S.B.; Stytz, M.R.; Hutson, L.J.; and Silver, S.M.  "A Computable Combat Psychology Model for Computer Generated Forces,"  Proceedings of the 1998 Fall Simulation Interoperability Workshop, Orlando, Florida, pp. 35-45, 14 - 18 September 1998.Calder, R.B., Smith, J.E., Courtemanche, A.J., Mar, J.M.F., & Ceranowicz, A.Z. “ModSAF Behavior Simulation and Control,” Proceedings of the Third Conference on Computer-Generated Forces and Behavioral Representation, Orlando, FL, pp. 347-356, 1993.Codella, C.; Jalili, R.; Koved, L.; Lewis, J. B.; Ling, D. T.; Lipscomb, James S.; Rabenhorst, David A.; Wang, Chu P.; Norton, Alan; Sweeney, Paula; Turk, Greg.  “Interactive Simulation in a Multi-Person Virtual World,” Human Factors in Computing Systems, SIGCHI ‘92 Conference Proceedings,  Monterey, California, pp. 329-334, 3 - 7 May 1992.Davis, A. M.  “Operational Prototyping:  A New Development Approach,” IEEE Software, vol. 9, no. 5, pp. 70-78, September 1992.Laird, J. E., Newell, A., & Rosenbloom, P.S. “SOAR:  An Architecture for General Intelligence,” Artificial Intelligence, vol. 33, pp. 1-64, 1987.Lewis, J. B.; Koved, L.; and Ling, D.T.  “Dialogue Structures for Virtual Worlds,” Human Factors in Computing Systems:  CHI ‘91 Conference Proceedings, New Orleans, Louisiana, pp. 131-136, 27 April - 2 May 1991.Pitman, J.H. and Kitrick, C.J.  “VUIMS: A Visual User Interface Management System,” Proceedings of UIST ‘90, The Third Annual ACM SIGGRAPH Symposium on User Interface Software and Technology, Snowbird, Utah, pp. 36-46, 3 - 5 October 1990.Robertson, G. G.; Card, S. K.; and Mackinlay, J. D.  “The Cognitive Coprocessor Architecture for Interactive User Interfaces,” Proceedings of UIST ‘89, The Second Annual ACM SIGGRAPH Symposium on User Interface Software and Technology, Williamsburg, Virginia, pp. 10-18, 13 - 15 November 1989.Shaw, C.; Liang, J.; Green, M.; and Sun, Y.  “The Decoupled Simulation Model for Virtual Reality Systems,” Human Factors in Computing Systems, SIGCHI ‘92 Conference Proceedings,  Monterey, California, pp. 321-328, 3 - 7 May 1992.Stytz, M. R.  “Distributed Virtual Environments,”  IEEE Computer Graphics and Applications, vol. 16, no. 3, pp. 19 - 31, May 1996.Stytz, M.R., Banks, Sheila B., & Santos, E.  “Moving Advanced Distributed Simulation into Operational Training:  The Distributed Mission Training Integrated Threat Environment Project,”  19th Interservice/Industry Training Systems and Education Conf., Orlando, Florida, 1-4 Dec, publication on CD-ROM, 1997.Stytz, M.R.; Banks, S.B. and Santos, E. Jr. “The Distributed Mission Training Integrated Threat Environment Project:  Goals, Architecture, and Current Status,” 7th Conference on Computer Generated Forces and Behavioral Representation, Orlando, FL, 12 - 14 pp. 155-168, May 1998.Stytz, M.R. and Banks, S.B.  “Requirements and Architecture for Distributed Threat Systems For Aircrew Mission Training,”  The SCS 1998 SMC Simulation Multiconference: 1998 Military, Government, & Aerospace Simulation Conference, Boston, MA, pp. 124-129, 5-9 April 1998.Stytz, M.R.; Banks, S.B.; and Santos, E.  “Requirements for Intelligent Aircraft Entities in Distributed Environments,” 18th Interservice/Industry Training Systems and Education Conference, Orlando, Florida, publication on CD-ROM, 3 - 5 December 1996.Stytz, M. R.; Adams, T.; Garcia, B.; Sheasby, S.M.; and Zurita, B.  “Rapid Prototyping for Distributed Virtual Environments,” IEEE Software, vol. 14, No. 5, pp. 83-92, September-October 1997.Tambe, M., Johnson, W. L., Jones, R.M., Koss, F., Laird, J. E., Rosenbloom, P. S., & Schwamb, K.   “Intelligent Agents for Interactive Simulation Environments,” AI Magazine, vol. 16, no. 1, pp. 15-40, Spring 1995.Author BiographiesMartin R. Stytz is an active duty Lieutenant Colonel in the U.S. Air Force serving as an Associate Professor of Computer Science and Engineering at the Air Force Institute of Technology.  He received a Bachelor of Science degree from the U.S. Air Force Academy in 1975, a Master of Arts degree from Central Missouri State University in 1979, a Master of Science degree from the University of Michigan in 1983.  Stytz received his Ph.D. in Computer Science and Engineering from the University of Michigan in 1989.  He is a member of the ACM, SIGGRAPH, SIGCHI, the IEEE, the IEEE Computer Society, AAAI, and the Society for Computer Simulation.  His research interests include virtual environments, distributed interactive simulation, modeling and simulation, user-interface design, software architecture, and computer-generated forces. Sheila B. Banks is the president of Calculated Insight.  Dr. Banks received her Bachelor of Science, Magna Cum Laude from University of Miami, Coral Gables, FL in 1984 and a Bachelor of Science in Electrical Engineering, Summa Cum Laude, from North Carolina State University, Raleigh, NC in 1986.  Also from North Carolina State University, Raleigh, NC, she received a Master of Science in Electrical and Computer Engineering in 1987 and her Doctor of Philosophy in Computer Engineering (Artificial Intelligence) from Clemson University, Clemson, SC in 1995.  Her research interests include artificial intelligence, intelligent computer generated forces, associate and collaborative systems, distributed virtual environments, intelligent human computer interaction, and man-machine interfaces. Large-grain code re-use is re-use at the system object and object levels.  Fine-grain code re-use is re-use at the statement, method, or procedure level.  Fine-grain re-use is prevalent and has been since the earliest days of computing, large-grain re-use is much less widespread and more difficult to achieve.PAGE  		