A Pilot Language for Conceptual Modelling of the BattlespaceR.  AyresM.  R.  Moulding *Computing Information Systems Engineering GroupDepartment of Informatics and SimulationRoyal Military College of ScienceCranfield UniversityShrivenham, Swindon, Wiltshire, UK.+44-1793-785522r.ayres@rmcs.cranfield.ac.uk;  HYPERLINK mailto:moulding@dial.pipex.com moulding@dial.pipex.com(* contact) Keywords:	Synthetic Environments; Conceptual Modelling; Command and Control; Verification and Validation.ABSTRACT: Both Synthetic Environments (SEs) and operational Command and Control (C2) systems, employed for defence applications, must contain a model of a battlespace environment, possibly at multiple levels of resolution.  For example, both kinds of system need to record data relating to terrain, conditions, equipment and personnel.  The current norm is for such systems to use completely distinct data representations: SEs have been influenced by the need to capture behavioural characteristics, while C2 representations have generally focussed on the static structure of data.  This paper discusses a Pilot Language which aims to integrate both the static structural relationships captured by C2 databases with the behavioural information required for SEs.   This Pilot Language combines a class hierarchy of propertied entities with behavioural specifications.  The behavioural aspect of the language has been designed using an approach similar to that of the DoD’s Conceptual Models of the Mission Space (CMMS) in that processes are defined and decomposed in terms of verbs, subjects and objects.  The paper also demonstrates how the Pilot Language can be used both as a specification tool for SEs and a medium for representing operational data models.  The authors believe that combining structural and behavioural information in this way is an important aspect of developing a full specification language for battlefield behaviours, which could be used as a basis for both SE and operational system specifications.1.	IntroductionBoth Synthetic Environments (SEs) used for defence applications and battlespace Command and Control (C2) systems must hold data relating to terrain, equipment, personnel, and operational status.  In SEs, this data is required to support the detailed simulation of a battlespace scenario.  C2 systems must capture similar kinds of information in order to present commanders with an operational picture of a battle in progress.  The kinds of data held in these systems are very similar, the main difference being in the way that the information is updated.  In a SE, the information is directly updated by the simulation software; in a C2 system, however, the data is updated as a result of input from sensors or operational personnel.Although SEs and C2 systems currently use distinct conceptual models of the battlespace, there is no reason, in principle, why such systems should not be based on a common representation of data.  Moreover, the use of such a representation has significant potential benefits.  For example:it would be easier to interface operational systems with simulations, for training and experimental purposes.it would avoid the duplication of effort that arises in designing and keeping up-to-date two separate data models or domain representations.it lays the foundation for developing a repository of useful pre-validated abstractions for modelling the battlespace, for a variety of purposes.  Such a repository could be used to inform the development of both SEs and operational systems, and would be particularly useful with the advent of battlespace digitization.However, the proposed use of a common representation of data for both SEs and C2 systems demands the existence of a representation language, or notation, which is sufficiently expressive to be used by both areas.In 1998, the UK Ministry of Defence (MOD), via its Defence Evaluation and Research Agency (DERA), set up a research project to investigate the use of multiple levels of representation (or resolution) in defence SEs.  Part of this project, sub-contracted to Cranfield University at the Royal Military College of Science (RMCS), was concerned with providing a conceptual language for specifying such multiple-level SEs.  The authors, in carrying out this research, elected to devise such a language by attempting to combine the concerns of  SEs and operational C2 systems, for the reasons highlighted, above.  The resulting prototype conceptual language, referred to henceforth as the Pilot Language, is the subject of this paper.Formally, the Pilot Language was developed to support the capture of information and knowledge relevant to the battlespace, and its particular research objective was to provide a medium in which battlespace entities and behaviours could be represented in varying levels of detail (or resolution).  Currently, the language, thus far developed, provides features which can represent both:the static structure of the battlespace; that is, the entities involved, their properties, and how they are related to each other.the behavioural aspects; that is, the behaviours that the entities in the battlespace can perform. The concern to integrate data modelling features into the Pilot Language, and to capture the way in which behaviours involve interactions between specific entities, means that specifications in the language tend to be fairly concrete.  Indeed, full specifications should contain sufficient detail in order for it to be possible to animate them directly.  However, it is not desirable, when developing specifications, to start off by capturing every last detail of battlespace entities and behaviours, and the research objective to accommodate multiple (or variable) levels of representation provides an advantage here. This would allow a particular behaviour, such as a unit moving to a particular location, to be specified in more than one way.  For example, one might give a fairly high-level specification which would simply calculate the time taken on the basis of average movement speeds.  A more detailed specification would break the behaviour down into various sub-behaviours involved in the unit moving (e.g. vehicles moving provided they had adequate fuel, and so on).The structural component of the language allows classes of entities (such as tanks or military units) to be specified by giving class definitions similar to those which are used in object-oriented programming (OOP) languages.  As with OOP languages, classes may be defined in terms of refinements to existing classes using an inheritance hierarchy (e.g. a Tank class may be defined by refining and extending the definition of a Vehicle class).The behavioural component of the language allows the behaviours of entities to be specified in terms of the changes of state that entities can bring about, both to themselves and to other entities.  Such behaviours are specified in terms of verbal templates which take the entities involved in behaviours as subjects and objects of verbs.  Part of the specification of behaviours is the facility to specify the times taken for behaviours to complete, as well as to specify how behaviours pass control between each other (e.g. if one behaviour fails).  It is in the behavioural component of the language that entities can be created (as instances of classes).In the current version of the language, variable levels of representation are accommodated by simply storing more than one set of definitions of a group of battlespace behaviours.  One set would represent behaviours in a relatively “broad brush” way, whereas others would seek to capture much greater detail.  More formally accommodating multiple representation is one of the research directions discussed at the end of the paper.Over recent years, a number of researchers have commented on the problems of inconsistencies between C2 data models and SE conceptual models, and highlighted the potential benefits of using common data representations for both operational systems and simulations.For example, Hieb and Blalock [1] have investigated the inconsistencies which occur between one particular C2 data model and the kinds of information represented in a simulation system.  Krusche and Tolk [2] have proposed that the Army/Allied Tactical Command and Control System (ATCCIS) data model could serve as the basis for a shared data representation scheme. There are also a number of projects concerned with developing comprehensive mission space models for the purposes of simulation specification.  Among the most notable of these are the Functional Description of the Battlespace (FDB), developed  primarily to support the US Army’s WARSIM 2000 procurement, and the Conceptual Models of the Mission Space (CMMS).The approach used in the Pilot Language for specifying behaviours is closer to that of  the CMMS [3,4].  The CMMS uses subject-verb-object templates for specifying behaviours.  The Pilot Language has followed this approach, and has attempted to link the specification of behaviours to objects which may perform, or be affected by, those behaviours.  It does this by using the data model component of the language to retrieve entities affected by a behaviour, via their relationships with the entity carrying out the behaviour.In the next section of this paper, we present the approach that was taken to developing the Pilot Language, and give an overview of its features.  In sections 3 and 4 we describe, in greater detail, the data modelling and behavioural components of the language, respectively.  The use of the language as a specification tool is then outlined in section 5.   Finally, the potential benefits of the language are discussed in section 6, and future development issues for the language are briefly presented in section 7.2.	Overview of the Pilot LanguageThe approach taken to developing the Pilot Language was to start from a military scenario and use this to determine the language features required to represent the entities and behaviours involved in that scenario.  The scenario was made as simple as possible in order to expose the basic features required in the language.The scenario used was based around a conflict at the border of two imaginary countries: Lowland and Upland.  These countries were assumed to be separated by a straight frontier which passed through an area of terrain without significant features.  The scenario was based on the perspective of a BattleGroup (BG A) on the Lowland side which has been tasked with defending the border against a postulated Upland attack.  BattleGroup A is part of a brigade of four infantry battlegroups (BG A, BG B, BG L, and BG R), which has been ordered to adopt a defensive position as shown in Figure 1, below. EMBED Word.Picture.8  Figure 1    Operational ScenarioThe behavioural aspects of the scenario were derived by developing an operational order which could have been sent from the brigade to BattleGroup A.  This order was developed with military assistance, and was based on a strategy of holding the border against enemy probing attacks, with the option for a counterattack by the support battlegroup (BG B) should the enemy successfully penetrate the border.This operational order was then used as a starting point for determining the kinds of entities and behaviours that would need to be represented in capturing the activities of BattleGroup A in the above scenario.  The order also provided the necessary background context which needed to be represented; for example, it gave BattleGroup A’s role within an order of battle, as well as highlighting issues such as re-supply.  The major requirements for the language, which were derived from considering this scenario, were the need:to be able to specify entities involved in the battlespace and, in particular, to capture the values of properties of entities (e.g. the current location of an entity).to capture the way in which the values of entities’ properties change as a result of battlespace behaviours.  Doing this implies the need to incorporate a similar range of operators and control structures (sequence, selection and iteration) as are found in ordinary programming languages.to represent time in some way, and to allow the execution of behaviours to be related to time.to specify the circumstances in which a behaviour is regarded as failing or succeeding, and to allow behaviours to be combined (i.e. to allow the specification to trigger behaviours in sequence, in parallel, or as a result of some condition such as the failure of another behaviour).To address these requirements, the following main design decisions were taken.  First, the specification of battlespace objects (or entities) was separated from the behaviour that they can perform.  Battlespace objects are then specified using a class hierarchy in a similar way to OOP languages.  However, these classes are purely declarative; that is, they do not include any methods which can result in the values of entity properties being updated.  Consequently, the class specification component of the language can be used to specify data models in terms of classes of entity, their properties, and relationships between them.An important consequence of separating out class specifications is that behaviour definitions are not constrained to follow the same inheritance hierarchy as classes; some behaviours may be shared by entities which are not otherwise related (e.g. trucks, helicopters and motor boats may all refuel, but they do not necessarily belong in the same part of a class hierarchy).  Another point is that behaviour involves interaction between (usually) several entities of different kinds, and it is not always clear which class should contain the definition for such a behaviour.  Ambiguities of this sort could even lead to the same behaviour having its definition duplicated in different classes.The second major design decision was to specify behaviours in terms of the way they affect the values of properties of objects.  Hence, all updating of objects is carried out by behaviours.Finally, facilities were incorporated to allow the execution of behaviours to be controlled.  There are four main facilities to allow this to happen:the first is to model time in terms of a number of clock “ticks” since some base time at which a simulation is considered to begin.  The language can, thus, capture some specification of the time taken for a behaviour to complete.when behaviours are executed by particular entities, they are considered either to succeed or fail.  The success or failure of an individual behaviour is used to control the way in which other behaviours are then activated or terminated.the language incorporates three behaviour-combining operators which allow behaviours to run in sequence, in parallel, or for one behaviour to be activated only if another has failed.the language incorporates “triggers”.  A trigger is a specification of circumstances which will result in a particular behaviour being activated.Class BSObj  {	string 	affiliation;	string 	status;	real		xPos;	real		yPos;	BSObj(string a) {		super();		affiliation = a;		status = “non-operational”;		xPos   = 0;   yPos   = 0;	}}class MilUnit extends BSObj {	string 		name;	real			firePower;	real			range;	real  		avgMovementSpeed;	list Person		persons;	list Item		materiel;	MilUnit(string n, string affiliation, real f, real r) {		super(affiliation);		name = n; firePower = f; range = r;	avgMovementSpeed = 0.5;	}	int numPersonnel()  =  length(persons);}Figure 2    Example Class Definitions3.	Representing Structural InformationOne major requirement when modelling the battlespace is to capture relevant information about the entities which is both concrete (such as tanks, units, and so on) and abstract (such as areas, events, and so on).The approach taken in the Pilot Language is to group such entities into classes.  A class definition then allows the properties of a particular kind of entity to be defined; for example, an entity such as “Tank” will have numeric properties such as speed and weight, and string-valued properties such as an index number and name.An example of a class specification is given at the top of Figure 2.  This is for the class “BSObj”, which is a general BattleSpace object; that is, any unit or piece of equipment which might appear on the battlespace.  The class definition specifies that any battlespace object has four properties: an affiliation which represents the name of the power to which the object belongs; the status of the object (e.g. “operational” or “destroyed”); and its x and y co-ordinates held as real numbers.In order to help eliminate errors, the language is typed; that is, all properties and variables used have a type associated with them. This allows automated checking of the consistency of specifications for verification purposes.  The type system incorporates the standard kinds of values (integers, reals, booleans, and strings), as well as classes and lists.  A list can be formed using any other type, or class, as list members.  Hence, the class “MilUnit” has two properties, “persons” and “materiel”, which refer to lists of “Person” and “Item” entities, respectively.  The facility whereby class properties can hold references to other objects (as well as to basic values) allows relationships between entity classes to be captured in the Pilot Language.Instances of the “BSObj” class can be created by calling the class constructor which always has the same name as the class itself.  For example, an instance of a “BSObj” which is affiliated to Lowland could be created with the command:	new BSObj(“Lowland”);This will result in the creation of an object whose affiliation is “Lowland”, whose status is non-operational, and whose initial co-ordinates are (0,0).  Note, however, that such entity-creating statements can only be invoked from the behavioural component of the language discussed in the next section.Classes are organised into an inheritance hierarchy, which is now a standard approach but, more importantly, is particularly appropriate to multiple representation levels.  When a behaviour is represented in both a high-level and then a more detailed way, the more detailed level of representation will tend to make use of classes further down the hierarchy which define entities with greater resolution.A class is defined as a subclass of another class by using the keyword “extends”, as illustrated in the “MilUnit” class shown in Figure 2.  The class “MilUnit” automatically inherits all the properties defined for the “BSObj” class.  Note that the use of the keyword “super” in the first line of the “MilUnit” constructor represents an invocation of the constructor of its parent class, in order to initialise the properties defined there.The Pilot Language supports single inheritance only; all user-defined classes have precisely one parent.  If a class is defined without the keyword “extends”, then it is considered to be a subclass of the built-in root class “Object”, from which all classes ultimately derive.  The “Object” class has no properties, but direct subclasses must invoke its constructor as the first action of their own constructor; hence, the use of “super()” as the first line of the “BSObj” constructor.The Pilot Language also supports derived properties; that is, ones which are specified in terms of a calculation.  For example, the “MilUnit” class contains a property “numPersonnel” which is specified by a calculation of the length of the list of persons assigned to the unit.  This feature is important when accommodating multiple levels of representation.  For example, a high-level representation of a tank may represent its status by a property whose value is updated in the course of a simulation.  However, a lower-level representation of the same entity may need to derive the tank’s status from a combination of other properties of the tank, such as fuel and ammunition levels, damage sustained, etc.Since classes only have properties (and no behaviour), they can be used to express data models; that is, pure data structures for representation of information.  EMBED Word.Picture.8  Figure 3    Simple Data ModelFor example, the two class definitions in Figure 2 (when supplemented with suitable definitions of “Person” and “Item” classes) can be seen as representing the simple data model of Figure 3, above (where inheritance between entities is represented by one entity being drawn within another).  Two comments should be made:since the Pilot Language caters for derived properties (i.e. ones which are calculated from the values of other properties of the entity as well as, potentially, user supplied parameters) it is more expressive than most standard data models.the link between a “MilUnit” object and its personnel is represented (in the class definitions) by a property in the “MilUnit” class.  Since the association is multi-valued (from one unit to zero, one or more personnel) we have a data model which is not in Third Normal Form according to Relational data theory.  However, there is nothing to prevent the association being represented by a separate class (called “UnitMembership” for example) which would produce a normalised data model.4. 	Representing Behavioural InformationIn designing the Pilot Language, behaviour has been interpreted as what an entity can do; in particular, the way that the states of entities (i.e. the values of their properties) are changed as a result of a behaviour being carried out.Figure 4 shows part of a top-level script to create the entities, and initiate the behaviours involved in simulating the scenario outlined in section 2.  In this script, two objects are first created: one to represent the battlegroup and another to represent the area it has been ordered to occupy (we have not given a definition of the Area class but the language allows rectangular areas of terrain to be represented in terms of their corner co-ordinates).  Once these objects are created they are assigned to two local variables using the command “set”.  The “set” command is again used to set the x and y co-ordinates of the object representing Battlegroup A.  Note that the command “set” is used in the behavioural component of the Pilot Language to represent a command in which the value of a variable or the property of an object (referenced using the format “property-name of object”) is actually changed, instead of simply being initialised.Once the objects have been created and their properties fully initialised, then the behaviours of those objects can be invoked.  First, the mobilisation of the Battlegroup A object is triggered through the statement:	bgA  mobilises;This invokes a behaviour “mobilises” which simulates the activities (and consequent delays) which a battlegroup performs when it mobilises.  Next, two streams of behaviour are linked by an operator “|” (corresponding to “or-else”).  The significance of a statement such as:	(b1  |  b2)is for behaviour “b1” to be invoked but if “b1” fails then “b2” is invoked.  If “b1” succeeds, however, then “b2” is not invoked at all.  Consequently, the significance of the final statements in Figure 4 is for Battlegroup A to occupy the area represented by bgaArea by a time 2000, and then for it to exclude Upland forces from entering the area.  If either of these two behaviours (carried out in sequence) fail, then the sequence as a whole fails and the alternative behaviour:	bgA retreats to bgbArea;will be executed, corresponding to Battlegroup A retreating to another area (whose original creation is not included in the incomplete script of Figure 4).There is a third operator, “&”, for combining behaviours, so that:	b1 & b2corresponds to the behaviours b1 and b2 being carried out in parallel until they have either both succeeded and completed, or one of them has failed (in which case the combined behaviour is considered to have failed).// create and initialise objects to represent BG A and area it must occupy.//-------------------------------------------------------------------------set bgA     = new BattleGroup(“BattleGroup A”, “lowland”);set bgaArea = new Area(“BG A area”, 250, 500, 500, 250);set xPos of bgA = -100;		set yPos of bgA = -2000;// Start BattleGroup A’s behaviour.  // NB: time represented by an integer count of time units from a start time//-------------------------------------------------------------------------bgA mobilises;(	(	bgA occupies bgaArea by 2000;       	bgA excludes “upland” from bgaArea    )|       bgA retreats to bgbArea )Figure 4    Top Level Behaviour InvocationA behaviour is invoked through a verbal template (in an approach similar to that of the CMMS).  Verbal templates in the Pilot Language have the form:subject verb parameterswhere there can be any number of parameters, and the parameters comprise a mixture of values, objects or additional words (such as prepositions).Such verbal templates have been used since they are syntactically easier for the user than the standard method-style definitions of object-oriented languages.  Also, they are, to an extent, self-documenting, and so help avoid ambiguities (e.g. different additional words may give the same set of parameters a different significance).An example of a behaviour definition is the one for the “occupies” behaviour given in Figure 5.  The general form of such definitions is:    behaviour (<class> subject)  <verb>  [params]  is  {  body of definition  } where the subject is an entity which is then considered to perform the behaviour.  It is possible to overload (i.e. give alternative definitions of behaviours) by using different templates for a behaviour (verb) of the same name.  Hence, a behaviour “drives” could be declared and defined with the template:(Person p) drives (Tank t)and alternative definitions could be given with different templates such as:(Person p) drives (Lorry l)or(Person p) drives (Lorry l)		   along (Road r)Definitions for these templates would associate alternative behaviours with the verb “drives”.Behaviours involve entity instances performing a sequence of actions which may change their own state and the state of one or more other entities.  Consequently, the bodies of behaviour definitions incorporate many of the standard features of programming languages, including: the declaration and assignment of local variables (using the “set” command).standard arithmetic and logical operators.control statements (such as “if”, and “while”).Furthermore, because the objective is to simulate behaviour, there are built-in facilities to pause or delay the execution of behaviours for specified time periods.  One of these facilities (pause) is used in the definition in Figure 5.The notion of behaviours either succeeding or failing has been explicitly incorporated into the language.  A behaviour succeeds by default.  However, if a “FAIL” statement is invoked, then the behaviour will fail (unless the “FAIL” statement is executed in a context where an alternative course of action has been specified using the “|” operator).  Consequently, when writing a behaviour definition the user must specify the conditions which correspond to the behaviour failing, and ensure that a FAIL statement is executed in those circumstances.The behaviour definition in Figure 5 specifies what is involved in a military unit occupying an area by a given time limit.  The first statements in the behaviour body set the local variables “dx” and “dy” to represent the x and y offsets of the unit’s current location from the centre of the area to be occupied.  The local variable “dist” is then set to the distance the unit needs to travel and the variable “timeAvail” is set to the time available to complete the behaviour (calculated from the global counter “clock” which returns the current time).  The following if-do-elsedo-end statement then tests whether the unit can reach the area in the time available, given its average speed of movement (a property of the military unit accessed with the expression “u.avgMovementSpeed”).  If it can, then the behaviour will pause for the time it takes the unit to reach the centre of the area and then update the military unit’s co-ordinates.  If it cannot, then the behaviour will fail without the unit’s position being changed.  (Note that the reserved word “FAIL” always results in failure when encountered.)behaviour	(MilUnit u) occupies (Area a) by (int time)is{	set dx = u.posX – a.centreX();	set dy = u.posY – a.centreY();	set dist = squareRoot ((dx * dx) + (dy * dy));	set timeAvail = (time – clock);	if ((timeAvail * u.avgMovementSpeed) >= dist)	do		pause (dist / u.avgMovementSpeed);		set posX of u = a.centreX();		set posY of u = a.centreY();	elsedo		FAIL;	end;}Figure 5    Behaviour SpecificationBehaviours specify threads of execution; in the Pilot Language, Classes and Behaviours are static definitions and entities and threads are their run-time instantiations.  Each thread is considered as being associated with an entity which is the subject of the behaviour that is invoked.  An entity may be executing more than one thread at a time, in which case the system will need to time-slice between the active threads.5. 	The Use of the Language as a Specification ToolDeveloping Pilot Language definitions of battlespace entities and behaviours has considerable potential benefits.  For example:a repository can be built up of battlespace specifications.  These then form a reusable resource which may be used in the development of both operational systems and simulations.specifications provide a criterion against which simulation systems can be validated and verified.In addition to its use as a specification tool, the Pilot Language also has a potential use in helping to elicit knowledge of the battlespace from military experts.  For example, part of the operational order for the scenario outlined, above, which was developed by our military expert included the order:BG A is to:Establish blocking position by 251700Z May 00 with 70% of BG Combat Power.Destroy and disrupt any enemy incursion into LOWLAND.In order to prevent an enemy invasion into LOWLAND.It is clear that phrases such as “establish blocking position” are quite acceptable to military experts.  However, the actual process of establishing a blocking position may well involve many complex behaviours on the part of a military unit and its commanders, such as: evaluating the terrain, determining available resources, positioning troops, and so forth.   The process of developing a precise specification of such behaviour in the Pilot Language helps with the process of eliciting knowledge from military experts.6. 	DiscussionThe authors believe that the Pilot Language demonstrates the feasibility of developing conceptual languages which can capture both data model and behavioural information of the battlespace.  One particular advantage of  combining these two kinds of information in the one representation scheme is that it makes it possible to capture the way in which the activation of behaviours for various battlespace entities is affected by the static relationships between those entities.  For example, the mobilisation of a unit will trigger the mobilisation of the subunits; mobilisation of these subunits will, in turn, trigger activities such as checking status and possibly replenishing supplies or fuel, and so on.  The order in which these behaviours are activated, and the delays in their activation, are closely governed by the relationship between the entities in terms of command structure, physical location, and so on.  These structural relationships are captured by the data model aspect of the language.Although, for reasons of space, we have not given an example of a refined (or lower-level) behaviour definition, it is quite feasible, in the Pilot Language, to represent behaviours with varying levels of detail.  Hence, we can develop a more detailed specification of the “occupies” behaviour defined in Figure 5.  Such a detailed behaviour specification would involve calculating a disposition of the equipment and personnel within the unit, and then invoking behaviours on those lower-level entities to move to those positions.Another important aspect of the Pilot Language, which has not been covered here, is that it is consistent with the proposed Defence Command and Army Data Model (DCADM) of the UK MOD [5].  The Pilot Language can be used to express the DCADM data model in its own syntax or, alternatively, Pilot Language specifications can themselves be held in a DCADM-based database.  The adopted approach would be contingent on the details of the particular application.More details of the Pilot Language, in particular its role in capturing multiple levels of resolution, its relationship to DCADM, and a comparison of its features compared with the CMMS, can be found in a recent report [6] available from the authors.7. 	Future DirectionsSince the Pilot Language was developed by considering the specific requirements for one particular, and simplified, scenario, it contains no modularisation, or packaging, facilities which would be required if large numbers of specifications were to be developed by one or more teams working in parallel.  In such circumstances, there would be obvious dangers of class names or behaviour names being reused and defined inconsistently, or completely differently.  One way to address this problem would be to incorporate some kind of modularisation facility into the language.  Another option would be to adopt a similar approach to that adopted by the CMMS designers with their Common Syntax and Semantics (CSS), which is effectively a shared repository of terms and definitions.  Using such a repository would help avoid the danger of inconsistent or contradictory specifications being developed.  Indeed, it would be instructive to consider integrating the Pilot Language with the CMMS repository.  With such an approach, the Pilot Language would provide an explicit linguistic framework in which to employ the vocabulary provided by the CMMS.Although it is possible to specify different sets of behaviour definitions in the language, and to document some definitions as being lower-level refinements of more general definitions, this facility is not explicitly supported by the language.  In terms of the future development of the language it is an important requirement to allow definitions at different levels to be linked in some way, so that a specification checker can ensure that they are mutually consistent (e.g. involve the same kinds of entities and values).Since the Pilot Language is quite detailed in terms of being able to give precise definitions of classes and behaviours, there is no reason, in principle, why an animator could not be built for the language.  Such an animator would process a set of class and behaviour definitions and then execute the behaviours in a multi-threaded environment so that users could see the kinds of outcome to which their specifications give rise.  Such an animator would have the obvious benefit of providing some dynamic testing of specifications to ease the task of verification and validation.  Furthermore, it would also help with knowledge elicitation, since military experts could gain feedback on the way particular specifications behave.8.	AcknowledgementsThe authors would like to express their gratitude to the UK MOD and DERA for funding this work as part of the TG5 area of its Corporate Research Programme (CRP).  Special thanks are due to Major Eamon Ross, of The King’s Royal Hussars, for his valuable assistance in formulating the military scenario used as the starting point for the design of the Pilot Language.9.	References[1]	Hieb Michael R and Blalock James. “Data Alignment between Army C4I Databases and Army Simulations”. Proc. Spring 99 SIW (Paper #034).[2]	Krusche Dr Stefan and Tolk Dr Andreas. “A SHADE Approach for Coupling C4I-Systems and Simulation Systems”.  Proc. Autumn 99 SIW (Paper #004).[3]	Sheehan Jack, et al. “Conceptual Models of the Mission Space (CMMS): Basic Concepts, Advanced Techniques, and Pragmatic Examples”.  Proc. Autumn 98 SIW (Paper #127).[4]	“Conceptual Model of the Mission Space-Technical Framework Toolset”.  (Online).  Defense Modeling and Simulation Office.  Available:  HYPERLINK http://38.241.48.9/intro.htm http://38.241.48.9/intro.htm (1999).[5]	(UK) Army CIS Authority.  “An Introduction to the Defence Command and Army Data Model (DCADM)”.  ACISAd, Jan 1999.[6]	Ayres, R. & Moulding, M. R. “Problem Domain Modelling for Multiple Representation in Synthetic Environments: A Pilot Conceptual Language”. RMCS Ref. SE029/TR2, Ver. 1, September 2000.Author BiographiesROBERT AYRES is a Lecturer with the Computing Information Systems Engineering Group in the Department of Informatics and Simulation, at RMCS.  Historically, his research interests have centred on integrating databases and programming languages, and his PhD thesis presented a system to support loosely-formulated database queries, which has particular relevance to criminal intelligence analysis.  Since joining RMCS, his research activities have mainly focussed upon database issues associated with the digital battlespace.MICHAEL R. MOULDING is Professor of Software Engineering, and Head of the Computing Information Systems Engineering Group, at RMCS.  Over the past decade his main research activities have been in the fields of high integrity software, requirements analysis, mathematically formal specification techniques, and the verification, validation and accreditation of Distributed Interactive Simulation (DIS) systems.  Currently, his main activities are associated with Battlespace Digitization, and he is Chairman of a new MSc course in this topic at RMCS. 	The language provides a built-in operator “length” which returns the number of elements in a list. 	subject to UK MOD agreement. 